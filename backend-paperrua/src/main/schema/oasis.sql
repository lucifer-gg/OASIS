-- MySQL dump 10.13  Distrib 8.0.18, for Win64 (x86_64)
--
-- Host: localhost    Database: oasis
-- ------------------------------------------------------
-- Server version	8.0.18

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `affiliation_info`
--

DROP TABLE IF EXISTS `affiliation_info`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `affiliation_info` (
  `affiliation_id` int(11) NOT NULL AUTO_INCREMENT,
  `affiliation_name` varchar(200) DEFAULT NULL,
  `affiliation_search_count` int(11) DEFAULT '0',
  PRIMARY KEY (`affiliation_id`)
) ENGINE=InnoDB AUTO_INCREMENT=1546 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `affiliation_info`
--

LOCK TABLES `affiliation_info` WRITE;
/*!40000 ALTER TABLE `affiliation_info` DISABLE KEYS */;
INSERT INTO `affiliation_info` VALUES (1,'Univ. Politec. de Madrid, Madrid, Spain',0),(2,'NA',0),(3,'Beihang University, China',0),(4,'Beijing Advanced Innovation Center for Big Data and Brain Computing, China',0),(5,'The University of Newcastle, Australia',0),(6,'State Univ. of Paraiba, Para铆ba, Brazil',0),(7,'Fed. Univ. of Pernambuco, Recife, Brazil',0),(8,'Fed. Univ. of Campina Grande, Campina Grande, Brazil',0),(9,'Sch. of Software, Tsinghua Univ., Beijing, China',0),(10,'Univ. of California, Davis, Davis, CA, USA',0),(11,'University of California, Irvine',0),(12,'Sch. of Comput. Sci., Tel Aviv Univ., Tel Aviv, Israel',0),(13,'HASLab, Univ. of Porto, Porto, Portugal',0),(14,'Delft Univ. of Technol., Delft, Netherlands',0),(15,'IBM T. J. Watson Res. Center, Yorktown Heights, NY, USA',0),(16,'Aarhus Univ., Aarhus, Denmark',0),(17,'Samsung Res. America, Mountain View, CA, USA',0),(18,'Northeastern Univ., Boston, MA, USA',0),(19,'EECS Dept., UC Berkeley, Berkeley, CA, USA',0),(20,'University of Massachusetts Amherst',0),(21,'Dept. of Comput. Sci., Univ. of Sheffield, Sheffield, UK',0),(22,'University of Notre Dame',0),(23,'Iowa State University',0),(24,'Northern Illinois University',0),(25,'University of California, Davis',0),(26,'Carnegie Mellon University',0),(27,'Dept. of Comput. Sci., Tech. Univ. Darmstadt, Darmstadt, Germany',0),(28,'Dept. of Comput. Sci., Univ. of Chicago, Chicago, IL, USA',0),(29,'Comput. Sci. Dept., Univ. of Southern California, Los Angeles, CA, USA',0),(30,'Kakao Corp., Seongnam, South Korea',0),(31,'The University of Adelaide',0),(32,'Monash University',0),(33,'The University of Melbourne',0),(34,'Nanyang Technological University, Singapore',0),(35,'Fudan University, China',0),(36,'Tsinghua University, China',0),(37,'The College of William and Mary',0),(38,'Universit脿 della Svizzera italiana (USI)',0),(39,'Microsoft Research, India',0),(40,'Microsoft Research, Redmond',0),(41,'Concordia University, Canada',0),(42,'The University of Alabama, United States of America',0),(43,'University of Birmingham (UK) and Federal Rural University of Pernambuco (Brazil)',0),(44,'University of Birmingham (UK)',0),(45,'Concordia University (Canada)',0),(46,'Key Lab. of High Confidence Software Technol., Peking Univ., Beijing, China',0),(47,'Univ. of Newcastle, Newcastle, NSW, Australia',0),(48,'Univ. of California, Irvine, Irvine, CA, USA',0),(49,'University of Pennsylvania',0),(50,'Korea University',0),(51,'KAIST',0),(52,'Key Lab. of Network Assessment Technol., Inst. of Inf. Eng., Beijing, China',0),(53,'Coll. of Inf. Sci. & Technol., Pennsylvania State Univ., University Park, PA, USA',0),(54,'State Key Lab. of Inf. Security, Inst. of Inf. Eng., Beijing, China',0),(55,'Georgia Institute of Technology',0),(56,'UC Davis',0),(57,'University of Evansville',0),(58,'CMU',0),(59,'North Carolina State University',0),(60,'Google LLC',0),(61,'CONICET and University of Rio Cuarto, Argentina',0),(62,'SnT, University of Luxembourg, Luxembourg',0),(63,'University of Rio Cuarto, Argentina',0),(64,'CONICET and Buenos Aires Institute of Technology, Argentina',0),(65,'Dept. of Comput. Sci., Univ. of California, Santa Barbara, Santa Barbara, CA, USA',0),(66,'Fac. of Technol. & Soc., Malmo Univ., Malmo, Sweden',0),(67,'Microsoft Anal. & Experimentation, Microsoft, Redmond, WA, USA',0),(68,'Dept. of Comput. Sci. & Eng., Chalmers Univ. of Technol., Goteborg, Sweden',0),(69,'Dept. of Comput., Hong Kong Polytech. Univ., Hong Kong, China',0),(70,'Coll. of Inf. Sci. & Technol, Pennsylvania State Univ., University Park, PA, USA',0),(71,'Oregon State University',0),(72,'Phase Change Software',0),(73,'UFCG, Brazil',0),(74,'Univ. of Wisconsin - Madison, Madison, WI, USA',0),(75,'Univ. of Washington, Seattle, WA, USA',0),(76,'Microsoft, Redmond, WA, USA',0),(77,'Univ. of Colorado Boulder, Boulder, CO, USA',0),(78,'UC Berkeley, Berkeley, CA, USA',0),(79,'IT University of Copenhagen',0),(80,'IT University of Copenhagen, Denmark',0),(81,'North Carolina State University, USA',0),(82,'Case Western Reserve University',0),(83,'The University of Texas at San Antonio',0),(84,'Princeton University',0),(85,'State Key Lab of Computer Sciences',0),(86,'State Key Lab of Computer Sciences, Institute of Software, Chinese Academy of Sciences, China',0),(87,'University of California, Riverside',0),(88,'New Jersey Institute of Technology',0),(89,'Carnegie Mellon University, Silicon Valley Campus',0),(90,'University of Auckland',0),(91,'State Key Lab. for Novel Software Technol., Nanjing Univ., Nanjing, China',0),(92,'Dept. of Comput. Sci., Purdue Univ., West Lafayette, IN, USA',0),(93,'Univ. della Svizzera Italiana, Lugano, Switzerland',0),(94,'Univ. of Milano-Bicocca, Milan, Italy',0),(95,'Taibah University, Saudi Arabia',0),(96,'University of Nebraska - Lincoln, USA',0),(97,'Kent State University, USA',0),(98,'King Saud University, Saudi Arabia',0),(99,'Department of Computer Science, Texas A&M University',0),(100,'Alibaba Group, China',0),(101,'Alibaba Group, US.',0),(102,'East China Normal University, China',0),(103,'Monash University, Australia',0),(104,'New York University Shanghai, China',0),(105,'The Hong Kong University of Science and Technology, Hong Kong, China',0),(106,'Shenzhen Key Laboratory of Computational Intelligence Southern University of Science and Technology, Shenzhen, China',0),(107,'Sun Yat-sen University',0),(108,'ETH Zurich, Switzerland & UC Davis, USA',0),(109,'Univ. of Notre Dame, Notre Dame, IN, USA',0),(110,'The Hong Kong Polytechnic University, Hong Kong SAR of China',0),(111,'The Chinese University of Hong Kong, Hong Kong SAR of China',0),(112,'University of Cambridge',0),(113,'Sch. of Comput. Sci. & Eng., Nanyang Technol. Univ., Singapore, Singapore',0),(114,'Res. Sch. of Comput. Sci., Australian Nat. Univ., Canberra, ACT, Australia',0),(115,'Australian National University',0),(116,'Shanghai Jiao Tong University',0),(117,'Nanjing University, Nanjing, China',0),(118,'Unaffiliated',0),(119,'ETH Zurich, Switzerland',0),(120,'University of Zurich',0),(121,'Coll. of Comput. Sci., Nanjing Univ. of Aeronaut. & Astronaut., Nanjing, China',0),(122,'Dept. of Comput. Sci., Middlesex Univ., London, UK',0),(123,'Dept. of Inf., Univ. of Zurich, Zurich, Switzerland',0),(124,'Nanyang Technological University',0),(125,'ETH Zurich/University of California, Davis',0),(126,'AnaLytics & Evaluation (SCALE) Lab., York Univ., Toronto, ON, Canada',0),(127,'Columbia University',0),(128,'Microsoft Research',0),(129,'University of Calgary, Canada',0),(130,'University of Pisa, Italy',0),(131,'University of Technology Sydney, Australia',0),(132,'EECS Dept., Univ. of California, Berkeley, Berkeley, CA, USA',0),(133,'Seoul Nat. Univ., Seoul, South Korea',0),(134,'Korea Univ., Seoul, South Korea',0),(135,'Shenzhen University, China',0),(136,'Singapore University of Technology and Design, Singapore',0),(137,'Zhejiang University, China',0),(138,'Universit脿 degli Studi dell\'Aquila, Italy',0),(139,'Centrum Wiskunde & Informatica, Netherlands',0),(140,'Universit脿 degli Studi del Sannio, Italy',0),(141,'Lero - University of Limerick, Ireland',0),(142,'Friedrich-Alexander-Universit盲t Erlangen-N眉rnberg, Germany',0),(143,'Lero - University College Cork, Ireland',0),(144,'Dept. of Comput. Sci. & Eng., Univ. of Notre Dame, Notre Dame, IN, USA',0),(145,'Univ. of Molise, Italy',0),(146,'Univ. of Sannio, Benevento, Italy',0),(147,'Univeristy of Michigan',0),(148,'University of Michigan',0),(149,'University of California, Santa Barbara',0),(150,'Sch. of Comput. Sci., Carnegie Mellon Univ., Pittsburgh, PA, USA',0),(151,'Hampton Univ., Hampton, VA, USA',0),(152,'ISTI, Pisa, Italy',0),(153,'Univ. degli Studi di Napoli Federico II, Naples, Italy',0),(154,'University of Passau',0),(155,'University of Weimar',0),(156,'Alibaba Group',0),(157,'University of Texas at Arlington',0),(158,'Humboldt-Universit盲t zu Berlin',0),(159,'Carnegie Mellon University Silicon Valley, NASA Ames Research Center',0),(160,'Coll. of William & Mary, Williamsburg, VA, USA',0),(161,'Univ. de los Andes, Bogota, Colombia',0),(162,'Univ. of Victoria, Victoria, BC, Canada',0),(163,'Xi鈥檃n Jiaotong University, China',0),(164,'Drexel University, United States',0),(165,'Xi\'an Jiaotong University, China',0),(166,'Univ. of Luxembourg, Luxembourg City, Luxembourg',0),(167,'htw saar, Germany',0),(168,'Univ. of Gothenburg, Gothenburg, Sweden',0),(169,'MIT',0),(170,'Chalmers and University of Gothenburg',0),(171,'Eastern Michigan University',0),(172,'Dept. of Electr. & Comput. Eng., Univ. of Auckland, Auckland, New Zealand',0),(173,'Sch. of Eng. & Comput. Sci., Victoria Univ. of Wellington, Wellington, New Zealand',0),(174,'Comput. Sci. Dept., Univ. of Alabama, Tuscaloosa, AL, USA',0),(175,'Dept. of Comput. Sci., Southern Illinois Univ., Carbondale, IL, USA',0),(176,'University of Illinois at Urbana-Champaign, USA',0),(177,'Microsoft Res., Redmond, WA, USA',0),(178,'Dept. of Comput. Sci., ETH Zurich, Z眉rich, Switzerland',0),(179,'Visteon Electronics, Universit茅 C么te d\'Azur, CNRS, I3S, France',0),(180,'SnT, University of Luxembourg',0),(181,'Universit茅 C么te d\'Azur, CNRS, I3S, France',0),(182,'University of Namur',0),(183,'Oregon State University, U.S.A.',0),(184,'University of British Columbia, Canada',0),(185,'Google Inc., U.S.A.',0),(186,'Southern University of Science and Technology, Shenzhen, China',0),(187,'The Hong Kong University of Science and Technology, Hong Kong, Chine',0),(188,'Northeastern University',0),(189,'The Hong Kong University of Science and Technology',0),(190,'Southern University of Science and Technology',0),(191,'University of California, Davis, United States',0),(192,'Nanjing University, China',0),(193,'Georgia Institute of Technology, United States',0),(194,'University of California, Davis, United States and ETH Zurich, Switzerland',0),(195,'Siemens AG, Erlangen, Germany',0),(196,'Univ. of Passau, Passau, Germany',0),(197,'OTH Regensburg Munich, Siemens AG, Munich, Germany',0),(198,'SnT Centre, Univ. of Luxembourg, Luxembourg City, Luxembourg',0),(199,'Univ. of Washington, St. Louis, MO, USA',0),(200,'Univ. of Sheffield, Sheffield, UK',0),(201,'Univ. of Massachusetts, Amherst, MA, USA',0),(202,'Palo Alto Res. Center, Palo Alto, CA, USA',0),(203,'McGill University',0),(204,'Polytechnique Montreal',0),(205,'Concordia University',0),(206,'Purdue Univ., West Lafayette, IN, USA',0),(207,'Interdisciplinary Centre for Security, Reliability and Trust (SnT), University of Luxembourg, Luxembourg',0),(208,'Department of Software Engineering, Chonbuk National University, South Korea',0),(209,'University of New South Wales, Australia',0),(210,'University of Chicago, USA',0),(211,'University of Washington, USA',0),(212,'University of Kentucky',0),(213,'Northwestern Polytechnical University',0),(214,'University of Southern California',0),(215,'Univ. of California, Los Angeles, Los Angeles, CA, USA',0),(216,'National University of Defense Technology, China',0),(217,'Universidad Nacional de Educacion a Distancia, Spain',0),(218,'Johannes Kepler University, Austria',0),(219,'Fraunhofer SIT, Tech. Univ. Darmstadt, Darmstadt, Germany',0),(220,'Fraunhofer SIT, Germany',0),(221,'University of Athens, Greece and University of Malta, Malta',0),(222,'The University of Sydney, Australia',0),(223,'University of Athens, Greece',0),(224,'University of California, Los Angeles',0),(225,'Iowa State University, USA',0),(226,'University of Texas at Dallas, USA',0),(227,'Carnegie Mellon University, USA',0),(228,'Univ. of Illinois at Urbana-Champaign, Urbana, IL, USA',0),(229,'Microsoft Corp., Redmond, WA, USA',0),(230,'Virginia Tech., Blacksburg, VA, USA',0),(231,'Univ. of Southern California, Los Angeles, CA, USA',0),(232,'Dept. of Comput. Sci. & Eng., Univ. of Nebraska-Lincoln, Lincoln, NE, USA',0),(233,'University at Buffalo, The State University of New York',0),(234,'Delft University of Technology / SIG',0),(235,'Leibniz Universitat Hannover',0),(236,'Paluno, University of Duisburg-Essen',0),(237,'Software Improvement Group',0),(238,'Purdue University',0),(239,'Zhejiang University',0),(240,'Renmin University of China',0),(241,'KAIST, Republic of Korea',0),(242,'Chalmers University and Blekinge Inst. of Technology, Sweden',0),(243,'Samsung Research, Republic of Korea',0),(244,'Naver Labs, Republic of Korea',0),(245,'The University of Texas at Austin',0),(246,'University of Illinois at Urbana-Champaign',0),(247,'Sch. of Software, Dalian Univ. of Technol., Dalian, China',0),(248,'Western Michigan Univ., Kalamazoo, MI, USA',0),(249,'State Key Lab. of Software Eng., Wuhan Univ., Wuhan, China',0),(250,'Univ. Coll. London, London, UK',0),(251,'Ohio State Univ., Columbus, OH, USA',0),(252,'Leipzig University, Germany',0),(253,'IT University of Copenhagen, Denmark and Chalmers and University of Gothenburg, Sweden',0),(254,'Chalmers and University of Gothenburg, Sweden',0),(255,'Univ. Lille, CNRS, France',0),(256,'RMOD - Inria Lille, France',0),(257,'Portland State University, Oregon, USA',0),(258,'Aarhus University',0),(259,'Hong Kong University of Science and Technology, Hong Kong, China',0),(260,'Sourcebrella Inc., China',0),(261,'Software Eng. Dept., Afeka Tel Aviv Acad. Coll. of Eng., Israel',0),(262,'Sch. of Comput. Sci., Acad. Coll. of Tel Aviv-Yaffo, Israel',0),(263,'State Key Laboratory for Novel Software Technology Nanjing University, China',0),(264,'University of California, Irvine, USA',0),(265,'SISE, Univ. of Electron. Sci. & Technol. of China, Chengdu, China',0),(266,'Microsoft Res., Beijing, China',0),(267,'Purdue University, USA',0),(268,'University of Virginia, USA',0),(269,'Ohio State University, USA',0),(270,'Virginia Tech, United States',0),(271,'Technical University of Munich, Germany',0),(272,'University of Texas at San Antonio, United States',0),(273,'Institute of Software Chinese Academy of Sciences',0),(274,'Stevens Institute of Technology, USA',0),(275,'Institute of Software Chinese Academy of Sciences, Beijing, China',0),(276,'Sch. of Comput., Nat. Univ. of Singapore, Singapore, Singapore',0),(277,'Singapore Univ. of Technol. & Design, Singapore, Singapore',0),(278,'Sch. of Comput. Eng., Nanyang Technol. Univ., Singapore, Singapore',0),(279,'University of Sannio',0),(280,'University of Tartu, Estonia',0),(281,'Bryn Mawr College, USA',0),(282,'Eindhoven University of Technology, Netherlands',0),(283,'Rochester Inst. of Technol., Rochester, NY, USA',0),(284,'Univ. of Canterbury, Christchurch, New Zealand',0),(285,'University of Alberta, Canada',0),(286,'University of Hawaii, USA',0),(287,'Kyushu University, Japan',0),(288,'Comput. Sci. & Software Eng., Concordia Univ., Montreal, QC, Canada',0),(289,'The Hong Kong Polytechnic University, China',0),(290,'Xi\'an Jiaotong University',0),(291,'Southeast University, China',0),(292,'Sch. of Inf. Sci. & Technol., Shanghai Tech Univ., China',0),(293,'Google, LLC',0),(294,'Bloomberg',0),(295,'Waymo',0),(296,'Faculty of Information Technology, Monash University',0),(297,'College of Computer Science and Technology, Zhejiang University',0),(298,'Microsoft, Canada',0),(299,'School of Information Systems, Singapore Management University',0),(300,'Coll. of Comput. Sci. & Technol., Harbin Eng. Univ., Harbin, China',0),(301,'City Univ. of New York, New York, NY, USA',0),(302,'Tokyo Inst. of Technol., Tokyo, Japan',0),(303,'Sch. of Comput. & Inf. Technol., Univ. of Wollongong, Wollongong, NSW, Australia',0),(304,'Fac. of Eng. & Inf. Technol, Univ. of Technol. Sydney, Sydney, NSW, Australia',0),(305,'Dept. of Comput. Sci., North Carolina State Univ., Raleigh, NC, USA',0),(306,'Coll. of Arts & Sci., Elon Univ., Elon, NC, USA',0),(307,'Dept. of Comput. Sci., Appalachian State Univ., Boone, NC, USA',0),(308,'City University of New York (CUNY) Hunter College',0),(309,'City University of New York (CUNY) Graduate Center',0),(310,'Oakland University',0),(311,'Gran Sasso Science Institute',0),(312,'Federal University of Pernambuco: Recife, Pernambuco',0),(313,'Gran Sasso Science Institute & Vrije Universiteit Amsterdam',0),(314,'ISTI 鈥� Consiglio Nazionale delle Ricerche',0),(315,'TU Darmstadt, Germany',0),(316,'Univ. of Salerno, Fisciano, Italy',0),(317,'Univ. of Zurich, Zurich, Switzerland',0),(318,'Centrum Wiskunde & Inf., Amsterdam, Netherlands',0),(319,'Dept. of Comput. Sci., Univ. Coll. London, London, UK',0),(320,'KAIST, South Korea',0),(321,'Software Institute, Universit脿 della Svizzera italiana (USI), Switzerland',0),(322,'Universidad de los Andes, Colombia',0),(323,'Colorado State University, USA',0),(324,'Zhejiang University City College',0),(325,'Singapore Management University',0),(326,'Carnegie Mellon University and NASA Ames Research Center',0),(327,'University of California, Los Angeles, USA',0),(328,'University of Waterloo, Canada',0),(329,'Pivotal, Palo Alto, CA, USA',0),(330,'Univ. of Auckland, Auckland, New Zealand',0),(331,'Electr. & Comput. Eng., Carnegie Mellon Univ., Moffett Field, CA, USA',0),(332,'College of William & Mary, USA',0),(333,'Scalable Machines Research, USA',0),(334,'ETH Zurich, Switzerland / UC Davis, United States',0),(335,'Dept. of Psychol., Washington & Lee Univ., Lexington, VA, USA',0),(336,'Dept. of Psychol., North Carolina State Univ., Raleigh, NC, USA',0),(337,'University at Buffalo',0),(338,'IBM T.J. Watson Research Center',0),(339,'Nara Institute of Science and Technology, Japan',0),(340,'University of Adelaide, Australia',0),(341,'Tel Aviv University',0),(342,'University of Leicester',0),(343,'OTH Regensburg',0),(344,'University of Hanover',0),(345,'University of California Santa Barbara',0),(346,'Fujitsu Laboratories of America, Inc.',0),(347,'Inst. for Software Res., Carnegie Mellon Univ., Pittsburgh, PA, USA',0),(348,'Carnegie Mellon University, United States',0),(349,'University of Auckland, New Zealand',0),(350,'University of California Irvine',0),(351,'Microsoft, USA',0),(352,'University of Waterloo',0),(353,'University of Science and Technology of China',0),(354,'The University of Chicago',0),(355,'Interdiscipl. Centre for Security, Reliability & Trust, Univ. of Luxembourg, Luxembourg City, Luxembourg',0),(356,'Univ. of Trento, Trento, Italy',0),(357,'Univ. of Southampton, Southampton, UK',0),(358,'Pontificia Univ. Catolica do Rio Grande do Sul, Rio Grande, Brazil',0),(359,'Digital Metropolis Inst., UFRN, Natal, Brazil',0),(360,'Inf. Dept., PUC-Rio, Rio de Janeiro, Brazil',0),(361,'Software Languages Lab., Vrije Univ. Brussel, Brussels, Belgium',0),(362,'Inst. for Dynamic Syst. & Control, ETH Zurich, Zurich, Switzerland',0),(363,'Dept. of Comput. Sci., Bonn-Rhein-Sieg Univ., St. Augustin, Germany',0),(364,'Dept. of Comput. Sci., George Mason Univ., Fairfax, VA, USA',0),(365,'Dept. of Comput. Sci., Kent State Univ., Kent, OH, USA',0),(366,'Dept. of Comput. Sci., Univ. of Akron, Akron, OH, USA',0),(367,'Dept. of Electr. Eng., Indian Inst. of Technol. Madras, Chennai, India',0),(368,'New Jersey Inst. of Technol., Newark, NJ, USA',0),(369,'Fac. of Sci. of Tunis, Univ. of Tunis El Manar, Tunis, Tunisia',0),(370,'Dept. of Electr. Eng. & Comput. Sci., York Univ., Toronto, ON, Canada',0),(371,'Scuderia, Ferrari, Italy',0),(372,'R&D Dept., Zeroturnaround OU, Tartu, Estonia',0),(373,'ETH Zurich, Zurich, Switzerland',0),(374,'Comput. Sci., North Carolina State Univ., Raleigh, NC, USA',0),(375,'Comptuer Sci., Univ. of Birmingham, Birmingham, UK',0),(376,'Lero, Univ. of Limerick, Limerick, Ireland',0),(377,'Comput. Sci., Univ. of British Columbia, Vancouver, BC, Canada',0),(378,'Fac. of Appl. Sci. & Technol., Sheridan Coll., Oakville, ON, Canada',0),(379,'Freie Univ. Berlin, Berlin, Germany',0),(380,'ABB Corp. Res., Raleigh, NC, USA',0),(381,'North Carolina State Univ., Raleigh, NC, USA',0),(382,'LIUPPA Lab., Univ. of PAU & Pays Adour, Mont-de-Marsan, France',0),(383,'Dept. of Manage. & Inf. Technol., Univ. of Salerno, Fisciano, Italy',0),(384,'Sch. of Inf., Univ. of Edinburgh, Edinburgh, UK',0),(385,'Software Eng. Res. Group, Delft Univ. of Technol., Delft, Netherlands',0),(386,'Inf. Center, Fed. Univ. of Pernambuco, Recife, Brazil',0),(387,'Saarland Univ., Saarbrucken, Germany',0),(388,'Dept. of Comput. Sci., Coll. of William & Mary, Williamsburg, VA, USA',0),(389,'Electr. & Comput. Eng. Dept., Iowa State Univ., Ames, IA, USA',0),(390,'UPMC Univ. Paris 06, Paris, France',0),(391,'Centre for Comput. & Eng. Software Syst. & Software Innovation Lab., Swinburne Univ. of Technol., Melbourne, VIC, Australia',0),(392,'Coll. of Comput. Sci., Zhejiang Univ., Hangzhou, China',0),(393,'Software Eng. Dept., Saarland Univ., Saarbrucken, Germany',0),(394,'Univ. of Tokyo, Tokyo, Japan',0),(395,'Johannes Kepler Univ. Linz, Linz, Austria',0),(396,'Dept. of Comput. Sci., ETH Zurich, Zurich, Switzerland',0),(397,'Dept. of Comput. Sci., Univ. of British Columbia, Vancouver, BC, Canada',0),(398,'Dept. of Inf., Syst. & Commun., Univ. of Milano-Bicocca, Milan, Italy',0),(399,'Fac. of Inf., Univ. of Lugano (USI), Lugano, Switzerland',0),(400,'Dept. of Comput. & Inf. Sci., Rochester Inst. of Technol., Rochester, NY, USA',0),(401,'Sci. & Technol. on Parallel & Distrib. Process. Lab., Nat. Univ. of Defense Technol., Changsha, China',0),(402,'Coll. of Comput., Nat. Univ. of Defense Technol., Changsha, China',0),(403,'Univ. of Malta, Msida, Malta',0),(404,'Fac. of Inf., Univ. of Lugano, Lugano, Switzerland',0),(405,'Univ. of Toronto, Toronto, ON, Canada',0),(406,'SINTEF, Trondheim, Norway',0),(407,'Dept. of Comput. Sci., Univ. of California at Davis, Davis, CA, USA',0),(408,'Sch. of Software & Electr. Eng., Swinburne Univ. of Technol., Melbourne, VIC, Australia',0),(409,'Dept. of Comput. Sci., VU Univ., Amsterdam, Netherlands',0),(410,'Tech. Univ. Munchen, Munich, Germany',0),(411,'Univ. of Twente, Enschede, Netherlands',0),(412,'Univ. of Texas at Dallas, Richardson, TX, USA',0),(413,'Florida State Univ., Tallahassee, FL, USA',0),(414,'Polytech. Montreal, Montreal, QC, Canada',0),(415,'Kyushu Univ., Fukuoka, Japan',0),(416,'Comput. & Electr. Eng. & Comput. Sci., Florida Atlantic Univ., Boca Raton, FL, USA',0),(417,'Politec. di Milano, Milan, Italy',0),(418,'Lero - the Irish Software Res. Centre, Limerick, Ireland',0),(419,'Tech. Univ. Darmstadt, Darmstadt, Germany',0),(420,'Vrije Univ., Amsterdam, Netherlands',0),(421,'Indian Inst. of Technol., Kharagpur, Kharagpur, India',0),(422,'Comput. Sci. Dept., Texas Tech Univ., Lubbock, TX, USA',0),(423,'Pleiad Lab., Univ. of Chile, Santiago, Chile',0),(424,'Dept. of Software Eng., Rochester Inst. of Technol., Rochester, NY, USA',0),(425,'Virginia State Univ., Petersburg, VA, USA',0),(426,'Univ. of Delaware, Newark, DE, USA',0),(427,'Software Eng. Inst., Carnegie Mellon Univ., Pittsburgh, PA, USA',0),(428,'Sch. of Comput. Sci., Univ. of Waterloo, Waterloo, ON, Canada',0),(429,'SGT / NASA Ames Res. Center, Moffett Field, CA, USA',0),(430,'Dept. of Comput. Sci., Univ. of York, York, UK',0),(431,'Dept. I.R.O., Univ. de Montreal, Montreal, QC, Canada',0),(432,'Worcester Polytech. Inst., Worcester, MA, USA',0),(433,'Dept. of Comput. Sci., Univ. of Auckland, Auckland, New Zealand',0),(434,'Univ. of Naples 鈥淔ederico II鈥�, Naples, Italy',0),(435,'Dept. of Comput. Sci., Iowa State Univ. of Sci. & Technol., Ames, IA, USA',0),(436,'Inst. of Comput. Sci., Univ. of Gottingen, Gottingen, Germany',0),(437,'Inria, Univ. of Lille 1, Lille, France',0),(438,'Univ. of Klagenfurt, Klagenfurt, Austria',0),(439,'Univ. of Lugano, Lugano, Switzerland',0),(440,'Software Composition Group, Univ. of Bern, Bern, Switzerland',0),(441,'IBM Res., Austin, TX, USA',0),(442,'Dept. of Comput. Sci., Florida State Univ., Tallahassee, FL, USA',0),(443,'Univ. of Wollongong, Wollongong, NSW, Australia',0),(444,'Univ. of Otago, Dunedin, New Zealand',0),(445,'Univ. of Lille, Lille, France',0),(446,'Univ. of Paderborn, Paderborn, Germany',0),(447,'Ivar Jacobson Int., Verbier, Switzerland',0),(448,'Uni Duisburg-Essen, Paluno, Duisburg-Essen, Germany',0),(449,'REVEAL @ Fac. of Inf., Univ. of Lugano, Lugano, Switzerland',0),(450,'Distrib. Syst. Group, Vienna Univ. of Technol., Vienna, Austria',0),(451,'Comput. Sci. Dept., UC Santa Cruz, Santa Cruz, CA, USA',0),(452,'Comput. Media Dept., UC Santa Cruz, Santa Cruz, CA, USA',0),(453,'DINF, Fed. Univ. of Parana, Curitiba, Brazil',0),(454,'Fac. of Inf. & Inf. Technol., Slovak Univ. of Technol. in Bratislava, Bratislava, Slovakia',0),(455,'State Key Lab. of High Performance Comput., Nat. Univ. of Defense Technol., Changsha, China',0),(456,'Dept. of Manage. & Inf. Technol., Univ. of Salerno, Salerno, Italy',0),(457,'Center for Appl. Software Eng., Free Univ. of Bolzano-Bozen, Bolzano, Italy',0),(458,'Dept. of Biosci. & Territory, Univ. of Molise, Campobasso, Italy',0),(459,'Dept. of Comput. Sci., Univ. of Texas, Austin, TX, USA',0),(460,'Indraprastha Inst. of Inf. Technol., Delhi, India',0),(461,'RMIT Univ., Melbourne, VIC, Australia',0),(462,'Hong Kong Polytech. Univ., Hong Kong, China',0),(463,'Swinburne Univ. of Technol., Hawthorn, VIC, Australia',0),(464,'ECpE Dept., Iowa State Univ., Ames, IA, USA',0),(465,'Group of Software & Service Eng. (GESSI), Univ. Politec. de Catalunya (UPC-BarcelonaTech), Barcelona, Spain',0),(466,'PReCISE Res. Center, Univ. of Namur, Namur, Belgium',0),(467,'EPFL, Lausanne, Switzerland',0),(468,'MPI-SWS, Germany',0),(469,'Yale Univ., New Haven, CT, USA',0),(470,'NTT Labs., Japan',0),(471,'Security-Lancaster Res. Centre, Lancaster Univ., Lancaster, UK',0),(472,'Google, Zurich, Switzerland',0),(473,'Nat. Libr. of Luxembourg, Luxembourg City, Luxembourg',0),(474,'SnT, Univ. of Luxembourg, Luxembourg City, Luxembourg',0),(475,'Singapore Manage. Univ. - Singapore, Singapore, Singapore',0),(476,'Fac. of Comput. Sci. & Manage., Wroclaw Univ. of Sci. & Technol., Wroclaw, Poland',0),(477,'Sch. of Comput. & Math., Keele Univ., Keele, UK',0),(478,'Georgia Inst. of Technol., Atlanta, GA, USA',0),(479,'Dept. of Comput. Sci., Edge Hill Univ., Ormskirk, UK',0),(480,'Dept. of Comput. Sci., Brunel Univ. London, Uxbridge, UK',0),(481,'Dept. of Comput. Sci., City Univ. of Hong Kong, Hong Kong, China',0),(482,'Coll. of Arts, Chiang Mai Univ., Chiang Mai, Thailand',0),(483,'Grad. Sch. of Natural Sci. & Technol., Okayama Univ., Okayama, Japan',0),(484,'Univ. of Duisburg-Essen, Essen, Germany',0),(485,'Univ. of California, Berkeley, Berkeley, CA, USA',0),(486,'Univ. of Illinois, Urbana, IL, USA',0),(487,'Oregon State Univ., Corvallis, OR, USA',0),(488,'Sch. of Comput., KAIST, Daejeon, South Korea',0),(489,'Univ. of Nebraska-Lincoln, Lincoln, NE, USA',0),(490,'Software Anal. & Intell. Lab., Queen\'s Univ., Kingston, ON, Canada',0),(491,'Sch. of Comput. Sci., Univ. of Adelaide, Adelaide, SA, Australia',0),(492,'Univ. of Molise, Pesche, Italy',0),(493,'Univ. of Salerno, Salerno, Italy',0),(494,'Univ. of British Columbia, Vancouver, BC, Canada',0),(495,'Insititute of Comput. Sci., Univ. of Goettingen, Gottingen, Germany',0),(496,'Nord Eur., Inria, Villeneuve-d\'Ascq, France',0),(497,'Univ. Lille, Villeneuve-d\'Ascq, France',0),(498,'Bretage Atlantique, Inria Rennes, Rennes, France',0),(499,'KTH R. Inst. of Technol., Stockholm, Sweden',0),(500,'Univ. of Bristol, Bristol, UK',0),(501,'Google, Switzerland',0),(502,'Inst. Univ. de Lisboa, Lisbon, Portugal',0),(503,'Lancaster Univ., Lancaster, UK',0),(504,'Pontifical Catholic Univ. of Rio Grande do Sul, Porto Alegre, Brazil',0),(505,'Fac. of Technol., Westerdals Oslo ACT, Oslo, Norway',0),(506,'Phase Change Software, Golden, CO, USA',0),(507,'Case Western Reserve Univ., Cleveland, OH, USA',0),(508,'Chillarege Inc., Raleigh, NC, USA',0),(509,'Univ. of Texas at Dallas, Dallas, TX, USA',0),(510,'Dept. of Comput. & Inf. Sci., Univ. of Strathclyde, Glasgow, UK',0),(511,'Sch. of Comput., Queen\'s Univ., Kingston, ON, Canada',0),(512,'DISIM Dept., Univ. of L\'Aquila, L\'Aquila, Italy',0),(513,'Vrije Univ. Amsterdam, Amsterdam, Netherlands',0),(514,'McGill Univ., Montr茅al, QC, Canada',0),(515,'Dept. of Comput. Languages & Syst., Univ. de Sevilla, Sevilla, Spain',0),(516,'Athens Univ. of Econ. & Bus., Athens, Greece',0),(517,'PESC/COPPE, Fed. Univ. of Rio de Janeiro, Rio de Janeiro, Brazil',0),(518,'Dept. of Comput. Sci. & Eng., Concordia Univ., Montreal, QC, Canada',0),(519,'Univ. of Texas at Austin, Austin, TX, USA',0),(520,'LMU Munich, Munich, Germany',0),(521,'Paderborn Univ., Paderborn, Germany',0),(522,'UCLA, Los Angeles, CA, USA',0),(523,'Dept. of Comput. Sci., Virginia Tech, Blacksburg, VA, USA',0),(524,'Sch. of Comput. Sci. & Software Eng., East China Normal Univ., Shanghai, China',0),(525,'SKLOIS, Inst. of Inf. Eng., Beijing, China',0),(526,'Shanghai Key Lab. of Trustworthy Comput., East China Normal Univ., Shanghai, China',0),(527,'Dept. of Comput. Sci., Univ. of California, Davis, Davis, CA, USA',0),(528,'Res. Sch. of Comput. Sciecne, Australian Nat. Univ., Canberra, ACT, Australia',0),(529,'Johannes Kepler Univ., Linz, Austria',0),(530,'Simula Res. Lab., Lysaker, Norway',0),(531,'Cancer Registry of Norway, Oslo, Norway',0),(532,'Dipt. di Elettron. Inf. e Bioingegneria Milano, Politec. di MilanoDipartimento di Elettronica Informazione e Bioingegneria Milano, Milan, Italy',0),(533,'Univ. of Bari Aldo Moro, Bari, Italy',0),(534,'Polish-Japanese Acad. of Inf. Technol., Warsaw, Japan',0),(535,'Univ. of Trento, Povo, Italy',0),(536,'George Mason Univ., Fairfax, VA, USA',0),(537,'Carnegie Mellon Univ., Pittsburgh, PA, USA',0),(538,'Dept. of Mech. & Ind. Eng., Ryerson Univ., Toronto, ON, Canada',0),(539,'Dept. of Comput. Sci., Ryerson Univ., Toronto, ON, Canada',0),(540,'ITEE, Univ. of Oulu, Oulu, Finland',0),(541,'MCIS, Polytech. Montreal, Montreal, QC, Canada',0),(542,'Wichita State Univ., Wichita, KS, USA',0),(543,'Dept. of Comput. Sci., Univ. of Alberta, Edmonton, AB, Canada',0),(544,'Software Anal. & Intell. Lab. (SAIL), Queen\'s Univ. Kingston, Kingston, ON, Canada',0),(545,'Dept. of Comput. Sci., Katholieke Univ. Leuven, Leuven, Belgium',0),(546,'Dept. of Comput. Sci., Linnaeus Univ., Vaxjo, Sweden',0),(547,'Dept. of Comput. Sci., Univ. of Texas at Dallas, Richardson, TX, USA',0),(548,'Dept. of Inf., Univ. of California, Irvine, Irvine, CA, USA',0),(549,'Harz Univ. of Appl. Sci., Magdeburg, Germany',0),(550,'Otto-von-Guericke-Univ., Magdeburg, Germany',0),(551,'METOP GmbH, Harz Univ. of Appl. Sci., Magdeburg, Germany',0),(552,'Dept. of Comput. Sci. & Eng., Hong Kong Univ. of Sci. & Technol., Hong Kong, China',0),(553,'Sch. of Electr. Eng. & Comput., Univ. of Newcastle, Newcastle, NSW, Australia',0),(554,'Dept. of Comput. Sci. & Software Eng., Concordia Univ., Montreal, QC, Canada',0),(555,'Modelling & Software Eng. Group, Univ. Autonoma de Madrid, Cantoblanco, Spain',0),(556,'Sch. of Comput. Sci. & Eng., Kyungpook Nat. Univ., Daegu, South Korea',0),(557,'Univ. of Pittsburgh, Pittsburgh, PA, USA',0),(558,'State Key Lab. of Novel Software Technol., Nanjing Univ., Nanjing, China',0),(559,'Fac. of Inf. Technol., Monash Univ., Clayton, VIC, Australia',0),(560,'Sch. of Inf. Syst., Singapore Manage. Univ., Singapore, Singapore',0),(561,'Dept. of Comput. Sci. & Eng., Shanghai Jiao Tong Univ., Shanghai, China',0),(562,'Shenzhen Res. Inst., Chinese Univ. of Hong Kong, Shenzhen, China',0),(563,'Univ. degli Studi di Milano-Bicocca, Milan, Italy',0),(564,'Virginia Commonwealth Univ., Richmond, VA, USA',0),(565,'Brooklyn, New York, NY, USA',0),(566,'Dept. of Inf. Syst., Univ. of Haifa, Haifa, Israel',0),(567,'Fac. of Eng., Tel Aviv Univ., Tel Aviv, Israel',0),(568,'Inria Lille - Nord Eur., Univ. of Lille 1, Lille, France',0),(569,'Zentrum fur Informationstechnik-Gestaltung (ITeG), Univ. of Kassel, Kassel, Germany',0),(570,'Univ. Nac. de Colombia, Bogota, Colombia',0),(571,'Nat. Univ. of Singapore, Singapore, Singapore',0),(572,'Inria, Le Chesnay, France',0),(573,'SafeRiver, Montrouge, France',0),(574,'Dept. of Comput. Sci. & Eng., Chalmers & the Univ. of Gothenburg, Gothenburg, Sweden',0),(575,'Software Practices Lab., Fed. Univ. of Campina Grande, Campina Grande, Brazil',0),(576,'Dept. of Electr. & Comput. Eng., Iowa State Univ., Ames, IA, USA',0),(577,'SUNY Binghamton, Binghamton, NY, USA',0),(578,'Radboud Univ. Nijmegen, Nijmegen, Netherlands',0),(579,'Free Univ. of Bozen-Bolzano, Bolzano, Italy',0),(580,'Wotan Eng. GmbH, Otelfingen, Switzerland',0),(581,'Dept. of Comput., Macquarie Univ., Sydney, NSW, Australia',0),(582,'CREST - The Centre for Res. on Eng. Software Technol., Univ. of Adelaide, Adelaide, SA, Australia',0),(583,'Inst. Super. Tecnico, Univ. de Lisboa, Lisbon, Portugal',0),(584,'Univ. of Stuttgart, Stuttgart, Germany',0),(585,'Dept. of Software Eng., Blekinge Inst. of Technol., Blekinge, Sweden',0),(586,'Software Anal. & Intell. Lab. (SAIL), Queen\'s Univ., Kingston, ON, Canada',0),(587,'Dept. of ECE, Virginia Tech, Blacksburg, VA, USA',0),(588,'IMDEA Software Inst., Madrid, Spain',0),(589,'Dipt. di Elettron., Inf. e Bioingegneria, Politec. di Milano, Milan, Italy',0),(590,'Dept. of Comput. Sci., Univ. of Maryland, College Park, MD, USA',0),(591,'Grad. Sch. of Inf. Sci., Nara Inst. of Sci. & Technol., Nara, Japan',0),(592,'Iowa State Univ., Ames, IA, USA',0),(593,'Univ. of California, Santa Barbara, Santa Barbara, CA, USA',0),(594,'Dept. of Comput. Sci., Univ. of Wisconsin, Madison, WI, USA',0),(595,'Dept. of Comput. Sci. & Eng., Pennsylvania State Univ., University Park, PA, USA',0),(596,'Univ. of Molise, Campobasso, Italy',0),(597,'HAN Univ. of Appl. Sci., Arnhem, Netherlands',0),(598,'Comput. Sci. & Eng., Ohio State Univ., Columbus, OH, USA',0),(599,'Dept. of Software Eng., Concordia Univ., Montreal, QC, Canada',0),(600,'Univ. of Minnesota, Minneapolis, MN, USA',0),(601,'NASA Langley Res. Center, Hampton, VA, USA',0),(602,'NASA Ames Res. Center, Moffett Field, CA, USA',0),(603,'Google Inc., Zurich, Switzerland',0),(604,'Univ. of St. Andrews, St. Andrews, UK',0),(605,'Queen\'s Univ., Kingston, ON, Canada',0),(606,'Chapman Univ., Orange, NJ, USA',0),(607,'Univ. of Wisconsin-Madison, Madison, WI, USA',0),(608,'Univ. of Chicago, Chicago, IL, USA',0),(609,'Univ. of Milano Bicocca, Milan, Italy',0),(610,'Univ. della Svizzera Italiana (USI), Lugano, Switzerland',0),(611,'Dept. of Comput. & Commun., Open Univ., Milton Keynes, UK',0),(612,'Center for Syst. & Software Eng., Univ. of Southern California, Los Angeles, CA, USA',0),(613,'Dept. de Inf. e Mat. Aplic., Univ. Fed. do Rio Grande do Norte, Natal, Brazil',0),(614,'Sch. of Comput. Sci., McGill Univ., Montreal, QC, Canada',0),(615,'Google Inc., Mountain View, CA, USA',0),(616,'Vanderbilt Univ., Nashville, TN, USA',0),(617,'California State Polytech. Univ., Pomona, CA, USA',0),(618,'Univ. of Alabama, Tuscaloosa, AL, USA',0),(619,'IBM Res. - Haifa, Haifa, Israel',0),(620,'Dept. of Autom. Control, Beihang Univ., Beijing, China',0),(621,'Dept. of Comput. Sci., Univ. of Leicester, Leicester, UK',0),(622,'Dept. of Comput. Sci., Univ. degli Studi di Milano, Milan, Italy',0),(623,'Sch. of Comput. & Commun., Lancaster Univ., Lancaster, UK',0),(624,'Grad. Sch. of Inf., Univ. of Amsterdam, Amsterdam, Netherlands',0),(625,'GrammaTech, Inc., Madison, WI, USA',0),(626,'GrammaTech, Inc., Ithaca, NY, USA',0),(627,'David Cheriton Sch. of Comput. Sci., Univ. of Waterloo, Waterloo, ON, Canada',0),(628,'Dept. of EECS, Univ. of California, Berkeley, Berkeley, CA, USA',0),(629,'Microsoft Res., Cambridge, UK',0),(630,'Dipt. di Elettron. Inf. e Bioingegneria, Politec. di Milano, Milan, Italy',0),(631,'Econocom-Osiatis, Lyon, France',0),(632,'MIT Media Lab., Cambridge, MA, USA',0),(633,'Inria, Rennes, France',0),(634,'Univ. of Appl. Sci. Neu-Ulm, Neu-Ulm, Germany',0),(635,'Electr. & Comput. Eng., Univ. of Waterloo, Waterloo, ON, Canada',0),(636,'Dept. of Inf. & Appl. Math., Fed. Univ. of Rio Grande do Norte, Natal, Brazil',0),(637,'Dept. of Comput. Sci., Univ. of Illinois at Urbana-Champaign, Urbana, IL, USA',0),(638,'Univ. of Waterloo, Waterloo, ON, Canada',0),(639,'Cisco Syst., Bangalore, India',0),(640,'Security Lancaster Res. Centre, Lancaster Univ., Lancaster, UK',0),(641,'Ecole Polytech. Fed. de Lausanne (EPFL), Lausanne, Switzerland',0),(642,'Key Lab. of High Performance Comput., Nat. Univ. of Defense Technol., Changsha, China',0),(643,'Centre for Software Eng., Birmingham City Univ., Birmingham, UK',0),(644,'Fraunhofer Inst. for Exp. Software Eng., Kaiserslautern, Germany',0),(645,'Daimler AG, Sindelfingen, Germany',0),(646,'Adv. Technol. & Res., Volvo Group Trucks Technol., Gothenburg, Sweden',0),(647,'Airbus Group Innovations, Hamburg, Germany',0),(648,'BlackBerry, Canada',0),(649,'York Univ., Toronto, ON, Canada',0),(650,'Sch. of Innovation, Design & Eng., Malardalen Univ., Vasteras, Sweden',0),(651,'Dept. of Appl. Inf. Technol., Chalmers Univ. of Technol., Gothenburg, Sweden',0),(652,'Dept. of Comput. Sci. & Software Eng., Rose-Hulman Inst. of Technol., Terre Haute, IN, USA',0),(653,'Dept. of Inf. Process. Sci., Univ. of Oulu, Oulu, Finland',0),(654,'Fac. of Comput. & Inf., Istanbul Tech. Univ., Istanbul, Turkey',0),(655,'Inst. of Software, Beijing, China',0),(656,'Dept. of Comput. Sci., Western Michigan Univ., Kalamazoo, MI, USA',0),(657,'Dept. of Electr. & Comput. Eng., Virginia Tech, Blacksburg, VA, USA',0),(658,'NEC Labs. America, Princeton, NJ, USA',0),(659,'SEU/CMU, Univ. of Hawaii, Honolulu, HI, USA',0),(660,'Drexel Univ., Philadelphia, PA, USA',0),(661,'SoftServe Inc., Lviv, Ukraine',0),(662,'Fac. of Inf., Univ. of Toronto, Toronto, ON, Canada',0),(663,'Dept. of Inf. & Comput. Sci., State Univ. of Rio de Janeiro, Rio de Janeiro, Brazil',0),(664,'Dept. of Comput. Sci., Univ. of Toronto, Toronto, ON, Canada',0),(665,'Inst. for Software Res., Univ. of California, Irvine, Irvine, CA, USA',0),(666,'Sch. of Comput. & Eng., Univ. of Huddersfield, Huddersfield, UK',0),(667,'Dept. de Comput., Univ. Nac. de Rio Cuarto, Rio Cuarto, Argentina',0),(668,'Dept. de Comput., Univ. de Buenos Aires, Buenos Aires, Argentina',0),(669,'Dept. of Comput. Sci., NCSU, Raleigh, NC, USA',0),(670,'Manage. Sch., Lancaster Univ., Lancaster, UK',0),(671,'LICA, Lancaster Univ., Lancaster, UK',0),(672,'Comput. Sci. Dept., Univ. of California, Davis, Davis, CA, USA',0),(673,'Specialised Archit. Services Ltd., Wellington, New Zealand',0),(674,'Dept. of Comput. Sci., Elon Univ., Elon, NC, USA',0),(675,'Dept. of Electr. Eng. & Comput. Sci., Northern Arizona Univ., Flagstaff, AZ, USA',0),(676,'Univ. of Central Florida, Orlando, FL, USA',0),(677,'Bowling Green State Univ., Bowling Green, OH, USA',0),(678,'SINTEF ICT, Oslo, Norway',0),(679,'Distrib. Syst. Group, Trinity Coll. Dublin, Dublin, Ireland',0),(680,'Sch. of Comput. Sci., Univ. of Massachusetts, Amherst, MA, USA',0),(681,'Microsoft, Washington, DC, USA',0),(682,'IBM Res., Bangalore, India',0),(683,'Lero - The Irish Software Res. Centre, Univ. of Limerick, Limerick, Ireland',0),(684,'Fraunhofer Center for Exp. SE, College Park, MD, USA',0),(685,'Semmle Ltd., Oxford, UK',0),(686,'Software Process Res. Group, Aalto Univ., Aalto, Finland',0),(687,'SEGAL, Univ. of Victoria, Victoria, BC, Canada',0),(688,'Centre For Security, Reliability & Trust, Univ. of Luxembourg, Luxembourg, Luxembourg',0),(689,'Dept. of Inf., Syst. & Commun., Univ. of Milano - Bicocca, Milan, Italy',0),(690,'State Key Lab. of Comput. Archit., Inst. of Comput. Technol., Beijing, China',0),(691,'Dept. of Comput. Sci. & Eng., Univ. of Minnesota at Twin-Cities, Minneapolis, MN, USA',0),(692,'Dept. of Comput. Sci. & Eng., Texas A&M Univ., College Station, TX, USA',0),(693,'Key Lab. of Network Data Sci. & Technol., Inst. of Comput. Technol., Beijing, China',0),(694,'Coll. of Inf. Eng., Capital Normal Univ., Beijing, China',0),(695,'Dept. of Inf. Technol., Rochester Inst. of Technol., Zagreb, Croatia',0),(696,'IBM Thomas J. Watson Res. Center, Yorktown Heights, NY, USA',0),(697,'DEEDS Group, Tech. Univ. Darmstadt, Darmstadt, Germany',0),(698,'DIETI, Federico II Univ. of Naples, Naples, Italy',0),(699,'Comput. & Commun. Dept., Open Univ., Milton Keynes, UK',0),(700,'Interdiscipl. Centre for Security, Univ. of Luxembourg, Luxembourg, Luxembourg',0),(701,'Microsoft, Beijing, China',0),(702,'Sch. of Sci. & Technol., Middlesex Univ., London, UK',0),(703,'R. Holloway Univ. of London, Egham, UK',0),(704,'Dept. de Informdtica, Pontiticia Univ. Catdlica do Rio de Janeiro, Rio de Janeiro, Brazil',0),(705,'Dept. de Inf. e Cienc. da Computacau, Univ. do Estado do Rio de Janeiro, Rio de Janeiro, Brazil',0),(706,'CS Dept., KAIST, Daejeon, South Korea',0),(707,'LG Electron., Seoul, South Korea',0),(708,'Google, Waterloo, ON, Canada',0),(709,'Interdiscipl. Centre for Security, Reliability & Trust, Univ. of Luxembourg, Luxembourg, Luxembourg',0),(710,'CREST Centre, Univ. Coll. London, London, UK',0),(711,'Fac. of Inf. Manage., Hannan Univ., Matsubara, Japan',0),(712,'Jonathan de Halleux Microsoft Res., Redmond, WA, USA',0),(713,'Appl. Data Sci., Australia',0),(714,'Monash Univ., Melbourne, VIC, Australia',0),(715,'OTH Regensburg, Siemens AG, Regensburg, Germany',0),(716,'Friedrich-Alexander-Univ., Erlangen, Germany',0),(717,'Massachusetts Inst. of Technol., Cambridge, MA, USA',0),(718,'Dept. of Math., Ryerson Univ., Toronto, ON, Canada',0),(719,'Mech. & Ind. Eng., Ryerson Univ., Toronto, ON, Canada',0),(720,'IBM Toronto Software Lab., Toronto, ON, Canada',0),(721,'Fac. of Electr. Eng. & Inf., Univ. of Appl. Sci. & Arts, Coburg, Germany',0),(722,'Univ. of Texas, Austin, TX, USA',0),(723,'Texas State Univ., San Marcos, TX, USA',0),(724,'NASA Ames Res. Center, Carnegie Mellon Univ., Moffett Field, CA, USA',0),(725,'Human-Comput. Interaction Inst., Carnegie Mellon Univ., Pittsburgh, PA, USA',0),(726,'Electr. & Comput. Eng., Univ. of Texas at Austin, Austin, TX, USA',0),(727,'Dept. of Comput. Sci., Univ. of Texas at Dallas, Dallas, TX, USA',0),(728,'Inst. for Comput. & Inf. Sci., Radboud Univ. Nijmegen, Nijmegen, Netherlands',0),(729,'Software Improvement Group, Amsterdam, Netherlands',0),(730,'Carnegie Mellon Univ. - Silicon Valley, Moffett Field, CA, USA',0),(731,'Dept. of Comput. Sci., Univ. of Oxford, Oxford, UK',0),(732,'iMinds-DistriNet, KU Leuven, Leuven, Belgium',0),(733,'Fraunhofer USA Center for Exp. Software Eng. (CESE), MD, USA',0),(734,'NASA Goddard Space Flight Center, Greenbelt, MD, USA',0),(735,'Dipt. di Ing. Elettr. e Tecnol. dell\'Inf., Univ. degli Studi di Napoli Federico II, Naples, Italy',0),(736,'Selex ES S.p.A., Finmeccanica Co., Rome, Italy',0),(737,'Dept. of Comput. Sci., UC Davis, Davis, CA, USA',0),(738,'Elon Univ., Elon, NC, USA',0),(739,'Wesleyan Univ., Middletown, CT, USA',0),(740,'Miami Univ., Oxford, OH, USA',0),(741,'Dept. de Genie Inf. et Genie Logiciel, Polytech. Montreal, Montr茅al, QC, Canada',0),(742,'NICTA, Sydney, NSW, Australia',0),(743,'Univ. of Sci. & Technol. of China, Hefei, China',0),(744,'Dept. of Ind. Eng., Tsinghua Univ., Beijing, China',0),(745,'Sch. of Comput. Sci. & Technol., Beijing Inst. of Technol., Beijing, China',0),(746,'Univ. of North Texas, Denton, TX, USA',0),(747,'Univ. of Portsmouth, Portsmouth, UK',0),(748,'Univ. of Magdeburg, Magdeburg, Germany',0),(749,'Tech. Univ. Braunschweig, Braunschweig, Germany',0),(750,'Software Improvement Group, Delft Univ. of Technol., Delft, Netherlands',0),(751,'Nara Inst. of Sci. & Technol., Nara, Japan',0),(752,'McGill Univ., Montreal, QC, Canada',0),(753,'Univ. of California Santa Cruz, Santa Cruz, CA, USA',0),(754,'SRI Int., Menlo Park, CA, USA',0),(755,'Dept. of Comput., Fed. Univ. of Technol., Paran谩, Brazil',0),(756,'Inst. of Comput., Fed. Univ. of Amazonas, Manaus, Brazil',0),(757,'Inst. of Math. & Stat., Univ. of Sao Paulo, Sao Paulo, Brazil',0),(758,'Paul G. Allen Sch. of Comput. Sci. & Eng., Univ. of Washington, Seattle, WA, USA',0),(759,'Software Inst., Univ. della Svizzera italiana, Lugano, Switzerland',0),(760,'Dept. of Eng., Univ. of Sannio, Benevento, Italy',0),(761,'STAKE Lab., Univ. of Molise, Pesche, Italy',0),(762,'Humboldt Univ. of Berlin, Berlin, Germany',0),(763,'State Key Lab. of Comput. Sci., Inst. of Software, Beijing, China',0),(764,'Comput. Sci. & Eng. Dept., Univ. of Texas at Arlington, Arlington, TX, USA',0),(765,'EECS Dept., Vanderbilt Univ., Nashville, TN, USA',0),(766,'Alibaba Group, Hangzhou, China',0),(767,'East China Univ. of Sci. & Technol., Shanghai, China',0),(768,'Nat. Taiwan Univ., Taipei, Taiwan',0),(769,'Hasso-Plattner-Inst. Potsdam, Potsdam, Germany',0),(770,'Univ. Koblenz-Landau, Koblenz, Germany',0),(771,'Univ. Marburg, Marburg, Germany',0),(772,'Univ. di Verona, Verona, Italy',0),(773,'Julia Srl, Italy',0),(774,'Dept. of Comput., Imperial Coll. London, London, UK',0),(775,'Concordia Univ., Montreal, QC, Canada',0),(776,'Dept. of Manage. Sci. & Technol., Athens Univ. of Econ. & Bus., Athens, Greece',0),(777,'Sch. of Inf. & Comput. Sci., UC Irvine, Irvine, CA, USA',0),(778,'Dept. of Comput. Sci., Univ. of Saskatchewan, Saskatoon, SK, Canada',0),(779,'IIT Kanpur',0),(780,'MSR Redmond',0),(781,'Sch. of Comput. Sci., McGill Univ., Montr茅al, QC, Canada',0),(782,'Gran Sasso Sci. Inst., L\'Aquila, Italy',0),(783,'Dept. of Comput. Sci. & Software Eng., Auburn Univ., Auburn, AL, USA',0),(784,'FACOM, UFMS, Campo Grande, Brazil',0),(785,'Valente ASERG Group, UFMG, Valente, Brazil',0),(786,'SwSE Group, Free Univ. of Bozen-Bolzano, Bolzano, Italy',0),(787,'Center for IT-Security, Privacy & Accountability, Saarbrucken, Germany',0),(788,'Tech. Univ. of Darmstadt, Darmstadt, Germany',0),(789,'TATA Res. Dev. & Design Centre, TATA Consultancy Services Ltd., Pune, India',0),(790,'Syst. & Requirements Eng. Center, DePaul Univ., Chicago, IL, USA',0),(791,'Shanghai Key Lab. of Data Sci., Fudan Univ., Shanghai, China',0),(792,'Sch. of Syst. & Enterprises, Stevens Inst. of Technol., Hoboken, NJ, USA',0),(793,'Inf. Dept., PUC-Rio Rio de Janeiro, Rio de Janeiro, Brazil',0),(794,'Dept. of Comput. Sci., USC, Los Angeles, CA, USA',0),(795,'Univ. Nac. de Rio Cuarto, Rio Cuarto, Argentina',0),(796,'ICTT & ISN Lab., Xidian Univ. Xi\'an, Xi\'an, China',0),(797,'Dept. of Comput. Sci. & Tech., Nanjing Univ., Nanjing, China',0),(798,'Sch. of Comput. Sci. & Eng., Univ. of New South Wales, Sydney, NSW, Australia',0),(799,'Centre for Artificial Intell. & Sch. of Software, Univ. of Technol., Sydney, NSW, Australia',0),(800,'Data61, CSIRO, Australia',0),(801,'DEEPSE group - DEIB, Politec. di Milano, Milan, Italy',0),(802,'SnT Centre, Univ. of Luxembourg, Luxembourg, Luxembourg',0),(803,'Dept. of Comput. Sci. & Eng., Univ. of Nebraska, Lincoln, NE, USA',0),(804,'Drexel Univ. Philadelphia, Philadelphia, PA, USA',0),(805,'SEI, Univ. of Hawaii, Honolulu, HI, USA',0),(806,'Sch. of Comput. Sci., Fudan Univ., Shanghai, China',0),(807,'Tel Aviv Univ., Tel Aviv, Israel',0),(808,'Imperial Coll. London, London, UK',0),(809,'Dept. of Comput. Sci., Univ. of Texas at San Antonio, San Antonio, TX, USA',0),(810,'Dept. of Comput. Sci., Grinnell Coll., Grinnell, IA, USA',0),(811,'Coll. of Inf. & Comput. Sci., Univ. of Massachusetts, Amherst, MA, USA',0),(812,'Key Lab. of Data Eng. & Knowledge Eng., Renmin Univ. of China, Beijing, China',0),(813,'Univ. of Texas at San Antonio, San Antonio, TX, USA',0),(814,'Grammatech Inc., Ithaca, NY, USA',0),(815,'Univ. of Nebraska - Lincoln, Lincoln, NE, USA',0),(816,'Dept. of Comput. Sci., Iowa State Univ. Ames, Ames, IA, USA',0),(817,'Dept. of Comp. Sci., Univ. of Kentucky, Lexington, KY, USA',0),(818,'Dept. of Comp. Sci. & Eng., Univ. of Nebraska - Lincoln, Lincoln, NE, USA',0),(819,'Simula Res. Lab., Oslo, Norway',0),(820,'Beihang Univ., Beijing, China',0),(821,'Cisco Syst., Oslo, Norway',0),(822,'UNSW Sydney, Sydney, NSW, Australia',0),(823,'Univ. of Technol. Sydney, Sydney, NSW, Australia',0),(824,'Software Eng. Inst., Pittsburgh, PA, USA',0),(825,'Dept. Electr. Eng. & Comput. Sci., Univ. of Tennessee, Knoxville, TN, USA',0),(826,'Hong Kong Univ. of Sci. & Technol., Hong Kong, China',0),(827,'Univ. of Newcastle, Callaghan, NSW, Australia',0),(828,'Key Lab. for Ubiquitous Network & Service Software of Liaoning Province, Dalian Univ. of Technol., Dalian, China',0),(829,'Sch. of Comput. Sci., Wuhan Univ., Wuhan, China',0),(830,'Dept. of Comput. Sci. & Technol., Nanjing Univ., Nanjing, China',0),(831,'Sch. of Comput. Sci., Carleton Univ., Ottawa, ON, Canada',0),(832,'Lawrence Berkeley Nat. Lab., Berkeley, CA, USA',0),(833,'Oracle Corp., USA',0),(834,'IT Univ. of Copenhagen, Copenhagen, Denmark',0),(835,'IBM T.J. Watson Res. Center, Yorktown Heights, NY, USA',0),(836,'Parasol Lab., Texas A&M Univ., College Station, TX, USA',0),(837,'IBM Res. - Almaden, San Jose, CA, USA',0),(838,'Google, Inc., Mountain View, CA, USA',0),(839,'MTA-BME Lendulet Cyber-Phys. Syst. Res. Group, Budapest, Hungary',0),(840,'IEE S.A., Luxembourg',0),(841,'EECS, MIT, Cambridge, MA, USA',0),(842,'Dept. of Electr. & Comput. Eng., Queen\'s Univ., Kingston, ON, Canada',0),(843,'List Software Safety & Security Lab., CEA, Gif-sur-Yvette, France',0),(844,'SnT, Univ. of Luxembourg, Luxembourg, Luxembourg',0),(845,'Dept. of Comput. Sci., Univ. of Nevada, Las Vegas, Las Vegas, NV, USA',0),(846,'Inst. for Comput. Sci. & Bus. Inf. Syst., Univ. of Duisburg-Essen, Essen, Germany',0),(847,'Univ. of Pennsylvania, Philadelphia, PA, USA',0),(848,'Lab. d\'Inf., Ecole Polytech., Palaiseau, France',0),(849,'Sch. of Electr. Eng. & Comput. Sci., Ohio Univ. Athens, Athens, OH, USA',0),(850,'Southern Univ. of Sci. & Technol., Shenzhen, China',0),(851,'Sch. of Comput. Sci., Univ. of Sci. & Technol. of China, Hefei, China',0),(852,'Univ. of Michigan, Ann Arbor, MI, USA',0),(853,'Wandoujia Lab., Beijing, China',0),(854,'Dept. of Comput. Sci., Iowa State Univ., Ames, IA, USA',0),(855,'ICTEAM, Univ. Catholique de Louvain, Louvain, Belgium',0),(856,'Univ. Rey Juan Carlos, Mostoles, Spain',0),(857,'Osaka Univ., Suita, Japan',0),(858,'Nara Inst. of Technol., Nara, Japan',0),(859,'Coll. of William & Mary Williamsburg, Williamsburg, VA, USA',0),(860,'Tech. Univ. Ilmenau, Ilmenau, Germany',0),(861,'Univ. of Notre Dame, Bend, OR, USA',0),(862,'Univ. of Bamberg, Bamberg, Germany',0),(863,'Rice Univ., Houston, TX, USA',0),(864,'SEI/CMU, Univ. of Hawaii, Honolulu, HI, USA',0),(865,'Lero (Irish Software Res. Centre), Univ. of Limerick, Limerick, Ireland',0),(866,'DeepSE Group at DEIB, Politec. di Milano, Milan, Italy',0),(867,'Applic. Threat Intell., Ixia, Bucharest, Romania',0),(868,'Centro de Inf., Univ. Fed. de Pernambuco, Recife, Brazil',0),(869,'Dept. de Estatistica e Inf., Univ. Fed. Rural de Pernambuco, Recife, Brazil',0),(870,'Univ. of Maryland, College Park, MD, USA',0),(871,'Secure Software Eng. Group, Tech. Univ. Darmstadt, Darmstadt, Germany',0),(872,'Fujitsu Labs. of America, Sunnyvale, CA, USA',0),(873,'Dept. Comput. Sci., Univ. of California, Davis, Davis, CA, USA',0),(874,'Dept. Electr. & Comput. Eng., Univ. of Auckland, Auckland, New Zealand',0),(875,'Dept. Autom., Zhejiang Univ. of Technol., Hangzhou, China',0),(876,'Dept. Comput. Sci., Univ. of Victoria, Victoria, BC, Canada',0),(877,'Netaji Subhas Inst. of Technol., Delhi, India',0),(878,'Google Deepmind, London, UK',0),(879,'Delphi Automotive Syst., Luxembourg',0),(880,'Carnegie Mellon Univ. Pittsburgh, Pittsburgh, PA, USA',0),(881,'Fed. Univ. of Alagoas, Maceio, Brazil',0),(882,'Univ. Passau, Passau, Germany',0),(883,'Google, USA',0),(884,'University of Texas at Dallas',0),(885,'Tsinghua University',0),(886,'Peking University',0),(887,'Wayne State University',0),(888,'Samsung Electronics',0),(889,'Fujitsu Laboratories Ltd.',0),(890,'East China Normal University',0),(891,'R&D Institute, CASCO Signal Ltd.',0),(892,'San Diego State University',0),(893,'Nanjing University',0),(894,'University of Washington',0),(895,'Ministry of Education',0),(896,'Shenzhen University',0),(897,'Teesside University',0),(898,'Queen\'s University',0),(899,'Institute for Enterprise Systems (InES), University of Mannheim',0),(900,'Institute of Software, Chinese Academy of Sciences',0),(901,'LMU Munich',0),(902,'ZTE Corporation',0),(903,'The Open University, UK',0),(904,'Tata Research Development and Design Center, India',0),(905,'Accenture Labs, India',0),(906,'Accenture, Singapore',0),(907,'Tata Consultancy Services Ltd.',0),(908,'TCS Research',0),(909,'Tongji University, China',0),(910,'The Hong Kong Polytechnic University',0),(911,'Wuhan University',0),(912,'Michigan State University',0),(913,'Rochester Institute of Technology',0),(914,'Chemnitz University of Technology, Airbus Defence and Space GmbH',0),(915,'Paul G. Allen University of Washington',0),(916,'Lawrence Livermore National Laboratory',0),(917,'IST, University of Lisbon',0),(918,'Palo Alto Research Center',0),(919,'IST, University of Lisbon and INESC-ID',0),(920,'Fraunhofer IEM',0),(921,'Paderborn University',0),(922,'Paderborn University and Fraunhofer IEM',0),(923,'JetBrains',0),(924,'JetBrains Research',0),(925,'Birla Institute of Technology and Science, Pilani, Goa, India',0),(926,'Deakin University',0),(927,'Anhui University',0),(928,'Swinburne University of Technology',0),(929,'State Key Laboratory of Computer Science, Institute of Software Chinese Academy of Sciences',0),(930,'University of Chinese Academy of Sciences',0),(931,'University of Minnesota',0),(932,'KTH Royal Institute of Technology',0),(933,'Imperial College London',0),(934,'University of Texas at San Antonio',0),(935,'Trail of Bits',0),(936,'Universidad de los Andes',0),(937,'The University of Tennessee',0),(938,'University of Siegen',0),(939,'Real-Time Systems Lab, TU Darmstadt',0),(940,'Software Systems Engineering, Department of Computer Science, University College London, United Kingdom',0),(941,'Comput. Sci. Dept., Utah State Univ., Logan, UT, USA',0),(942,'NASA Ames Research Center, USA',0),(943,'Institute for Theoretical Computer Science, Karlsruhe Institute of Technology (KIT), Germany',0),(944,'Nimble Research, Arcadia, CA 91006, USA',0),(945,'Dept. of Bus. Inf. - Software Eng., Johannes Kepler Univ. Linz, Linz, Austria',0),(946,'State Key Lab of Computer Science, Institute of Software, Chinese Academy of Sciences, China, University of Chinese Academy of Sciences, China',0),(947,'Department of Software Technolgy, Delft University of Technology, The Netherlands',0),(948,'Dept. of Math. & Comput. Sci., Eindhoven Univ. of Technol., Eindhoven, Netherlands',0),(949,'School of Computer Science, The University of Manchester, U.K.',0),(950,'Politecnico di Milano, DEIB, Italy',0),(951,'University of California at Berkeley, USA',0),(952,'Faculty of ICT, Centre for Computing and Engineering Software and Systems (SUCCESS), Swinburne University of Technology, Hawthorn 3122, VIC, Australia',0),(953,'Institute of Software Technology, Universit盲t Stuttgart, Universit盲tsstra脽e 38, D-70569, Germany',0),(954,'Abel Bliss Professor, Department of Computer Science, University of Illinois at Urbana-Champaign, USA',0),(955,'North Dakota State University, Computer Science, Fargo, USA',0),(956,'Chair of Software Engineering, Faculty of Computer Science, Otto-von-Guericke University Magdeburg, Germany',0),(957,'Department of Computer Science, University of York, UK',0),(958,'Centre for Artificial Intell. Res. Comput. Sci. Div., Matieland Stellenbosch Univ., Stellenbosch, South Africa',0),(959,'Beijing Institute of Technology',0),(960,'Dalian University of Technology',0),(961,'University of Saskatchewan',0),(962,'Bauhaus-University Weimar',0),(963,'Saarland University',0),(964,'Kyungpook National University',0),(965,'RIT',0),(966,'Beijing University of Posts and Telecommunications',0),(967,'SKLOIS, Chinese Academy of Sciences',0),(968,'Zhejiang University, Ningbo Research Institute, PengCheng Laboratory',0),(969,'State University of Cear谩, Fortaleza, CE, Brazil',0),(970,'University of British Columbia',0),(971,'University of California San Diego',0),(972,'University of Adelaide',0),(973,'Tianjin University',0),(974,'Kyushu University',0),(975,'The Pennsylvania State University',0),(976,'UC Riverside',0),(977,'Robert Bosch GmbH, Corporate Research',0),(978,'Robert Bosch Automotive Steering GmbH',0),(979,'University of Luxembourg, Luxembourg',0),(980,'Nantong University',0),(981,'The University of Newcastle',0),(982,'China University of Mining and Technology',0),(983,'IIIT Delhi',0),(984,'The University of Queensland',0),(985,'ITBA',0),(986,'UNRC',0),(987,'Universit盲t Leipzig',0),(988,'Christian-Albrechts-Universit盲t zu Kiel',0),(989,'Federal University of Pernambuco',0),(990,'Saint Petersburg Polytechnic University',0),(991,'Microsoft Azure',0),(992,'Queensland University of Technology',0),(993,'National University of Defense Technology',0),(994,'Chinese Academy of Sciences',0),(995,'University of New South Wales',0),(996,'Carnegie Mellon University and NASA Ames',0),(997,'Fiddler labs',0),(998,'Microsoft, China',0),(999,'The Hong Kong University of Sci. and Tech.',0),(1000,'Boston University',0),(1001,'UNSW Sydney',0),(1002,'SKL of Computer Architecture, ICT, CAS, China',0),(1003,'Berger-Levrault, France',0),(1004,'脡cole de Technologie Sup茅rieure, Montreal, Canada',0),(1005,'Universit茅 de Lille, France',0),(1006,'RMoD - Inria Nord Europe, Lille, France',0),(1007,'MINES ParisTech',0),(1008,'XiDian University',0),(1009,'Zhejiang University City College, China',0),(1010,'Singapore Management University, Singapore',0),(1011,'Stellenbosch University',0),(1012,'University of Salerno',0),(1013,'University of Molise',0),(1014,'Technical University of Munich',0),(1015,'BMW Group Research',0),(1016,'Charles University in Prague',0),(1017,'Nanjing University of Aeronautics and Astronautics',0),(1018,'Waterloo University',0),(1019,'CISPA Helmholtz Institute for Information Security',0),(1020,'York University',0),(1021,'Copywell Inc.',0),(1022,'City University of Hong Kong',0),(1023,'University of Minnesota, Duluth',0),(1024,'Virginia Tech',0),(1025,'University of Bradford',0),(1026,'Stony Brook University & Virginia Tech',0),(1027,'Paderborn University & Fraunhofer IEM',0),(1028,'University of Michigan-Dearborn',0),(1029,'The Ohio State University',0),(1030,'Boise State University',0),(1031,'Fuxi AI Lab, Neteast, Inc.',0),(1032,'Fuxi AI Lab, Netease, Inc.',0),(1033,'AI Lab, Netease, Inc.',0),(1034,'Institute of Information Science, Academia Sinica',0),(1035,'Arizona State University',0),(1036,'University of New Mexico',0),(1037,'CEA LIST',0),(1038,'Univ. Grenoble Alpes',0),(1039,'Technische Universit盲t Darmstadt',0),(1040,'Drexel University',0),(1041,'University of Hawaii & SEI/CMU',0),(1042,'The Chinese University of Hong Kong',0),(1043,'Carnegie Mellon University Software Engineering Institute',0),(1044,'Singapore University of Technology and Design',0),(1045,'Zhejiang University and Alibaba-Zhejiang University Joint Institute of Frontier Technologies',0),(1046,'Stony Brook University',0),(1047,'Sun Yat-Sen University & The Chinese University of Hong Kong',0),(1048,'Huawei Noah鈥檚 Ark Lab, China',0),(1049,'ETH Zurich',0),(1050,'University of Colorado at Colorado Springs',0),(1051,'University of Central Florida',0),(1052,'University of Technology Sydney',0),(1053,'University of Illinois at Chicago',0),(1054,'Tencent Inc.',0),(1055,'Fudan University',0),(1056,'University of Virginia',0),(1057,'University of California at Santa Barbara',0),(1058,'Southern Methodist University',0),(1059,'National University of Singapore',0),(1060,'University College London',0),(1061,'The University of Texas at Dallas',0),(1062,'Huazhong University of Science and Technology',0),(1063,'University of Lahore, Pakistan',0),(1064,'Google',0),(1065,'The University of Texas at Dallas, USA',0),(1066,'Amazon Corporation',0),(1067,'Indian Institute of Technology Madras',0),(1068,'Dept. of Comput. Sci., Univ. of Calgary, Calgary, AB, Canada',0),(1069,'Gachon University, Republic of Korea',0),(1070,'National University of Singapore, Singapore',0),(1071,'Australia National University, Australia',0),(1072,'University of Passau, Germany',0),(1073,'Siemens AG 脰sterreich, Vienna, Austria',0),(1074,'Max Planck Institute for Informatics, Saarbr眉cken, Germany',0),(1075,'Logic4Business GmbH, Saarbr眉cken, Germany',0),(1076,'Comptuer Science, North Carolina State University, USA',0),(1077,'Department of Computer Science, Florida State University, Tallahassee, USA',0),(1078,'The University of Tokyo, Japan',0),(1079,'Waseda University, Tokyo, Japan',0),(1080,'National Institute of Informatics, Tokyo, Japan',0),(1081,'The University of Tokyo, National Institute of Informatics, Japan',0),(1082,'Department of Computer Science, University of Illinois at Urbana-Champaign, USA',0),(1083,'UFPA, Brazil',0),(1084,'SUNY Binghamton, USA',0),(1085,'UFPE, Brazil',0),(1086,'UC Irvine, USA',0),(1087,'University of Nebraska-Lincoln, USA',0),(1088,'Stellenbosch University, South Africa',0),(1089,'School of Computer Sci. & Eng., Nanjing University of Sci. & Tech., Nanjing, China',0),(1090,'Parasol Laboratory, Texas A&M University, College Station, TX, USA',0),(1091,'NEC Laboratories America, USA',0),(1092,'School of Computer Engineering, Nanyang Technological University, Singapore',0),(1093,'Sch. of Electr. Eng. & Comput. Sci., Washington State Univ., Pullman, WA, USA',0),(1094,'Dept. of Comput. Sci., Vrije Univ., Amsterdam, Netherlands',0),(1095,'University of Molise, Italy',0),(1096,'Universit脿 della Svizzera italiana (USI), Switzerland',0),(1097,'The College of William and Mary, USA',0),(1098,'Tata Research, Development and Design Center, 54 Hadapsar Industrial Estates, Pune, 411013, India',0),(1099,'Christian Doppler Lab. MEVSS, Johannes Kepler Univ. Linz, Linz, Austria',0),(1100,'Inst. for Software Syst. Eng., Johannes Kepler Univ., Linz, Austria',0),(1101,'Computer Science & Engineering, University of Washington, USA',0),(1102,'School of Computing, Teesside University, United Kingdom',0),(1103,'School of Computer Science and Engineering, Nanyang Technological University, Singapore',0),(1104,'Christian Doppler Laboratory MEVSS, Institute for Software Systems Engineering, Johannes Kepler University Linz, Austria',0),(1105,'Department of Computer Science, ETH Zurich, Switzerland',0),(1106,'Department of Computer Science, TU Darmstadt, Germany',0),(1107,'Department of Computing and Software, McMaster University, Hamilton, Ontario, Canada, L8S 4K1',0),(1108,'North Carolina State University, Raleigh, NC, USA',0),(1109,'Laboratory for Internet Software Technologies, Institute of Software Chinese Academy of Sciences, Beijing, China',0),(1110,'Center for Systems and Software Engineering, University of Southern California, Los Angeles, USA',0),(1111,'Gran Sasso Science Institute, Viale Francesco Crispi, 7, L\'Aquila, Italy',0),(1112,'IMT School for Advanced Studies, Piazza San Francesco, 19 Lucca, Italy',0),(1113,'University of Rennes 1, Irisa/Inria, Campus Universitaire de Beaulieu, 35042 cedex, France',0),(1114,'Fondazione Bruno Kessler, Trento, Italy',0),(1115,'Georgia Institute of Technology, USA',0),(1116,'Carnegie Mellon Silicon Valley, NASA Ames, Moffet Field, CA, USA',0),(1117,'Sch. of Electr. Eng. & Comput. Sci., Oregon State Univ., Corvallis, OR, USA',0),(1118,'North Carolina State University, Raleigh, USA',0),(1119,'Microsoft Research, Redmond, WA, USA',0),(1120,'Federal University of Pernambuco, Pernambuco, Brazil',0),(1121,'Eindhoven U of Technology, The Netherlands',0),(1122,'Nanjing Universit, China',0),(1123,'UC Davis, USA',0),(1124,'Department of Computer Science & Engineering, Bangladesh University of Engineering and Technology, Dhaka, Bangladeshi',0),(1125,'Department of Computer Science, Southern Illinois University Carbondale, IL, USA',0),(1126,'AtlanMod Team, Inria, IMT Atlantique, LS2N, Nantes, France',0),(1127,'TRAME Team, Groupe ESEO, Angers, France',0),(1128,'ICREA, UOC, Barcelona, Spain',0),(1129,'Department of Computer Science, University of California, Davis, USA',0),(1130,'State Key Laboratory for Novel Software Technology, Nanjing University, Jiangsu, China',0),(1131,'University of Southern California, Los Angeles, USA',0),(1132,'University of Salerno, Fisciano, Italy',0),(1133,'University of Sannio, Benevento, Italy',0),(1134,'University of Molise, Pesche (IS), Italy',0),(1135,'The College of William and Mary, Williamsburg, VA, USA',0),(1136,'School of Electrical and Electronic Engineering, Nanyang Technological University, Singapore',0),(1137,'SnT Centre, University of Luxembourg, Luxembourg',0),(1138,'Key Laboratory of High Confidence Software Technologies, Ministry of Education, Beijing, China, 100871',0),(1139,'Inst. for Syst. Software, Johannes Kepler Univ. Linz, Linz, Austria',0),(1140,'IMDEA Software Inst., Spain',0),(1141,'Christian Doppler Lab MEVSS, ISSE, Johannes Kepler University Linz, Austria',0),(1142,'Computer Science and Engineering, University of Notre Dame, IN, USA',0),(1143,'Graduate School of Information Science and Technology, Osaka University, 1-5, Yamadaoka, Suita, Osaka, 565-0871, Japan',0),(1144,'Institute of Mathematics and Statistics, University of Sao Paulo, Brazil',0),(1145,'School of Arts, Sciences and Humanities, University of Sao Paulo, Brazil',0),(1146,'Dept. of Inf. Eng., Univ. of L\'Aquila, L\'Aquila, Italy',0),(1147,'Inria/Lip6 Regal, France',0),(1148,'Department of Computer Science, Wayne State University, Detroit, Michigan, USA',0),(1149,'Computer Science Department, University of Southern California, 941 Bloom Walk, Los Angeles, California, USA 90089',0),(1150,'University of Chinese Academy of Sciences, Beijing, 100049, P.R. China',0),(1151,'Department of Computer Science, Occidental College, Los Angeles, CA',0),(1152,'ICTT and ISN Lab, Xidian University, Xi\'an 710071, P.R. China',0),(1153,'Department of Computer Science, University of Oxford, UK',0),(1154,'IMT Inst. for Adv. Studies Lucca, Lucca, Italy',0),(1155,'Department of Electrical and Computer Engineering, University of Waterloo, Waterloo, ON N2L 3G1, Canada',0),(1156,'Department of Computer Science and Engineering, University of California at San Diego, La Jolla, CA, USA',0),(1157,'Imperial College London, United Kingdom',0),(1158,'RWTH Aachen University, Germany',0),(1159,'University of Basilicata, Italy',0),(1160,'University of Salerno, Italy',0),(1161,'Wayne State University, USA',0),(1162,'West Virginia University, USA',0),(1163,'Department of Informatics, University of Zurich, Switzerland',0),(1164,'Computer Science Department, University of Virginia, Charlottesville, USA',0),(1165,'Computer Science Department, University of New Mexico, Albuquerque, USA',0),(1166,'School of Computer Science, McGill University, Montr茅al, QC, Canada',0),(1167,'SWAT Lab Polytechnique, Montr茅al, QC, Canada',0),(1168,'Departamento de Computaci贸n, FCEyN, UBA, CONICET, Buenos Aires, Argentina',0),(1169,'Software Engineering Group, University of Siegen, Germany',0),(1170,'Department of Computer Science, Humboldt-University of Berlin, Germany',0),(1171,'Department of ECE, Virginia Tech, Blacksburg, 24061, USA',0),(1172,'Delft University of Technology - The Netherlands',0),(1173,'School of Computing and Information Systems, The University of Melbourne, Victoria 3010, Australia',0),(1174,'University at Buffalo, The State University of New York, USA',0),(1175,'Accenture Technology Labs, Bangalore, India',0),(1176,'University of Wisconsin-Madison, USA',0),(1177,'Interdiscipl. Centre for Security, Univ. of Luxembourg, Luxembourg City, Luxembourg',0),(1178,'School of Science and Technology, University of Camerino, Camerino, Italy',0),(1179,'DTU Compute, Technical University of Denmark, Lyngby, Denmark',0),(1180,'Sch. of Electron. Eng. & Comput. Sci., Peking Univ., Beijing, China',0),(1181,'Dept. of Comput. Sci., Jinan Univ., Guangzhou, China',0),(1182,'Brigham Young Univ., Provo, UT, USA',0),(1183,'Key Laboratory for Information System Security, Ministry of Education, China',0),(1184,'Electrical and Computer Engineering, Portland State University, USA',0),(1185,'Department of Computer Science, Brigham Young University, Provo, UT, 84602, USA',0),(1186,'Department of Computing, The Hong Kong Polytechnic University, China',0),(1187,'Department of Computer Science and Engineering, Chalmers University of Technology, Sweden',0),(1188,'LIRMM, Universit茅 Montpellier 2 et CNRS, France',0),(1189,'DIRO, Universit茅 de Montr茅al, Canada',0),(1190,'Comput. Sci. Dept., Univ. of Illinois at Urbana-Champaign, Urbana, IL, USA',0),(1191,'Nat. Inst. of Adv. Ind. Sci. & Technol., Amagasaki, Japan',0),(1192,'Univ. of Nantes, Nantes, France',0),(1193,'Software Competence Center Hagenberg, Hagenberg, Austria',0),(1194,'Electrical and Computer Engineering Department, Iowa State University, USA',0),(1195,'Comput. Sci. & Eng. Dept., Univ. of Nebraska-Lincoln, Lincoln, NE, USA',0),(1196,'Department of Computer Science, Purdue University, West Lafayette, Indiana, USA',0),(1197,'IBM T.J. Watson Research Center, Yorktown Height, New York, USA',0),(1198,'Imperial College London UK',0),(1199,'University College London, UK',0),(1200,'University of Southampton, UK',0),(1201,'University of Exeter, UK',0),(1202,'Chalmers & University of Gothenburg, Sweden',0),(1203,'Dept. of Inf. Irvine, Univ. of California, Irvine, Irvine, CA, USA',0),(1204,'Temasek Laboratories, National University of Singapore, Singapore',0),(1205,'School of Computing, National University of Singapore, Singapore',0),(1206,'University of Camerino, Italy',0),(1207,'DTU Compute, Denmark',0),(1208,'Inria / University of Lille, France',0),(1209,'Saarland University, Germany',0),(1210,'University of Lille / Inria / Institut Universitaire de France, France',0),(1211,'Telecom Nancy / Inria, France',0),(1212,'Department of Computer Science, Brown University, Providence, RI, USA',0),(1213,'Simula Research Laboratory, Oslo, Norway',0),(1214,'Loyola University Maryland, Baltimore, Maryland, USA',0),(1215,'Faculty of Information and Communication Technologies, Swinburrne University of Technology, Melbourne, Victoria 3122, Australia',0),(1216,'University of Lugano, Switzerland',0),(1217,'Vienna University of Technology, Austria',0),(1218,'Sch. of Comput., Univ. of Utah, Salt Lake City, UT, USA',0),(1219,'AIST / ITRI, Japan',0),(1220,'Saarland University, Saarbr眉cken, Germany',0),(1221,'School of Computer Science and Engineering, Beihang University, Beijing, China',0),(1222,'Department of Computer Science, City University of Hong Kong, Hong Kong',0),(1223,'paluno - The Ruhr Institute for Software Technology, University of Duisburg-Essen, Gerlingstr. 16, 45127, Germany',0),(1224,'University of Notre Dame, South Bend, IN, USA',0),(1225,'School of Computing, DePaul University, Chicago, USA',0),(1226,'University of Illinois at Urbana-Champaign, United States of America',0),(1227,'University of Nebraska, Lincoln, USA',0),(1228,'IBM Watson Research, Yorktown Heights, NY, USA',0),(1229,'School of Software, Tsinghua University, TNLIST, KLISS, Beijing, China',0),(1230,'State Key Laboratory of Software Development Environment, School of Computer Science and Engineering, Beihang University, Beijing, China',0),(1231,'Virginia Tech, Blacksburg, 24061, USA',0),(1232,'Univ. of Lille / Inria, Lille, France',0),(1233,'Univ. du Quebec a Montreal, Montreal, QC, Canada',0),(1234,'The Pennsylvania State University, University Park, PA 16802, USA',0),(1235,'Microsoft Research Asia, Beijing, China',0),(1236,'Edirium K.K., Japan',0),(1237,'City University of New York, USA',0),(1238,'Tokyo Institute of Technology, Japan',0),(1239,'School of Computing Science, Simon Fraser University, Canada',0),(1240,'Department of Computer Science, Purdue University, USA',0),(1241,'DIETI department, Universit脿 degli Studi di Napoli Federico II, Via Claudio 21, 80125, Italy',0),(1242,'Department of Computer Science, University of Texas at San Antonio, USA',0),(1243,'State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences, Beijing, China',0),(1244,'Microsoft Research, One Microsoft Way, Redmond, WA, USA',0),(1245,'Sch. of Software, Shanghai Jiao Tong Univ., Shanghai, China',0),(1246,'Department of Computer and Information Science, Link枚ping University, Link枚ping, Sweden',0),(1247,'Technical University of Ko拧ice, Slovakia',0),(1248,'School of Computer Science, Fudan University, Shanghai, China',0),(1249,'Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg, Luxembourg',0),(1250,'SES S.A., Betzdorf, Luxembourg',0),(1251,'Fraunhofer SIT, Lancaster, UK',0),(1252,'School of Software, TNLIST, KLISS, Tsinghua University, China',0),(1253,'Department of Computer Science, University of Toronto, Toronto, ON, Canada',0),(1254,'Department of Computer Science, FCEyN, UBA, Argentina',0),(1255,'Department of Computer Science, LUMS School of Science and Engineering, Pakistan',0),(1256,'Department of Computer Science, FCEFQyN, UNRC, Argentina',0),(1257,'Department of Electrical and Computer Engineering, The University of Texas at Austin, USA',0),(1258,'Department of Software Engineering, Instituto Tecnol贸gico de Buenos Aires, Argentina',0),(1259,'University of Sussex, UK',0),(1260,'Universita degli Studi di Salerno, Italy',0),(1261,'Tampere University of Technology, Finland',0),(1262,'Facebook London, Facebook, 10 Brock Street, London, NW1 3FG, UK CREST, University College London, Malet Place, London, WC1E 6BT, UK',0),(1263,'University of California, Irvine, U.S.A.',0),(1264,'University of Nebraska-Lincoln, Lincoln, NE, USA',0),(1265,'Sandia National Laboratories, Albuquerque, NM, USA',0),(1266,'Department of Computer Science, North Carolina State University, USA',0),(1267,'CS Dept. KAIST, South Korea',0),(1268,'Samsung Electronics, South Korea',0),(1269,'University of Waterloo, Ontario, Canada',0),(1270,'SUNY - Univ. at Buffalo, Buffalo, NY, USA',0),(1271,'Department of Computer Science and Engineering, Mississippi State University, MS, USA',0),(1272,'AIST/RISEC, Amagasaki, Japan',0),(1273,'Chiba University, Japan',0),(1274,'Institute for Software Research, Carnegie Mellon University, Pittsburgh, PA, USA',0),(1275,'Technische Univerist盲t Darmstadt, Germany',0),(1276,'University of California, San Diego, USA',0),(1277,'State Key Laboratory for Novel Software Technology, Nanjing University, Nanjing, China',0),(1278,'Department of Electrical and Computer Engineering, University of Calgary, 2500 University DR., N.W., Alberta, Canada (T2N 1N4)',0),(1279,'Department of Computer Science, University of California at Davis, USA',0),(1280,'Department of Linguistics, University of California at Davis, USA',0),(1281,'DePaul University, School of Computing, Chicago, IL 60604, USA',0),(1282,'Department of Computer Science, University of Saskatchewan, Canada',0),(1283,'Dept. Languages and Computer Systems, University of Seville, Spain',0),(1284,'Airbus Helicopters S.A.S., Germany',0),(1285,'Philipps-Universit盲t Marburg, Germany',0),(1286,'Computer Science Department, University of Massachusetts, Amherst, USA',0),(1287,'Institute of Informatics, Goethe University Frankfurt, Germany',0),(1288,'Department of Informatics, University of Athens, Greece',0),(1289,'Computer Science and Engineering, University of Texas at Arlington, USA',0),(1290,'School of Computer Science and Engineering, University of New South Wales (UNSW), Sydney, NSW 2052',0),(1291,'University of Trento, Italy / Tomsk Polytechnic University, Russia',0),(1292,'Microsoft Research, USA',0),(1293,'Technion, Israel',0),(1294,'University College London, United Kingdom',0),(1295,'Sch. of Inf. Technol., Deakin Univ., Melbourne, VIC, Australia',0),(1296,'School of Computing and Communications, The Open University, UK',0),(1297,'Bauhaus-University Weimar, Germany',0),(1298,'Center of Excellence for Software Traceability (CoEST), School of Computing, DePaul University, Chicago, IL, USA',0),(1299,'University of British Columbia, Vancouver, Canada',0),(1300,'Dept. of Comput. Sci., Allegheny Coll., USA',0),(1301,'Faculty of Engineering of University of Porto, Portugal',0),(1302,'University of Sheffield, United Kingdom',0),(1303,'Federal University of Pernambuco, Brazil',0),(1304,'Western Michigan University, Kalamazoo, MI, USA',0),(1305,'University of Southern California, Los Angeles, CA, USA',0),(1306,'School of Computer Science, McGill University, Montreal, QC, Canada',0),(1307,'Project Group Mechatron. Syst. Design, Fraunhofer IPT, Paderborn, Germany',0),(1308,'Dept. of Comput. Sci. & Eng., Univ. of Minnesota, Minneapolis, MN, USA',0),(1309,'Medtronic PLC, USA',0),(1310,'Dept. of Comput. & Inf. Sci., Univ. of Pennsylvania, Philadelphia, PA, USA',0),(1311,'School of Computing, Depaul University, Chicago IL, USA',0),(1312,'Computer Science, Iowa State University, Ames, IA, USA',0),(1313,'Computer Science and Eng., University of Notre Dame, South Bend IN, USA',0),(1314,'State Key Lab of Computer Science, Institute of Software, Chinese Academy of Sciences, China',0),(1315,'Dept. of Computer Science and Engineering, The Ohio State University, United States',0),(1316,'Dept. of Computer Science, Virginia Tech, Blacksburg, 24061, USA',0),(1317,'Tech. Univ. Munchen, Garching, Germany',0),(1318,'University of Waterloo, ON, Canada',0),(1319,'Hong Kong University of Science and Technology, China',0),(1320,'SnT Centre for Security, Reliability and Trust, University of Luxembourg, Luxembourg',0),(1321,'Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN, USA',0),(1322,'University of Texas at Austin, Austin, TX-78712, USA',0),(1323,'University of Illinois at Urbana-Champaign, Urbana, IL-61801, USA',0),(1324,'Department of Computer Science, Brown University, Providence, RI 02912, USA',0),(1325,'University of Illinois at Urbana-Champaign, 61801, USA',0),(1326,'Fac. of Eng., Dept. of Inf. Eng., Univ. of Porto, Porto, Portugal',0),(1327,'Electron. & Comput. Sci., Univ. of Southampton, Southampton, UK',0),(1328,'Div. of Comput. Sci., Stellenbosch Univ., Stellenbosch, South Africa',0),(1329,'School of Information, The University of Texas at Austin, USA',0),(1330,'School of Information Systems, Singapore Management University, Singapore',0),(1331,'Department of Computer Science & Engineering, University of Minnesota, MN, USA',0),(1332,'Rockwell Collins, Advanced Technology Center, IA, USA',0),(1333,'KAIST, Daejeon, South Korea',0),(1334,'GIST, Gwangju, South Korea',0),(1335,'Information Technology Group, Wageningen University and Research Centre, The Netherlands',0),(1336,'CNRS, LORIA, UMR 7503 Vandoeuvre-les-Nancy, F-54500, Nancy, France',0),(1337,'System Engineering Platforms, Airbus Group Innovations, Toulouse, France',0),(1338,'Ege University, International Computer Institute, Izmir, Turkey',0),(1339,'UNIT Information Technologies R&D Ltd., Izmir, Turkey',0),(1340,'University of British Columbia, Vancouver, BC, Canada',0),(1341,'Department of Computer, Control, and Management Engineering, Sapienza University of Rome, Italy',0),(1342,'University of Illinois at Chicago, USA',0),(1343,'University of Notre Dame, IN, USA',0),(1344,'University of Maryland Baltimore County, USA',0),(1345,'Oxford Brookes University, UK',0),(1346,'The University of Texas at Austin, USA',0),(1347,'NASA Langley Research Center, Hampton, USA',0),(1348,'NASA Ames Research Center, Mountain View, USA',0),(1349,'University of Southern, California Los Angeles, CA, USA',0),(1350,'Virginia Tech Blacksburg, VA, USA',0),(1351,'University of Oxford, Oxford, United Kingdom',0),(1352,'Federal University of Amazonas, Manaus, Brazil',0),(1353,'Northeastern University, Boston, MA, USA 02115',0),(1354,'University of Massachusetts, Amherst, Amherst, MA, USA 01003',0),(1355,'University of Manchester, United Kingdom',0),(1356,'Lehrgebiet Programmiersysteme, Fernuniversit盲t in Hagen, Germany',0),(1357,'Dept. of Comput. & Inf. Sci., Univ. of Delaware, Newark, DE, USA',0),(1358,'Dept. of Comput. Sci. & Eng., Univ. of Nebraska - Lincoln, Lincoln, NE, USA',0),(1359,'State Key Laboratory of Computer Science Institute of Software, Chinese Academy of Sciences, Beijing, China',0),(1360,'Technology Center of Software Engineering Institute of Software, Chinese Academy of Sciences, Beijing, China',0),(1361,'Dept. of Comput. Sci., Univ. of Western Ontario, London, ON, Canada',0),(1362,'The University of Texas at Austin, United States',0),(1363,'Trusted Computing and Information Assurance Laboratory, Institute of Software, Chinese Academy of Sciences, Beijing, China',0),(1364,'Department of Computer Science, National University of Singapore',0),(1365,'Department of Measurement and Information Systems, Budapest University of Technology and Economics, Hungary',0),(1366,'Drew Univ., Madison, NJ, USA',0),(1367,'Paderborn University, Germany',0),(1368,'Technische Universit盲t Darmstadt, Germany',0),(1369,'Department of Computer Science & Engineering, University of Nebraska-Lincoln, Lincoln, NE 68588-0115, USA',0),(1370,'NEC Labs America, Princeton, USA',0),(1371,'Fujitsu Laboratories of America, Sunnyvale, CA, USA',0),(1372,'HASLAB - High Assurance Software Laboratory, INESC TEC & Universidade do Minho, Braga, Portugal',0),(1373,'ITRI, AIST, Tsukuba, Japan',0),(1374,'Software Competence Center, Hagenberg, Austria',0),(1375,'Software Technology Group, Linnaeus University, V盲xj枚, Sweden',0),(1376,'Comput. Sci. & Eng., Univ. of Washington, Seattle, WA, USA',0),(1377,'Cognius, Boston, MA, USA',0),(1378,'Comput. Sci. Dept., Univ. of California, Santa Cruz, Santa Cruz, CA, USA',0),(1379,'Comput. Sci. Dept., Williams Coll., Williamstown, MA, USA',0),(1380,'KAIST, Korea',0),(1381,'LG Electronics, Korea',0),(1382,'Huawei R&D, USA',0),(1383,'Eindhoven University of Technology, The Netherlands',0),(1384,'Tel Aviv University, Israel',0),(1385,'East Carolina Univ., Greenville, NC, USA',0),(1386,'MIT CSAIL, USA',0),(1387,'CEA, France',0),(1388,'Adobe, USA',0),(1389,'Electrical and Computer Engineering Department, Clarkson University, USA',0),(1390,'University of Texas, Austin, 78712, USA',0),(1391,'University of Illinois, Urbana, 61801, USA',0),(1392,'Department of Computer Science and Engineering, Shanghai Jiao Tong University, China',0),(1393,'College of Computer Science and Technology, Zhejiang University, China',0),(1394,'School of Engineering and Computer Science, Australian National University, Australia',0),(1395,'Department of Computer Science, University of British Columbia, Canada',0),(1396,'FBK-irst, Trento, Italy',0),(1397,'Software Eng. Group, Univ. of Siegen, Siegen, Germany',0),(1398,'Dept. of Inf. Eng., Univ. of Porto, Porto, Portugal',0),(1399,'Lane Department of Computer Science and Electrical Engineering, West Virginia University, Morgantown, USA',0),(1400,'Inst. fur Inf., Goethe Univ. Frankfurt, Frankfurt, Germany',0),(1401,'SWAT Lab, Polytechnique Montr茅al, QC, Canada',0),(1402,'Department of Computer Science, University of Illinois, Urbana, 61801, USA',0),(1403,'Free University of Bozen-Bolzano, Piazza Domenicani, 3, 39100 Bolzano, Italy',0),(1404,'Universidad Aut贸noma de Madrid (Spain)',0),(1405,'Division of Computer Science, Stellenbosch University, South Africa',0),(1406,'Electronics and Computer Science, University of Southampton, UK',0),(1407,'Sch. of Comput. Sci., Univ. of Birmingham, Birmingham, UK',0),(1408,'Dept. of Comput. Sci. & Eng., Univ. of Washington, Seattle, WA, USA',0),(1409,'Scienta, Norway',0),(1410,'University of Bamberg, Germany',0),(1411,'Vrije Universiteit Amsterdam, The Netherlands',0),(1412,'DEEDS Group, TU Darmstadt, Darmstadt, Germany',0),(1413,'Computer Science Department, University of Southern California, Los Angeles, 90089, USA',0),(1414,'Wilfrid Laurier University, 75 University Avenue West, Waterloo, ON, N2L 3C5, Canada',0),(1415,'SnT Center, University of Luxembourg, Luxembourg',0),(1416,'Delphi Automotive Systems, Luxembourg',0),(1417,'Global InfoTek Inc., USA',0),(1418,'LIFIA, Universidad Nacional de La Plata, Argentina, Also at CIC, Argentina',0),(1419,'LIFIA, Universidad Nacional de La Plata, Argentina, Also at CONICET, Argentina',0),(1420,'University of California, Berkeley, USA',0),(1421,'DSO National Laboratories, Singapore',0),(1422,'University of Science and Technology of China, China',0),(1423,'Microsoft Research, China',0),(1424,'TU Darmstadt, Darmstadt, Germany',0),(1425,'TU Darmstadt, Darmstadt, Germany & Universit脿 degli Studi di Torino, Torino, Italy',0),(1426,'Eindhoven University of Technology, 5600 MB Eindhoven, The Netherlands',0),(1427,'Indian Institute of Information Technology, Design and Manufacturing, Jabalpur, India, Jabalpur Engineering College, Jabalpur, India',0),(1428,'Indian Institute of Information Technology, Design and Manufacturing Jabalpur, India',0),(1429,'School of Computer Science, Engineering, and Mathematics, Flinders University, Adelaide, Australia',0),(1430,'Software evolution & architecture lab, University of Zurich, Switzerland',0),(1431,'Department of ECE, Virginia Tech, Blacksburg, VA, USA',0),(1432,'Department of CS, University of Southern California, Los Angeles, CA, USA',0),(1433,'Indian Institute of Information Technology, Design and Manufacturing, Jabalpur, India',0),(1434,'itemis, Germany / Delft University of Technology, Netherlands',0),(1435,'JetBrains, Czechia',0),(1436,'Delft University of Technology, Netherlands',0),(1437,'independent/itemis, Germany',0),(1438,'Institute for Software Systems Engineering, Johannes Kepler University, Linz, Austria',0),(1439,'Electrical and Computer Engineering, University of Waterloo, Canada',0),(1440,'Department of Computer Science and Engineering, The Hong Kong University of Science and Technology, Hong Kong, China',0),(1441,'Department of Computer Science, Western Michigan University, Kalamazoo, MI, USA',0),(1442,'Department of Computer Science, University of Southern California, Los Angeles, CA, USA',0),(1443,'University of Innsbruck, Austria',0),(1444,'National Institute of Advanced Industrial Science and Technology (AIST), Japan',0),(1445,'School of Computer Science, Fudan University, China',0),(1446,'Department of Computing and Communications, The Open University, UK',0),(1447,'IBM Research, USA',0),(1448,'Research and Development, Medidata Solutions, New York, NY, USA',0),(1449,'Dept. of Computer Science and Engineering, The University of Texas at Arlington, Arlington, TX, USA',0),(1450,'Dept. of Computer Science, George Mason University, Fairfax, VA, USA',0),(1451,'Friedrich-Alexander University Erlangen-N眉rnberg (FAU), Germany, Programming Systems Group',0),(1452,'ANSYMO - Universiteit Antwerpen, Belgium',0),(1453,'Department of Computer Science and Technology, Nanjing University, China',0),(1454,'Department of Computer Science, University College London, UK',0),(1455,'School of Architecture, Computing and Engineering, University of East London, UK',0),(1456,'Department of Computer Science, Loyola University Maryland, USA',0),(1457,'School of Electrical Engineering and Computer Science, Washington State University, Pullman, WA, USA',0),(1458,'University of Zurich, Zurich, Switzerland',0),(1459,'MIT, Cambridge, MA, USA',0),(1460,'independent / itemis, Germany',0),(1461,'School of Software, ShanghaiJiao Tong University, China',0),(1462,'Department of Computer Science and Engineering, ShanghaiJiao Tong University, China',0),(1463,'Department of Advanced Information Technology, Kyushu University, Japan',0),(1464,'University of Sannio, Italy',0),(1465,'Saarland University, Saarland Informatics Campus, Saarbr眉cken, Germany',0),(1466,'CSE, Pennsylvania State University, USA',0),(1467,'Technische Universit盲t, M眉nchen, Germany',0),(1468,'University of Wisconsin-Madison, Madison, WI, USA',0),(1469,'State Key Laboratory of Networking and Switching Technology, Beijing University of Posts and Telecommunications, Beijing, China',0),(1470,'Chalmers | University of Gothenburg, Sweden',0),(1471,'University of Paderborn, Paderborn, Germany',0),(1472,'New York University, USA',0),(1473,'Stanford University, USA',0),(1474,'School of Informatics, University of Edinburgh, UK',0),(1475,'Siemens AG, Germany',0),(1476,'Computer Science Department, Modelling and Software Engineering Research Group, Universidad Aut贸noma de Madrid (Spain)',0),(1477,'Columbia University, USA',0),(1478,'SnT / University of Luxembourg, Luxembourg',0),(1479,'IEE S.A. Contern, Luxembourg',0),(1480,'Software Technology Group, Technische Universit盲t Darmstadt, Germany',0),(1481,'University of Saskatchewan, Canada',0),(1482,'Vendasta Technologies, Canada',0),(1483,'Google Inc., USA',0),(1484,'Department of Computer Science, University of Leicester, UK',0),(1485,'Department of Electronics, Information and Bioengineering, Politecnico di Milano, Italy',0),(1486,'University of Toronto, Toronto, ON, Canada',0),(1487,'Department of Computer Science, College of William and Mary, Williamsburg, Virginia, USA',0),(1488,'University of Rennes 1, France',0),(1489,'University of Rennes 1/INRIA, France',0),(1490,'INRIA, France',0),(1491,'CAIR, CSIR Meraka, Computer Science Division, University of Stellenbosch, South Africa',0),(1492,'Department of Computer Science, LUMS School of Science and Engineering, Lahore, Pakistan',0),(1493,'Center for Technology Innovation, R&D Group, Hitachi Ltd, Japan',0),(1494,'Department of Computer Science, University of California, Santa Barbara, USA',0),(1495,'School of Software and Electrical Engineering, Swinburne University of Technology, Hawthorn, VIC 3122, Australia',0),(1496,'School of Information Technology, Deakin University, Burwood, VIC 3125, Australia',0),(1497,'Institute for Software Technology, University of Koblenz-Landau, Germany',0),(1498,'Real-Time Systems Lab, TU Darmstadt, Germany',0),(1499,'Institute of Software Technology Systems, TU Hamburg-Harburg, Germany',0),(1500,'Key Laboratory of High Confidence Software Technologies (Peking University), MoE',0),(1501,'Department of Computer Science, University of Texas at Dallas, 75080, USA',0),(1502,'Department of Informatics, University of California, Irvine, USA',0),(1503,'Korea Advanced Institute of Science and Technology (KAIST) Daeieon. Republic of Korea',0),(1504,'Innovative Software System and Services Group, Universiti Teknikal Malaysia Melaka, Melaka, Malaysia',0),(1505,'Fulgent Corporation, USA',0),(1506,'Faculty of Science Engineering and Built Environment, School of Information Technology, Melbourne Burwood Campus, Deakin University, Victoria 3125, Australia',0),(1507,'University of Delaware, Newark, DE, USA',0),(1508,'Drew University, Madison, NJ, USA',0),(1509,'Department of Plant Sciences, University of Cambridge, United Kingdom',0),(1510,'State key Laboratory of Computer Sciences, Institute of Software, Chinese Academy of Sciences, China',0),(1511,'Computer Science and Software Engineering, Concordia University, Montreal, Canada',0),(1512,'Computer and Information Science Department, University of Michigan, Dearborn, MI, USA',0),(1513,'Graduate School of Information Science and Technology, Osaka University, Osaka, Japan',0),(1514,'Microsoft Research, Redmond, USA',0),(1515,'College of Information Sciences and Technology, The Pennsylvania State University, University Park, PA 16802, USA',0),(1516,'Computer Science Department, Carnegie Mellon University, USA',0),(1517,'University of Oxford, Oxford, UK',0),(1518,'University of Sussex, Brighton, UK',0),(1519,'SSW-Trading GmbH, Germany',0),(1520,'School of Electrical Engineering and Computer Science, Oregon State University, USA',0),(1521,'Computer Science Department, Utah State University',0),(1522,'Technology Center of Software Engineering, Institute of Software, Chinese Academy of Sciences, Beijing, China',0),(1523,'TU Darmstadt, Dept. of Computer Science, Darmstadt, Germany',0),(1524,'Dept. of Computer Science, ETH Zurich, Switzerland',0),(1525,'Ergon Informatik AG, Zurich, Switzerland',0),(1526,'Department of Computer Science, Stellenbosch University, South Africa',0),(1527,'Department of Computer Science, University of Illinois at Urbana-Champaign, Illinois, USA',0),(1528,'Oregon State University, USA',0),(1529,'University of Illinois, USA',0),(1530,'Universidade Federal de Minas Gerais, Belo Horizonte, Brazil',0),(1531,'State Key Laboratory of Novel Software Technology, Nanjing University, Nanjing, 210023, China',0),(1532,'Institute, University of Potsdam, August-Bebel-Str. 88 Potsdam, Germany',0),(1533,'University of Magdeburg, Germany',0),(1534,'TU Braunschweig, Germany',0),(1535,'State Key Laboratory of Software Engineering, School of Computer, Wuhan University, China',0),(1536,'Computer Science, North Carolina State University, USA',0),(1537,'INESC TEC/University of Porto - Faculty of Engineering, Rua Dr. Roberto Frias, s/n, 4200-465 Porto Portugal',0),(1538,'Applied Computer Science, University of Bayreuth, 95440 Bayreuth, Germany',0),(1539,'Departamento de Computaci贸n, Universidad Nacional de R铆o Cuarto and CONICET, Argentina',0),(1540,'Department of Computing, Imperial College London, UK',0),(1541,'State Key Laboratory for Novel Software Technology, Department of Computer Science and Technology, Nanjing University, Nanjing, Jiangsu, P.R. China',0),(1542,'paluno - The Ruhr Institute for Software Technology, University of Duisburg-Essen, Germany',0),(1543,'School of Computer Science, Tel Aviv University and IBM Research, Israel',0),(1544,'IBM Systems, USA',0),(1545,'School of Computer Science, Tel Aviv University, Israel',0);
/*!40000 ALTER TABLE `affiliation_info` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article_info`
--

DROP TABLE IF EXISTS `article_info`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `article_info` (
  `doc_id` int(11) NOT NULL AUTO_INCREMENT,
  `doc_title` varchar(500) DEFAULT NULL,
  `publication_id` int(11) DEFAULT NULL,
  `startpage` int(11) DEFAULT NULL,
  `endpage` int(11) DEFAULT NULL,
  `doc_abstract` varchar(5000) DEFAULT NULL,
  `pdf_link` varchar(500) DEFAULT NULL,
  `doi` varchar(100) DEFAULT NULL,
  `reference_count` int(11) DEFAULT NULL,
  `citation` int(11) DEFAULT NULL,
  `publisher` varchar(100) DEFAULT NULL,
  `doc_identifier` varchar(200) DEFAULT NULL,
  `search_count` int(11) DEFAULT '0',
  PRIMARY KEY (`doc_id`)
) ENGINE=InnoDB AUTO_INCREMENT=1298 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article_info`
--

LOCK TABLES `article_info` WRITE;
/*!40000 ALTER TABLE `article_info` DISABLE KEYS */;
INSERT INTO `article_info` VALUES (1,'Statistical Errors in Software Engineering Experiments: A Preliminary Literature Review',1,1195,1206,'Background: Statistical concepts and techniques are often applied incorrectly, even in mature disciplines such as medicine or psychology. Surprisingly, there are very few works that study statistical problems in software engineering (SE). Aim: Assess the existence of statistical errors in SE experiments. Method: Compile the most common statistical errors in experimental disciplines. Survey experiments published in ICSE to assess whether errors occur in high quality SE publications. Results: The same errors as identified in others disciplines were found in ICSE experiments, where 30 of the reviewed papers included several error types such as: a) missing statistical hypotheses, b) missing sample size calculation, c) failure to assess statistical test assumptions, and d) uncorrected multiple testing. This rather large error rate is greater for research papers where experiments are confined to the validation section. The origin of the errors can be traced back to: a) researchers not having sufficient statistical training, and b) a profusion of exploratory research. Conclusions: This paper provides preliminary evidence that SE research suffers from the same statistical problems as other experimental disciplines. However, the SE community appears to be unaware of any shortcomings in its experiments, whereas other disciplines work hard to avoid these threats. Further research is necessary to find the underlying causes and set up corrective measures, but there are some potentially effective actions and are a priori easy to implement: a) improve the statistical training of SE researchers, and b) enforce quality assessment and reporting guidelines in SE publications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453201','10.1145/3180155.3180161',0,0,'IEEE','IEEE Conferences',0),(2,'3rd FME Workshop on Formal Methods in Software Engineering (FormaliSE 2015)',2,977,978,'Despite their significant advantages, formal methods are not widely used in industrial software development. Following the successful workshops we organized at ICSE 2103 in San Francisco, and ICSE 2014 in Hyderabad, we organize a third edition of the FormaliSE workshop with the main goal to promote the integration between the formal methods and the software engineering communities.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203136','10.1109/ICSE.2015.313',0,0,'IEEE','IEEE Conferences',0),(3,'A Novel Neural Source Code Representation Based on Abstract Syntax Tree',3,783,794,'Exploiting machine learning techniques for analyzing programs has attracted much attention. One key problem is how to represent code fragments well for follow-up analysis. Traditional information retrieval based methods often treat programs as natural language texts, which could miss important semantic information of source code. Recently, state-of-the-art studies demonstrate that abstract syntax tree (AST) based neural models can better represent source code. However, the sizes of ASTs are usually large and the existing models are prone to the long-term dependency problem. In this paper, we propose a novel AST-based Neural Network (ASTNN) for source code representation. Unlike existing models that work on entire ASTs, ASTNN splits each large AST into a sequence of small statement trees, and encodes the statement trees to vectors by capturing the lexical and syntactical knowledge of statements. Based on the sequence of statement vectors, a bidirectional RNN model is used to leverage the naturalness of statements and finally produce the vector representation of a code fragment. We have applied our neural network based source code representation method to two common program comprehension tasks: source code classification and code clone detection. Experimental results on the two tasks indicate that our model is superior to state-of-the-art approaches.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812062','10.1109/ICSE.2019.00086',66,1,'IEEE','IEEE Conferences',0),(4,'Balancing Soundness and Efficiency for Practical Testing of Configurable Systems',4,632,642,'Testing configurable systems is important and challenging due to the enormous space of configurations where errors can hide. Existing approaches to test these systems are often costly or unreliable. This paper proposes S-SPLat, a technique that combines heuristic sampling with symbolic search to obtain both breadth and depth in the exploration of the configuration space. S-SPLat builds on SPLat, our previously developed technique, that explores all reachable configurations from tests. In contrast to its predecessor, S-SPLat sacrifices soundness in favor of efficiency. We evaluated our technique on eight software product lines of various sizes and on a large configurable system - GCC. Considering the results for GCC, S-SPLat was able to reproduce all five bugs that we previously found in a previous study with SPLat but much faster and it was able to find two new bugs in a recent release of GCC. Results suggest that it is preferable to use a combination of simple heuristics to drive the symbolic search as opposed to a single heuristic. S-SPLat and our experimental infrastructure are publicly available.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985700','10.1109/ICSE.2017.64',52,1,'IEEE','IEEE Conferences',0),(5,'Stochastic Optimization of Program Obfuscation',4,221,231,'Program obfuscation is a common practice in software development to obscure source code or binary code, in order to prevent humans from understanding the purpose or logic of software. It protects intellectual property and deters malicious attacks. While tremendous efforts have been devoted to the development of various obfuscation techniques, we have relatively little knowledge on how to most effectively use them together. The biggest challenge lies in identifying the most effective combination of obfuscation techniques. This paper presents a unified framework to optimize program obfuscation. Given an input program P and a set T of obfuscation transformations, our technique can automatically identify a sequence seq = 銆坱1, t2, ..., tn銆� (鈭�i 鈭� [1, n]. ti 鈭� T), such that applying ti in order on P yields the optimal obfuscation performance. We model the process of searching for seq as a mathematical optimization problem. The key technical contributions of this paper are: (1) an obscurity language model to assess obfuscation effectiveness/optimality, and (2) a guided stochastic algorithm based on Markov chain Monte Carlo methods to search for the optimal solution seq. We have realized the framework in a tool Closure* for JavaScript, and evaluated it on 25 most starred JavaScript projects on GitHub (19K lines of code). Our machinery study shows that Closure* outperforms the well-known Google Closure Compiler by defending 26% of the attacks initiated by JSNice. Our human study also reveals that Closure* is practical and can reduce the human attack success rate by 30%.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985664','10.1109/ICSE.2017.28',41,2,'IEEE','IEEE Conferences',0),(6,'Search-Based Energy Testing of Android',3,1119,1130,'The utility of a smartphone is limited by its battery capacity and the ability of its hardware and software to efficiently use the device\'s battery. To properly characterize the energy consumption of an app and identify energy defects, it is critical that apps are properly tested, i.e., analyzed dynamically to assess the app\'s energy properties. However, currently there is a lack of testing tools for evaluating the energy properties of apps. We present COBWEB, a search-based energy testing technique for Android. By leveraging a set of novel models, representing both the functional behavior of an app as well as the contextual conditions affecting the app\'s energy behavior, COBWEB generates a test suite that can effectively find energy defects. Our experimental results using real-world apps demonstrate not only its ability to effectively and efficiently test energy behavior of apps, but also its superiority over prior techniques by finding a wider and more diverse set of energy defects.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812097','10.1109/ICSE.2019.00115',69,1,'IEEE','IEEE Conferences',0),(7,'Syntactic and Semantic Differencing for Combinatorial Models of Test Designs',4,621,631,'Combinatorial test design (CTD) is an effective test design technique, considered to be a testing best practice. CTD provides automatic test plan generation, but it requires a manual definition of the test space in the form of a combinatorial model. As the system under test evolves, e.g., due to iterative development processes and bug fixing, so does the test space, and thus, in the context of CTD, evolution translates into frequent manual model definition updates. Manually reasoning about the differences between versions of real-world models following such updates is infeasible due to their complexity and size. Moreover, representing the differences is challenging. In this work, we propose a first syntactic and semantic differencing technique for combinatorial models of test designs. We define a concise and canonical representation for differences between two models, and suggest a scalable algorithm for automatically computing and presenting it. We use our differencing technique to analyze the evolution of 42 real-world industrial models, demonstrating its applicability and scalability. Further, a user study with 16 CTD practitioners shows that comprehension of differences between real-world combinatorial model versions is challenging and that our differencing tool significantly improves the performance of less experienced practitioners. The analysis and user study provide evidence for the potential usefulness of our differencing approach. Our work advances the state-of-the-art in CTD with better capabilities for change comprehension and management.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985699','10.1109/ICSE.2017.63',38,2,'IEEE','IEEE Conferences',0),(8,'A Test-Suite Diagnosability Metric for Spectrum-Based Fault Localization Approaches',4,654,664,'Current metrics for assessing the adequacy of a test-suite plainly focus on the number of components (be it lines, branches, paths) covered by the suite, but do not explicitly check how the tests actually exercise these components and whether they provide enough information so that spectrum-based fault localization techniques can perform accurate fault isolation. We propose a metric, called DDU, aimed at complementing adequacy measurements by quantifying a test-suite\'s diagnosability, i.e., the effectiveness of applying spectrum-based fault localization to pinpoint faults in the code in the event of test failures. Our aim is to increase the value generated by creating thorough test-suites, so they are not only regarded as error detection mechanisms but also as effective diagnostic aids that help widely-used fault-localization techniques to accurately pinpoint the location of bugs in the system. Our experiments show that optimizing a test suite with respect to DDU yields a 34% gain in spectrum-based fault localization report accuracy when compared to the standard branch-coverage metric.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985702','10.1109/ICSE.2017.66',39,6,'IEEE','IEEE Conferences',0),(9,'Statically Checking Web API Requests in JavaScript',4,244,254,'Many JavaScript applications perform HTTP requests to web APIs, relying on the request URL, HTTP method, and request data to be constructed correctly by string operations. Traditional compile-time error checking, such as calling a non-existent method in Java, are not available for checking whether such requests comply with the requirements of a web API. In this paper, we propose an approach to statically check web API requests in JavaScript. Our approach first extracts a request\'s URL string, HTTP method, and the corresponding request data using an inter-procedural string analysis, and then checks whether the request conforms to given web API specifications. We evaluated our approach by checking whether web API requests in JavaScript files mined from GitHub are consistent or inconsistent with publicly available API specifications. From the 6575 requests in scope, our approach determined whether the request\'s URL and HTTP method was consistent or inconsistent with web API specifications with a precision of 96.0%. Our approach also correctly determined whether extracted request data was consistent or inconsistent with the data requirements with a precision of 87.9% for payload data and 99.9% for query data. In a systematic analysis of the inconsistent cases, we found that many of them were due to errors in the client code. The here proposed checker can be integrated with code editors or with continuous integration tools to warn programmers about code containing potentially erroneous requests.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985666','10.1109/ICSE.2017.30',31,7,'IEEE','IEEE Conferences',0),(10,'Repairing Event Race Errors by Controlling Nondeterminism',4,289,299,'Modern web applications are written in an event-driven style, in which event handlers execute asynchronously in response to user or system events. The nondeterminism arising from this programming style can lead to pernicious errors. Recent work focuses on detecting event races and classifying them as harmful or harmless. However, since modifying the source code to prevent harmful races can be a difficult and error-prone task, it may be preferable to steer away from the bad executions. In this paper, we present a technique for automated repair of event race errors in JavaScript web applications. Our approach relies on an event controller that restricts event handler scheduling in the browser according to a specified repair policy, by intercepting and carefully postponing or discarding selected events. We have implemented the technique in a tool called EventRaceCommander, which relies entirely on source code instrumentation, and evaluated it by repairing more than 100 event race errors that occur in the web applications from the largest 20 of the Fortune 500 companies. Our results show that application-independent repair policies usually suffice to repair event race errors without excessive negative impact on performance or user experience, though application-specific repair policies that target specific event races are sometimes desirable.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985670','10.1109/ICSE.2017.34',34,2,'IEEE','IEEE Conferences',0),(11,'Automatically Generating Precise Oracles from Structured Natural Language Specifications',3,188,199,'Software specifications often use natural language to describe the desired behavior, but such specifications are difficult to verify automatically. We present Swami, an automated technique that extracts test oracles and generates executable tests from structured natural language specifications. Swami focuses on exceptional behavior and boundary conditions that often cause field failures but that developers often fail to manually write tests for. Evaluated on the official JavaScript specification (ECMA-262), 98.4% of the tests Swami generated were precise to the specification. Using Swami to augment developer-written test suites improved coverage and identified 1 previously unknown defect and 15 missing JavaScript features in Rhino, 1 previously unknown defect in Node.js, and 18 semantic ambiguities in the ECMA-262 specification.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812070','10.1109/ICSE.2019.00035',80,0,'IEEE','IEEE Conferences',0),(12,'Code Defenders: Crowdsourcing Effective Tests and Subtle Mutants with a Mutation Testing Game',4,677,688,'Writing good software tests is difficult and not every developer\'s favorite occupation. Mutation testing aims to help by seeding artificial faults (mutants) that good tests should identify, and test generation tools help by providing automatically generated tests. However, mutation tools tend to produce huge numbers of mutants, many of which are trivial, redundant, or semantically equivalent to the original program, automated test generation tools tend to produce tests that achieve good code coverage, but are otherwise weak and have no clear purpose. In this paper, we present an approach based on gamification and crowdsourcing to produce better software tests and mutants: The Code Defenders web-based game lets teams of players compete over a program, where attackers try to create subtle mutants, which the defenders try to counter by writing strong tests. Experiments in controlled and crowdsourced scenarios reveal that writing tests as part of the game is more enjoyable, and that playing Code Defenders results in stronger test suites and mutants than those produced by automated tools.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985704','10.1109/ICSE.2017.68',53,2,'IEEE','IEEE Conferences',0),(13,'Leveraging Artifact Trees to Evolve and Reuse Safety Cases',3,1222,1233,'Safety Assurance Cases (SACs) are increasingly used to guide and evaluate the safety of software-intensive systems. They are used to construct a hierarchically organized set of claims, arguments, and evidence in order to provide a structured argument that a system is safe for use. However, as the system evolves and grows in size, a SAC can be difficult to maintain. In this paper we utilize design science to develop a novel solution for identifying areas of a SAC that are affected by changes to the system. Moreover, we generate actionable recommendations for updating the SAC, including its underlying artifacts and trace links, in order to evolve an existing safety case for use in a new version of the system. Our approach, Safety Artifact Forest Analysis (SAFA), leverages traceability to automatically compare software artifacts from a previously approved or certified version with a new version of the system. We identify, visualize, and explain changes in a Delta Tree. We evaluate our approach using the Dronology system for monitoring and coordinating the actions of cooperating, small Unmanned Aerial Vehicles. Results from a user study show that SAFA helped users to identify changes that potentially impacted system safety and provided information that could be used to help maintain and evolve a SAC.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812137','10.1109/ICSE.2019.00124',63,0,'IEEE','IEEE Conferences',0),(14,'BugSwarm: Mining and Continuously Growing a Dataset of Reproducible Failures and Fixes',3,339,349,'Fault-detection, localization, and repair methods are vital to software quality; but it is difficult to evaluate their generality, applicability, and current effectiveness. Large, diverse, realistic datasets of durably-reproducible faults and fixes are vital to good experimental evaluation of approaches to software quality, but they are difficult and expensive to assemble and keep current. Modern continuous-integration (CI) approaches, like TRAVIS-CI, which are widely used, fully configurable, and executed within custom-built containers, promise a path toward much larger defect datasets. If we can identify and archive failing and subsequent passing runs, the containers will provide a substantial assurance of durable future reproducibility of build and test. Several obstacles, however, must be overcome to make this a practical reality. We describe BUGSWARM, a toolset that navigates these obstacles to enable the creation of a scalable, diverse, realistic, continuously growing set of durably reproducible failing and passing versions of real-world, open-source systems. The BUGSWARM toolkit has already gathered 3,091 fail-pass pairs, in Java and Python, all packaged within fully reproducible containers. Furthermore, the toolkit can be run periodically to detect fail-pass activities, thus growing the dataset continually.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812141','10.1109/ICSE.2019.00048',32,1,'IEEE','IEEE Conferences',0),(15,'Efficient Detection of Thread Safety Violations via Coverage-Guided Generation of Concurrent Tests',4,266,277,'As writing concurrent programs is challenging, developers often rely on thread-safe classes, which encapsulate most synchronization issues. Testing such classes is crucial to ensure the correctness of concurrent programs. An effective approach to uncover otherwise missed concurrency bugs is to automatically generate concurrent tests. Existing approaches either create tests randomly, which is inefficient, build on a computationally expensive analysis of potential concurrency bugs exposed by sequential tests, or focus on exposing a particular kind of concurrency bugs, such as atomicity violations. This paper presents CovCon, a coverage-guided approach to generate concurrent tests. The key idea is to measure how often pairs of methods have already been executed concurrently and to focus the test generation on infrequently or not at all covered pairs of methods. The approach is independent of any particular bug pattern, allowing it to find arbitrary concurrency bugs, and is computationally inexpensive, allowing it to generate many tests in short time. We apply CovCon to 18 thread-safe Java classes, and it detects concurrency bugs in 17 of them. Compared to five state of the art approaches, CovCon detects more bugs than any other approach while requiring less time. Specifically, our approach finds bugs faster in 38 of 47 cases, with speedups of at least 4x for 22 of 47 cases.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985668','10.1109/ICSE.2017.32',67,6,'IEEE','IEEE Conferences',0),(16,'A SEALANT for Inter-App Security Holes in Android',4,312,323,'Android\'s communication model has a major security weakness: malicious apps can manipulate other apps into performing unintended operations and can steal end-user data, while appearing ordinary and harmless. This paper presents SEALANT, a technique that combines static analysis of app code, which infers vulnerable communication channels, with runtime monitoring of inter-app communication through those channels, which helps to prevent attacks. SEALANT\'s extensive evaluation demonstrates that (1) it detects and blocks inter-app attacks with high accuracy in a corpus of over 1,100 real-world apps, (2) it suffers from fewer false alarms than existing techniques in several representative scenarios, (3) its performance overhead is negligible, and (4) end-users do not find it challenging to adopt.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985672','10.1109/ICSE.2017.36',95,8,'IEEE','IEEE Conferences',0),(17,'Mining Software Defects: Should We Consider Affected Releases?',3,654,665,'With the rise of the Mining Software Repositories (MSR) field, defect datasets extracted from software repositories play a foundational role in many empirical studies related to software quality. At the core of defect data preparation is the identification of post-release defects. Prior studies leverage many heuristics (e.g., keywords and issue IDs) to identify post-release defects. However, such the heuristic approach is based on several assumptions, which pose common threats to the validity of many studies. In this paper, we set out to investigate the nature of the difference of defect datasets generated by the heuristic approach and the realistic approach that leverages the earliest affected release that is realistically estimated by a software development team for a given defect. In addition, we investigate the impact of defect identification approaches on the predictive accuracy and the ranking of defective modules that are produced by defect models. Through a case study of defect datasets of 32 releases, we find that that the heuristic approach has a large impact on both defect count datasets and binary defect datasets. Surprisingly, we find that the heuristic approach has a minimal impact on defect count models, suggesting that future work should not be too concerned about defect count models that are constructed using heuristic defect datasets. On the other hand, using defect datasets generated by the realistic approach lead to an improvement in the predictive accuracy of defect classification models.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811982','10.1109/ICSE.2019.00075',76,0,'IEEE','IEEE Conferences',0),(18,'LEOPARD: Identifying Vulnerable Code for Vulnerability Assessment Through Program Metrics',3,60,71,'Identifying potentially vulnerable locations in a code base is critical as a pre-step for effective vulnerability assessment; i.e., it can greatly help security experts put their time and effort to where it is needed most. Metric-based and pattern-based methods have been presented for identifying vulnerable code. The former relies on machine learning and cannot work well due to the severe imbalance between non-vulnerable and vulnerable code or lack of features to characterize vulnerabilities. The latter needs the prior knowledge of known vulnerabilities and can only identify similar but not new types of vulnerabilities. In this paper, we propose and implement a generic, lightweight and extensible framework, LEOPARD, to identify potentially vulnerable functions through program metrics. LEOPARD requires no prior knowledge about known vulnerabilities. It has two steps by combining two sets of systematically derived metrics. First, it uses complexity metrics to group the functions in a target application into a set of bins. Then, it uses vulnerability metrics to rank the functions in each bin and identifies the top ones as potentially vulnerable. Our experimental results on 11 real-world projects have demonstrated that, LEOPARD can cover 74.0% of vulnerable functions by identifying 20% of functions as vulnerable and outperform machine learning-based and static analysis-based techniques. We further propose three applications of LEOPARD for manual code review and fuzzing, through which we discovered 22 new bugs in real applications like PHP, radare2 and FFmpeg, and eight of them are new vulnerabilities.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812029','10.1109/ICSE.2019.00024',82,0,'IEEE','IEEE Conferences',0),(19,'On Learning Meaningful Code Changes Via Neural Machine Translation',3,25,36,'Recent years have seen the rise of Deep Learning (DL) techniques applied to source code. Researchers have exploited DL to automate several development and maintenance tasks, such as writing commit messages, generating comments and detecting vulnerabilities among others. One of the long lasting dreams of applying DL to source code is the possibility to automate non-trivial coding activities. While some steps in this direction have been taken (e.g., learning how to fix bugs), there is still a glaring lack of empirical evidence on the types of code changes that can be learned and automatically applied by DL. Our goal is to make this first important step by quantitatively and qualitatively investigating the ability of a Neural Machine Translation (NMT) model to learn how to automatically apply code changes implemented by developers during pull requests. We train and experiment with the NMT model on a set of 236k pairs of code components before and after the implementation of the changes provided in the pull requests. We show that, when applied in a narrow enough context (i.e., small/medium-sized pairs of methods before/after the pull request changes), NMT can automatically replicate the changes implemented by developers during pull requests in up to 36% of the cases. Moreover, our qualitative analysis shows that the model is capable of learning and replicating a wide variety of meaningful code changes, especially refactorings and bug-fixing activities. Our results pave the way for novel research in the area of DL on code, such as the automatic learning and applications of refactoring.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811910','10.1109/ICSE.2019.00021',67,0,'IEEE','IEEE Conferences',0),(20,'FastLane: Test Minimization for Rapidly Deployed Large-Scale Online Services',3,408,418,'Today, we depend on numerous large-scale services for basic operations such as email. These services, built on the basis of Continuous Integration/Continuous Deployment (CI/CD) processes, are extremely dynamic: developers continuously commit code and introduce new features, functionality and fixes. Hundreds of commits may enter the code-base in a single day. Therefore one of the most time-critical, yet resource-intensive tasks towards ensuring code-quality is effectively testing such large code-bases. This paper presents FastLane, a system that performs data-driven test minimization. FastLane uses light-weight machine-learning models built upon a rich history of test and commit logs to predict test outcomes. Tests for which we predict outcomes need not be explicitly run, thereby saving us precious test-time and resources. Our evaluation on a large-scale email and collaboration platform service shows that our techniques can save 18.04%, i.e., almost a fifth of test-time while obtaining a test outcome accuracy of 99.99%.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812033','10.1109/ICSE.2019.00054',39,0,'IEEE','IEEE Conferences',0),(21,'DLFinder: Characterizing and Detecting Duplicate Logging Code Smells',3,152,163,'Developers rely on software logs for a wide variety of tasks, such as debugging, testing, program comprehension, verification, and performance analysis. Despite the importance of logs, prior studies show that there is no industrial standard on how to write logging statements. Recent research on logs often only considers the appropriateness of a log as an individual item (e.g., one single logging statement); while logs are typically analyzed in tandem. In this paper, we focus on studying duplicate logging statements, which are logging statements that have the same static text message. Such duplications in the text message are potential indications of logging code smells, which may affect developers\' understanding of the dynamic view of the system. We manually studied over 3K duplicate logging statements and their surrounding code in four large-scale open source systems: Hadoop, CloudStack, ElasticSearch, and Cassandra. We uncovered five patterns of duplicate logging code smells. For each instance of the code smell, we further manually identify the problematic (i.e., require fixes) and justifiable (i.e., do not require fixes) cases. Then, we contact developers in order to verify our manual study result. We integrated our manual study result and developers\' feedback into our automated static analysis tool, DLFinder, which automatically detects problematic duplicate logging code smells. We evaluated DLFinder on the four manually studied systems and two additional systems: Camel and Wicket. In total, combining the results of DLFinder and our manual analysis, we reported 82 problematic code smell instances to developers and all of them have been fixed.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811945','10.1109/ICSE.2019.00032',54,1,'IEEE','IEEE Conferences',0),(22,'FLOSS Participants\' Perceptions About Gender and Inclusiveness: A Survey',3,677,687,'Background: While FLOSS projects espouse openness and acceptance for all, in practice, female contributors often face discriminatory barriers to contribution. Aims: In this paper, we examine the extent to which these problems still exist. We also study male and female contributors\' perceptions of other contributors. Method: We surveyed participants from 15 FLOSS projects, asking a series of open-ended, closed-ended, and behavioral scale questions to gather information about the issue of gender in FLOSS projects. Results: Though many of those we surveyed expressed a positive sentiment towards females who participate in FLOSS projects, some were still strongly against their inclusion. Often, the respondents who were against inclusiveness also believed their own sentiments were the prevailing belief in the community, contrary to our findings. Others did not see the purpose of attempting to be inclusive, expressing the sentiment that a discussion of gender has no place in FLOSS. Conclusions: FLOSS projects have started to move forwards in terms of gender acceptance. However, there is still a need for more progress in the inclusion of gender-diverse contributors.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812068','10.1109/ICSE.2019.00077',27,0,'IEEE','IEEE Conferences',0),(23,'Class Imbalance Evolution and Verification Latency in Just-in-Time Software Defect Prediction',3,666,676,'Just-in-Time Software Defect Prediction (JIT-SDP) is an SDP approach that makes defect predictions at the software change level. Most existing JIT-SDP work assumes that the characteristics of the problem remain the same over time. However, JIT-SDP may suffer from class imbalance evolution. Specifically, the imbalance status of the problem (i.e., how much underrepresented the defect-inducing changes are) may be intensified or reduced over time. If occurring, this could render existing JIT-SDP approaches unsuitable, including those that re-build classifiers over time using only recent data. This work thus provides the first investigation of whether class imbalance evolution poses a threat to JIT-SDP. This investigation is performed in a realistic scenario by taking into account verification latency -- the often overlooked fact that labeled training examples arrive with a delay. Based on 10 GitHub projects, we show that JIT-SDP suffers from class imbalance evolution, significantly hindering the predictive performance of existing JIT-SDP approaches. Compared to state-of-the-art class imbalance evolution learning approaches, the predictive performance of JIT-SDP approaches was up to 97.2% lower in terms of g-mean. Hence, it is essential to tackle class imbalance evolution in JIT-SDP. We then propose a novel class imbalance evolution approach for the specific context of JIT-SDP. While maintaining top ranked g-means, this approach managed to produce up to 63.59% more balanced recalls on the defect-inducing and clean classes than state-of-the-art class imbalance evolution approaches. We thus recommend it to avoid overemphasizing one class over the other in JIT-SDP.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812072','10.1109/ICSE.2019.00076',36,0,'IEEE','IEEE Conferences',0),(24,'Learning to Prioritize Test Programs for Compiler Testing',4,700,711,'Compiler testing is a crucial way of guaranteeing the reliability of compilers (and software systems in general). Many techniques have been proposed to facilitate automated compiler testing. These techniques rely on a large number of test programs (which are test inputs of compilers) generated by some test-generation tools (e.g., CSmith). However, these compiler testing techniques have serious efficiency problems as they usually take a long period of time to find compiler bugs. To accelerate compiler testing, it is desirable to prioritize the generated test programs so that the test programs that are more likely to trigger compiler bugs are executed earlier. In this paper, we propose the idea of learning to test, which learns the characteristics of bug-revealing test programs from previous test programs that triggered bugs. Based on the idea of learning to test, we propose LET, an approach to prioritizing test programs for compiler testing acceleration. LET consists of a learning process and a scheduling process. In the learning process, LET identifies a set of features of test programs, trains a capability model to predict the probability of a new test program for triggering compiler bugs and a time model to predict the execution time of a test program. In the scheduling process, LET prioritizes new test programs according to their bug-revealing probabilities in unit time, which is calculated based on the two trained models. Our extensive experiments show that LET significantly accelerates compiler testing. In particular, LET reduces more than 50% of the testing time in 24.64% of the cases, and reduces between 25% and 50% of the testing time in 36.23% of the cases.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985706','10.1109/ICSE.2017.70',79,2,'IEEE','IEEE Conferences',0),(25,'Fuzzy Fine-Grained Code-History Analysis',4,746,757,'Existing software-history techniques represent source-code evolution as an absolute and unambiguous mapping of lines of code in prior revisions to lines of code in subsequent revisions. However, the true evolutionary lineage of a line of code is often complex, subjective, and ambiguous. As such, existing techniques are predisposed to, both, overestimate and underestimate true evolution lineage. In this paper, we seek to address these issues by providing a more expressive model of code evolution, the fuzzy history graph, by representing code lineage as a continuous (i.e., fuzzy) metric rather than a discrete (i.e., absolute) one. Using this more descriptive model, we additionally provide a novel multi-revision code-history analysis - fuzzy history slicing. In our experiments over three real-world software systems, we found that the fuzzy history graph provides a tunable balance of precision and recall, and an overall improved accuracy over existing code-evolution models. Furthermore, we found that the use of such a fuzzy model of history provided improved accuracy for code-history analysis tasks.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985710','10.1109/ICSE.2017.74',55,1,'IEEE','IEEE Conferences',0),(26,'Resource-Aware Program Analysis Via Online Abstraction Coarsening',3,94,104,'We present a new technique for developing a resource-aware program analysis. Such an analysis is aware of constraints on available physical resources, such as memory size, tracks its resource use, and adjusts its behaviors during fixpoint computation in order to meet the constraint and achieve high precision. Our resource-aware analysis adjusts behaviors by coarsening program abstraction, which usually makes the analysis consume less memory and time until completion. It does so multiple times during the analysis, under the direction of what we call a controller. The controller constantly intervenes in the fixpoint computation of the analysis and decides how much the analysis should coarsen the abstraction. We present an algorithm for learning a good controller automatically from benchmark programs. We applied our technique to a static analysis for C programs, where we control the degree of flow-sensitivity to meet a constraint on peak memory consumption. The experimental results with 18 real-world programs show that our algorithm can learn a good controller and the analysis with this controller meets the constraint and utilizes available memory effectively.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812143','10.1109/ICSE.2019.00027',37,0,'IEEE','IEEE Conferences',0),(27,'LibD: Scalable and Precise Third-Party Library Detection in Android Markets',4,335,346,'With the thriving of the mobile app markets, third-party libraries are pervasively integrated in the Android applications. Third-party libraries provide functionality such as advertisements, location services, and social networking services, making multi-functional app development much more productive. However, the spread of vulnerable or harmful third-party libraries may also hurt the entire mobile ecosystem, leading to various security problems. The Android platform suffers severely from such problems due to the way its ecosystem is constructed and maintained. Therefore, third-party Android library identification has emerged as an important problem which is the basis of many security applications such as repackaging detection and malware analysis. According to our investigation, existing work on Android library detection still requires improvement in many aspects, including accuracy and obfuscation resilience. In response to these limitations, we propose a novel approach to identifying third-party Android libraries. Our method utilizes the internal code dependencies of an Android app to detect and classify library candidates. Different from most previous methods which classify detected library candidates based on similarity comparison, our method is based on feature hashing and can better handle code whose package and method names are obfuscated. Based on this approach, we have developed a prototypical tool called LibD and evaluated it with an update-to-date and large-scale dataset. Our experimental results on 1,427,395 apps show that compared to existing tools, LibD can better handle multi-package third-party libraries in the presence of name-based obfuscation, leading to significantly improved precision without the loss of scalability.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985674','10.1109/ICSE.2017.38',46,12,'IEEE','IEEE Conferences',0),(28,'Zero-Overhead Path Prediction with Progressive Symbolic Execution',3,234,245,'In previous work, we introduced zero-overhead profiling (ZOP), a technique that leverages the electromagnetic emissions generated by the computer hardware to profile a program without instrumenting it. Although effective, ZOP has several shortcomings: it requires test inputs that achieve extensive code coverage for its training phase; it predicts path profiles instead of complete execution traces; and its predictions can suffer unrecoverable accuracy losses. In this paper, we present zero-overhead path prediction (ZOP-2), an approach that extends ZOP and addresses its limitations. First, ZOP-2 achieves high coverage during training through progressive symbolic execution (PSE)-symbolic execution of increasingly small program fragments. Second, ZOP-2 predicts complete execution traces, rather than path profiles. Finally, ZOP-2 mitigates the problem of path mispredictions by using a stateless approach that can recover from prediction errors. We evaluated our approach on a set of benchmarks with promising results; for the cases considered, (1) ZOP-2 achieved over 90% path prediction accuracy, and (2) PSE covered feasible paths missed by traditional symbolic execution, thus boosting ZOP-2\'s accuracy.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812035','10.1109/ICSE.2019.00039',49,0,'IEEE','IEEE Conferences',0),(29,'Tool Choice Matters: JavaScript Quality Assurance Tools and Usage Outcomes in GitHub Projects',3,476,487,'Quality assurance automation is essential in modern software development. In practice, this automation is supported by a multitude of tools that fit different needs and require developers to make decisions about which tool to choose in a given context. Data and analytics of the pros and cons can inform these decisions. Yet, in most cases, there is a dearth of empirical evidence on the effectiveness of existing practices and tool choices. We propose a general methodology to model the time-dependent effect of automation tool choice on four outcomes of interest: prevalence of issues, code churn, number of pull requests, and number of contributors, all with a multitude of controls. On a large data set of npm JavaScript projects, we extract the adoption events for popular tools in three task classes: linters, dependency managers, and coverage reporters. Using mixed methods approaches, we study the reasons for the adoptions and compare the adoption effects within each class, and sequential tool adoptions across classes. We find that some tools within each group are associated with more beneficial outcomes than others, providing an empirical perspective for the benefits of each. We also find that the order in which some tools are implemented is associated with varying outcomes.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812106','10.1109/ICSE.2019.00060',86,1,'IEEE','IEEE Conferences',0),(30,'Investigating the Effects of Gender Bias on GitHub',3,700,711,'Diversity, including gender diversity, is valued by many software development organizations, yet the field remains dominated by men. One reason for this lack of diversity is gender bias. In this paper, we study the effects of that bias by using an existing framework derived from the gender studies literature.We adapt the four main effects proposed in the framework by posing hypotheses about how they might manifest on GitHub,then evaluate those hypotheses quantitatively. While our results how that effects of gender bias are largely invisible on the GitHub platform itself, there are still signals of women concentrating their work in fewer places and being more restrained in communication than men.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812110','10.1109/ICSE.2019.00079',50,0,'IEEE','IEEE Conferences',0),(31,'Training Binary Classifiers as Data Structure Invariants',3,759,770,'We present a technique to distinguish valid from invalid data structure objects. The technique is based on building an artificial neural network, more precisely a binary classifier, and training it to identify valid and invalid instances of a data structure. The obtained classifier can then be used in place of the data structure\'s invariant, in order to attempt to identify (in)correct behaviors in programs manipulating the structure. In order to produce the valid objects to train the network, an assumed-correct set of object building routines is randomly executed. Invalid instances are produced by generating values for object fields that \'break\' the collected valid values, i.e., that assign values to object fields that have not been observed as feasible in the assumed-correct executions that led to the collected valid instances. We experimentally assess this approach, over a benchmark of data structures. We show that this learning technique produces classifiers that achieve significantly better accuracy in classifying valid/invalid objects compared to a technique for dynamic invariant detection, and leads to improved bug finding.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811951','10.1109/ICSE.2019.00084',43,0,'IEEE','IEEE Conferences',0),(32,'Symbolic Model Extraction for Web Application Verification',4,724,734,'Modern web applications use complex data models and access control rules which lead to data integrity and access control errors. One approach to find such errors is to use formal verification techniques. However, as a first step, most formal verification techniques require extraction of a formal model which is a difficult problem in itself due to dynamic features of modern languages, and it is typically done either manually, or using ad hoc techniques. In this paper, we present a technique called symbolic model extraction for extracting formal data models from web applications. The key ideas of symbolic model extraction are 1) to use the source language interpreter for model extraction, which enables us to handle dynamic features of the language, 2) to use code instrumentation so that execution of each instrumented piece of code returns the formal model that corresponds to that piece of code, 3) to instrument the code dynamically so that the models of methods that are created at runtime can also be extracted, and 4) to execute both sides of branches during instrumented execution so that all program behaviors can be covered in a single instrumented execution. We implemented the symbolic model extraction technique for the Rails framework and used it to extract data and access control models from web applications. Our experiments demonstrate that symbolic model extraction is scalable and extracts formal models that are precise enough to find bugs in real-world applications without reporting too many false positives.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985708','10.1109/ICSE.2017.72',31,0,'IEEE','IEEE Conferences',0),(33,'The Evolution of Continuous Experimentation in Software Product Development: From Data to a Data-Driven Organization at Scale',4,770,780,'Software development companies are increasingly aiming to become data-driven by trying to continuously experiment with the products used by their customers. Although familiar with the competitive edge that the A/B testing technology delivers, they seldom succeed in evolving and adopting the methodology. In this paper, and based on an exhaustive and collaborative case study research in a large software-intense company with highly developed experimentation culture, we present the evolution process of moving from ad-hoc customer data analysis towards continuous controlled experimentation at scale. Our main contribution is the \'Experimentation Evolution Model\' in which we detail three phases of evolution: technical, organizational and business evolution. With our contribution, we aim to provide guidance to practitioners on how to develop and scale continuous experimentation in software organizations with the purpose of becoming data-driven at scale.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985712','10.1109/ICSE.2017.76',43,12,'IEEE','IEEE Conferences',0),(34,'Adaptive Unpacking of Android Apps',4,358,369,'More and more app developers use the packing services (or packers) to prevent attackers from reverse engineering and modifying the executable (or Dex files) of their apps. At the same time, malware authors also use the packers to hide the malicious component and evade the signature-based detection. Although there are a few recent studies on unpacking Android apps, it has been shown that the evolving packers can easily circumvent them because they are not adaptive to the changes of packers. In this paper, we propose a novel adaptive approach and develop a new system, named PackerGrind, to unpack Android apps. We also evaluate PackerGrind with real packed apps, and the results show that PackerGrind can successfully reveal the packers\' protection mechanisms and recover the Dex files with low overhead, showing that our approach can effectively handle the evolution of packers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985676','10.1109/ICSE.2017.40',61,12,'IEEE','IEEE Conferences',0),(35,'Latent Patterns in Activities: A Field Study of How Developers Manage Context',3,373,383,'In order to build efficient tools that support complex programming tasks, it is imperative that we understand how developers program. We know that developers create a context around their programming task by gathering relevant information. We also know that developers decompose their tasks recursively into smaller units. However, important gaps exist in our knowledge about: (1) the role that context plays in supporting smaller units of tasks, (2) the relationship that exists among these smaller units, and (3) how context flows across them. The goal of this research is to gain a better understanding of how developers structure their tasks and manage context through a field study of ten professional developers in an industrial setting. Our analysis reveals that developers decompose their tasks into smaller units with distinct goals, that specific patterns exist in how they sequence these smaller units, and that developers may maintain context between those smaller units with related goals.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811986','10.1109/ICSE.2019.00051',34,0,'IEEE','IEEE Conferences',0),(36,'Learning Syntactic Program Transformations from Examples',4,404,415,'Automatic program transformation tools can be valuable for programmers to help them with refactoring tasks, and for Computer Science students in the form of tutoring systems that suggest repairs to programming assignments. However, manually creating catalogs of transformations is complex and time-consuming. In this paper, we present REFAZER, a technique for automatically learning program transformations. REFAZER builds on the observation that code edits performed by developers can be used as input-output examples for learning program transformations. Example edits may share the same structure but involve different variables and subexpressions, which must be generalized in a transformation at the right level of abstraction. To learn transformations, REFAZER leverages state-of-the-art programming-by-example methodology using the following key components: (a) a novel domain-specific language (DSL) for describing program transformations, (b) domain-specific deductive algorithms for efficiently synthesizing transformations in the DSL, and (c) functions for ranking the synthesized transformations. We instantiate and evaluate REFAZER in two domains. First, given examples of code edits used by students to fix incorrect programming assignment submissions, we learn program transformations that can fix other students\' submissions with similar faults. In our evaluation conducted on 4 programming tasks performed by 720 students, our technique helped to fix incorrect submissions for 87% of the students. In the second domain, we use repetitive code edits applied by developers to the same project to synthesize a program transformation that applies these edits to other locations in the code. In our evaluation conducted on 56 scenarios of repetitive edits taken from three large C# open-source projects, REFAZER learns the intended program transformation in 84% of the cases using only 2.9 examples on average.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985680','10.1109/ICSE.2017.44',50,10,'IEEE','IEEE Conferences',0),(37,'Why Does Code Review Work for Open Source Software Communities?',3,1073,1083,'Open source software communities have demonstrated that they can produce high quality results. The overall success of peer code review, commonly used in open source projects, has likely contributed strongly to this success. Code review is an emotionally loaded practice, with public exposure of reputation and ample opportunities for conflict. We set off to ask why code review works for open source communities, despite this inherent challenge. We interviewed 21 open source contributors from four communities and participated in meetings of ROS community devoted to implementation of the code review process. It appears that the hacker ethic is a key reason behind the success of code review in FOSS communities. It is built around the ethic of passion and the ethic of caring. Furthermore, we observed that tasks of code review are performed with strong intrinsic motivation, supported by many non-material extrinsic motivation mechanisms, such as desire to learn, to grow reputation, or to improve one\'s positioning on the job market. In the paper, we describe the study design, analyze the collected data and formulate 20 proposals for how what we know about hacker ethics and human and social aspects of code review, could be exploited to improve the effectiveness of the practice in software projects.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812037','10.1109/ICSE.2019.00111',46,0,'IEEE','IEEE Conferences',0),(38,'The Seven Sins: Security Smells in Infrastructure as Code Scripts',3,164,175,'Practitioners use infrastructure as code (IaC) scripts to provision servers and development environments. While developing IaC scripts, practitioners may inadvertently introduce security smells. Security smells are recurring coding patterns that are indicative of security weakness and can potentially lead to security breaches. The goal of this paper is to help practitioners avoid insecure coding practices while developing infrastructure as code (IaC) scripts through an empirical study of security smells in IaC scripts. We apply qualitative analysis on 1,726 IaC scripts to identify seven security smells. Next, we implement and validate a static analysis tool called Security Linter for Infrastructure as Code scripts (SLIC) to identify the occurrence of each smell in 15,232 IaC scripts collected from 293 open source repositories. We identify 21,201 occurrences of security smells that include 1,326 occurrences of hard-coded passwords. We submitted bug reports for 1,000 randomly-selected security smell occurrences. We obtain 212 responses to these bug reports, of which 148 occurrences were accepted by the development teams to be fixed. We observe security smells can have a long lifetime, e.g., a hard-coded secret can persist for as long as 98 months, with a median lifetime of 20 months.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812041','10.1109/ICSE.2019.00033',56,6,'IEEE','IEEE Conferences',0),(39,'IconIntent: Automatic Identification of Sensitive UI Widgets Based on Icon Classification for Android Apps',3,257,268,'Many mobile applications (i.e., apps) include UI widgets to use or collect users\' sensitive data. Thus, to identify suspicious sensitive data usage such as UI-permission mismatch, it is crucial to understand the intentions of UI widgets. However, many UI widgets leverage icons of specific shapes (object icons) and icons embedded with text (text icons) to express their intentions, posing challenges for existing detection techniques that analyze only textual data to identify sensitive UI widgets. In this work, we propose a novel app analysis framework, ICONINTENT, that synergistically combines program analysis and icon classification to identify sensitive UI widgets in Android apps. ICONINTENT automatically associates UI widgets and icons via static analysis on app\'s UI layout files and code, and then adapts computer vision techniques to classify the associated icons into eight categories of sensitive data. Our evaluations of ICONINTENT on 150 apps from Google Play show that ICONINTENT can detect 248 sensitive UI widgets in 97 apps, achieving a precision of 82.4%. When combined with SUPOR, the state-of-the-art sensitive UI widget identification technique based on text analysis, SUPOR +ICONINTENT can detect 487 sensitive UI widgets (101.2% improvement over SUPOR only), and reduces suspicious permissions to be inspected by 50.7% (129.4% improvement over SUPOR only).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812108','10.1109/ICSE.2019.00041',45,1,'IEEE','IEEE Conferences',0),(40,'Detecting Atomicity Violations for Event-Driven Node.js Applications',3,631,642,'Node.js has been widely-used as an event-driven server-side architecture. To improve performance, a task in a Node.js application is usually divided into a group of events, which are non-deterministically scheduled by Node.js. Developers may assume that the group of events (named atomic event group) should be atomically processed, without interruption. However, the atomicity of an atomic event group is not guaranteed by Node.js, and thus other events may interrupt the execution of the atomic event group, break down the atomicity and cause unexpected results. Existing approaches mainly focus on event race among two events, and cannot detect high-level atomicity violations among a group of events. In this paper, we propose NodeAV, which can predictively detect atomicity violations in Node.js applications based on an execution trace. Based on happens-before relations among events in an execution trace, we automatically identify a pair of events that should be atomically processed, and use predefined atomicity violation patterns to detect atomicity violations. We have evaluated NodeAV on real-world Node.js applications. The experimental results show that NodeAV can effectively detect atomicity violations in these Node.js applications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811949','10.1109/ICSE.2019.00073',48,0,'IEEE','IEEE Conferences',0),(41,'Dynamic Slicing for Android',3,1154,1164,'Dynamic program slicing is useful for a variety of tasks, from testing to debugging to security. Prior slicing approaches have targeted traditional desktop/server platforms, rather than mobile platforms such as Android. Slicing mobile, event-based systems is challenging due to their asynchronous callback construction and the IPC (interprocess communication)- heavy, sensor-driven, timing-sensitive nature of the platform. To address these problems, we introduce AndroidSlicer1, the first slicing approach for Android. AndroidSlicer combines a novel asynchronous slicing approach for modeling data and control dependences in the presence of callbacks with lightweight and precise instrumentation; this allows slicing for apps running on actual phones, and without requiring the app\'s source code. Our slicer is capable of handling a wide array of inputs that Android supports without adding any noticeable overhead. Experiments on 60 apps from Google Play show that AndroidSlicer is effective (reducing the number of instructions to be examined to 0.3% of executed instructions) and efficient (app instrumentation and post-processing combined takes 31 seconds); all while imposing a runtime overhead of just 4%. We present three applications of AndroidSlicer that are particularly relevant in the mobile domain: (1) finding and tracking input parts responsible for an error/crash, (2) fault localization, i.e., finding the instructions responsible for an error/crash, and (3) reducing the regression test suite. Experiments with these applications on an additional set of 18 popular apps indicate that AndroidSlicer is effective for Android testing and debugging.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811953','10.1109/ICSE.2019.00118',32,0,'IEEE','IEEE Conferences',0),(42,'The Product Backlog',3,200,211,'Context: One of the most common artifacts in contemporary software projects is a product backlog comprising user stories, bugs, chores or other work items. However, little research has investigated how the backlog is generated or the precise role it plays in a project. Objective: The purpose of this paper is to determine what is a product backlog, what is its role, and how does it emerge? Method: Following Constructivist Grounded Theory, we conducted a two-year, five-month participant-observation study of eight software development projects at Pivotal, a large, international software company. We interviewed 56 software engineers, product designers, and product managers.We conducted a survey of 27 product designers. We alternated between analysis and theoretical sampling until achieving theoretical saturation. Results: We observed 13 practices and 6 obstacles related to product backlog generation. Limitations: Grounded Theory does not support statistical generalization. While the proposed theory of product backlogs appears widely applicable, organizations with different software development cultures may use different practices. Conclusion: The product backlog is simultaneously a model of work to be done and a boundary object that helps bridge the gap between the processes of generating user stories and realizing them in working code. It emerges from sensemaking (the team making sense of the project context) and coevolution (a cognitive process where the team simultaneously refines its understanding of the problematic context and fledgling solution concepts).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812076','10.1109/ICSE.2019.00036',58,0,'IEEE','IEEE Conferences',0),(43,'How Do Developers Fix Cross-Project Correlated Bugs? A Case Study on the GitHub Scientific Python Ecosystem',4,381,392,'GitHub, a popular social-software-development platform, has fostered a variety of software ecosystems where projects depend on one another and practitioners interact with each other. Projects within an ecosystem often have complex inter-dependencies that impose new challenges in bug reporting and fixing. In this paper, we conduct an empirical study on cross-project correlated bugs, i.e., causally related bugs reported to different projects, focusing on two aspects: 1) how developers track the root causes across projects, and 2) how the downstream developers coordinate to deal with upstream bugs. Through manual inspection of bug reports collected from the scientific Python ecosystem and an online survey with developers, this study reveals the common practices of developers and the various factors in fixing cross-project bugs. These findings provide implications for future software bug analysis in the scope of ecosystem, as well as shed light on the requirements of issue trackers for such bugs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985678','10.1109/ICSE.2017.42',39,9,'IEEE','IEEE Conferences',0),(44,'DeepPerf: Performance Prediction for Configurable Software with Deep Sparse Neural Network',3,1095,1106,'Many software systems provide users with a set of configuration options and different configurations may lead to different runtime performance of the system. As the combination of configurations could be exponential, it is difficult to exhaustively deploy and measure system performance under all possible configurations. Recently, several learning methods have been proposed to build a performance prediction model based on performance data collected from a small sample of configurations, and then use the model to predict system performance under a new configuration. In this paper, we propose a novel approach to model highly configurable software system using a deep feedforward neural network (FNN) combined with a sparsity regularization technique, e.g. the L1 regularization. Besides, we also design a practical search strategy for automatically tuning the network hyperparameters efficiently. Our method, called DeepPerf, can predict performance values of highly configurable software systems with binary and/or numeric configuration options at much higher prediction accuracy with less training data than the state-of-the art approaches. Experimental results on eleven public real-world datasets confirm the effectiveness of our approach.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811988','10.1109/ICSE.2019.00113',55,3,'IEEE','IEEE Conferences',0),(45,'Heuristically Matching Solution Spaces of Arithmetic Formulas to Efficiently Reuse Solutions',4,427,437,'Many symbolic program analysis techniques rely on SMT solvers to verify properties of programs. Despite the remarkable progress made in the development of such tools, SMT solvers still represent a main bottleneck to the scalability of these techniques. Recent approaches tackle this bottleneck by reusing solutions of formulas that recur during program analysis, thus reducing the number of queries to SMT solvers. Current approaches only reuse solutions across formulas that are equivalent to, contained in or implied by other formulas, as identified through a set of predefined rules, and cannot reuse solutions across formulas that differ in their structure, even if they share some potentially reusable solutions. In this paper, we propose a novel approach that can reuse solutions across formulas that share at least one solution, regardless of their structural resemblance. Our approach exploits a novel heuristic to efficiently identify solutions computed for previously solved formulas and most likely shared by new formulas. The results of an empirical evaluation of our approach on two different logics show that our approach can identify on average more reuse opportunities and is markedly faster than competing approaches.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985682','10.1109/ICSE.2017.46',19,1,'IEEE','IEEE Conferences',0),(46,'Developer Reading Behavior While Summarizing Java Methods: Size and Context Matters',3,384,395,'An eye-tracking study of 18 developers reading and summarizing Java methods is presented. The developers provide a written summary for methods assigned to them. In total, 63 methods are used from five different systems. Previous studies on this topic use only short methods presented in isolation usually as images. In contrast, this work presents the study in the Eclipse IDE allowing access to all the source code in the system. The developer can navigate via scrolling and switching files while writing the summary. New eye-tracking infrastructure allows for this improvement in the study environment. Data collected includes eye gazes on source code, written summaries, and time to complete each summary. Unlike prior work that concluded developers focus on the signature the most, these results indicate that they tend to focus on the method body more than the signature. Moreover, both experts and novices tend to revisit control flow terms rather than reading them for a long period. They also spend a significant amount of gaze time and have higher gaze visits when they read call terms. Experts tend to revisit the body of the method significantly more frequently than its signature as the size of the method increases. Moreover, experts tend to write their summaries from source code lines that they read the most.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812039','10.1109/ICSE.2019.00052',48,2,'IEEE','IEEE Conferences',0),(47,'SafeCheck: Safety Enhancement of Java Unsafe API',3,889,899,'Java is a safe programming language by providing bytecode verification and enforcing memory protection. For instance, programmers cannot directly access the memory but have to use object references. Yet, the Java runtime provides an Unsafe API as a backdoor for the developers to access the low- level system code. Whereas the Unsafe API is designed to be used by the Java core library, a growing community of third-party libraries use it to achieve high performance. The Unsafe API is powerful, but dangerous, which leads to data corruption, resource leaks and difficult-to-diagnose JVM crash if used improperly. In this work, we study the Unsafe crash patterns and propose a memory checker to enforce memory safety, thus avoiding the JVM crash caused by the misuse of the Unsafe API at the bytecode level. We evaluate our technique on real crash cases from the openJDK bug system and real-world applications from AJDK. Our tool reduces the efforts from several days to a few minutes for the developers to diagnose the Unsafe related crashes. We also evaluate the runtime overhead of our tool on projects using intensive Unsafe operations, and the result shows that our tool causes a negligible perturbation to the execution of the applications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811920','10.1109/ICSE.2019.00095',28,0,'IEEE','IEEE Conferences',0),(48,'StoryDroid: Automated Generation of Storyboard for Android Apps',3,596,607,'Mobile apps are now ubiquitous. Before developing a new app, the development team usually endeavors painstaking efforts to review many existing apps with similar purposes. The review process is crucial in the sense that it reduces market risks and provides inspiration for app development. However, manual exploration of hundreds of existing apps by different roles (e.g., product manager, UI/UX designer, developer) in a development team can be ineffective. For example, it is difficult to completely explore all the functionalities of the app in a short period of time. Inspired by the conception of storyboard in movie production, we propose a system, StoryDroid, to automatically generate the storyboard for Android apps, and assist different roles to review apps efficiently. Specifically, StoryDroid extracts the activity transition graph and leverages static analysis techniques to render UI pages to visualize the storyboard with the rendered pages. The mapping relations between UI pages and the corresponding implementation code (e.g., layout code, activity code, and method hierarchy) are also provided to users. Our comprehensive experiments unveil that StoryDroid is effective and indeed useful to assist app development. The outputs of StoryDroid enable several potential applications, such as the recommendation of UI design and layout code.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812043','10.1109/ICSE.2019.00070',70,2,'IEEE','IEEE Conferences',0),(49,'Exposing Library API Misuses Via Mutation Analysis',3,866,877,'Misuses of library APIs are pervasive and often lead to software crashes and vulnerability issues. Various static analysis tools have been proposed to detect library API misuses. They often involve mining frequent patterns from a large number of correct API usage examples, which can be hard to obtain in practice. They also suffer from low precision due to an over-simplified assumption that a deviation from frequent usage patterns indicates a misuse. We make two observations on the discovery of API misuse patterns. First, API misuses can be represented as mutants of the corresponding correct usages. Second, whether a mutant will introduce a misuse can be validated via executing it against a test suite and analyzing the execution information. Based on these observations, we propose MutApi, the first approach to discovering API misuse patterns via mutation analysis. To effectively mimic API misuses based on correct usages, we first design eight effective mutation operators inspired by the common characteristics of API misuses. MutApi generates mutants by applying these mutation operators on a set of client projects and collects mutant-killing tests as well as the associated stack traces. Misuse patterns are discovered from the killed mutants that are prioritized according to their likelihood of causing API misuses based on the collected information. We applied MutApi on 16 client projects with respect to 73 popular Java APIs. The results show that MutApi is able to discover substantial API misuse patterns with a high precision of 0.78. It also achieves a recall of $0.49$ on the MuBench benchmark, which outperforms the state-of-the-art techniques.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812114','10.1109/ICSE.2019.00093',60,0,'IEEE','IEEE Conferences',0),(50,'Semantically Enhanced Software Traceability Using Deep Learning Techniques',4,3,14,'In most safety-critical domains the need for traceability is prescribed by certifying bodies. Trace links are generally created among requirements, design, source code, test cases and other artifacts, however, creating such links manually is time consuming and error prone. Automated solutions use information retrieval and machine learning techniques to generate trace links, however, current techniques fail to understand semantics of the software artifacts or to integrate domain knowledge into the tracing process and therefore tend to deliver imprecise and inaccurate results. In this paper, we present a solution that uses deep learning to incorporate requirements artifact semantics and domain knowledge into the tracing solution. We propose a tracing network architecture that utilizes Word Embedding and Recurrent Neural Network (RNN) models to generate trace links. Word embedding learns word vectors that represent knowledge of the domain corpus and RNN uses these word vectors to learn the sentence semantics of requirements artifacts. We trained 360 different configurations of the tracing network using existing trace links in the Positive Train Control domain and identified the Bidirectional Gated Recurrent Unit (BI-GRU) as the best model for the tracing task. BI-GRU significantly out-performed state-of-the-art tracing methods including the Vector Space Model and Latent Semantic Indexing.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985645','10.1109/ICSE.2017.9',70,28,'IEEE','IEEE Conferences',0),(51,'A System Identification Based Oracle for Control-CPS Software Fault Localization',3,116,127,'Control-CPS software fault localization (SFL, aka bug localization) is of critical importance as bugs may cause major failures, even injuries/deaths. To locate the bugs in control-CPSs, SFL tools often demand many labeled (\'correct\'/\'incorrect\') source code execution traces as inputs. To label the correctness of these traces, we must judge the corresponding control-CPS physical trajectories\' correctness. However, unlike discrete outputs, the boundaries between correct and incorrect physical trajectories are often vague. The mechanism (aka oracle) to judge the physical trajectories\' correctness thus becomes a major challenge. So far, the ad hoc practice of ``human oracles\'\' is still widely used, whose qualities heavily depend on the human experts\' expertise and availability. This paper proposes an oracle based on the well adopted autoregressive system identification (AR-SI). With proven success for controlling black-box physical systems, AR-SI is adapted by us to identify the buggy control-CPS as a black-box. We use this identification result as an oracle to judge the control-CPS\'s behaviors, and propose a methodology to prepare traces for control-CPS debugging. Comprehensive evaluations on classic control-CPSs with injected real-life and artificial bugs show that our proposed approach significantly outperforms the human oracle approach in SFL accuracy (recall) and latency, and in oracle false positive/negative rates. Our approach also helps discover a new real-life bug in a consumer-grade control-CPS.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811955','10.1109/ICSE.2019.00029',101,0,'IEEE','IEEE Conferences',0),(52,'Detecting Incorrect Build Rules',3,1234,1244,'Automated build systems are routinely used by software engineers to minimize the number of objects that need to be recompiled after incremental changes to the source files of a project. In order to achieve efficient and correct builds, developers must provide the build tools with dependency information between the files and modules of a project, usually expressed in a macro language specific to each build tool. In order to guarantee correctness, the authors of these tools are responsible for enumerating all the files whose contents an output depends on. Unfortunately, this is a tedious process and not all dependencies are captured in practice, which leads to incorrect builds. We automatically uncover such missing dependencies through a novel method that we call build fuzzing. The correctness of build definitions is verified by modifying files in a project, triggering incremental builds and comparing the set of changed files to the set of expected changes. These sets are determined using a dependency graph inferred by tracing the system calls executed during a clean build. We evaluate our method by exhaustively testing build rules of open-source projects, uncovering issues leading to race conditions and faulty builds in 31 of them. We provide a discussion of the bugs we detect, identifying anti-patterns in the use of the macro languages. We fix some of the issues in projects where the features of build systems allow a clean solution.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812082','10.1109/ICSE.2019.00125',25,1,'IEEE','IEEE Conferences',0),(53,'Unsupervised Software-Specific Morphological Forms Inference from Informal Discussions',4,450,461,'Informal discussions on social platforms (e.g., Stack Overflow) accumulates a large body of programming knowledge in natural language text. Natural language process (NLP) techniques can be exploited to harvest this knowledge base for software engineering tasks. To make an effective use of NLP techniques, consistent vocabulary is essential. Unfortunately, the same concepts are often intentionally or accidentally mentioned in many different morphological forms in informal discussions, such as abbreviations, synonyms and misspellings. Existing techniques to deal with such morphological forms are either designed for general English or predominantly rely on domain-specific lexical rules. A thesaurus of software-specific terms and commonly-used morphological forms is desirable for normalizing software engineering text, but very difficult to build manually. In this work, we propose an automatic approach to build such a thesaurus. Our approach identifies software-specific terms by contrasting software-specific and general corpuses, and infers morphological forms of software-specific terms by combining distributed word semantics, domain-specific lexical rules and transformations, and graph analysis of morphological relations. We evaluate the coverage and accuracy of the resulting thesaurus against community-curated lists of software-specific terms, abbreviations and synonyms. We also manually examine the correctness of the identified abbreviations and synonyms in our thesaurus. We demonstrate the usefulness of our thesaurus in a case study of normalizing questions from Stack Overflow and CodeProject.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985684','10.1109/ICSE.2017.48',60,4,'IEEE','IEEE Conferences',0),(54,'ActionNet: Vision-Based Workflow Action Recognition From Programming Screencasts',3,350,361,'Programming screencasts have two important applications in software engineering context: study developer behaviors, information needs and disseminate software engineering knowledge. Although programming screencasts are easy to produce, they are not easy to analyze or index due to the image nature of the data. Existing techniques extract only content from screencasts, but ignore workflow actions by which developers accomplish programming tasks. This significantly limits the effective use of programming screencasts in downstream applications. In this paper, we are the first to present a novel technique for recognizing workflow actions in programming screencasts. Our technique exploits image differencing and Convolutional Neural Network (CNN) to analyze the correspondence and change of consecutive frames, based on which nine classes of frequent developer actions can be recognized from programming screencasts. Using programming screencasts from Youtube, we evaluate different configurations of our CNN model and the performance of our technique for developer action recognition across developers, working environments and programming languages. Using screencasts of developers\' real work, we demonstrate the usefulness of our technique in a practical application for actionaware extraction of key-code frames in developers\' work.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811922','10.1109/ICSE.2019.00049',69,1,'IEEE','IEEE Conferences',0),(55,'Hunting for Bugs in Code Coverage Tools via Randomized Differential Testing',3,488,499,'Reliable code coverage tools are critically important as it is heavily used to facilitate many quality assurance activities, such as software testing, fuzzing, and debugging. However, little attention has been devoted to assessing the reliability of code coverage tools. In this study, we propose a randomized differential testing approach to hunting for bugs in the most widely used C code coverage tools. Specifically, by generating random input programs, our approach seeks for inconsistencies in code coverage reports produced by different code coverage tools, and then identifies inconsistencies as potential code coverage bugs. To effectively report code coverage bugs, we addressed three specific challenges: (1) How to filter out duplicate test programs as many of them triggering the same bugs in code coverage tools; (2) how to automatically reduce large test programs to much smaller ones that have the same properties; and (3) how to determine which code coverage tools have bugs? The extensive evaluations validate the effectiveness of our approach, resulting in 42 and 28 confirmed/fixed bugs for gcov and llvm-cov, respectively. This case study indicates that code coverage tools are not as reliable as it might have been envisaged. It not only demonstrates the effectiveness of our approach, but also highlights the need to continue improving the reliability of code coverage tools. This work opens up a new direction in code coverage validation which calls for more attention in this area.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812045','10.1109/ICSE.2019.00061',60,2,'IEEE','IEEE Conferences',0),(56,'When Code Completion Fails: A Case Study on Real-World Completions',3,960,970,'Code completion is commonly used by software developers and is integrated into all major IDE\'s. Good completion tools can not only save time and effort but may also help avoid incorrect API usage. Many proposed completion tools have shown promising results on synthetic benchmarks, but these benchmarks make no claims about the realism of the completions they test. This lack of grounding in real-world data could hinder our scientific understanding of developer needs and of the efficacy of completion models. This paper presents a case study on 15,000 code completions that were applied by 66 real developers, which we study and contrast with artificial completions to inform future research and tools in this area. We find that synthetic benchmarks misrepresent many aspects of real-world completions; tested completion tools were far less accurate on real-world data. Worse, on the few completions that consumed most of the developers\' time, prediction accuracy was less than 20% -- an effect that is invisible in synthetic benchmarks. Our findings have ramifications for future benchmarks, tool design and real-world efficacy: Benchmarks must account for completions that developers use most, such as intra-project APIs; models should be designed to be amenable to intra-project data; and real-world developer trials are essential to quantifying performance on the least predictable completions, which are both most time-consuming and far more typical than artificial data suggests. We publicly release our preprint [https://doi.org/10.5281/zenodo.2565673] and replication data and materials [https://doi.org/10.5281/zenodo.2562249].','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812116','10.1109/ICSE.2019.00101',29,1,'IEEE','IEEE Conferences',0),(57,'Analyzing APIs Documentation and Code to Detect Directive Defects',4,27,37,'Application Programming Interface (API) documents represent one of the most important references for API users. However, it is frequently reported that the documentation is inconsistent with the source code and deviates from the API itself. Such inconsistencies in the documents inevitably confuse the API users hampering considerably their API comprehension and the quality of software built from such APIs. In this paper, we propose an automated approach to detect defects of API documents by leveraging techniques from program comprehension and natural language processing. Particularly, we focus on the directives of the API documents which are related to parameter constraints and exception throwing declarations. A first-order logic based constraint solver is employed to detect such defects based on the obtained analysis results. We evaluate our approach on parts of well documented JDK 1.8 APIs. Experiment results show that, out of around 2000 API usage constraints, our approach can detect 1158 defective document directives, with a precision rate of 81.6%, and a recall rate of 82.0%, which demonstrates its practical feasibility.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985647','10.1109/ICSE.2017.11',41,14,'IEEE','IEEE Conferences',0),(58,'Deep Differential Testing of JVM Implementations',3,1257,1268,'The Java Virtual Machine (JVM) is the cornerstone of the widely-used Java platform. Thus, it is critical to ensure the reliability and robustness of popular JVM implementations. However, little research exists on validating production JVMs. One notable effort is classfuzz, which mutates Java bytecode syntactically to stress-test different JVMs. It is shown that classfuzz mainly produces illegal bytecode files and uncovers defects in JVMs\' startup processes. It remains a challenge to effectively test JVMs\' bytecode verifiers and execution engines to expose deeper bugs. This paper tackles this challenge by introducing classming, a novel, effective approach to performing deep, differential JVM testing. The key of classming is a technique, live bytecode mutation, to generate, from a seed bytecode file f, likely valid, executable (live) bytecode files: (1) capture the seed f\'s live bytecode, the sequence of its executed bytecode instructions; (2) repeatedly manipulate the control- and data-flow in f\'s live bytecode to generate semantically different mutants; and (3) selectively accept the generated mutants to steer the mutation process toward live, diverse mutants. The generated mutants are then employed to differentially test JVMs. We have evaluated classming on mainstream JVM implementations, including OpenJDK\'s HotSpot and IBM\'s J9, by mutating the DaCapo benchmarks. Our results show that classming is very effective in uncovering deep JVM differences. More than 1,800 of the generated classes exposed JVM differences, and more than 30 triggered JVM crashes. We analyzed and reported the JVM runtime differences and crashes, of which 14 have already been confirmed/fixed, including a highly critical security vulnerability in J9 that allowed untrusted code to disable the security manager and elevate its privileges (CVE-2017-1376).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811957','10.1109/ICSE.2019.00127',49,0,'IEEE','IEEE Conferences',0),(59,'Characterizing and Detecting Anti-Patterns in the Logging Code',4,71,81,'Snippets of logging code are output statements (e.g., LOG.info or System.out.println) that developers insert into a software system. Although more logging code can provide more execution context of the system\'s behavior during runtime, it is undesirable to instrument the system with too much logging code due to maintenance overhead. Furthermore, excessive logging may cause unexpected side-effects like performance slow-down or high disk I/O bandwidth. Recent studies show that there are no well-defined coding guidelines for performing effective logging. Previous research on the logging code mainly tackles the problems of where-to-log and what-to-log. There are very few works trying to address the problem of how-to-log (developing and maintaining high-quality logging code). In this paper, we study the problem of how-to-log by characterizing and detecting the anti-patterns in the logging code. As the majority of the logging code is evolved together with the feature code, the remaining set of logging code changes usually contains the fixes to the anti-patterns. We have manually examined 352 pairs of independently changed logging code snippets from three well-maintenance open source systems: ActiveMQ, Hadoop and Maven. Our analysis has resulted in six different anti-patterns in the logging code. To demonstrate the value of our findings, we have encoded these anti-patterns into a static code analysis tool, LCAnalyzer. Case studies show that LCAnalyzer has an average recall of 95% and precision of 60% and can be used to automatically detect previously unknown anti-patterns in the source code. To gather feedback, we have filed 64 representative instances of the logging code anti-patterns from the most recent releases of ten open source software systems. Among them, 46 instances (72%) have already been accepted by their developers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985651','10.1109/ICSE.2017.15',47,12,'IEEE','IEEE Conferences',0),(60,'RESTler: Stateful REST API Fuzzing',3,748,758,'This paper introduces RESTler, the first stateful REST API fuzzer. RESTler analyzes the API specification of a cloud service and generates sequences of requests that automatically test the service through its API. RESTler generates test sequences by (1) inferring producer-consumer dependencies among request types declared in the specification (e.g., inferring that \'a request B should be executed after request A\' because B takes as an input a resource-id x produced by A) and by (2) analyzing dynamic feedback from responses observed during prior test executions in order to generate new tests (e.g., learning that \'a request C after a request sequence A;B is refused by the service\' and therefore avoiding this combination in the future). We present experimental results showing that these two techniques are necessary to thoroughly exercise a service under test while pruning the large search space of possible request sequences. We used RESTler to test GitLab, an open-source Git service, as well as several Microsoft Azure and Office365 cloud services. RESTler found 28 bugs in GitLab and several bugs in each of the Azure and Office365 cloud services tested so far. These bugs have been confirmed and fixed by the service owners.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811961','10.1109/ICSE.2019.00083',43,1,'IEEE','IEEE Conferences',0),(61,'Supporting Analysts by Dynamic Extraction and Classification of Requirements-Related Knowledge',3,442,453,'In many software development projects, analysts are required to deal with systems\' requirements from unfamiliar domains. Familiarity with the domain is necessary in order to get full leverage from interaction with stakeholders and for extracting relevant information from the existing project documents. Accurate and timely extraction and classification of requirements knowledge support analysts in this challenging scenario. Our approach is to mine real-time interaction records and project documents for the relevant phrasal units about the requirements related topics being discussed during elicitation. We propose to use both generative and discriminating methods. To extract the relevant terms, we leverage the flexibility and power of Weighted Finite State Transducers (WFSTs) in dynamic modelling of natural language processing tasks. We used an extended version of Support Vector Machines (SVMs) with variable-sized feature vectors to efficiently and dynamically extract and classify requirements-related knowledge from the existing documents. To evaluate the performance of our approach intuitively and quantitatively, we used edit distance and precision/recall metrics. We show in three case studies that the snippets extracted by our method are intuitively relevant and reasonably accurate. Furthermore, we found that statistical and linguistic parameters such as smoothing methods, and words contiguity and order features can impact the performance of both extraction and classification tasks.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812084','10.1109/ICSE.2019.00057',80,0,'IEEE','IEEE Conferences',0),(62,'Travioli: A Dynamic Analysis for Detecting Data-Structure Traversals',4,473,483,'Traversal is one of the most fundamental operations on data structures, in which an algorithm systematically visits some or all of the data items of a data structure. We propose a dynamic analysis technique, called Travioli, for detecting data-structure traversals. We introduce the concept of acyclic execution contexts, which enables precise detection of traversals of arrays and linked data structures such as lists and trees in the presence of both loops and recursion. We describe how the information reported by Travioli can be used for visualizing data-structure traversals, manually generating performance regression tests, and for discovering performance bugs caused by redundant traversals. We evaluate Travioli on five real-world JavaScript programs. In our experiments, Travioli produced fewer than 4% false positives. We were able to construct performance tests for 93.75% of the reported true traversals. Travioli also found two asymptotic performance bugs in widely used JavaScript frameworks D3 and express.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985686','10.1109/ICSE.2017.50',32,1,'IEEE','IEEE Conferences',0),(63,'Machine-Learning-Guided Selectively Unsound Static Analysis',4,519,529,'We present a machine-learning-based technique for selectively applying unsoundness in static analysis. Existing bug-finding static analyzers are unsound in order to be precise and scalable in practice. However, they are uniformly unsound and hence at the risk of missing a large amount of real bugs. By being sound, we can improve the detectability of the analyzer but it often suffers from a large number of false alarms. Our approach aims to strike a balance between these two approaches by selectively allowing unsoundness only when it is likely to reduce false alarms, while retaining true alarms. We use an anomaly-detection technique to learn such harmless unsoundness. We implemented our technique in two static analyzers for full C. One is for a taint analysis for detecting format-string vulnerabilities, and the other is for an interval analysis for buffer-overflow detection. The experimental results show that our approach significantly improves the recall of the original unsound analysis without sacrificing the precision.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985690','10.1109/ICSE.2017.54',24,2,'IEEE','IEEE Conferences',0),(64,'Adversarial Sample Detection for Deep Neural Network through Model Mutation Testing',3,1245,1256,'Deep neural networks (DNN) have been shown to be useful in a wide range of applications. However, they are also known to be vulnerable to adversarial samples. By transforming a normal sample with some carefully crafted human imperceptible perturbations, even highly accurate DNN make wrong decisions. Multiple defense mechanisms have been proposed which aim to hinder the generation of such adversarial samples. However, a recent work show that most of them are ineffective. In this work, we propose an alternative approach to detect adversarial samples at runtime. Our main observation is that adversarial samples are much more sensitive than normal samples if we impose random mutations on the DNN. We thus first propose a measure of \'sensitivity\' and show empirically that normal samples and adversarial samples have distinguishable sensitivity. We then integrate statistical hypothesis testing and model mutation testing to check whether an input sample is likely to be normal or adversarial at runtime by measuring its sensitivity. We evaluated our approach on the MNIST and CIFAR10 datasets. The results show that our approach detects adversarial samples generated by state-of-the-art attacking methods efficiently and accurately.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812047','10.1109/ICSE.2019.00126',56,3,'IEEE','IEEE Conferences',0),(65,'FOCUS: A Recommender System for Mining API Function Calls and Usage Patterns',3,1050,1060,'Software developers interact with APIs on a daily basis and, therefore, often face the need to learn how to use new APIs suitable for their purposes. Previous work has shown that recommending usage patterns to developers facilitates the learning process. Current approaches to usage pattern recommendation, however, still suffer from high redundancy and poor run-time performance. In this paper, we reformulate the problem of usage pattern recommendation in terms of a collaborative-filtering recommender system. We present a new tool, FOCUS, which mines open-source project repositories to recommend API method invocations and usage patterns by analyzing how APIs are used in projects similar to the current project. We evaluate FOCUS on a large number of Java projects extracted from GitHub and Maven Central and find that it outperforms the state-of-the-art approach PAM with regards to success rate, accuracy, and execution time. Results indicate the suitability of context-aware collaborative-filtering recommender systems to provide API usage patterns.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812051','10.1109/ICSE.2019.00109',45,2,'IEEE','IEEE Conferences',0),(66,'Why Do Episodic Volunteers Stay in FLOSS Communities?',3,948,959,'Successful Free/Libre and Open Source Software (FLOSS) projects incorporate both habitual and infrequent, or episodic, contributors. Using the concept of episodic volunteering (EV) from the general volunteering literature, we derive a model consisting of five key constructs that we hypothesize affect episodic volunteers\' retention in FLOSS communities. To evaluate the model we conducted a survey with over 100 FLOSS episodic volunteers. We observe that three of our model constructs (social norms, satisfaction and community commitment) are all positively associated with volunteers\' intention to remain, while the two other constructs (psychological sense of community and contributor benefit motivations) are not. Furthermore, exploratory clustering on unobserved heterogeneity suggests that there are four distinct categories of volunteers: satisfied, classic, social and obligated. Based on our findings, we offer suggestions for projects to incorporate and manage episodic volunteers, so as to better leverage this type of contributors and potentially improve projects\' sustainability.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811892','10.1109/ICSE.2019.00100',88,1,'IEEE','IEEE Conferences',0),(67,'Detecting User Story Information in Developer-Client Conversations to Generate Extractive Summaries',4,49,59,'User stories are descriptions of functionality that a software user needs. They play an important role in determining which software requirements and bug fixes should be handled and in what order. Developers elicit user stories through meetings with customers. But user story elicitation is complex, and involves many passes to accommodate shifting and unclear customer needs. The result is that developers must take detailed notes during meetings or risk missing important information. Ideally, developers would be freed of the need to take notes themselves, and instead speak naturally with their customers. This paper is a step towards that ideal. We present a technique for automatically extracting information relevant to user stories from recorded conversations between customers and developers. We perform a qualitative study to demonstrate that user story information exists in these conversations in a sufficient quantity to extract automatically. From this, we found that roughly 10.2% of these conversations contained user story information. Then, we test our technique in a quantitative study to determine the degree to which our technique can extract user story information. In our experiment, our process obtained about 70.8% precision and 18.3% recall on the information.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985649','10.1109/ICSE.2017.13',39,6,'IEEE','IEEE Conferences',0),(68,'Supporting Software Developers with a Holistic Recommender System',4,94,105,'The promise of recommender systems is to provide intelligent support to developers during their programming tasks. Such support ranges from suggesting program entities to taking into account pertinent Q&A pages. However, current recommender systems limit the context analysis to change history and developers\' activities in the IDE, without considering what a developer has already consulted or perused, e.g., by performing searches from the Web browser. Given the faceted nature of many programming tasks, and the incompleteness of the information provided by a single artifact, several heterogeneous resources are required to obtain the broader picture needed by a developer to accomplish a task. We present Libra, a holistic recommender system. It supports the process of searching and navigating the information needed by constructing a holistic meta-information model of the resources perused by a developer, analyzing their semantic relationships, and augmenting the web browser with a dedicated interactive navigation chart. The quantitative and qualitative evaluation of Libra provides evidence that a holistic analysis of a developer\'s information context can indeed offer comprehensive and contextualized support to information navigation and retrieval during software development.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985653','10.1109/ICSE.2017.17',56,8,'IEEE','IEEE Conferences',0),(69,'Distilling Neural Representations of Data Structure Manipulation using fMRI and fNIRS',3,396,407,'Data structures permeate many aspects of software engineering, but their associated human cognitive processes are not thoroughly understood. We leverage medical imaging and insights from the psychological notion of spatial ability to decode the neural representations of several fundamental data structures and their manipulations. In a human study involving 76 participants, we examine list, array, tree, and mental rotation tasks using both functional near-infrared spectroscopy (fNIRS) and functional magnetic resonance imaging (fMRI). We find a nuanced relationship: data structure and spatial operations use the same focal regions of the brain but to different degrees. They are related but distinct neural tasks. In addition, more difficult computer science problems induce higher cognitive load than do problems of pure spatial reasoning. Finally, while fNIRS is less expensive and more permissive, there are some computing-relevant brain regions that only fMRI can reach.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812086','10.1109/ICSE.2019.00053',92,0,'IEEE','IEEE Conferences',0),(70,'Glacier: Transitive Class Immutability for Java',4,496,506,'Though immutability has been long-proposed as a way to prevent bugs in software, little is known about how to make immutability support in programming languages effective for software engineers. We designed a new formalism that extends Java to support transitive class immutability, the form of immutability for which there is the strongest empirical support, and implemented that formalism in a tool called Glacier. We applied Glacier successfully to two real-world systems. We also compared Glacier to Java\'s final in a user study of twenty participants. We found that even after being given instructions on how to express immutability with final, participants who used final were unable to express immutability correctly, whereas almost all participants who used Glacier succeeded. We also asked participants to make specific changes to immutable classes and found that participants who used final all incorrectly mutated immutable state, whereas almost all of the participants who used Glacier succeeded. Glacier represents a promising approach to enforcing immutability in Java and provides a model for enforcement in other languages.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985688','10.1109/ICSE.2017.52',27,7,'IEEE','IEEE Conferences',0),(71,'Adaptive Coverage and Operational Profile-Based Testing for Reliability Improvement',4,541,551,'We introduce covrel, an adaptive software testing approach based on the combined use of operational profile and coverage spectrum, with the ultimate goal of improving the delivered reliability of the program under test. Operational profile-based testing is a black-box technique that selects test cases having the largest impact on failure probability in operation, as such, it is considered well suited when reliability is a major concern. Program spectrum is a characterization of a program\'s behavior in terms of the code entities (e.g., branches, statements, functions) that are covered as the program executes. The driving idea of covrel is to complement operational profile information with white-box coverage measures based on count spectra, so as to dynamically select the most effective test cases for reliability improvement. In particular, we bias operational profile-based test selection towards those entities covered less frequently. We assess the approach by experiments with 18 versions from 4 subjects commonly used in software testing research, comparing results with traditional operational and coverage testing. Results show that exploiting operational and coverage data in a combined adaptive way actually pays in terms of reliability improvement, with covrel overcoming conventional operational testing in more than 80% of the cases.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985692','10.1109/ICSE.2017.56',36,1,'IEEE','IEEE Conferences',0),(72,'Distance-Based Sampling of Software Configuration Spaces',3,1084,1094,'Configurable software systems provide a multitude of configuration options to adjust and optimize their functional and non-functional properties. For instance, to find the fastest configuration for a given setting, a brute-force strategy measures the performance of all configurations, which is typically intractable. Addressing this challenge, state-of-the-art strategies rely on machine learning, analyzing only a few configurations (i.e., a sample set) to predict the performance of other configurations. However, to obtain accurate performance predictions, a representative sample set of configurations is required. Addressing this task, different sampling strategies have been proposed, which come with different advantages (e.g., covering the configuration space systematically) and disadvantages (e.g., the need to enumerate all configurations). In our experiments, we found that most sampling strategies do not achieve a good coverage of the configuration space with respect to covering relevant performance values. That is, they miss important configurations with distinct performance behavior. Based on this observation, we devise a new sampling strategy, called distance-based sampling, that is based on a distance metric and a probability distribution to spread the configurations of the sample set according to a given probability distribution across the configuration space. This way, we cover different kinds of interactions among configuration options in the sample set. To demonstrate the merits of distance-based sampling, we compare it to state-of-the-art sampling strategies, such as t-wise sampling, on 10 real-world configurable software systems. Our results show that distance-based sampling leads to more accurate performance models for medium to large sample sets.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812049','10.1109/ICSE.2019.00112',36,3,'IEEE','IEEE Conferences',0),(73,'DifFuzz: Differential Fuzzing for Side-Channel Analysis',3,176,187,'Side-channel attacks allow an adversary to uncover secret program data by observing the behavior of a program with respect to a resource, such as execution time, consumed memory or response size. Side-channel vulnerabilities are difficult to reason about as they involve analyzing the correlations between resource usage over multiple program paths. We present DifFuzz, a fuzzing-based approach for detecting side-channel vulnerabilities related to time and space. DifFuzz automatically detects these vulnerabilities by analyzing two versions of the program and using resource-guided heuristics to find inputs that maximize the difference in resource consumption between secret-dependent paths. The methodology of DifFuzz is general and can be applied to programs written in any language. For this paper, we present an implementation that targets analysis of Java programs, and uses and extends the Kelinci and AFL fuzzers. We evaluate DifFuzz on a large number of Java programs and demonstrate that it can reveal unknown side-channel vulnerabilities in popular applications. We also show that DifFuzz compares favorably against Blazer and Themis, two state-of-the-art analysis tools for finding side-channels in Java programs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812124','10.1109/ICSE.2019.00034',42,0,'IEEE','IEEE Conferences',0),(74,'Machine Learning-Based Detection of Open Source License Exceptions',4,118,129,'From a legal perspective, software licenses govern the redistribution, reuse, and modification of software as both source and binary code. Free and Open Source Software (FOSS) licenses vary in the degree to which they are permissive or restrictive in allowing redistribution or modification under licenses different from the original one(s). In certain cases, developers may modify the license by appending to it an exception to specifically allow reuse or modification under a particular condition. These exceptions are an important factor to consider for license compliance analysis since they modify the standard (and widely understood) terms of the original license. In this work, we first perform a large-scale empirical study on the change history of over 51K FOSS systems aimed at quantitatively investigating the prevalence of known license exceptions and identifying new ones. Subsequently, we performed a study on the detection of license exceptions by relying on machine learning. We evaluated the license exception classification with four different supervised learners and sensitivity analysis. Finally, we present a categorization of license exceptions and explain their implications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985655','10.1109/ICSE.2017.19',49,3,'IEEE','IEEE Conferences',0),(75,'Investigating the Impact of Multiple Dependency Structures on Software Defects',3,584,595,'Over the past decades, numerous approaches were proposed to help practitioner to predict or locate defective files. These techniques often use syntactic dependency, history co-change relation, or semantic similarity. The problem is that, it remains unclear whether these different dependency relations will present similar accuracy in terms of defect prediction and localization. In this paper, we present our systematic investigation of this question from the perspective of software architecture. Considering files involved in each dependency type as an individual design space, we model such a design space using one DRSpace. We derived 3 DRSpaces for each of the 117 Apache open source projects, with 643,079 revision commits and 101,364 bug reports in total, and calculated their interactions with defective files. The experiment results are surprising: the three dependency types present significantly different architectural views, and their interactions with defective files are also drastically different. Intuitively, they play completely different roles when used for defect prediction/localization. The good news is that the combination of these structures has the potential to improve the accuracy of defect prediction/localization. In summary, our work provides a new perspective regarding to which type(s) of relations should be used for the task of defect prediction/localization. These quantitative and qualitative results also advance our knowledge of the relationship between software quality and architectural views formed using different dependency types.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812092','10.1109/ICSE.2019.00069',35,0,'IEEE','IEEE Conferences',0),(76,'PEoPL: Projectional Editing of Product Lines',4,563,574,'The features of a software product line - a portfolio of system variants - can be realized using various implementation techniques (a. k. a., variability mechanisms). Each technique represents the software artifacts of features differently, typically classified into annotative (e.g., C preprocessor) and modular representations (e.g., feature modules), each with distinct advantages and disadvantages. Annotative representations are easy to realize, but annotations clutter source code and hinder program comprehension. Modular representations support comprehension, but are difficult to realize. Most importantly, to engineer feature artifacts, developers need to choose one representation and adhere to it for evolving and maintaining the same artifacts. We present PEoPL, an approach to combine the advantages of annotative and modular representations. When engineering a feature artifact, developers can choose the most-suited representation and even use different representations in parallel. PEoPL relies on separating a product line into an internal and external representation, the latter by providing editable projections used by the developers. We contribute a programming-language-independent internal representation of variability, five editable projections reflecting different variability representations, a supporting IDE, and a tailoring of PEoPL to Java. We evaluate PEoPL\'s expressiveness, scalability, and flexibility in eight Java-based product lines, finding that all can be realized, that projections are feasible, and that variant computation is fast (<;45ms on average for our largest subject Berkeley DB).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985694','10.1109/ICSE.2017.58',65,2,'IEEE','IEEE Conferences',0),(77,'Interactive Production Performance Feedback in the IDE',3,971,981,'Because of differences between development and production environments, many software performance problems are detected only after software enters production. We present PerformanceHat, a new system that uses profiling information from production executions to develop a global performance model suitable for integration into interactive development environments. PerformanceHat\'s ability to incrementally update this global model as the software is changed in the development environment enables it to deliver near real-time predictions of performance consequences reflecting the impact on the production environment. We implement PerformanceHat as an Eclipse plugin and evaluate it in a controlled experiment with 20 professional software developers implementing several software maintenance tasks using our approach and a representative baseline (Kibana). Our results indicate that developers using PerformanceHat were significantly faster in (1) detecting the performance problem, and (2) finding the root-cause of the problem. These results provide encouraging evidence that our approach helps developers detect, prevent, and debug production performance problems during development before the problem manifests in production.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811928','10.1109/ICSE.2019.00102',33,0,'IEEE','IEEE Conferences',0),(78,'A Neural Model for Generating Natural Language Summaries of Program Subroutines',3,795,806,'Source code summarization -- creating natural language descriptions of source code behavior -- is a rapidly-growing research topic with applications to automatic documentation generation, program comprehension, and software maintenance. Traditional techniques relied on heuristics and templates built manually by human experts. Recently, data-driven approaches based on neural machine translation have largely overtaken template-based systems. But nearly all of these techniques rely almost entirely on programs having good internal documentation; without clear identifier names, the models fail to create good summaries. In this paper, we present a neural model that combines words from code with code structure from an AST. Unlike previous approaches, our model processes each data source as a separate input, which allows the model to learn code structure independent of the text in code. This process helps our approach provide coherent summaries in many cases even when zero internal documentation is provided. We evaluate our technique with a dataset we created from 2.1m Java methods. We find improvement over two baseline techniques from SE literature and one from NLP literature.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811932','10.1109/ICSE.2019.00087',60,1,'IEEE','IEEE Conferences',0),(79,'Becoming Agile: A Grounded Theory of Agile Transitions in Practice',4,141,151,'Agile adoption is typically understood as a one-off organizational process involving a staged selection of agile development practices. This view of agility fails to explain the differences in the pace and effectiveness of individual teams transitioning to agile development. Based on a Grounded Theory study of 31 agile practitioners drawn from 18 teams across five countries, we present a grounded theory of becoming agile as a network of on-going transitions across five dimensions: software development practices, team practices, management approach, reflective practices, and culture. The unique position of a software team through this network, and their pace of progress along the five dimensions, explains why individual agile teams present distinct manifestations of agility and unique transition experiences. The theory expands the current understanding of agility as a holistic and complex network of on-going multidimensional transitions, and will help software teams, their managers, and organizations better navigate their individual agile journeys.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985657','10.1109/ICSE.2017.21',44,6,'IEEE','IEEE Conferences',0),(80,'Understanding the Impressions, Motivations, and Barriers of One Time Code Contributors to FLOSS Projects: A Survey',4,187,197,'Successful Free/Libre Open Source Software (FLOSS) projects must attract and retain high-quality talent. Researchers have invested considerable effort in the study of core and peripheral FLOSS developers. To this point, one critical subset of developers that have not been studied are One-Time code Contributors (OTC) - those that have had exactly one patch accepted. To understand why OTCs have not contributed another patch and provide guidance to FLOSS projects on retaining OTCs, this study seeks to understand the impressions, motivations, and barriers experienced by OTCs. We conducted an online survey of OTCs from 23 popular FLOSS projects. Based on the 184 responses received, we observed that OTCs generally have positive impressions of their FLOSS project and are driven by a variety of motivations. Most OTCs primarily made contributions to fix bugs that impeded their work and did not plan on becoming long term contributors. Furthermore, OTCs encounter a number of barriers that prevent them from continuing to contribute to the project. Based on our findings, there are some concrete actions FLOSS projects can take to increase the chances of converting OTCs into long-term contributors.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985661','10.1109/ICSE.2017.25',31,7,'IEEE','IEEE Conferences',0),(81,'Statistical Algorithmic Profiling for Randomized Approximate Programs',3,608,618,'Many modern applications require low-latency processing of large data sets, often by using approximate algorithms that trade accuracy of the results for faster execution or reduced memory consumption. Although the algorithms provide probabilistic accuracy and performance guarantees, a software developer who implements these algorithms has little support from existing tools. Standard profilers do not consider accuracy of the computation and do not check whether the outputs of these programs satisfy their accuracy specifications. We present AXPROF, an algorithmic profiling framework for analyzing randomized approximate programs. The developer provides the accuracy specification as a formula in a mathematical notation, using probability or expected value predicates. AXPROF automatically generates statistical reasoning code. It first constructs the empirical models of accuracy, time, and memory consumption. It then selects and runs appropriate statistical tests that can, with high confidence, determine if the implementation satisfies the specification. We used AXPROF to profile 15 approximate applications from three domains - data analytics, numerical linear algebra, and approximate computing. AXPROF was effective in finding bugs and identifying various performance optimizations. In particular, we discovered five previously unknown bugs in the implementations of the algorithms and created fixes, guided by AXPROF.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811971','10.1109/ICSE.2019.00071',67,0,'IEEE','IEEE Conferences',0),(82,'A General Framework for Dynamic Stub Injection',4,586,596,'Stub testing is a standard technique to simulate the behavior of dependencies of an application under test such as the file system. Even though existing frameworks automate the actual stub injection, testers typically have to implement manually where and when to inject stubs, in addition to the stub behavior. This paper presents a novel framework that reduces this effort. The framework provides a domain specific language to describe stub injection strategies and stub behaviors via declarative rules, as well as a tool that automatically injects stubs dynamically into binary code according to these rules. Both the domain specific language and the injection are language independent, which enables the reuse of stubs and injection strategies across applications. We implemented this framework for both unmanaged (assembly) and managed (.NET) code and used it to perform fault injection for twelve large applications, which revealed numerous crashes and bugs in error handling code. We also show how to prioritize the analysis of test failures based on a comparison of the effectiveness of stub injection rules across applications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985696','10.1109/ICSE.2017.60',26,1,'IEEE','IEEE Conferences',0),(83,'Multifaceted Automated Analyses for Variability-Intensive Embedded Systems',3,854,865,'Embedded systems, like those found in the automotive domain, must comply with stringent functional and non-functional requirements. To fulfil these requirements, engineers are confronted with a plethora of design alternatives both at the software and hardware level, out of which they must select the optimal solution wrt. possibly-antagonistic quality attributes (e.g. cost of manufacturing vs. speed of execution). We propose a model-driven framework to assist engineers in this choice. It captures high-level specifications of the system in the form of variable dataflows and configurable hardware platforms. A mapping algorithm then derives the design space, i.e. the set of compatible pairs of application and platform variants, and a variability-aware executable model, which encodes the functional and non-functional behaviour of all viable system variants. Novel verification algorithms then pinpoint the optimal system variants efficiently. The benefits of our approach are evaluated through a real-world case study from the automotive industry.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812057','10.1109/ICSE.2019.00092',81,1,'IEEE','IEEE Conferences',0),(84,'Type Migration in Ultra-Large-Scale Codebases',3,1142,1153,'Type migration is a refactoring activity in which an existing type is replaced with another one throughout the source code. Manually performing type migration is tedious as programmers need to find all instances of the type to be migrated, along with its dependencies that propagate over assignment operations, method hierarchies, and subtypes. Existing automated approaches for type migration are not adequate for ultra-large-codebases - they perform an intensive whole-program analysis that does not scale. If we could represent the type structure of the program as graphs, then we could employ a MAPREDUCE parallel and distributed process that scales to hundreds of millions of LOC. We implemented this approach as an IDE-independent tool called T2R, which integrates with most build systems. We evaluated T2R\'s accuracy, usefulness and scalability on seven open source projects and one proprietary codebase of 300M LOC. T2R generated 130 type migration patches, of which the original developers accepted 98%.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812061','10.1109/ICSE.2019.00117',47,1,'IEEE','IEEE Conferences',0),(85,'PIVOT: Learning API-Device Correlations to Facilitate Android Compatibility Issue Detection',3,878,888,'The heavily fragmented Android ecosystem has induced various compatibility issues in Android apps. The search space for such fragmentation-induced compatibility issues (FIC issues) is huge, comprising three dimensions: device models, Android OS versions, and Android APIs. FIC issues, especially those arising from device models, evolve quickly with the frequent release of new device models to the market. As a result, an automated technique is desired to maintain timely knowledge of such FIC issues, which are mostly undocumented. In this paper, we propose such a technique, PIVOT, that automatically learns API-device correlations of FIC issues from existing Android apps. PIVOT extracts and prioritizes API-device correlations from a given corpus of Android apps. We evaluated PIVOT with popular Android apps on Google Play. Evaluation results show that PIVOT can effectively prioritize valid API-device correlations for app corpora collected at different time. Leveraging the knowledge in the learned API-device correlations, we further conducted a case study and successfully uncovered ten previously-undetected FIC issues in open-source Android apps.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811898','10.1109/ICSE.2019.00094',63,0,'IEEE','IEEE Conferences',0),(86,'Could I Have a Stack Trace to Examine the Dependency Conflict Issue?',3,572,583,'Intensive use of libraries in Java projects brings potential risk of dependency conflicts, which occur when a project directly or indirectly depends on multiple versions of the same library or class. When this happens, JVM loads one version and shadows the others. Runtime exceptions can occur when methods in the shadowed versions are referenced. Although project management tools such as Maven are able to give warnings of potential dependency conflicts when a project is built, developers often ask for crashing stack traces before examining these warnings. It motivates us to develop Riddle, an automated approach that generates tests and collects crashing stack traces for projects subject to risk of dependency conflicts. Riddle, built on top of Asm and Evosuite, combines condition mutation, search strategies and condition restoration. We applied Riddle on 19 real-world Java projects with duplicate libraries or classes. We reported 20 identified dependency conflicts including their induced crashing stack traces and the details of generated tests. Among them, 15 conflicts were confirmed by developers as real issues, and 10 were readily fixed. The evaluation results demonstrate the effectiveness and usefulness of Riddle.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812128','10.1109/ICSE.2019.00068',105,0,'IEEE','IEEE Conferences',0),(87,'Practical GUI Testing of Android Applications Via Model Abstraction and Refinement',3,269,280,'This paper introduces a new, fully automated modelbased approach for effective testing of Android apps. Different from existing model-based approaches that guide testing with a static GUI model (i.e., the model does not evolve its abstraction during testing, and is thus often imprecise), our approach dynamically optimizes the model by leveraging the runtime information during testing. This capability of model evolution significantly improves model precision, and thus dramatically enhances the testing effectiveness compared to existing approaches, which our evaluation confirms.We have realized our technique in a practical tool, APE. On 15 large, widely-used apps from the Google Play Store, APE outperforms the state-of-the-art Android GUI testing tools in terms of both testing coverage and the number of detected unique crashes. To further demonstrate APE\'s effectiveness and usability, we conduct another evaluation of APE on 1,316 popular apps, where it found 537 unique crashes. Out of the 38 reported crashes, 13 have been fixed and 5 have been confirmed.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812132','10.1109/ICSE.2019.00042',54,1,'IEEE','IEEE Conferences',0),(88,'Classifying Developers into Core and Peripheral: An Empirical Study on Count and Network Metrics',4,164,174,'Knowledge about the roles developers play in a software project is crucial to understanding the project\'s collaborative dynamics. In practice, developers are often classified according to the dichotomy of core and peripheral roles. Typically, count-based operationalizations, which rely on simple counts of individual developer activities (e.g., number of commits), are used for this purpose, but there is concern regarding their validity and ability to elicit meaningful insights. To shed light on this issue, we investigate whether count-based operationalizations of developer roles produce consistent results, and we validate them with respect to developers\' perceptions by surveying 166 developers. Improving over the state of the art, we propose a relational perspective on developer roles, using fine-grained developer networks modeling the organizational structure, and by examining developer roles in terms of developers\' positions and stability within the developer network. In a study of 10 substantial open-source projects, we found that the primary difference between the count-based and our proposed network-based core-peripheral operationalizations is that the network-based ones agree more with developer perception than count-based ones. Furthermore, we demonstrate that a relational perspective can reveal further meaningful insights, such as that core developers exhibit high positional stability, upper positions in the hierarchy, and high levels of coordination with other core developers, which confirms assumptions of previous work.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985659','10.1109/ICSE.2017.23',34,9,'IEEE','IEEE Conferences',0),(89,'A Guided Genetic Algorithm for Automated Crash Reproduction',4,209,220,'To reduce the effort developers have to make for crash debugging, researchers have proposed several solutions for automatic failure reproduction. Recent advances proposed the use of symbolic execution, mutation analysis, and directed model checking as underling techniques for post-failure analysis of crash stack traces. However, existing approaches still cannot reproduce many real-world crashes due to such limitations as environment dependencies, path explosion, and time complexity. To address these challenges, we present EvoCrash, a post-failure approach which uses a novel Guided Genetic Algorithm (GGA) to cope with the large search space characterizing real-world software programs. Our empirical study on three open-source systems shows that EvoCrash can replicate 41 (82%) of real-world crashes, 34 (89%) of which are useful reproductions for debugging purposes, outperforming the state-of-the-art in crash replication.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985663','10.1109/ICSE.2017.27',40,6,'IEEE','IEEE Conferences',0),(90,'Evaluating and Improving Fault Localization',4,609,620,'Most fault localization techniques take as input a faulty program, and produce as output a ranked list of suspicious code locations at which the program may be defective. When researchers propose a new fault localization technique, they typically evaluate it on programs with known faults. The technique is scored based on where in its output list the defective code appears. This enables the comparison of multiple fault localization techniques to determine which one is better. Previous research has evaluated fault localization techniques using artificial faults, generated either by mutation tools or manually. In other words, previous research has determined which fault localization techniques are best at finding artificial faults. However, it is not known which fault localization techniques are best at finding real faults. It is not obvious that the answer is the same, given previous work showing that artificial faults have both similarities to and differences from real faults. We performed a replication study to evaluate 10 claims in the literature that compared fault localization techniques (from the spectrum-based and mutation-based families). We used 2995 artificial faults in 6 real-world programs. Our results support 7 of the previous claims as statistically significant, but only 3 as having non-negligible effect sizes. Then, we evaluated the same 10 claims, using 310 real faults from the 6 programs. Every previous result was refuted or was statistically and practically insignificant. Our experiments show that artificial faults are not useful for predicting which fault localization techniques perform best on real faults. In light of these results, we identified a design space that includes many previously-studied fault localization techniques as well as hundreds of new techniques. We experimentally determined which factors in the design space are most important, using an overall set of 395 real faults. Then, we extended this design space with new techniques. Several of our novel techniques outperform all existing techniques, notably in terms of ranking defective code in the top-5 or top-10 reports.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985698','10.1109/ICSE.2017.62',50,35,'IEEE','IEEE Conferences',0),(91,'Analysis and Detection of Information Types of Open Source Software Issue Discussions',3,454,464,'Most modern Issue Tracking Systems (ITSs) for open source software (OSS) projects allow users to add comments to issues. Over time, these comments accumulate into discussion threads embedded with rich information about the software project, which can potentially satisfy the diverse needs of OSS stakeholders. However, discovering and retrieving relevant information from the discussion threads is a challenging task, especially when the discussions are lengthy and the number of issues in ITSs are vast. In this paper, we address this challenge by identifying the information types presented in OSS issue discussions. Through qualitative content analysis of 15 complex issue threads across three projects hosted on GitHub, we uncovered 16 information types and created a labeled corpus containing 4656 sentences. Our investigation of supervised, automated classification techniques indicated that, when prior knowledge about the issue is available, Random Forest can effectively detect most sentence types using conversational features such as the sentence length and its position. When classifying sentences from new issues, Logistic Regression can yield satisfactory performance using textual features for certain information types, while falling short on others. Our work represents a nontrivial first step towards tools and techniques for identifying and obtaining the rich information recorded in the ITSs to support various software engineering activities and to satisfy the diverse needs of OSS stakeholders.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811936','10.1109/ICSE.2019.00058',29,0,'IEEE','IEEE Conferences',0),(92,'Natural Software Revisited',3,37,48,'Recent works have concluded that software code is more repetitive and predictable, i.e. more natural, than English texts. On re-examination, we find that much of the apparent \'naturalness\' of source code is due to the presence of language specific syntax, especially separators, such as semi-colons and brackets. For example, separators account for 44% of all tokens in our Java corpus. When we follow the NLP practices of eliminating punctuation (e.g., separators) and stopwords (e.g., keywords), we find that code is still repetitive and predictable, but to a lesser degree than previously thought. We suggest that SyntaxTokens be filtered to reduce noise in code recommenders. Unlike the code written for a particular project, API code usage is similar across projects: a file is opened and closed in the same manner regardless of domain. When we restrict our n-grams to those contained in the Java API, we find that API usages are highly repetitive. Since API calls are common across programs, researchers have made reliable statistical models to recommend sophisticated API call sequences. Sequential n-gram models were developed for natural languages. Code is usually represented by an AST which contains control and data flow, making n-grams models a poor representation of code. Comparing n-grams to statistical graph representations of the same codebase, we find that graphs are more repetitive and contain higherlevel patterns than n-grams. We suggest that future work focus on statistical code graphs models that accurately capture complex coding patterns. Our replication package makes our scripts and data available to future researchers[1].','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811940','10.1109/ICSE.2019.00022',58,2,'IEEE','IEEE Conferences',0),(93,'Automatic Text Input Generation for Mobile Testing',4,643,653,'Many designs have been proposed to improve the automated mobile testing. Despite these improvements, providing appropriate text inputs remains a prominent obstacle, which hinders the large-scale adoption of automated testing approaches. The key challenge is how to automatically produce the most relevant text in a use case context. For example, a valid website address should be entered in the address bar of a mobile browser app to continue the testing of the app, a singer\'s name should be entered in the search bar of a music recommendation app. Without the proper text inputs, the testing would get stuck. We propose a novel deep learning based approach to address the challenge, which reduces the problem to a minimization problem. Another challenge is how to make the approach generally applicable to both the trained apps and the untrained apps. We leverage the Word2Vec model to address the challenge. We have built our approaches as a tool and evaluated it with 50 iOS mobile apps including Firefox and Wikipedia. The results show that our approach significantly outperforms existing automatic text input generation methods.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985701','10.1109/ICSE.2017.65',37,7,'IEEE','IEEE Conferences',0),(94,'Learning to Spot and Refactor Inconsistent Method Names',3,1,12,'To ensure code readability and facilitate software maintenance, program methods must be named properly. In particular, method names must be consistent with the corresponding method implementations. Debugging method names remains an important topic in the literature, where various approaches analyze commonalities among method names in a large dataset to detect inconsistent method names and suggest better ones. We note that the state-of-the-art does not analyze the implemented code itself to assess consistency. We thus propose a novel automated approach to debugging method names based on the analysis of consistency between method names and method code. The approach leverages deep feature representation techniques adapted to the nature of each artifact. Experimental results on over 2.1 million Java methods show that we can achieve up to 15 percentage points improvement over the state-of-the-art, establishing a record performance of 67.9% F1- measure in identifying inconsistent method names. We further demonstrate that our approach yields up to 25% accuracy in suggesting full names, while the state-of-the-art lags far behind at 1.1% accuracy. Finally, we report on our success in fixing 66 inconsistent method names in a live study on projects in the wild.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812134','10.1109/ICSE.2019.00019',86,4,'IEEE','IEEE Conferences',0),(95,'ZenIDS: Introspective Intrusion Detection for PHP Applications',4,232,243,'Since its first appearance more than 20 years ago, PHP has steadily increased in popularity, and has become the foundation of the Internet\'s most popular content management systems (CMS). Of the world\'s 1 million most visited websites, nearly half use a CMS, and WordPress alone claims 25% market share of all websites. While their easy-to-use templates and components have greatly simplified the work of developing high quality websites, it comes at the cost of software vulnerabilities that are inevitable in such large and rapidly evolving frameworks. Intrusion Detection Systems (IDS) are often used to protect Internet-facing applications, but conventional techniques struggle to keep up with the fast pace of development in today\'s web applications. Rapid changes to application interfaces increase the workload of maintaining an IDS whitelist, yet the broad attack surface of a web application makes for a similarly verbose blacklist. We developed ZenIDS to dynamically learn the trusted execution paths of an application during a short online training period and report execution anomalies as potential intrusions. We implement ZenIDS as a PHP extension supported by 8 hooks instrumented in the PHP interpreter. Our experiments demonstrate its effectiveness monitoring live web traffic for one year to 3 large PHP applications, detecting malicious requests with a false positive rate of less than .01% after training on fewer than 4,000 requests. ZenIDS excludes the vast majority of deployed PHP code from the whitelist because it is never used for valid requests-yet could potentially be exploited by a remote adversary. We observe 5% performance overhead (or less) for our applications vs. an optimized vanilla LAMP stack.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985665','10.1109/ICSE.2017.29',54,0,'IEEE','IEEE Conferences',0),(96,'VFix: Value-Flow-Guided Precise Program Repair for Null Pointer Dereferences',3,512,523,'Automated Program Repair (APR) faces a key challenge in efficiently generating correct patches from a potentially infinite solution space. Existing approaches, which attempt to reason about the entire solution space, can be ineffective (by often producing no plausible patches at all) and imprecise (by often producing plausible but incorrect patches). We present VFIX, a new value-flow-guided APR approach, to fix null pointer exception (NPE) bugs by considering a substantially reduced solution space in order to greatly increase the number of correct patches generated. By reasoning about the data and control dependences in the program, VFIX can identify bug-relevant repair statements more accurately and generate more correct repairs than before. VFIX outperforms a set of 8 state-of-the-art APR tools in fixing the NPE bugs in Defects4j in terms of both precision (by correctly fixing 3 times as many bugs as the most precise one and 50% more than all the bugs correctly fixed by these 8 tools altogether) and efficiency (by producing a correct patch in minutes instead of hours).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812101','10.1109/ICSE.2019.00063',92,1,'IEEE','IEEE Conferences',0),(97,'View-Centric Performance Optimization for Database-Backed Web Applications',3,994,1004,'Web developers face the stringent task of designing informative web pages while keeping the page-load time low. This task has become increasingly challenging as most web contents are now generated by processing ever-growing amount of user data stored in back-end databases. It is difficult for developers to understand the cost of generating every web-page element, not to mention explore and pick the web design with the best trade-off between performance and functionality. In this paper, we present Panorama, a view-centric and database-aware development environment for web developers. Using database-aware program analysis and novel IDE design, Panorama provides developers with intuitive information about the cost and the performance-enhancing opportunities behind every HTML element, as well as suggesting various global code refactorings that enable developers to easily explore a wide spectrum of performance and functionality trade-offs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811938','10.1109/ICSE.2019.00104',43,2,'IEEE','IEEE Conferences',0),(98,'ReCDroid: Automatically Reproducing Android Application Crashes from Bug Reports',3,128,139,'The large demand of mobile devices creates significant concerns about the quality of mobile applications (apps). Developers heavily rely on bug reports in issue tracking systems to reproduce failures (e.g., crashes). However, the process of crash reproduction is often manually done by developers, making the resolution of bugs inefficient, especially that bug reports are often written in natural language. To improve the productivity of developers in resolving bug reports, in this paper, we introduce a novel approach, called ReCDroid, that can automatically reproduce crashes from bug reports for Android apps. ReCDroid uses a combination of natural language processing (NLP) and dynamic GUI exploration to synthesize event sequences with the goal of reproducing the reported crash. We have evaluated ReCDroid on 51 original bug reports from 33 Android apps. The results show that ReCDroid successfully reproduced 33 crashes (63.5% success rate) directly from the textual description of bug reports. A user study involving 12 participants demonstrates that ReCDroid can improve the productivity of developers when resolving crash bug reports.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811942','10.1109/ICSE.2019.00030',57,0,'IEEE','IEEE Conferences',0),(99,'Automated Transplantation and Differential Testing for Clones',4,665,676,'Code clones are common in software. When applying similar edits to clones, developers often find it difficult to examine the runtime behavior of clones. The problem is exacerbated when some clones are tested, while their counterparts are not. To reuse tests for similar but not identical clones, Grafter transplants one clone to its counterpart by (1) identifying variations in identifier names, types, and method call targets, (2) resolving compilation errors caused by such variations through code transformation, and (3) inserting stub code to transfer input data and intermediate output values for examination. To help developers examine behavioral differences between clones, Grafter supports fine-grained differential testing at both the test outcome level and the intermediate program state level. In our evaluation on three open source projects, Grafter successfully reuses tests in 94% of clone pairs without inducing build errors, demonstrating its automated code transplantation capability. To examine the robustness of G RAFTER, we systematically inject faults using a mutation testing tool, Major, and detect behavioral differences induced by seeded faults. Compared with a static cloning bug finder, Grafter detects 31% more mutants using the test-level comparison and almost 2X more using the state-level comparison. This result indicates that Grafter should effectively complement static cloning bug finders.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985703','10.1109/ICSE.2017.67',52,5,'IEEE','IEEE Conferences',0),(100,'Parallel Refinement for Multi-Threaded Program Verification',3,643,653,'Program verification is one of the most important methods to ensuring the correctness of concurrent programs. However, due to the path explosion problem, concurrent program verification is usually time consuming, which hinders its scalability to industrial programs. Parallel processing is a mainstream technique to deal with those problems which require mass computing. Hence, designing parallel algorithms to improve the performance of concurrent program verification is highly desired. This paper focuses on parallelization of the abstraction refinement technique, one of the most efficient techniques for concurrent program verification. We present a parallel refinement framework which employs multiple engines to refine the abstraction in parallel. Different from existing work which parallelizes the search process, our method achieves the effect of parallelization by refinement constraint and learnt clause sharing, so that the number of required iterations can be significantly reduced. We have implemented this framework on the scheduling constraint based abstraction refinement method, one of the best methods for concurrent program verification. Experiments on SV-COMP 2018 show the encouraging results of our method. For those complex programs requiring a large number of iterations, our method can obtain a linear reduction of the iteration number and significantly improve the verification performance.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812136','10.1109/ICSE.2019.00074',39,0,'IEEE','IEEE Conferences',0),(101,'On Cross-Stack Configuration Errors',4,255,265,'Today\'s web applications are deployed on powerful software stacks such as MEAN (JavaScript) or LAMP (PHP), which consist of multiple layers such as an operating system, web server, database, execution engine and application framework, each of which provide resources to the layer just above it. These powerful software stacks unfortunately are plagued by so-called cross-stack configuration errors (CsCEs), where a higher layer in the stack suddenly starts to behave incorrectly or even crash due to incorrect configuration choices in lower layers. Due to differences in programming languages and lack of explicit links between configuration options of different layers, sysadmins and developers have a hard time identifying the cause of a CsCE, which is why this paper (1) performs a qualitative analysis of 1,082 configuration errors to understand the impact, effort and complexity of dealing with CsCEs, then (2) proposes a modular approach that plugs existing source code analysis (slicing) techniques, in order to recommend the culprit configuration option. Empirical evaluation of this approach on 36 real CsCEs of the top 3 LAMP stack layers shows that our approach reports the misconfigured option with an average rank of 2.18 for 32 of the CsCEs, and takes only few minutes, making it practically useful.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985667','10.1109/ICSE.2017.31',53,4,'IEEE','IEEE Conferences',0),(102,'Supporting the Statistical Analysis of Variability Models',3,843,853,'Variability models are broadly used to specify the configurable features of highly customizable software. In practice, they can be large, defining thousands of features with their dependencies and conflicts. In such cases, visualization techniques and automated analysis support are crucial for understanding the models. This paper contributes to this line of research by presenting a novel, probabilistic foundation for statistical reasoning about variability models. Our approach not only provides a new way to visualize, describe and interpret variability models, but it also supports the improvement of additional state-of-the-art methods for software product lines; for instance, providing exact computations where only approximations were available before, and increasing the sensitivity of existing analysis operations for variability models. We demonstrate the benefits of our approach using real case studies with up to 17,365 features, and written in two different languages (KConfig and feature models).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811977','10.1109/ICSE.2019.00091',41,0,'IEEE','IEEE Conferences',0),(103,'Making Malory Behave Maliciously: Targeted Fuzzing of Android Execution Environments',4,300,311,'Android applications, or apps, provide useful features to end-users, but many apps also contain malicious behavior. Modern malware makes understanding such behavior challenging by behaving maliciously only under particular conditions. For example, a malware app may check whether it runs on a real device and not an emulator, in a particular country, and alongside a specific target app, such as a vulnerable banking app. To observe the malicious behavior, a security analyst must find out and emulate all these app-specific constraints. This paper presents FuzzDroid, a framework for automatically generating an Android execution environment where an app exposes its malicious behavior. The key idea is to combine an extensible set of static and dynamic analyses through a search-based algorithm that steers the app toward a configurable target location. On recent malware, the approach reaches the target location in 75% of the apps. In total, we reach 240 code locations within an average time of only one minute. To reach these code locations, FuzzDroid generates 106 different environments, too many for a human analyst to create manually.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985671','10.1109/ICSE.2017.35',44,9,'IEEE','IEEE Conferences',0),(104,'Gigahorse: Thorough, Declarative Decompilation of Smart Contracts',3,1176,1186,'The rise of smart contracts - autonomous applications running on blockchains - has led to a growing number of threats, necessitating sophisticated program analysis. However, smart contracts, which transact valuable tokens and cryptocurrencies, are compiled to very low-level bytecode. This bytecode is the ultimate semantics and means of enforcement of the contract. We present the Gigahorse toolchain. At its core is a reverse compiler (i.e., a decompiler) that decompiles smart contracts from Ethereum Virtual Machine (EVM) bytecode into a highlevel 3-address code representation. The new intermediate representation of smart contracts makes implicit data- and control-flow dependencies of the EVM bytecode explicit. Decompilation obviates the need for a contract\'s source and allows the analysis of both new and deployed contracts. Gigahorse advances the state of the art on several fronts. It gives the highest analysis precision and completeness among decompilers for Ethereum smart contracts - e.g., Gigahorse can decompile over 99.98% of deployed contracts, compared to 88% for the recently-published Vandal decompiler and under 50% for the state-of-the-practice Porosity decompiler. Importantly, Gigahorse offers a full-featured toolchain for further analyses (and a 鈥渂atteries included鈥� approach, with multiple clients already implemented), together with the highest performance and scalability. Key to these improvements is Gigahorse\'s use of a declarative, logic-based specification, which allows high-level insights to inform low-level decompilation.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811905','10.1109/ICSE.2019.00120',36,0,'IEEE','IEEE Conferences',0),(105,'Analyzing and Supporting Adaptation of Online Code Examples',3,316,327,'Developers often resort to online Q&A forums such as Stack Overflow (SO) for filling their programming needs. Although code examples on those forums are good starting points, they are often incomplete and inadequate for developers\' local program contexts; adaptation of those examples is necessary to integrate them to production code. As a consequence, the process of adapting online code examples is done over and over again, by multiple developers independently. Our work extensively studies these adaptations and variations, serving as the basis for a tool that helps integrate these online code examples in a target context in an interactive manner. We perform a large-scale empirical study about the nature and extent of adaptations and variations of SO snippets. We construct a comprehensive dataset linking SO posts to GitHub counterparts based on clone detection, time stamp analysis, and explicit URL references. We then qualitatively inspect 400 SO examples and their GitHub counterparts and develop a taxonomy of 24 adaptation types. Using this taxonomy, we build an automated adaptation analysis technique on top of GumTree to classify the entire dataset into these types. We build a Chrome extension called ExampleStack that automatically lifts an adaptation-aware template from each SO example and its GitHub counterparts to identify hot spots where most changes happen. A user study with sixteen programmers shows that seeing the commonalities and variations in similar GitHub counterparts increases their confidence about the given SO example, and helps them grasp a more comprehensive view about how to reuse the example differently and avoid common pitfalls.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812028','10.1109/ICSE.2019.00046',68,0,'IEEE','IEEE Conferences',0),(106,'Graph-Based Mining of In-the-Wild, Fine-Grained, Semantic Code Change Patterns',3,819,830,'Prior research exploited the repetitiveness of code changes to enable several tasks such as code completion, bug-fix recommendation, library adaption, etc. These and other novel applications require accurate detection of semantic changes, but the state-of-the-art methods are limited to algorithms that detect specific kinds of changes at the syntactic level. Existing algorithms relying on syntactic similarity have lower accuracy, and cannot effectively detect semantic change patterns. We introduce a novel graph-based mining approach, CPatMiner, to detect previously unknown repetitive changes in the wild, by mining fine-grained semantic code change patterns from a large number of repositories. To overcome unique challenges such as detecting meaningful change patterns and scaling to large repositories, we rely on fine-grained change graphs to capture program dependencies. We evaluate CPatMiner by mining change patterns in a diverse corpus of 5,000+ open-source projects from GitHub across a population of 170,000+ developers. We use three complementary methods. First, we sent the mined patterns to 108 open-source developers. We found that 70% of respondents recognized those patterns as their meaningful frequent changes. Moreover, 79% of respondents even named the patterns, and 44% wanted future IDEs to automate such repetitive changes. We found that the mined change patterns belong to various development activities: adaptive (9%), perfective (20%), corrective (35%) and preventive (36%, including refactorings). Second, we compared our tool with the state-of-the-art, AST-based technique, and reported that it detects 2.1x more meaningful patterns. Third, we use CPatMiner to search for patterns in a corpus of 88 GitHub projects with longer histories consisting of 164M SLOCs. It constructed 322K fine-grained change graphs containing 3M nodes, and detected 17K instances of change patterns from which we provide unique insights on the practice of change patterns among individuals and teams. We found that a large percentage (75%) of the change patterns from individual developers are commonly shared with others, and this holds true for teams. Moreover, we found that the patterns are not intermittent but spread widely over time. Thus, we call for a community-based change pattern database to provide important resources in novel applications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812071','10.1109/ICSE.2019.00089',48,1,'IEEE','IEEE Conferences',0),(107,'Optimizing Test Placement for Module-Level Regression Testing',4,689,699,'Modern build systems help increase developer productivity by performing incremental building and testing. These build systems view a software project as a group of interdependent modules and perform regression test selection at the module level. However, many large software projects have imprecise dependency graphs that lead to wasteful test executions. If a test belongs to a module that has more dependencies than the actual dependencies of the test, then it is executed unnecessarily whenever a code change impacts those additional dependencies. In this paper, we formulate the problem of wasteful test executions due to suboptimal placement of tests in modules. We propose a greedy algorithm to reduce the number of test executions by suggesting test movements while considering historical build information and actual dependencies of tests. We have implemented our technique, called TestOptimizer, on top of CloudBuild, the build system developed within Microsoft over the last few years. We have evaluated the technique on five large proprietary projects. Our results show that the suggested test movements can lead to a reduction of 21.66 million test executions (17.09%) across all our subject projects. We received encouraging feedback from the developers of these projects; they accepted and intend to implement 鈮�80% of our reported suggestions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985705','10.1109/ICSE.2017.69',24,2,'IEEE','IEEE Conferences',0),(108,'RClassify: Classifying Race Conditions in Web Applications via Deterministic Replay',4,278,288,'Race conditions are common in web applications but are difficult to diagnose and repair. Although there exist tools for detecting races in web applications, they all report a large number of false positives. That is, the races they report are either bogus, meaning they can never occur in practice, or benign, meaning they do not lead to erroneous behaviors. Since manually diagnosing them is tedious and error prone, reporting these race warnings to developers would be counter-productive. We propose a platform-agnostic, deterministic replay-based method for identifying not only the real but also the truly harmful race conditions. It relies on executing each pair of racing events in two different orders and assessing their impact on the program state: we say a race is harmful only if (1) both of the two executions arefeasible and (2) they lead to different program states. We have evaluated our evidence-based classification method on a large set of real websites from Fortune-500 companies and demonstrated that it significantly outperforms all state-of-the-art techniques.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985669','10.1109/ICSE.2017.33',33,2,'IEEE','IEEE Conferences',0),(109,'An Efficient, Robust, and Scalable Approach for Analyzing Interacting Android Apps',4,324,334,'When multiple apps on an Android platform interact, faults and security vulnerabilities can occur. Software engineers need to be able to analyze interacting apps to detect such problems. Current approaches for performing such analyses, however, do not scale to the numbers of apps that may need to be considered, and thus, are impractical for application to real-world scenarios. In this paper, we introduce JITANA, a program analysis framework designed to analyze multiple Android apps simultaneously. By using a classloader-based approach instead of a compiler-based approach such as SOOT, JITANA is able to simultaneously analyze large numbers of interacting apps, perform on-demand analysis of large libraries, and effectively analyze dynamically generated code. Empirical studies of JITANA show that it is substantially more efficient than a state-of-the-art approach, and that it can effectively and efficiently analyze complex apps including Facebook, Pokemon Go, and Pandora that the state-of-the-art approach cannot handle.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985673','10.1109/ICSE.2017.37',33,3,'IEEE','IEEE Conferences',0),(110,'Mimic: UI Compatibility Testing System for Android Apps',3,246,256,'This paper proposes Mimic, an automated UI compatibility testing system for Android apps. Mimic is designed specifically for comparing the UI behavior of an app across different devices, different Android versions, and different app versions. This design choice stems from a common problem that Android developers and researchers face-how to test whether or not an app behaves consistently across different environments or internal changes. Mimic allows Android app developers to easily perform backward and forward compatibility testing for their apps. It also enables a clear comparison between a stable version of app and a newer version of app. In doing so, Mimic allows multiple testing strategies to be used, such as randomized or sequential testing. Finally, Mimic programming model allows such tests to be scripted with much less developer effort than other comparable systems. Additionally, Mimic allows parallel testing with multiple testing devices and thereby speeds up testing time. To demonstrate these capabilities, we perform extensive tests for each of the scenarios described above. Our results show that Mimic is effective in detecting forward and backward compatibility issues, and verify runtime behavior of apps. Our evaluation also shows that Mimic significantly reduces the development burden for developers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811983','10.1109/ICSE.2019.00040',37,1,'IEEE','IEEE Conferences',0),(111,'Test-Driven Code Review: An Empirical Study',3,1061,1072,'Test-Driven Code Review (TDR) is a code review practice in which a reviewer inspects a patch by examining the changed test code before the changed production code. Although this practice has been mentioned positively by practitioners in informal literature and interviews, there is no systematic knowledge of its effects, prevalence, problems, and advantages. In this paper, we aim at empirically understanding whether this practice has an effect on code review effectiveness and how developers\' perceive TDR. We conduct (i) a controlled experiment with 93 developers that perform more than 150 reviews, and (ii) 9 semi-structured interviews and a survey with 103 respondents to gather information on how TDR is perceived. Key results from the experiment show that developers adopting TDR find the same proportion of defects in production code, but more in test code, at the expenses of fewer maintainability issues in production code. Furthermore, we found that most developers prefer to review production code as they deem it more critical and tests should follow from it. Moreover, general poor test code quality and no tool support hinder the adoption of TDR. Public preprint: [https: //doi.org/10.5281/zenodo.2551217], data and materials: [https:// doi.org/10.5281/zenodo.2553139].','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811911','10.1109/ICSE.2019.00110',56,1,'IEEE','IEEE Conferences',0),(112,'Recovering Variable Names for Minified Code with Usage Contexts',3,1165,1175,'To avoid the exposure of original source code in a Web application, the variable names in JS code deployed in the wild are often replaced by short, meaningless names, thus making the code extremely difficult to manually understand and analysis. This paper presents JSNeat, an information retrieval (IR)-based approach to recover the variable names in minified JS code. JSNeat follows a data-driven approach to recover names by searching for them in a large corpus of open-source JS code. We use three types of contexts to match a variable in given minified code against the corpus including the context of the properties and roles of the variable, the context of that variable and relations with other variables under recovery, and the context of the task of the function to which the variable contributes. We performed several empirical experiments to evaluate JSNeat on the dataset of more than 322K JS files with 1M functions, and 3.5M variables with 176K unique variable names. We found that JSNeat achieves a high accuracy of 69.1%, which is the relative improvements of 66.1% and 43% over two state-of-the-art approaches JSNice and JSNaughty, respectively. The time to recover for a file or a variable with JSNeat is twice as fast as with JSNice and 4x as fast as with JNaughty, respectively.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812034','10.1109/ICSE.2019.00119',21,1,'IEEE','IEEE Conferences',0),(113,'SLF: Fuzzing without Valid Seed Inputs',3,712,723,'Fuzzing is an important technique to detect software bugs and vulnerabilities. It works by mutating a small set of seed inputs to generate a large number of new inputs. Fuzzers\' performance often substantially degrades when valid seed inputs are not available. Although existing techniques such as symbolic execution can generate seed inputs from scratch, they have various limitations hindering their applications in real-world complex software. In this paper, we propose a novel fuzzing technique that features the capability of generating valid seed inputs. It piggy-backs on AFL to identify input validity checks and the input fields that have impact on such checks. It further classifies these checks according to their relations to the input. Such classes include arithmetic relation, object offset, data structure length and so on. A multi-goal search algorithm is developed to apply class-specific mutations in order to satisfy inter-dependent checks all together. We evaluate our technique on 20 popular benchmark programs collected from other fuzzing projects and the Google fuzzer test suite, and compare it with existing fuzzers AFL and AFLFast, symbolic execution engines KLEE and S2E, and a hybrid tool Driller that combines fuzzing with symbolic execution. The results show that our technique is highly effective and efficient, out-performing the other tools.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812105','10.1109/ICSE.2019.00080',57,0,'IEEE','IEEE Conferences',0),(114,'Guiding Deep Learning System Testing Using Surprise Adequacy',3,1039,1049,'Deep Learning (DL) systems are rapidly being adopted in safety and security critical domains, urgently calling for ways to test their correctness and robustness. Testing of DL systems has traditionally relied on manual collection and labelling of data. Recently, a number of coverage criteria based on neuron activation values have been proposed. These criteria essentially count the number of neurons whose activation during the execution of a DL system satisfied certain properties, such as being above predefined thresholds. However, existing coverage criteria are not sufficiently fine grained to capture subtle behaviours exhibited by DL systems. Moreover, evaluations have focused on showing correlation between adversarial examples and proposed criteria rather than evaluating and guiding their use for actual testing of DL systems. We propose a novel test adequacy criterion for testing of DL systems, called Surprise Adequacy for Deep Learning Systems (SADL), which is based on the behaviour of DL systems with respect to their training data. We measure the surprise of an input as the difference in DL system\'s behaviour between the input and the training data (i.e., what was learnt during training), and subsequently develop this as an adequacy criterion: a good test input should be sufficiently but not overtly surprising compared to training data. Empirical evaluation using a range of DL systems from simple image classifiers to autonomous driving car platforms shows that systematic sampling of inputs based on their surprise can improve classification accuracy of DL systems against adversarial examples by up to 77.5% via retraining.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812069','10.1109/ICSE.2019.00108',44,4,'IEEE','IEEE Conferences',0),(115,'Grey-Box Concolic Testing on Binary Code',3,736,747,'We present grey-box concolic testing, a novel path-based test case generation method that combines the best of both white-box and grey-box fuzzing. At a high level, our technique systematically explores execution paths of a program under test as in white-box fuzzing, a.k.a. concolic testing, while not giving up the simplicity of grey-box fuzzing: it only uses a lightweight instrumentation, and it does not rely on an SMT solver. We implemented our technique in a system called Eclipser, and compared it to the state-of-the-art grey-box fuzzers (including AFLFast, LAF-intel, Steelix, and VUzzer) as well as a symbolic executor (KLEE). In our experiments, we achieved higher code coverage and found more bugs than the other tools.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811950','10.1109/ICSE.2019.00082',63,0,'IEEE','IEEE Conferences',0),(116,'A Framework for Checking Regression Test Selection Tools',3,430,441,'Regression test selection (RTS) reduces regression testing costs by re-running only tests that can change behavior due to code changes. Researchers and large software organizations recently developed and adopted several RTS tools to deal with the rapidly growing costs of regression testing. As RTS tools gain adoption, it becomes critical to check that they are correct and efficient. Unfortunately, checking RTS tools currently relies solely on limited tests that RTS tool developers manually write. We present RTSCheck, the first framework for checking RTS tools. RTSCheck feeds evolving programs (i.e., sequences of program revisions) to an RTS tool and checks the output against rules inspired by existing RTS test suites. Violations of these rules are likely due to deviations from expected RTS tool behavior, and indicative of bugs in the tool. RTSCheck uses three components to obtain evolving programs: (1) AutoEP automatically generates evolving programs and corresponding tests, (2) DefectsEP uses buggy and fixed program revisions from bug databases, and (3) EvoEP uses sequences of program revisions from actual open-source projects\' histories. We used RTSCheck to check three recently developed RTS tools for Java: Clover, Ekstazi, and STARTS. RTSCheck discovered 27 bugs in these three tools.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812073','10.1109/ICSE.2019.00056',80,0,'IEEE','IEEE Conferences',0),(117,'What Causes My Test Alarm? Automatic Cause Analysis for Test Alarms in System and Integration Testing',4,712,723,'Driven by new software development processes and testing in clouds, system and integration testing nowadays tends to produce enormous number of alarms. Such test alarms lay an almost unbearable burden on software testing engineers who have to manually analyze the causes of these alarms. The causes are critical because they decide which stakeholders are responsible to fix the bugs detected during the testing. In this paper, we present a novel approach that aims to relieve the burden by automating the procedure. Our approach, called Cause Analysis Model, exploits information retrieval techniques to efficiently infer test alarm causes based on test logs. We have developed a prototype and evaluated our tool on two industrial datasets with more than 14,000 test alarms. Experiments on the two datasets show that our tool achieves an accuracy of 58.3% and 65.8%, respectively, which outperforms the baseline algorithms by up to 13.3%. Our algorithm is also extremely efficient, spending about 0.1s per cause analysis. Due to the attractive experimental results, our industrial partner, a leading information and communication technology company in the world, has deployed the tool and it achieves an average accuracy of 72% after two months of running, nearly three times more accurate than a previous strategy based on regular expressions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985707','10.1109/ICSE.2017.71',51,7,'IEEE','IEEE Conferences',0),(118,'To Type or Not to Type: Quantifying Detectable Bugs in JavaScript',4,758,769,'JavaScript is growing explosively and is now used in large mature projects even outside the web domain. JavaScript is also a dynamically typed language for which static type systems, notably Facebook\'s Flow and Microsoft\'s TypeScript, have been written. What benefits do these static type systems provide? Leveraging JavaScript project histories, we select a fixed bug and check out the code just prior to the fix. We manually add type annotations to the buggy code and test whether Flow and TypeScript report an error on the buggy code, thereby possibly prompting a developer to fix the bug before its public release. We then report the proportion of bugs on which these type systems reported an error. Evaluating static type systems against public bugs, which have survived testing and review, is conservative: it understates their effectiveness at detecting bugs during private development, not to mention their other benefits such as facilitating code search/completion and serving as documentation. Despite this uneven playing field, our central finding is that both static type systems find an important percentage of public bugs: both Flow 0.30 and TypeScript 2.0 successfully detect 15%!.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985711','10.1109/ICSE.2017.75',53,5,'IEEE','IEEE Conferences',0),(119,'Analysis and Testing of Notifications in Android Wear Applications',4,347,357,'Android Wear (AW) is Google\'s platform for developing applications for wearable devices. Our goal is to make a first step toward a foundation for analysis and testing of AW apps. We focus on a core feature of such apps: notifications issued by a handheld device (e.g., a smartphone) and displayed on a wearable device (e.g., a smartwatch). We first define a formal semantics of AW notifications in order to capture the core features and behavior of the notification mechanism. Next, we describe a constraint-based static analysis to build a model of this run-time behavior. We then use this model to develop a novel testing tool for AW apps. The tool contains a testing framework together with components to support AW-specific coverage criteria and to automate the generation of GUI events on the wearable. These contributions advance the state of the art in the increasingly important area of software for wearable devices.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985675','10.1109/ICSE.2017.39',43,8,'IEEE','IEEE Conferences',0),(120,'Intention-Based Integration of Software Variants',3,831,842,'Cloning is a simple way to create new variants of a system. While cheap at first, it increases maintenance cost in the long term. Eventually, the cloned variants need to be integrated into a configurable platform. Such an integration is challenging: it involves merging the usual code improvements between the variants, and also integrating the variable code (features) into the platform. Thus, variant integration differs from traditional soft- ware merging, which does not produce or organize configurable code, but creates a single system that cannot be configured into variants. In practice, variant integration requires fine-grained code edits, performed in an exploratory manner, in multiple iterations. Unfortunately, little tool support exists for integrating cloned variants. In this work, we show that fine-grained code edits needed for integration can be alleviated by a small set of integration intentions-domain-specific actions declared over code snippets controlling the integration. Developers can interactively explore the integration space by declaring (or revoking) intentions on code elements. We contribute the intentions (e.g., \'keep functionality\' or \'keep as a configurable feature\') and the IDE tool INCLINE, which implements the intentions and five editable views that visualize the integration process and allow declaring intentions producing a configurable integrated platform. In a series of experiments, we evaluated the completeness of the pro- posed intentions, the correctness and performance of INCLINE, and the benefits of using intentions for variant integration. The experiments show that INCLINE can handle complex integration tasks, that views help to navigate the code, and that it consistently reduces mistakes made by developers during variant integration.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811913','10.1109/ICSE.2019.00090',46,0,'IEEE','IEEE Conferences',0),(121,'Rotten Green Tests',3,500,511,'Unit tests are a tenant of agile programming methodologies, and are widely used to improve code quality and prevent code regression. A green (passing) test is usually taken as a robust sign that the code under test is valid. However, some green tests contain assertions that are never executed. We call such tests Rotten Green Tests. Rotten Green Tests represent a case worse than a broken test: they report that the code under test is valid, but in fact do not test that validity. We describe an approach to identify rotten green tests by combining simple static and dynamic call-site analyses. Our approach takes into account test helper methods, inherited helpers, and trait compositions, and has been implemented in a tool called DrTest. DrTest reports no false negatives, yet it still reports some false positives due to conditional use or multiple test contexts. Using DrTest we conducted an empirical evaluation of 19,905 real test cases in mature projects of the Pharo ecosystem. The results of the evaluation show that the tool is effective; it detected 294 tests as rotten-green tests that contain assertions that are not executed. Some rotten tests have been 鈥渟leeping鈥� in Pharo for at least 5 years.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812040','10.1109/ICSE.2019.00062',44,0,'IEEE','IEEE Conferences',0),(122,'Reasonably-Most-General Clients for JavaScript Library Analysis',3,83,93,'A well-known approach to statically analyze libraries without having access to their client code is to model all possible clients abstractly using a most-general client. In dynamic languages, however, a most-general client would be too general: it may interact with the library in ways that are not intended by the library developer and are not realistic in actual clients, resulting in useless analysis results. In this work, we explore the concept of a reasonably-most-general client, in the context of a new static analysis tool REAGENT that aims to detect errors in TypeScript declaration files for JavaScript libraries. By incorporating different variations of reasonably-most-general clients into an existing static analyzer for JavaScript, we use REAGENT to study how different assumptions of client behavior affect the analysis results. We also show how REAGENT is able to find type errors in real-world TypeScript declaration files, and, once the errors have been corrected, to guarantee that no remaining errors exist relative to the selected assumptions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812107','10.1109/ICSE.2019.00026',29,0,'IEEE','IEEE Conferences',0),(123,'SMOKE: Scalable Path-Sensitive Memory Leak Detection for Millions of Lines of Code',3,72,82,'Detecting memory leak at industrial scale is still not well addressed, in spite of the tremendous effort from both industry and academia in the past decades. Existing work suffers from an unresolved paradox - a highly precise analysis limits its scalability and an imprecise one seriously hurts its precision or recall. In this work, we present SMOKE, a staged approach to resolve this paradox. In the first stage, instead of using a uniform precise analysis for all paths, we use a scalable but imprecise analysis to compute a succinct set of candidate memory leak paths. In the second stage, we leverage a more precise analysis to verify the feasibility of those candidates. The first stage is scalable, due to the design of a new sparse program representation, the use-flow graph (UFG), that models the problem as a polynomial-time state analysis. The second stage analysis is both precise and efficient, due to the smaller number of candidates and the design of a dedicated constraint solver. Experimental results show that SMOKE can finish checking industrial-sized projects, up to 8MLoC, in forty minutes with an average false positive rate of 24.4%. Besides, SMOKE is significantly faster than the state-of-the-art research techniques as well as the industrial tools, with the speedup ranging from 5.2X to 22.8X. In the twenty-nine mature and extensively checked benchmark projects, SMOKE has discovered thirty previously unknown memory leaks which were con?rmed by developers, and one even assigned a CVE ID.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812075','10.1109/ICSE.2019.00025',36,0,'IEEE','IEEE Conferences',0),(124,'UML Diagram Refinement (Focusing on Class-and Use Case Diagrams)',4,735,745,'Large and complicated UML models are not useful, because they are difficult to understand. This problem can be solved by using several diagrams of the same system at different levels of abstraction. Unfortunately, UML does not define an explicit set of rules for ensuring that diagrams at different levels of abstraction are consistent. We define such a set of rules, that we call diagram refinement. Diagram refinement is intuitive, and applicable to several kinds of UML diagrams (mostly to structural diagrams but also to use case diagrams), yet it rests on a solid mathematical basis-the theory of graph homomorphisms. We illustrate its usefulness with a series of examples.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985709','10.1109/ICSE.2017.73',25,3,'IEEE','IEEE Conferences',0),(125,'Performance Diagnosis for Inefficient Loops',4,370,380,'Writing efficient software is difficult. Design and implementation defects can cause severe performance degradation. Unfortunately, existing performance diagnosis techniques like profilers are still preliminary. They can locate code regions that consume resources, but not the ones that waste resources. In this paper, we first design a root-cause and fix-strategy taxonomy for inefficient loops, one of the most common performance problems in the field. We then design a static-dynamic hybrid analysis tool, LDoctor, to provide accurate performance diagnosis for loops. We further use sampling techniques to lower the run-time overhead without degrading the accuracy or latency of LDoctor diagnosis. Evaluation using real-world performance problems shows that LDoctor can provide better coverage and accuracy than existing techniques, with low overhead.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985677','10.1109/ICSE.2017.41',37,5,'IEEE','IEEE Conferences',0),(126,'CTRAS: Crowdsourced Test Report Aggregation and Summarization',3,900,911,'Crowdsourced testing has been widely adopted to improve the quality of various software products. Crowdsourced workers typically perform testing tasks and report their experiences through test reports. While the crowdsourced test reports provide feedbacks from real usage scenarios, inspecting such a large number of reports becomes a time-consuming yet inevitable task. To improve the efficiency of this task, existing widely used issue-tracking systems, such as JIRA, Bugzilla, and Mantis, have provided keyword-search-based methods to assist users in identifying duplicate test reports. However, on mobile devices (such as mobile phones), where the crowdsourced test reports often contain insufficient text descriptions but instead rich screenshots, these text-analysis-based methods become less effective because the data has fundamentally changed. In this paper, instead of focusing on only detecting duplicates based on textual descriptions, we present CTRAS: a novel approach to leveraging duplicates to enrich the content of bug descriptions and improve the efficiency of inspecting these reports. CTRAS is capable of automatically aggregating duplicates based on both textual information and screenshots, and further summarizes the duplicate test reports into a comprehensive and comprehensible report. To validate CTRAS, we conducted quantitative studies using more than 5000 test reports, collected from 12 industrial crowdsourced projects. The experimental results reveal that CTRAS can reach an accuracy of 0.87, on average, regarding automatically detecting duplicate reports, and it outperforms the classic Max-Coverage-based and MMR summarization methods under Jensen Shannon divergence metric. Moreover, we conducted a task-based user study with 30 participants, whose result indicates that CTRAS can save nearly 30% time cost on average without loss of correctness.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811987','10.1109/ICSE.2019.00096',45,1,'IEEE','IEEE Conferences',0),(127,'Precise Condition Synthesis for Program Repair',4,416,426,'Due to the difficulty of repairing defect, many research efforts have been devoted into automatic defect repair. Given a buggy program that fails some test cases, a typical automatic repair technique tries to modify the program to make all tests pass. However, since the test suites in real world projects are usually insufficient, aiming at passing the test suites often leads to incorrect patches. This problem is known as weak test suites or overfitting. In this paper we aim to produce precise patches, that is, any patch we produce has a relatively high probability to be correct. More concretely, we focus on condition synthesis, which was shown to be able to repair more than half of the defects in existing approaches. Our key insight is threefold. First, it is important to know what variables in a local context should be used in an \'if\' condition, and we propose a sorting method based on the dependency relations between variables. Second, we observe that the API document can be used to guide the repair process, and propose document analysis technique to further filter the variables. Third, it is important to know what predicates should be performed on the set of variables, and we propose to mine a set of frequently used predicates in similar contexts from existing projects. Based on the insight, we develop a novel program repair system, ACS, that could generate precise conditions at faulty locations. Furthermore, given the generated conditions are very precise, we can perform a repair operation that is previously deemed to be too overfitting: directly returning the test oracle to repair the defect. Using our approach, we successfully repaired 18 defects on four projects of Defects4J, which is the largest number of fully automatically repaired defects reported on the dataset so far. More importantly, the precision of our approach in the evaluation is 78.3%, which is significantly higher than previous approaches, which are usually less than 40%.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985681','10.1109/ICSE.2017.45',48,28,'IEEE','IEEE Conferences',0),(128,'Probabilistic Disassembly',3,1187,1198,'Disassembling stripped binaries is a prominent challenge for binary analysis, due to the interleaving of code segments and data, and the difficulties of resolving control transfer targets of indirect calls and jumps. As a result, most existing disassemblers have both false positives (FP) and false negatives (FN). We observe that uncertainty is inevitable in disassembly due to the information loss during compilation and code generation. Therefore, we propose to model such uncertainty using probabilities and propose a novel disassembly technique, which computes a probability for each address in the code space, indicating its likelihood of being a true positive instruction. The probability is computed from a set of features that are reachable to an address, including control flow and data flow features. Our experiments with more than two thousands binaries show that our technique does not have any FN and has only 3.7% FP. In comparison, a state-of-the-art superset disassembly technique has 85% FP. A rewriter built on our disassembly can generate binaries that are only half of the size of those by superset disassembly and run 3% faster. While many widely-used disassemblers such as IDA and BAP suffer from missing function entries, our experiment also shows that even without any function entry information, our disassembler can still achieve 0 FN and 6.8% FP.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812038','10.1109/ICSE.2019.00121',57,0,'IEEE','IEEE Conferences',0),(129,'How Reliable is the Crowdsourced Knowledge of Security Implementation?',3,536,547,'Stack Overflow (SO) is the most popular online Q&A site for developers to share their expertise in solving programming issues. Given multiple answers to a certain question, developers may take the accepted answer, the answer from a person with high reputation, or the one frequently suggested. However, researchers recently observed that SO contains exploitable security vulnerabilities in the suggested code of popular answers, which found their way into security-sensitive high-profile applications that millions of users install every day. This observation inspires us to explore the following questions: How much can we trust the security implementation suggestions on SO? If suggested answers are vulnerable, can developers rely on the community\'s dynamics to infer the vulnerability and identify a secure counterpart? To answer these highly important questions, we conducted a comprehensive study on security-related SO posts by contrasting secure and insecure advice with the community-given content evaluation. Thereby, we investigated whether SO\'s gamification approach on incentivizing users is effective in improving security properties of distributed code examples. Moreover, we traced the distribution of duplicated samples over given answers to test whether the community behavior facilitates or prevents propagation of secure and insecure code suggestions within SO. We compiled 953 different groups of similar security-related code examples and labeled their security, identifying 785 secure answer posts and 644 insecure answer posts. Compared with secure suggestions, insecure ones had higher view counts (36,508 vs. 18,713), received a higher score (14 vs. 5), and had significantly more duplicates (3.8 vs. 3.0) on average. 34% of the posts provided by highly reputable so-called trusted users were insecure. Our findings show that based on the distribution of secure and insecure code on SO, users being laymen in security rely on additional advice and guidance. However, the community-given feedback does not allow differentiating secure from insecure choices. The reputation mechanism fails in indicating trustworthy users with respect to security questions, ultimately leaving other users wandering around alone in a software security minefield.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812042','10.1109/ICSE.2019.00065',73,2,'IEEE','IEEE Conferences',0),(130,'iSENSE: Completion-Aware Crowdtesting Management',3,912,923,'Crowdtesting has become an effective alternative to traditional testing, especially for mobile applications. However, crowdtesting is hard to manage in nature. Given the complexity of mobile applications and unpredictability of distributed crowdtesting processes, it is difficult to estimate (a) remaining number of bugs yet to be detected or (b) required cost to find those bugs. Experience-based decisions may result in ineffective crowdtesting processes, e.g., there is an average of 32% wasteful spending in current crowdtesting practices. This paper aims at exploring automated decision support to effectively manage crowdtesting processes. It proposes an approach named ISENSE which applies incremental sampling technique to process crowdtesting reports arriving in chronological order, organizes them into fixed-size groups as dynamic inputs, and predicts two test completion indicators in an incremental manner. The two indicators are: 1) total number of bugs predicted with Capture-ReCapture model, and 2) required test cost for achieving certain test objectives predicted with AutoRegressive Integrated Moving Average model. The evaluation of ISENSE is conducted on 46,434 reports of 218 crowdtesting tasks from one of the largest crowdtesting platforms in China. Its effectiveness is demonstrated through two application studies for automating crowdtesting management and semi-automation of task closing trade-off analysis. The results show that ISENSE can provide managers with greater awareness of testing progress to achieve cost-effectiveness gains of crowdtesting. Specifically, a median of 100% bugs can be detected with 30% saved cost based on the automated close prediction.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812109','10.1109/ICSE.2019.00097',68,0,'IEEE','IEEE Conferences',0),(131,'Mining Historical Test Logs to Predict Bugs and Localize Faults in the Test Logs',3,140,151,'Software testing is an integral part of modern software development. However, test runs can produce thousands of lines of logged output that make it difficult to find the cause of a fault in the logs. This problem is exacerbated by environmental failures that distract from product faults. In this paper we present techniques with the goal of capturing the maximum number of product faults, while flagging the minimum number of log lines for inspection. We observe that the location of a fault in a log should be contained in the lines of a failing test log. In contrast, a passing test log should not contain the lines related to a failure. Lines that occur in both a passing and failing log introduce noise when attempting to find the fault in a failing log. We introduce an approach where we remove the lines that occur in the passing log from the failing log. After removing these lines, we use information retrieval techniques to flag the most probable lines for investigation. We modify TF-IDF to identify the most relevant log lines related to past product failures. We then vectorize the logs and develop an exclusive version of KNN to identify which logs are likely to lead to product faults and which lines are the most probable indication of the failure. Our best approach, LogFaultFlagger finds 89% of the total faults and flags less than 1% of the total failed log lines for inspection. LogFaultFlagger drastically outperforms the previous work CAM. We implemented LogFaultFlagger as a tool at Ericsson where it presents fault prediction summaries to base station testers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812113','10.1109/ICSE.2019.00031',60,1,'IEEE','IEEE Conferences',0),(132,'Feedback-Based Debugging',4,393,403,'Software debugging has long been regarded as a time and effort consuming task. In the process of debugging, developers usually need to manually inspect many program steps to see whether they deviate from their intended behaviors. Given that intended behaviors usually exist nowhere but in human mind, the automation of debugging turns out to be extremely hard, if not impossible. In this work, we propose a feedback-based debugging approach, which (1) builds on light-weight human feedbacks on a buggy program and (2) regards the feedbacks as partial program specification to infer suspicious steps of the buggy execution. Given a buggy program, we record its execution trace and allow developers to provide light-weight feedback on trace steps. Based on the feedbacks, we recommend suspicious steps on the trace. Moreover, our approach can further learn and approximate bug-free paths, which helps reduce required feedbacks to expedite the debugging process. We conduct an experiment to evaluate our approach with simulated feedbacks on 3409 mutated bugs across 3 open source projects. The results show that our feedback-based approach can detect 92.8% of the bugs and 65% of the detected bugs require less than 20 feedbacks. In addition, we implement our proof-of-concept tool, Microbat, and conduct a user study involving 16 participants on 3 debugging tasks. The results show that, compared to the participants using the baseline tool, Whyline, the ones using Microbat can spend on average 55.8% less time to locate the bugs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985679','10.1109/ICSE.2017.43',38,4,'IEEE','IEEE Conferences',0),(133,'Exploring API Embedding for API Usages and Applications',4,438,449,'Word2Vec is a class of neural network models that as being trainedfrom a large corpus of texts, they can produce for each unique word acorresponding vector in a continuous space in which linguisticcontexts of words can be observed. In this work, we study thecharacteristics of Word2Vec vectors, called API2VEC or API embeddings, for the API elements within the API sequences in source code. Ourempirical study shows that the close proximity of the API2VEC vectorsfor API elements reflects the similar usage contexts containing thesurrounding APIs of those API elements. Moreover, API2VEC can captureseveral similar semantic relations between API elements in API usagesvia vector offsets. We demonstrate the usefulness of API2VEC vectorsfor API elements in three applications. First, we build a tool thatmines the pairs of API elements that share the same usage relationsamong them. The other applications are in the code migrationdomain. We develop API2API, a tool to automatically learn the APImappings between Java and C# using a characteristic of the API2VECvectors for API elements in the two languages: semantic relationsamong API elements in their usages are observed in the two vectorspaces for the two languages as similar geometric arrangements amongtheir API2VEC vectors. Our empirical evaluation shows that API2APIrelatively improves 22.6% and 40.1% top-1 and top-5 accuracy over astate-of-the-art mining approach for API mappings. Finally, as anotherapplication in code migration, we are able to migrate equivalent APIusages from Java to C# with up to 90.6% recall and 87.2% precision.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985683','10.1109/ICSE.2017.47',45,9,'IEEE','IEEE Conferences',0),(134,'Automated Reporting of Anti-Patterns and Decay in Continuous Integration',3,105,115,'Continuous Integration (CI) is a widely-used software engineering practice. The software is continuously built so that changes can be easily integrated and issues such as unmet quality goals or style inconsistencies get detected early. Unfortunately, it is not only hard to introduce CI into an existing project, but it is also challenging to live up to the CI principles when facing tough deadlines or business decisions. Previous work has identified common anti-patterns that reduce the promised benefits of CI. Typically, these anti-patterns slowly creep into a project over time before they are identified. We argue that automated detection can help with early identification and prevent such a process decay. In this work, we further analyze this assumption and survey 124 developers about CI anti-patterns. From the results, we build CI-Odor, a reporting tool for CI processes that detects the existence of four relevant anti-patterns by analyzing regular build logs and repository information. In a study on the 18,474 build logs of 36 popular JAVA projects, we reveal the presence of 3,823 high-severity warnings spread across projects. We validate our reports in a survey among 13 original developers of these projects and through general feedback from 42 developers that confirm the relevance of our reports.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811921','10.1109/ICSE.2019.00028',35,2,'IEEE','IEEE Conferences',0),(135,'Going Farther Together: The Impact of Social Capital on Sustained Participation in Open Source',3,688,699,'Sustained participation by contributors in opensource software is critical to the survival of open-source projects and can provide career advancement benefits to individual contributors. However, not all contributors reap the benefits of open-source participation fully, with prior work showing that women are particularly underrepresented and at higher risk of disengagement. While many barriers to participation in open-source have been documented in the literature, relatively little is known about how the social networks that open-source contributors form impact their chances of long-term engagement. In this paper we report on a mixed-methods empirical study of the role of social capital (i.e., the resources people can gain from their social connections) for sustained participation by women and men in open-source GitHub projects. After combining survival analysis on a large, longitudinal data set with insights derived from a user survey, we confirm that while social capital is beneficial for prolonged engagement for both genders, women are at disadvantage in teams lacking diversity in expertise.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812044','10.1109/ICSE.2019.00078',100,5,'IEEE','IEEE Conferences',0),(136,'Can Latent Topics in Source Code Predict Missing Architectural Tactics?',4,15,26,'Architectural tactics such as heartbeat, resource pooling, and scheduling provide solutions to satisfy reliability, security, performance, and other critical characteristics of a software system. Current design practices advocate rigorous up-front analysis of the system\'s quality concerns to identify tactics and where in the code they should be used. In this paper, we explore a bottom-up approach to recommend architectural tactics based on latent topics discovered in the source code of projects. We present a recommender system developed by building predictor models which capture relationships between topical concepts in source code and the use of specific architectural tactics in that code. Based on an extensive analysis of over 116,000 open source systems, we identify significant correlations between latent topics in source code and the usage of architectural tactics. We use this information to construct a predictor for generating tactic recommendations. Our approach is validated through a series of experiments which demonstrate the ability to generate package-level tactic recommendations. We provide further validation via two large-scale studies of Apache Hive and Hadoop to illustrate that our recommender system predicts tactics that are actually implemented by developers in later releases.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985646','10.1109/ICSE.2017.10',58,1,'IEEE','IEEE Conferences',0),(137,'GreenBundle: An Empirical Study on the Energy Impact of Bundled Processing',3,1107,1118,'Energy consumption is a concern in the data-center and at the edge, on mobile devices such as smartphones. Software that consumes too much energy threatens the utility of the end-user\'s mobile device. Energy consumption is fundamentally a systemic kind of performance and hence it should be addressed at design time via a software architecture that supports it, rather than after release, via some form of refactoring. Unfortunately developers often lack knowledge of what kinds of designs and architectures can help address software energy consumption. In this paper we show that some simple design choices can have significant effects on energy consumption. In particular we examine the Model-View-Controller architectural pattern and demonstrate how converting to Model-View-Presenter with bundling can improve the energy performance of both benchmark systems and real world applications. We show the relationship between energy consumption and bundled and delayed view updates: bundling events in the presenter can often reduce energy consumption by 30%.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811956','10.1109/ICSE.2019.00114',80,0,'IEEE','IEEE Conferences',0),(138,'Clone Refactoring with Lambda Expressions',4,60,70,'Lambda expressions have been introduced in Java 8 to support functional programming and enable behavior parameterization by passing functions as parameters to methods. The majority of software clones (duplicated code) are known to have behavioral differences (i.e., Type-2 and Type-3 clones). However, to the best of our knowledge, there is no previous work to investigate the utility of Lambda expressions for parameterizing such behavioral differences in clones. In this paper, we propose a technique that examines the applicability of Lambda expressions for the refactoring of clones with behavioral differences. Moreover, we empirically investigate the applicability and characteristics of the Lambda expressions introduced to refactor a large dataset of clones. Our findings show that Lambda expressions enable the refactoring of a significant portion of clones that could not be refactored by any other means.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985650','10.1109/ICSE.2017.14',41,9,'IEEE','IEEE Conferences',0),(139,'Detection and Repair of Architectural Inconsistencies in Java',3,560,571,'Java is one of the most widely used programming languages. However, the absence of explicit support for architectural constructs, such as software components, in the programming language itself has prevented software developers from achieving the many benefits that come with architecture-based development. To address this issue, Java 9 has introduced the Java Platform Module System (JPMS), resulting in the first instance of encapsulation of modules with rich software architectural interfaces added to a mainstream programming language. The primary goal of JPMS is to construct and maintain large applications efficiently-as well as improve the encapsulation, security, and maintainability of Java applications in general and the JDK itself. A challenge, however, is that module declarations do not necessarily reflect actual usage of modules in an application, allowing developers to mistakenly specify inconsistent dependencies among the modules. In this paper, we formally define 8 inconsistent modular dependencies that may arise in Java-9 applications. We also present DARCY, an approach that leverages these definitions and static program analyses to automatically (1) detect the specified inconsistent dependencies within Java applications and (2) repair those identified inconsistencies. The results of our experiments, conducted over 38 open-source Java-9 applications, indicate that architectural inconsistencies are widespread and demonstrate the benefits of DARCY in automated detection and repair of these inconsistencies.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812079','10.1109/ICSE.2019.00067',74,1,'IEEE','IEEE Conferences',0),(140,'Pattern-Based Mining of Opinions in Q&A Websites',3,548,559,'Informal documentation contained in resources such as Q&A websites (e.g., Stack Overflow) is a precious resource for developers, who can find there examples on how to use certain APIs, as well as opinions about pros and cons of such APIs. Automatically identifying and classifying such opinions can alleviate developers\' burden in performing manual searches, and can be used to recommend APIs that are good from some points of view (e.g., performance), or highlight those less ideal from other perspectives (e.g., compatibility). We propose POME (Pattern-based Opinion MinEr), an approach that leverages natural language parsing and pattern-matching to classify Stack Overflow sentences referring to APIs according to seven aspects (e.g., performance, usability), and to determine their polarity (positive vs negative). The patterns have been inferred by manually analyzing 4,346 sentences from Stack Overflow linked to a total of 30 APIs. We evaluated POME by (i) comparing the pattern-matching approach with machine learners leveraging the patterns themselves as well as n-grams extracted from Stack Overflow posts; (ii) assessing the ability of POME to detect the polarity of sentences, as compared to sentiment-analysis tools; (iii) comparing POME with the state-of-the-art Stack Overflow opinion mining approach, Opiner, through a study involving 24 human evaluators. Our study shows that POME exhibits a higher precision than a state-of-the-art technique (Opiner), in terms of both opinion aspect identification and polarity assessment.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811960','10.1109/ICSE.2019.00066',47,0,'IEEE','IEEE Conferences',0),(141,'Graph Embedding Based Familial Analysis of Android Malware using Unsupervised Learning',3,771,782,'The rapid growth of Android malware has posed severe security threats to smartphone users. On the basis of the familial trait of Android malware observed by previous work, the familial analysis is a promising way to help analysts better focus on the commonalities of malware samples within the same families, thus reducing the analytical workload and accelerating malware analysis. The majority of existing approaches rely on supervised learning and face three main challenges, i.e., low accuracy, low efficiency, and the lack of labeled dataset. To address these challenges, we first construct a fine-grained behavior model by abstracting the program semantics into a set of subgraphs. Then, we propose SRA, a novel feature that depicts the similarity relationships between the Structural Roles of sensitive API call nodes in subgraphs. An SRA is obtained based on graph embedding techniques and represented as a vector, thus we can effectively reduce the high complexity of graph matching. After that, instead of training a classifier with labeled samples, we construct malware link network based on SRAs and apply community detection algorithms on it to group the unlabeled samples into groups. We implement these ideas in a system called GefDroid that performs Graph embedding based familial analysis of AnDroid malware using unsupervised learning. Moreover, we conduct extensive experiments to evaluate GefDroid on three datasets with ground truth. The results show that GefDroid can achieve high agreements (0.707-0.883 in term of NMI) between the clustering results and the ground truth. Furthermore, GefDroid requires only linear run-time overhead and takes around 8.6s to analyze a sample on average, which is considerably faster than the previous work.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812083','10.1109/ICSE.2019.00085',61,0,'IEEE','IEEE Conferences',0),(142,'SPAIN: Security Patch Analysis for Binaries towards Understanding the Pain and Pills',4,462,472,'Software vulnerability is one of the major threats to software security. Once discovered, vulnerabilities are often fixed by applying security patches. In that sense, security patches carry valuable information about vulnerabilities, which could be used to discover, understand and fix (similar) vulnerabilities. However, most existing patch analysis approaches work at the source code level, while binary-level patch analysis often heavily relies on a lot of human efforts and expertise. Even worse, some vulnerabilities may be secretly patched without applying CVE numbers, or only the patched binary programs are available while the patches are not publicly released. These practices greatly hinder patch analysis and vulnerability analysis. In this paper, we propose a scalable binary-level patch analysis framework, named SPAIN, which can automatically identify security patches and summarize patch patterns and their corresponding vulnerability patterns. Specifically, given the original and patched versions of a binary program, we locate the patched functions and identify the changed traces (i.e., a sequence of basic blocks) that may contain security or non-security patches. Then we identify security patches through a semantic analysis of these traces and summarize the patterns through a taint analysis on the patched functions. The summarized patterns can be used to search similar patches or vulnerabilities in binary programs. Our experimental results on several real-world projects have shown that: i) SPAIN identified security patches with high accuracy and high scalability, ii) SPAIN summarized 5 patch patterns and their corresponding vulnerability patterns for 5 vulnerability types, and iii) SPAIN discovered security patches that were not documented, and discovered 3 zero-day vulnerabilities.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985685','10.1109/ICSE.2017.49',44,9,'IEEE','IEEE Conferences',0),(143,'Superion: Grammar-Aware Greybox Fuzzing',3,724,735,'In recent years, coverage-based greybox fuzzing has proven itself to be one of the most effective techniques for finding security bugs in practice. Particularly, American Fuzzy Lop (AFL for short) is deemed to be a great success in fuzzing relatively simple test inputs. Unfortunately, when it meets structured test inputs such as XML and JavaScript, those grammar-blind trimming and mutation strategies in AFL hinder the effectiveness and efficiency. To this end, we propose a grammar-aware coverage-based greybox fuzzing approach to fuzz programs that process structured inputs. Given the grammar (which is often publicly available) of test inputs, we introduce a grammar-aware trimming strategy to trim test inputs at the tree level using the abstract syntax trees (ASTs) of parsed test inputs. Further, we introduce two grammar-aware mutation strategies (i.e., enhanced dictionary-based mutation and tree-based mutation). Specifically, tree-based mutation works via replacing subtrees using the ASTs of parsed test inputs. Equipped with grammar-awareness, our approach can carry the fuzzing exploration into width and depth. We implemented our approach as an extension to AFL, named Superion; and evaluated the effectiveness of Superion using large- scale programs (i.e., an XML engine libplist and three JavaScript engines WebKit, Jerryscript and ChakraCore). Our results have demonstrated that Superion can improve the code coverage (i.e., 16.7% and 8.8% in line and function coverage) and bug-finding capability (i.e., 34 new bugs, among which we discovered 22 new vulnerabilities with 19 CVEs assigned and 3.2K USD bug bounty rewards received) over AFL and jsfunfuzz.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811923','10.1109/ICSE.2019.00081',73,1,'IEEE','IEEE Conferences',0),(144,'Do Developers Discover New Tools On The Toilet?',3,465,475,'Maintaining awareness of useful tools is a substantial challenge for developers. Physical newsletters are a simple technique to inform developers about tools. In this paper, we evaluate such a technique, called Testing on the Toilet, by performing a mixed-methods case study. We first quantitatively evaluate how effective this technique is by applying statistical causal inference over six years of data about tools used by thousands of developers. We then qualitatively contextualize these results by interviewing and surveying 382 developers, from authors to editors to readers. We found that the technique was generally effective at increasing software development tool use, although the increase varied depending on factors such as the breadth of applicability of the tool, the extent to which the tool has reached saturation, and the memorability of the tool name.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812046','10.1109/ICSE.2019.00059',43,1,'IEEE','IEEE Conferences',0),(145,'How Practitioners Perceive Coding Proficiency',3,924,935,'Coding proficiency is essential to software practitioners. Unfortunately, our understanding on coding proficiency often translates to vague stereotypes, e.g., \'able to write good code\'. The lack of specificity hinders employers from measuring a software engineer\'s coding proficiency, and software engineers from improving their coding proficiency skills. This raises an important question: what skills matter to improve one\'s coding proficiency. To answer this question, we perform an empirical study by surveying 340 software practitioners from 33 countries across 5 continents. We first identify 38 coding proficiency skills grouped into nine categories by interviewing 15 developers from three companies. We then ask our survey respondents to rate the level of importance for these skills, and provide rationales of their ratings. Our study highlights a total of 21 important skills that receive an average rating of 4.0 and above (important and very important), along with rationales given by proponents and dissenters. We discuss implications of our findings to researchers, educators, and practitioners.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812050','10.1109/ICSE.2019.00098',49,0,'IEEE','IEEE Conferences',0),(146,'An Unsupervised Approach for Discovering Relevant Tutorial Fragments for APIs',4,38,48,'Developers increasingly rely on API tutorials to facilitate software development. However, it remains a challenging task for them to discover relevant API tutorial fragments explaining unfamiliar APIs. Existing supervised approaches suffer from the heavy burden of manually preparing corpus-specific annotated data and features. In this study, we propose a novel unsupervised approach, namely Fragment Recommender for APIs with PageRank and Topic model (FRAPT). FRAPT can well address two main challenges lying in the task and effectively determine relevant tutorial fragments for APIs. In FRAPT, a Fragment Parser is proposed to identify APIs in tutorial fragments and replace ambiguous pronouns and variables with related ontologies and API names, so as to address the pronoun and variable resolution challenge. Then, a Fragment Filter employs a set of non-explanatory detection rules to remove non-explanatory fragments, thus address the non-explanatory fragment identification challenge. Finally, two correlation scores are achieved and aggregated to determine relevant fragments for APIs, by applying both topic model and PageRank algorithm to the retained fragments. Extensive experiments over two publicly open tutorial corpora show that, FRAPT improves the state-of-the-art approach by 8.77% and 12.32% respectively in terms of F-Measure. The effectiveness of key components of FRAPT is also validated.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985648','10.1109/ICSE.2017.12',41,8,'IEEE','IEEE Conferences',0),(147,'Automated Refactoring of Legacy Java Software to Default Methods',4,82,93,'Java 8 default methods, which allow interfaces to contain (instance) method implementations, are useful for the skeletal implementation software design pattern. However, it is not easy to transform existing software to exploit default methods as it requires analyzing complex type hierarchies, resolving multiple implementation inheritance issues, reconciling differences between class and interface methods, and analyzing tie-breakers (dispatch precedence) with overriding class methods to preserve type-correctness and confirm semantics preservation. In this paper, we present an efficient, fully-automated, type constraint-based refactoring approach that assists developers in taking advantage of enhanced interfaces for their legacy Java software. The approach features an extensive rule set that covers various corner-cases where default methods cannot be used. To demonstrate applicability, we implemented our approach as an Eclipse plug-in and applied it to 19 real-world Java projects, as well as submitted pull requests to popular GitHub repositories. The indication is that it is useful in migrating skeletal implementation methods to interfaces as default methods, sheds light onto the pattern\'s usage, and provides insight to language designers on how this new construct applies to existing software.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985652','10.1109/ICSE.2017.16',42,5,'IEEE','IEEE Conferences',0),(148,'Easy Modelling and Verification of Unpredictable and Preemptive Interrupt-Driven Systems',3,212,222,'The widespread real-time and embedded systems are mostly interrupt-driven because their heavy interaction with the environment is often initiated by interrupts. With the interrupt arrival being unpredictable and the interrupt handling being preemptive, a large number of possible system behaviours are generated, which makes the correctness assurance of such systems difficult and costly. Model checking is considered to be one of the effective methods for exhausting behavioural state space for correctness. However, existing modelling approaches for interrupt-driven systems are based on either calculus or automata theory, and have a steep learning curve. To address this problem, we propose a new modelling language called interrupt sequence diagram (ISD). By extending the popular UML sequence diagram notations, the ISD supports the modelling of interrupts\' essential features visually and concisely. We also propose an automata-based semantics for ISD, based on which ISD can be transformed to a subset of hybrid automata so as to leverage the abundant off-the-shelf checkers. Experiments on examples from both real-world and existing literature were conducted, and the results demonstrate our approach\'s usability and effectiveness.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812085','10.1109/ICSE.2019.00037',40,0,'IEEE','IEEE Conferences',0),(149,'ProEva: Runtime Proactive Performance Evaluation Based on Continuous-Time Markov Chains',4,484,495,'Software systems, especially service-based software systems, need to guarantee runtime performance. If their performance is degraded, some reconfiguration countermeasures should be taken. However, there is usually some latency before the countermeasures take effect. It is thus important not only to monitor the current system status passively but also to predict its future performance proactively. Continuous-time Markov chains (CTMCs) are suitable models to analyze time-bounded performance metrics (e.g., how likely a performance degradation may occur within some future period). One challenge to harness CTMCs is the measurement of model parameters (i.e., transition rates) in CTMCs at runtime. As these parameters may be updated by the system or environment frequently, it is difficult for the model builder to provide precise parameter values. In this paper, we present a framework called ProEva, which extends the conventional technique of time-bounded CTMC model checking by admitting imprecise, interval-valued estimates for transition rates. The core method of ProEva computes asymptotic expressions and bounds for the imprecise model checking output. We also present an evaluation of accuracy and computational overhead for ProEva.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985687','10.1109/ICSE.2017.51',37,2,'IEEE','IEEE Conferences',0),(150,'How Good Is a Security Policy against Real Breaches? A HIPAA Case Study',4,530,540,'Policy design is an important part of software development. As security breaches increase in variety, designing a security policy that addresses all potential breaches becomes a nontrivial task. A complete security policy would specify rules to prevent breaches. Systematically determining which, if any, policy clause has been violated by a reported breach is a means for identifying gaps in a policy. Our research goal is to help analysts measure the gaps between security policies and reported breaches by developing a systematic process based on semantic reasoning. We propose SEMAVER, a framework for determining coverage of breaches by policies via comparison of individual policy clauses and breach descriptions. We represent a security policy as a set of norms. Norms (commitments, authorizations, and prohibitions) describe expected behaviors of users, and formalize who is accountable to whom and for what. A breach corresponds to a norm violation. We develop a semantic similarity metric for pairwise comparison between the norm that represents a policy clause and the norm that has been violated by a reported breach. We use the US Health Insurance Portability and Accountability Act (HIPAA) as a case study. Our investigation of a subset of the breaches reported by the US Department of Health and Human Services (HHS) reveals the gaps between HIPAA and reported breaches, leading to a coverage of 65%. Additionally, our classification of the 1,577 HHS breaches shows that 44% of the breaches are accidental misuses and 56% are malicious misuses. We find that HIPAA\'s gaps regarding accidental misuses are significantly larger than its gaps regarding malicious misuses.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985691','10.1109/ICSE.2017.55',41,1,'IEEE','IEEE Conferences',0),(151,'Safe Automated Refactoring for Intelligent Parallelization of Java 8 Streams',3,619,630,'Streaming APIs are becoming more pervasive in mainstream Object-Oriented programming languages. For example, the Stream API introduced in Java 8 allows for functional-like, MapReduce-style operations in processing both finite and infinite data structures. However, using this API efficiently involves subtle considerations like determining when it is best for stream operations to run in parallel, when running operations in parallel can be less efficient, and when it is safe to run in parallel due to possible lambda expression side-effects. In this paper, we present an automated refactoring approach that assists developers in writing efficient stream code in a semantics-preserving fashion. The approach, based on a novel data ordering and typestate analysis, consists of preconditions for automatically determining when it is safe and possibly advantageous to convert sequential streams to parallel and unorder or de-parallelize already parallel streams. The approach was implemented as a plug-in to the Eclipse IDE, uses the WALA and SAFE analysis frameworks, and was evaluated on 11 Java projects consisting of ?642K lines of code. We found that 57 of 157 candidate streams (36.31%) were refactorable, and an average speedup of 3.49 on performance tests was observed. The results indicate that the approach is useful in optimizing stream code to their full potential.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811925','10.1109/ICSE.2019.00072',76,0,'IEEE','IEEE Conferences',0),(152,'Scalable Approaches for Test Suite Reduction',3,419,429,'Test suite reduction approaches aim at decreasing software regression testing costs by selecting a representative subset from large-size test suites. Most existing techniques are too expensive for handling modern massive systems and moreover depend on artifacts, such as code coverage metrics or specification models, that are not commonly available at large scale. We present a family of novel very efficient approaches for similarity-based test suite reduction that apply algorithms borrowed from the big data domain together with smart heuristics for finding an evenly spread subset of test cases. The approaches are very general since they only use as input the test cases themselves (test source code or command line input). We evaluate four approaches in a version that selects a fixed budget B of test cases, and also in an adequate version that does the reduction guaranteeing some fixed coverage. The results show that the approaches yield a fault detection loss comparable to state-of-the-art techniques, while providing huge gains in terms of efficiency. When applied to a suite of more than 500K real world test cases, the most efficient of the four approaches could select B test cases (for varying B values) in less than 10 seconds.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812048','10.1109/ICSE.2019.00055',36,0,'IEEE','IEEE Conferences',0),(153,'NL2Type: Inferring JavaScript Function Types from Natural Language Information',3,304,315,'JavaScript is dynamically typed and hence lacks the type safety of statically typed languages, leading to suboptimal IDE support, difficult to understand APIs, and unexpected runtime behavior. Several gradual type systems have been proposed, e.g., Flow and TypeScript, but they rely on developers to annotate code with types. This paper presents NL2Type, a learning-based approach for predicting likely type signatures of JavaScript functions. The key idea is to exploit natural language information in source code, such as comments, function names, and parameter names, a rich source of knowledge that is typically ignored by type inference algorithms. We formulate the problem of predicting types as a classification problem and train a recurrent, LSTM-based neural model that, after learning from an annotated code base, predicts function types for unannotated code. We evaluate the approach with a corpus of 162,673 JavaScript files from real-world projects. NL2Type predicts types with a precision of 84.1% and a recall of 78.9% when considering only the top-most suggestion, and with a precision of 95.5% and a recall of 89.6% when considering the top-5 suggestions. The approach outperforms both JSNice, a state-of-the-art approach that analyzes implementations of functions instead of natural language information, and DeepTyper, a recent type prediction approach that is also based on deep learning. Beyond predicting types, NL2Type serves as a consistency checker for existing type annotations. We show that it discovers 39 inconsistencies that deserve developer attention (from a manual analysis of 50 warnings), most of which are due to incorrect type annotations.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811893','10.1109/ICSE.2019.00045',65,2,'IEEE','IEEE Conferences',0),(154,'Recommending and Localizing Change Requests for Mobile Apps Based on User Reviews',4,106,117,'Researchers have proposed several approaches to extract information from user reviews useful for maintaining and evolving mobile apps. However, most of them just perform automatic classification of user reviews according to specific keywords (e.g., bugs, features). Moreover, they do not provide any support for linking user feedback to the source code components to be changed, thus requiring a manual, time-consuming, and error-prone task. In this paper, we introduce CHANGEADVISOR, a novel approach that analyzes the structure, semantics, and sentiments of sentences contained in user reviews to extract useful (user) feedback from maintenance perspectives and recommend to developers changes to software artifacts. It relies on natural language processing and clustering algorithms to group user reviews around similar user needs and suggestions for change. Then, it involves textual based heuristics to determine the code artifacts that need to be maintained according to the recommended software changes. The quantitative and qualitative studies carried out on 44,683 user reviews of 10 open source mobile apps and their original developers showed a high accuracy of CHANGEADVISOR in (i) clustering similar user change requests and (ii) identifying the code components impacted by the suggested changes. Moreover, the obtained results show that ChangeAdvisor is more accurate than a baseline approach for linking user feedback clusters to the source code in terms of both precision (+47%) and recall (+38%).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985654','10.1109/ICSE.2017.18',63,20,'IEEE','IEEE Conferences',0),(155,'Active Inductive Logic Programming for Code Search',3,292,303,'Modern search techniques either cannot efficiently incorporate human feedback to refine search results or cannot express structural or semantic properties of desired code. The key insight of our interactive code search technique ALICE is that user feedback can be actively incorporated to allow users to easily express and refine search queries. We design a query language to model the structure and semantics of code as logic facts. Given a code example with user annotations, ALICE automatically extracts a logic query from code features that are tagged as important. Users can refine the search query by labeling one or more examples as desired (positive) or irrelevant (negative). ALICE then infers a new logic query that separates positive examples from negative examples via active inductive logic programming. Our comprehensive simulation experiment shows that ALICE removes a large number of false positives quickly by actively incorporating user feedback. Its search algorithm is also robust to user labeling mistakes. Our choice of leveraging both positive and negative examples and using nested program structure as an inductive bias is effective in refining search queries. Compared with an existing interactive code search technique, ALICE does not require a user to manually construct a search pattern and yet achieves comparable precision and recall with much fewer search iterations. A case study with real developers shows that ALICE is easy to use and helps express complex code patterns.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812091','10.1109/ICSE.2019.00044',66,1,'IEEE','IEEE Conferences',0),(156,'Challenges for Static Analysis of Java Reflection - Literature Review and Empirical Study',4,507,518,'The behavior of software that uses the Java Reflection API is fundamentally hard to predict by analyzing code. Only recent static analysis approaches can resolve reflection under unsound yet pragmatic assumptions. We survey what approaches exist and what their limitations are. We then analyze how real-world Java code uses the Reflection API, and how many Java projects contain code challenging state-of-the-art static analysis. Using a systematic literature review we collected and categorized all known methods of statically approximating reflective Java code. Next to this we constructed a representative corpus of Java systems and collected descriptive statistics of the usage of the Reflection API. We then applied an analysis on the abstract syntax trees of all source code to count code idioms which go beyond the limitation boundaries of static analysis approaches. The resulting data answers the research questions. The corpus, the tool and the results are openly available. We conclude that the need for unsound assumptions to resolve reflection is widely supported. In our corpus, reflection can not be ignored for 78% of the projects. Common challenges for analysis tools such as non-exceptional exceptions, programmatic filtering meta objects, semantics of collections, and dynamic proxies, widely occur in the corpus. For Java software engineers prioritizing on robustness, we list tactics to obtain more easy to analyze reflection code, and for static analysis tool builders we provide a list of opportunities to have significant impact on real Java code.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985689','10.1109/ICSE.2017.53',80,9,'IEEE','IEEE Conferences',0),(157,'RADAR: A Lightweight Tool for Requirements and Architecture Decision Analysis',4,552,562,'Uncertainty and conflicting stakeholders\' objectives make many requirements and architecture decisions particularly hard. Quantitative probabilistic models allow software architects to analyse such decisions using stochastic simulation and multi-objective optimisation, but the difficulty of elaborating the models is an obstacle to the wider adoption of such techniques. To reduce this obstacle, this paper presents a novel modelling language and analysis tool, called RADAR, intended to facilitate requirements and architecture decision analysis. The language has relations to quantitative AND/OR goal models used in requirements engineering and to feature models used in software product lines. However, it simplifies such models to a minimum set of language constructs essential for decision analysis. The paper presents RADAR\'s modelling language, automated support for decision analysis, and evaluates its application to four real-world examples.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985693','10.1109/ICSE.2017.57',46,2,'IEEE','IEEE Conferences',0),(158,'Towards Understanding and Reasoning About Android Interoperations',3,223,233,'Hybrid applications (apps) have become one of the most attractive options for mobile app developers thanks to its support for portability and device-specific features. Android hybrid apps, for example, support portability via JavaScript, device-specific features via Android Java, and seamless interactions between them. However, their interoperation semantics is often under-documented and unintuitive, which makes hybrid apps vulnerable to errors. While recent research has addressed such vulnerabilities, none of them are based on any formal grounds. In this paper, we present the first formal specification of Android interoperability to establish a firm ground for understanding and reasoning about the interoperations. We identify its semantics via extensive testing and thorough inspection of Android source code. We extend an existing multi-language semantics to formally express the key features of hybrid mechanisms, dynamic and indistinguishable interoperability. Based on the extensions, we incrementally define a formal interoperation semantics and disclose its numerous unintuitive and inconsistent behaviors. Moreover, on top of the formal semantics, we devise a lightweight type system that can detect bugs due to the unintuitive inter-language communication. We show that it detects more bugs more efficiently than HybriDroid, the state-of-the-art analyzer of Android hybrid apps, in real-world Android hybrid apps.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811927','10.1109/ICSE.2019.00038',25,1,'IEEE','IEEE Conferences',0),(159,'Software Documentation Issues Unveiled',3,1199,1210,'(Good) Software documentation provides developers and users with a description of what a software system does, how it operates, and how it should be used. For example, technical documentation (e.g., an API reference guide) aids developers during evolution/maintenance activities, while a user manual explains how users are to interact with a system. Despite its intrinsic value, the creation and the maintenance of documentation is often neglected, negatively impacting its quality and usefulness, ultimately leading to a generally unfavourable take on documentation. Previous studies investigating documentation issues have been based on surveying developers, which naturally leads to a somewhat biased view of problems affecting documentation. We present a large scale empirical study, where we mined, analyzed, and categorized 878 documentation-related artifacts stemming from four different sources, namely mailing lists, Stack Overflow discussions, issue repositories, and pull requests. The result is a detailed taxonomy of documentation issues from which we infer a series of actionable proposals both for researchers and practitioners.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811931','10.1109/ICSE.2019.00122',127,0,'IEEE','IEEE Conferences',0),(160,'On Reliability of Patch Correctness Assessment',3,524,535,'Current state-of-the-art automatic software repair (ASR) techniques rely heavily on incomplete specifications, or test suites, to generate repairs. This, however, may cause ASR tools to generate repairs that are incorrect and hard to generalize. To assess patch correctness, researchers have been following two methods separately: (1) Automated annotation, wherein patches are automatically labeled by an independent test suite (ITS) - a patch passing the ITS is regarded as correct or generalizable, and incorrect otherwise, (2) Author annotation, wherein authors of ASR techniques manually annotate the correctness labels of patches generated by their and competing tools. While automated annotation cannot ascertain that a patch is actually correct, author annotation is prone to subjectivity. This concern has caused an on-going debate on the appropriate ways to assess the effectiveness of numerous ASR techniques proposed recently. In this work, we propose to assess reliability of author and automated annotations on patch correctness assessment. We do this by first constructing a gold set of correctness labels for 189 randomly selected patches generated by 8 state-of-the-art ASR techniques through a user study involving 35 professional developers as independent annotators. By measuring inter-rater agreement as a proxy for annotation quality - as commonly done in the literature - we demonstrate that our constructed gold set is on par with other high-quality gold sets. We then compare labels generated by author and automated annotations with this gold set to assess reliability of the patch assessment methodologies. We subsequently report several findings and highlight implications for future studies.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812054','10.1109/ICSE.2019.00064',84,0,'IEEE','IEEE Conferences',0),(161,'How C++ Developers Use Immutability Declarations: An Empirical Study',3,362,372,'Best practices for developers, as encoded in recent programming language designs, recommend the use of immutability whenever practical. However, there is a lack of empirical evidence about the uptake of this advice. Our goal is to understand the usage of immutability by C++ developers in practice. This work investigates how C++ developers use immutability by analyzing their use of the C++ immutability qualifier, const, and by analyzing the code itself. We answer the following broad questions about const usage: 1) do developers actually write non-trivial (more than 3 methods) immutable classes and immutable methods? 2) do developers label their immutable classes and methods? We analyzed 7 medium-to-large open source projects and collected two sources of empirical data: 1) const annotations by developers, indicating an intent to write immutable code; and 2) the results of a simple static analysis which identified easily const-able methods---those that clearly did not mutate state. We estimate that 5% of non-trivial classes (median) are immutable. We found the vast majority of classes do carry immutability labels on methods: surprisingly, developers const-annotate 46% of methods, and we estimate that at least 51% of methods could be const-annotated. Furthermore, developers missed immutability labels on at least 6% of unannotated methods. We provide an in-depth discussion on how developers use const and the results of our analyses.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812125','10.1109/ICSE.2019.00050',18,0,'IEEE','IEEE Conferences',0),(162,'Software Development Waste',4,130,140,'Context: Since software development is a complex socio-technical activity that involves coordinating different disciplines and skill sets, it provides ample opportunities for waste to emerge. Waste is any activity that produces no value for the customer or user. Objective: The purpose of this paper is to identify and describe different types of waste in software development. Method: Following Constructivist Grounded Theory, we conducted a two-year five-month participant-observation study of eight software development projects at Pivotal, a software development consultancy. We also interviewed 33 software engineers, interaction designers, and product managers, and analyzed one year of retrospection topics. We iterated between analysis and theoretical sampling until achieving theoretical saturation. Results: This paper introduces the first empirical waste taxonomy. It identifies nine wastes and explores their causes, underlying tensions, and overall relationship to the waste taxonomy found in Lean Software Development. Limitations: Grounded Theory does not support statistical generalization. While the proposed taxonomy appears widely applicable, organizations with different software development cultures may experience different waste types. Conclusion: Software development projects manifest nine types of waste: building the wrong feature or product, mismanaging the backlog, rework, unnecessarily complex solutions, extraneous cognitive load, psychological distress, waiting/multitasking, knowledge loss, and ineffective communication.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985656','10.1109/ICSE.2017.20',30,10,'IEEE','IEEE Conferences',0),(163,'Decoding the Representation of Code in the Brain: An fMRI Study of Code Review and Expertise',4,175,186,'Subjective judgments in software engineering tasks are of critical importance but can be difficult to study with conventional means. Medical imaging techniques hold the promise of relating cognition to physical activities and brain structures. In a controlled experiment involving 29 participants, we examine code comprehension, code review and prose review using functional magnetic resonance imaging. We find that the neural representations of programming languages vs. natural languages are distinct. We can classify which task a participant is undertaking based solely on brain activity (balanced accuracy 79%, p <; 0.001). Further, we find that the same set of brain regions distinguish between code and prose (near-perfect correlation, r = 0.99, p <; 0.001). Finally, we find that task distinctions are modulated by expertise, such that greater skill predicts a less differentiated neural representation (r = -0.44, p = 0.016) indicating that more skilled participants treat code and prose more similarly at a neural activation level.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985660','10.1109/ICSE.2017.24',85,11,'IEEE','IEEE Conferences',0),(164,'Redundant Loads: A Software Inefficiency Indicator',3,982,993,'Modern software packages have become increasingly complex with millions of lines of code and references to many external libraries. Redundant operations are a common performance limiter in these code bases. Missed compiler optimization opportunities, inappropriate data structure and algorithm choices, and developers\' inattention to performance are some common reasons for the existence of redundant operations. Developers mainly depend on compilers to eliminate redundant operations. However, compilers\' static analysis often misses optimization opportunities due to ambiguities and limited analysis scope; automatic optimizations to algorithmic and data structural problems are out of scope. We develop LoadSpy, a whole-program profiler to pinpoint redundant memory load operations, which are often a symptom of many redundant operations. The strength of LoadSpy exists in identifying and quantifying redundant load operations in programs and associating the redundancies with program execution contexts and scopes to focus developers\' attention on problematic code. LoadSpy works on fully optimized binaries, adopts various optimization techniques to reduce its overhead, and provides a rich graphic user interface, which make it a complete developer tool. Applying LoadSpy showed that a large fraction of redundant loads is common in modern software packages despite highest levels of automatic compiler optimizations. Guided by LoadSpy, we optimize several well-known benchmarks and real-world applications, yielding significant speedups.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811970','10.1109/ICSE.2019.00103',81,1,'IEEE','IEEE Conferences',0),(165,'Global Optimization of Numerical Programs Via Prioritized Stochastic Algebraic Transformations',3,1131,1141,'Numerical code is often applied in the safety-critical, but resource-limited areas. Hence, it is crucial for it to be correct and efficient, both of which are difficult to ensure. On one hand, accumulated rounding errors in numerical programs can cause system failures. On the other hand, arbitrary/infinite-precision arithmetic, although accurate, is infeasible in practice and especially in resource-limited scenarios because it performs thousands of times slower than floating-point arithmetic. Thus, it has been a significant challenge to obtain high-precision, easy-to-maintain, and efficient numerical code. This paper introduces a novel global optimization framework to tackle this challenge. Using our framework, a developer simply writes the infinite-precision numerical program directly following the problem\'s mathematical requirement specification. The resulting code is correct and easy-to-maintain, but inefficient. Our framework then optimizes the program in a global fashion (i.e., considering the whole program, rather than individual expressions or statements as in prior work), the key technical difficulty this work solves. To this end, it analyzes the program\'s numerical value flows across different statements through a symbolic trace extraction algorithm, and generates optimized traces via stochastic algebraic transformations guided by effective rule selection. We first evaluate our technique on numerical benchmarks from the literature; results show that our global optimization achieves significantly higher worst-case accuracy than the state-of-the-art numerical optimization tool. Second, we show that our framework is also effective on benchmarks having complicated program structures, which are challenging for numerical optimization. Finally, we apply our framework on real-world code to successfully detect numerical bugs that have been confirmed by developers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812093','10.1109/ICSE.2019.00116',41,0,'IEEE','IEEE Conferences',0),(166,'Do Developers Read Compiler Error Messages?',4,575,585,'In integrated development environments, developers receive compiler error messages through a variety of textual and visual mechanisms, such as popups and wavy red underlines. Although error messages are the primary means of communicating defects to developers, researchers have a limited understanding on how developers actually use these messages to resolve defects. To understand how developers use error messages, we conducted an eye tracking study with 56 participants from undergraduate and graduate software engineering courses at our university. The participants attempted to resolve common, yet problematic defects in a Java code base within the Eclipse development environment. We found that: 1) participants read error messages and the difficulty of reading these messages is comparable to the difficulty of reading source code, 2) difficulty reading error messages significantly predicts participants\' task performance, and 3) participants allocate a substantial portion of their total task to reading error messages (13%-25%). The results of our study offer empirical justification for the need to improve compiler error messages for developers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985695','10.1109/ICSE.2017.59',38,6,'IEEE','IEEE Conferences',0),(167,'AdJust: Runtime Mitigation of Resource Abusing Third-Party Online Ads',3,1005,1015,'Online advertising is the most critical revenue stream for many Internet companies. However, showing ads on websites comes with a price tag. Since website contents and third-party ads are blended together, third-party ads may compete with the publisher contents, delaying or even breaking the rendering of first-party contents. In addition, dynamically including scripts from ad networks all over the world may introduce buggy scripts that slow down page loads and even freeze the browser. The resulting poor usability problems lead to bad user experience and lower profits. The problems caused by such resource abusing ads are originated from two root causes: First, content publishers have no control over third-party ads. Second, publishers cannot differentiate resource consumed by ads from that consumed by their own contents. To address these challenges, we propose an effective technique, AdJust, that allows publishers to specify constraints on events associated with third-party ads (e.g., URL requests, HTML element creations, and timers), so that they can mitigate user experience degradations and enforce consistent ads experience to all users. We report on a series of experiments over the Alexa top 200 news websites. The results point to the efficacy of our proposed techniques: AdJust effectively mitigated degradations that freeze web browsers (on 36 websites), reduced the load time of publisher contents (on 61 websites), prioritized publisher contents (on 166 websites) and ensured consistent rendering orders among top ads (on 68 websites).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811929','10.1109/ICSE.2019.00105',30,0,'IEEE','IEEE Conferences',0),(168,'9.6 Million Links in Source Code Comments: Purpose, Evolution, and Decay',3,1211,1221,'Links are an essential feature of the World Wide Web, and source code repositories are no exception. However, despite their many undisputed benefits, links can suffer from decay, insufficient versioning, and lack of bidirectional traceability. In this paper, we investigate the role of links contained in source code comments from these perspectives. We conducted a large-scale study of around 9.6 million links to establish their prevalence, and we used a mixed-methods approach to identify the links\' targets, purposes, decay, and evolutionary aspects. We found that links are prevalent in source code repositories, that licenses, software homepages, and specifications are common types of link targets, and that links are often included to provide metadata or attribution. Links are rarely updated, but many link targets evolve. Almost 10% of the links included in source code comments are dead. We then submitted a batch of link-fixing pull requests to open source software repositories, resulting in most of our fixes being merged successfully. Our findings indicate that links in source code comments can indeed be fragile, and our work opens up avenues for future work to address these problems.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811933','10.1109/ICSE.2019.00123',45,1,'IEEE','IEEE Conferences',0),(169,'Symbolic Repairs for GR(1) Specifications',3,1016,1026,'Unrealizability is a major challenge for GR(1), an expressive assume-guarantee fragment of LTL that enables efficient synthesis. Some works attempt to help engineers deal with unrealizability by generating counter-strategies or computing an unrealizable core. Other works propose to repair the unrealizable specification by suggesting repairs in the form of automatically generated assumptions. In this work we present two novel symbolic algorithms for repairing unrealizable GR(1) specifications. The first algorithm infers new assumptions based on the recently introduced JVTS. The second algorithm infers new assumptions directly from the specification. Both algorithms are sound. The first is incomplete but can be used to suggest many different repairs. The second is complete but suggests a single repair. Both are symbolic and therefore efficient. We implemented our work, validated its correctness, and evaluated it on benchmarks from the literature. The evaluation shows the strength of our algorithms, in their ability to suggest repairs and in their performance and scalability compared to previous solutions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812056','10.1109/ICSE.2019.00106',37,0,'IEEE','IEEE Conferences',0),(170,'The List is the Process: Reliable Pre-Integration Tracking of Commits on Mailing Lists',3,807,818,'A considerable corpus of research on software evolution focuses on mining changes in software repositories, but omits their pre-integration history. We present a novel method for tracking this otherwise invisible evolution of software changes on mailing lists by connecting all early revisions of changes to their final version in repositories. Since artefact modifications on mailing lists are communicated by updates to fragments (i.e., patches) only, identifying semantically similar changes is a non-trivial task that our approach solves in a language-independent way. We evaluate our method on high-profile open source software (OSS) projects like the Linux kernel, and validate its high accuracy using an elaborately created ground truth. Our approach can be used to quantify properties of OSS development processes, which is an essential requirement for using OSS in reliable or safety-critical industrial products, where certifiability and conformance to processes are crucial. The high accuracy of our technique allows, to the best of our knowledge, for the first time to quantitatively determine if an open development process effectively aligns with given formal process requirements.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812060','10.1109/ICSE.2019.00088',41,0,'IEEE','IEEE Conferences',0),(171,'DockerizeMe: Automatic Inference of Environment Dependencies for Python Code Snippets',3,328,338,'Platforms like Stack Overflow and GitHub\'s gist system promote the sharing of ideas and programming techniques via the distribution of code snippets designed to illustrate particular tasks. Python, a popular and fast-growing programming language, sees heavy use on both sites, with nearly one million questions asked on Stack Overflow and 400 thousand public gists on GitHub. Unfortunately, around 75% of the Python example code shared through these sites cannot be directly executed. When run in a clean environment, over 50% of public Python gists fail due to an import error for a missing library. We present DockerizeMe, a technique for inferring the dependencies needed to execute a Python code snippet without import error. DockerizeMe starts with offline knowledge acquisition of the resources and dependencies for popular Python packages from the Python Package Index (PyPI). It then builds Docker specifications using a graph-based inference procedure. Our inference procedure resolves import errors in 892 out of nearly 3,000 gists from the Gistable dataset for which Gistable\'s baseline approach could not find and install all dependencies.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811897','10.1109/ICSE.2019.00047',26,1,'IEEE','IEEE Conferences',0),(172,'Harnessing Evolution for Multi-Hunk Program Repair',3,13,24,'Despite significant advances in automatic program repair (APR) techniques over the past decade, practical deployment remains an elusive goal. One of the important challenges in this regard is the general inability of current APR techniques to produce patches that require edits in multiple locations, i.e., multi-hunk patches. In this work, we present a novel APR technique that generalizes single-hunk repair techniques to include an important class of multi-hunk bugs, namely bugs that may require applying a substantially similar patch at a number of locations. We term such sets of repair locations as evolutionary siblings - similar looking code, instantiated in similar contexts, that are expected to undergo similar changes. At the heart of our proposed method is an analysis to accurately identify a set of evolutionary siblings, for a given bug. This analysis leverages three distinct sources of information, namely the test-suite spectrum, a novel code similarity analysis, and the revision history of the project. The discovered siblings are then simultaneously repaired in a similar fashion. We instantiate this technique in a tool called HERCULES and demonstrate that it is able to correctly fix 46 bugs in the Defects4J dataset, the highest of any individual APR technique to date. This includes 15 multi-hunk bugs and overall 11 bugs which have not been fixed by any other technique so far.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812131','10.1109/ICSE.2019.00020',47,0,'IEEE','IEEE Conferences',0),(173,'From Diversity by Numbers to Diversity as Process: Supporting Inclusiveness in Software Development Teams with Brainstorming',4,152,163,'Negative experiences in diverse software development teams have the potential to turn off minority participants from future team-based software development activity. We examine the use of brainstorming as one concrete team processes that may be used to improve the satisfaction of minority developers when working in a group. Situating our study in time-intensive hackathon-like environments where engagement of all team members is particularly crucial, we use a combination of survey and interview data to test our propositions. We find that brainstorming strategies are particularly effective for team members who identify as minorities, and support satisfaction with both the process and outcomes of teamwork through different mechanisms.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985658','10.1109/ICSE.2017.22',47,4,'IEEE','IEEE Conferences',0),(174,'Socio-Technical Work-Rate Increase Associates With Changes in Work Patterns in Online Projects',3,936,947,'Software developers work on a variety of tasks ranging from the technical, e.g., writing code, to the social, e.g., participating in issue resolution discussions. The amount of work developers perform per week (their work-rate) also varies and depends on project needs and developer schedules. Prior work has shown that while moderate levels of increased technical work and multitasking lead to higher productivity, beyond a certain threshold, they can lead to lowered performance. Here, we study how increases in the short-term work-rate along both the technical and social dimensions are associated with changes in developers\' work patterns, in particular communication sentiment, technical productivity, and social productivity. We surveyed active and prolific developers on GitHub to understand the causes and impacts of increased work-rates. Guided by the responses, we developed regression models to study how communication and committing patterns change with increased work-rates and fit those models to large-scale data gathered from traces left by thousands of GitHub developers. From our survey and models, we find that most developers do experience work-rate-increase-related changes in behavior. Most notably, our models show that there is a sizable effect when developers comment much more than their average: the negative sentiment in their comments increases, suggesting an increased level of stress. Our models also show that committing patterns do not change with increased commenting, and vice versa, suggesting that technical and social activities tend not to be multitasked.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811968','10.1109/ICSE.2019.00099',58,0,'IEEE','IEEE Conferences',0),(175,'Search-Driven String Constraint Solving for Vulnerability Detection',4,198,208,'Constraint solving is an essential technique for detecting vulnerabilities in programs, since it can reason about input sanitization and validation operations performed on user inputs. However, real-world programs typically contain complex string operations that challenge vulnerability detection. State-of-the-art string constraint solvers support only a limited set of string operations and fail when they encounter an unsupported one, this leads to limited effectiveness in finding vulnerabilities. In this paper we propose a search-driven constraint solving technique that complements the support for complex string operations provided by any existing string constraint solver. Our technique uses a hybrid constraint solving procedure based on the Ant Colony Optimization meta-heuristic. The idea is to execute it as a fallback mechanism, only when a solver encounters a constraint containing an operation that it does not support. We have implemented the proposed search-driven constraint solving technique in the ACO-Solver tool, which we have evaluated in the context of injection and XSS vulnerability detection for Java Web applications. We have assessed the benefits and costs of combining the proposed technique with two state-of-the-art constraint solvers (Z3-str2 and CVC4). The experimental results, based on a benchmark with 104 constraints derived from nine realistic Web applications, show that our approach, when combined in a state-of-the-art solver, significantly improves the number of detected vulnerabilities (from 4.7% to 71.9% for Z3-str2, from 85.9% to 100.0% for CVC4), and solves several cases on which the solver fails when used stand-alone (46 more solved cases for Z3-str2, and 11 more for CVC4), while still keeping the execution time affordable in practice.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985662','10.1109/ICSE.2017.26',56,1,'IEEE','IEEE Conferences',0),(176,'Towards Automating Precision Studies of Clone Detectors',3,49,59,'Current research in clone detection suffers from poor ecosystems for evaluating precision of clone detection tools. Corpora of labeled clones are scarce and incomplete, making evaluation labor intensive and idiosyncratic, and limiting intertool comparison. Precision-assessment tools are simply lacking. We present a semiautomated approach to facilitate precision studies of clone detection tools. The approach merges automatic mechanisms of clone classification with manual validation of clone pairs. We demonstrate that the proposed automatic approach has a very high precision and it significantly reduces the number of clone pairs that need human validation during precision experiments. Moreover, we aggregate the individual effort of multiple teams into a single evolving dataset of labeled clone pairs, creating an important asset for software clone research.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811972','10.1109/ICSE.2019.00023',28,0,'IEEE','IEEE Conferences',0),(177,'CRADLE: Cross-Backend Validation to Detect and Localize Bugs in Deep Learning Libraries',3,1027,1038,'Deep learning (DL) systems are widely used in domains including aircraft collision avoidance systems, Alzheimer\'s disease diagnosis, and autonomous driving cars. Despite the requirement for high reliability, DL systems are difficult to test. Existing DL testing work focuses on testing the DL models, not the implementations (e.g., DL software libraries) of the models. One key challenge of testing DL libraries is the difficulty of knowing the expected output of DL libraries given an input instance. Fortunately, there are multiple implementations of the same DL algorithms in different DL libraries. Thus, we propose CRADLE, a new approach that focuses on finding and localizing bugs in DL software libraries. CRADLE (1) performs cross-implementation inconsistency checking to detect bugs in DL libraries, and (2) leverages anomaly propagation tracking and analysis to localize faulty functions in DL libraries that cause the bugs. We evaluate CRADLE on three libraries (TensorFlow, CNTK, and Theano), 11 datasets (including ImageNet, MNIST, and KGS Go game), and 30 pre-trained models. CRADLE detects 12 bugs and 104 unique inconsistencies, and highlights functions relevant to the causes of inconsistencies for all 104 unique inconsistencies.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812095','10.1109/ICSE.2019.00107',75,2,'IEEE','IEEE Conferences',0),(178,'AutoTap: Synthesizing and Repairing Trigger-Action Programs Using LTL Properties',3,281,291,'End-user programming, particularly trigger-action programming (TAP), is a popular method of letting users express their intent for how smart devices and cloud services interact. Unfortunately, sometimes it can be challenging for users to correctly express their desires through TAP. This paper presents AutoTap, a system that lets novice users easily specify desired properties for devices and services. AutoTap translates these properties to linear temporal logic (LTL) and both automatically synthesizes property-satisfying TAP rules from scratch and repairs existing TAP rules. We designed AutoTap based on a user study about properties users wish to express. Through a second user study, we show that novice users made significantly fewer mistakes when expressing desired behaviors using AutoTap than using TAP rules. Our experiments show that AutoTap is a simple and effective option for expressive end-user programming.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811900','10.1109/ICSE.2019.00043',41,0,'IEEE','IEEE Conferences',0),(179,'An Empirical Study on Mutation, Statement and Branch Coverage Fault Revelation That Avoids the Unreliable Clean Program Assumption',4,597,608,'Many studies suggest using coverage concepts, such as branch coverage, as the starting point of testing, while others as the most prominent test quality indicator. Yet the relationship between coverage and fault-revelation remains unknown, yielding uncertainty and controversy. Most previous studies rely on the Clean Program Assumption, that a test suite will obtain similar coverage for both faulty and fixed (\'clean\') program versions. This assumption may appear intuitive, especially for bugs that denote small semantic deviations. However, we present evidence that the Clean Program Assumption does not always hold, thereby raising a critical threat to the validity of previous results. We then conducted a study using a robust experimental methodology that avoids this threat to validity, from which our primary finding is that strong mutation testing has the highest fault revelation of four widely-used criteria. Our findings also revealed that fault revelation starts to increase significantly only once relatively high levels of coverage are attained.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985697','10.1109/ICSE.2017.61',57,14,'IEEE','IEEE Conferences',0),(180,'2nd International Workshop on Rapid Continuous Software Engineering (RCoSE 2015)',2,993,994,'Continuous software engineering refers to the organizational聽聽capability to develop, release and learn from software in very short聽聽rapid cycles, typically hours, days or a very small numbers of聽聽weeks.聽聽This requires not only agile processes in teams but in the聽聽complete research and development organization. Additionally, the聽聽technology used in the different development phases, like聽聽requirements engineering and system integration, must support the聽聽quick development cycles. Finally, automatic live experimentation聽聽for different system alternatives enables fast gathering of required聽聽data for decision making. The workshop, the second in the series聽聽after the first one at ICSE 2014, aims to bring the research聽聽communities of the aforementioned areas together to exchange聽聽challenges, ideas, and solutions to bring software engineering a聽聽step further to being a holistic continuous process. The workshop聽聽program is based on eight papers selected in the peer-review process聽聽and supplemented by interaction and discussions at the workshop. The聽聽topics range from agile methods, continuous software engineering聽聽practices to specific techniques, like visualization and testing.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203144','10.1109/ICSE.2015.343',8,2,'IEEE','IEEE Conferences',0),(181,'8th International Workshop on Search-Based Software Testing (SBST 2015)',2,1001,1002,'This paper is a report on the 8th International Workshop on Search-Based Software Testing at the 37th International Conference on Sofrware Engineering (ICSE). Search-Based Software Testing (SBST) is a form of Search-Based Software Engineering (SBSE) that optimizes testing through the use of computational search. SBST is used to generate test data, prioritize test cases, minimize test suites, reduce human oracle cost, verify software models, test service-orientated architectures, construct test suites for interaction testing, and validate real time properties. The objectives of this workshop are to bring together researchers and industrial practitioners from SBST and the wider software engineering community to share experience and provide directions for future research, and to encourage the use of search techniques to combine aspects of testing with other aspects of the software engineering lifecycle.Three full research papers, three short papers, and threeposition papers will be presented in the two-day workshop. Additionally, six development groups have pitted their test generation tools against a common set of programs and benchmarks, and will present their techniques and results. This report will give the background of the workshop and detail the provisional program.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203148','10.1109/ICSE.2015.323',3,1,'IEEE','IEEE Conferences',0),(182,'1st International Workshop on Software Protection (SPRO 2015)',2,1013,1014,'There are many reasons to protect software: your banking app needs to be protected to prevent fraud; software operating on critical infrastructures needs to be protected against vulnerability discovery; software vendors and service companies need it to protect their business; etc. In the past decade, many techniques to protect software have been presented and broken. Beyond making individual techniques better, the challenge includes to be able to deploy them in practice and be able to evaluate them. This is the objective of SPRO, the first International Workshop on Software Protection: to bring together researchers and industrial practitioners both from software protection and the wider software engineering community to share experience and provide directions for future research, in order to stimulate the use of software engineering techniques in novel aspects of software protection. This first edition of the workshop is held at ICSE 2015 in Florence (Italy) with the aim of creating a community working in this new growing area of security, and to highlight its synergies with different research fields of software engineering, like: formal models, program analysis, reverse engineering, code transformations, empirical evaluation, and software metrics. This paper presents the research themes and challenges of the workshop, describes the workshop organization, and summarizes the research papers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203154','10.1109/ICSE.2015.328',9,0,'IEEE','IEEE Conferences',0),(183,'5th International Workshop on the Twin Peaks of Requirements and Architecture (TwinPeaks 2015)',2,1017,1018,'The relationships and interdependencies between software requirements and the architectures of software-intensive systems are described in the Twin Peaks model. The fundamental idea of the Twin Peaks model is that Requirements Engineering and Software Architecture should not be treated in isolation. Instead, we need to progressively discover and specify requirements while concurrently exploring alternative architectural solutions. However, bridging the gap between Requirements Engineering and Software Architecture has mainly been discussed independently in the respective communities. Therefore, this ICSE workshop aims at bringing together researchers, practitioners and educators from the Requirements Engineering and Software Architecture fields to jointly explore the strong interdependencies between requirements and architecture. Based on the results from previous editions of the workshop, this edition focuses on agile software development contexts and on exploring lightweight techniques for integrating requirements and architectural thinking.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203156','10.1109/ICSE.2015.330',4,0,'IEEE','IEEE Conferences',0),(184,'10th International Workshop on Automation of Software Test (AST 2015)',2,963,964,'This paper is a report on The 10th IEEE/ACMInternational Workshop on Automation of Software Test (AST2015) at the 37th International Conference on Software Engineering(ICSE 2015). It sets a special theme on testing oracles.Keynote speeches and charette discussions are organized aroundthis special theme. 16 full research papers and 2 keynotes willbe presented in the two-day workshop. The report will give thebackground of the workshop and the selection of the specialtheme, and report on the organization of the workshop. Theprovisional program will be presented with a list of the sessionsand papers to be presented at the workshop.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203129','10.1109/ICSE.2015.307',0,0,'IEEE','IEEE Conferences',0),(185,'4th International Workshop on Games and Software Engineering (GAS 2015)',2,979,980,'We present a summary of the 4th ICSE Workshop on Games and Software Engineering. The full day workshop is planned to include a keynote speaker, game-jam demonstration session, and paper presentations on game software engineering topics related to software engineering education, frameworks for game development and infrastructure, quality assurance, and model-based game development. The accepted papers are overviewed here.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203137','10.1109/ICSE.2015.314',0,0,'IEEE','IEEE Conferences',0),(186,'4th International Workshop on Realizing AI Synergies in Software Engineering (RAISE 2015)',2,991,992,'This workshop is the fourth in the series and continued to build upon the work carried out at the previous iterations of the International Workshop on Realizing Artificial Intelligence Synergies in Software Engineering, which were held at ICSE in 2012, 2013 and 2014. RAISE 2015 brought together researchers and practitioners from the artificial intelligence (AI) and software engineering (SE) disciplines to build on the interdis- ciplinary synergies that exist and to stimulate further interaction across these disciplines. Mutually beneficial characteristics have appeared in the past few decades and are still evolving due to new challenges and technological advances. Hence, the question that motivates and drives the RAISE Workshop series is: \'Are SE and AI researchers ignoring important insights from AI and SE?\'. To pursue this question, RAISE\'15 explored not only the application of AI techniques to SE problems but also the application of SE techniques to AI problems. RAISE not only strengthens the AI- and-SE community but also continues to develop a roadmap of strategic research directions for AI and SE.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203143','10.1109/ICSE.2015.320',0,0,'IEEE','IEEE Conferences',0),(187,'3rd International Workshop on Software Engineering for Systems-of-Systems (SESoS 2015)',2,1011,1012,'Systems-of-Systems (SoS) refer to a new class of software-intensive systems, where their constituent systems work cooperatively in order to fulfill specific missions. Characterized by managerial and operational independence, geographic distribution, evolutionary development, and emergent behavior, SoS bring substantial challenges to the software engineering area. SESoS 2015, held in Florence, Italy, on May 17, 2015, as a joint workshop of the 37th International Conference on Software Engineering (ICSE), provided a forum to exchange ideas and experiences, analyze current research and development issues, discuss promising solutions, and to explore inspiring visions for the future of Software Engineering (SE) for SoS.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203153','10.1109/ICSE.2015.327',5,0,'IEEE','IEEE Conferences',0),(188,'1st International Workshop on TEchnical and LEgal aspects of data pRIvacy and Security (TELERISE 2015)',2,1015,1016,'This paper is the report on the 1st International Workshop on TEchnical and LEgal aspects of data pRIvacy and SEcurity (TELERISE 2015) at the 37th International Conference on Software Engineering (ICSE 2015). TELERISE investigates privacy and security issues in data sharing from a technical and legal perspective. Keynote speech as well as selected papers presented at the event fit the topics of the workshop. This report gives the rationale of TELERISE and it provides a provisional program.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203155','10.1109/ICSE.2015.329',3,0,'IEEE','IEEE Conferences',0),(189,'[Journal First] Model Comprehension for Security Risk Assessment: An Empirical Comparison of Tabular vs. Graphical Representations',1,395,395,'Context: Tabular and graphical representations are used to communicate security risk assessments for IT systems. However, there is no consensus on which type of representation better supports the comprehension of risks (such as the relationships between threats, vulnerabilities and security controls). Vessey\'s cognitive fit theory predicts that graphs should be better because they capture spatial relationships. Method: We report the results of two studies performed in two countries with 69 and 83 participants respectively, in which we assessed the effectiveness of tabular and graphical representations concerning the extraction of correct information about security risks. Results: Participants who applied tabular risk models gave more precise and complete answers to the comprehension questions when requested to find simple and complex information about threats, vulnerabilities, or other elements of the risk models. Conclusions: Our findings can be explained by Vessey\'s cognitive fit theory as tabular models implicitly capture elementary linear spatial relationships. Interest for ICSE: It is almost taken for granted in Software Engineering that graphical-, diagram-based models are \'the\' way to go (e.g., the SE Body of Knowledge). This paper provides some experimental-based doubts that this might not always be the case. It will provide an interesting debate that might ripple to traditional requirements and design notations outside security.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453097','10.1145/3180155.3182511',0,0,'IEEE','IEEE Conferences',0),(190,'Global-Aware Recommendations for Repairing Violations in Exception Handling',1,858,858,'This paper presents an extended abstract incorporated as a journalrst paper into the ICSE\'18 program.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453159','10.1145/3180155.3182539',0,1,'IEEE','IEEE Conferences',0),(191,'Poster: Static Analysis of Concurrent Higher-Order Programs',2,821,822,'Few static analyses support concurrent higher-order programs. Tools for detecting concurrency bugs such as deadlocks and race conditions are nonetheless invaluable to developers. Concurrency can be implemented using a variety of models, each supported by different synchronization primitives. Using this poster, we present an approach for analyzing concurrent higher-order programs in a precise manner through abstract interpretation. We instantiate the approach for two static analyses that are capable of detecting deadlocks and race conditions in programs that rely either on compare-and-swap (cas), or on conventional locks for synchronization. We observe few false positives and false negatives on a corpus of small concurrent programs, with better results for the lock-based analyses. We also observe that these programs lead to a smaller state space to be explored by the analyses. Our results show that the choice of synchronization primitives supported by an abstract interpreter has an important impact on the complexity of the static analyses performed with this abstract interpreter.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203086','10.1109/ICSE.2015.265',9,0,'IEEE','IEEE Conferences',0),(192,'Poster: Model-based Run-time Variability Resolution for Robotic Applications',2,829,830,'In this paper we present our ongoing work on Robotics Run-time Adaptation (RRA). RRA is a model-driven approach that addresses robotics runtime adaptation by modeling and resolving run-time variability of robotic applications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203090','10.1109/ICSE.2015.269',4,1,'IEEE','IEEE Conferences',0),(193,'Workshop on Applications of Human Error Research to Improve Software Engineering (WAHESE 2015)',2,1019,1020,'Advances in the psychological understanding of the origins and manifestations of human error have led to tremendous reductions in errors in fields such as medicine, aviation, and nuclear power plants. This workshop is intended to foster a better understanding of software engineering errors and how a psychological perspective can reduce them, improving software quality and reducing maintenance costs. The workshop goal is to develop a body of knowledge that can advance our understanding of the psychological processes (of human reasoning, planning, and problem solving) and how they fail during the software development. Applying human error research to software quality improvement will provide insights to the cognitive aspects of software development. The workshop will include interactive session to discuss common themes of errors in different fields, and structure software error information to detect and prevent software errors during the development.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203157','10.1109/ICSE.2015.353',15,0,'IEEE','IEEE Conferences',0),(194,'Analysis of Android Inter-App Security Vulnerabilities Using COVERT',2,725,728,'The state-of-the-art in securing mobile software systems are substantially intended to detect and mitigate vulnerabilities in a single app, but fail to identify vulnerabilities that arise due to the interaction of multiple apps, such as collusion attacks and privilege escalation chaining, shown to be quite common in the apps on the market. This paper demonstrates COVERT, a novel approach and accompanying tool-suite that relies on a hybrid static analysis and lightweight formal analysis technique to enable compositional security assessment of complex software. Through static analysis of Android application packages, it extracts relevant security specifications in an analyzable formal specification language, and checks them as a whole for inter-app vulnerabilities. To our knowledge, COVERT is the first formally-precise analysis tool for automated compositional analysis of Android apps. Our study of hundreds of Android apps revealed dozens of inter-app vulnerabilities, many of which were previously unknown.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203053','10.1109/ICSE.2015.233',14,16,'IEEE','IEEE Conferences',0),(195,'Exploration, Analysis, and Manipulation of聽聽Source Code Using srcML',2,951,952,'This technology briefing is intended for those interested in constructing custom software analysis and manipulation tools to support research or commercial applications. srcML (srcML.org) is an infrastructure consisting of an XML representation for C/C++/C#/Java source code along with efficient parsing technology to convert source code to-and-from the srcML format. The briefing describes srcML, the toolkit, and the application of XPath and XSLT to query and modify source code. Additionally, a hands-on tutorial of how to use srcML and XML tools to construct custom analysis and manipulation tools will be conducted.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203124','10.1109/ICSE.2015.302',4,2,'IEEE','IEEE Conferences',0),(196,'Poster: MAPP: The Berkeley Model and Algorithm Prototyping Platform',2,825,826,'We describe the Berkeley Model and Algorithm Prototyping Platform (MAPP), designed to facilitate experimentation with numerical algorithms and models. MAPP is written entirely in MATLAB and is available as open source under the GNU GPL.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203088','10.1109/ICSE.2015.267',7,1,'IEEE','IEEE Conferences',0),(197,'Poster: Software Development Risk Management: Using Machine Learning for Generating Risk Prompts',2,833,834,'Software risk management is a critical component of software development management. Due to the magnitude of potential losses, risk identification and mitigation early on become paramount. Lists containing hundreds of possible risk prompts are available both in academic literature as well as in practice. Given the large number of risks documented, scanning the lists for risks and pinning down relevant risks, though comprehensive, becomes impractical. In this work, a machine learning algorithm is developed to generate risk prompts, based on software project characteristics and other factors. The work also explores the utility of post-classification tagging of risks.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203092','10.1109/ICSE.2015.271',10,0,'IEEE','IEEE Conferences',0),(198,'Correctness and Relative Correctness',2,591,594,'In the process of trying to define what is a software fault, we have found that to formally define software faults we need to introduce the concept of relative correctness, i.e. the property of a program to be more-correct than another with respect to a given specification. A feature of a program is a fault (for a given specification)only because there exists an alternative to it that would make the program more-correct with respect to the specification.In this paper, we explore applications of the concept of relative correctness in program testing, program repair, and program design.Specifically, we argue that in many situations of software testing, fault removal and program repair, testing for relative correctness rather than absolute correctness leads to clearer conclusions and better outcomes. Also, we find that designing programs by stepwise correctness-enhancing transformations rather than by stepwise correctness-preserving refinements leads to simpler programs and is more tolerant of designer mistakes.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203020','10.1109/ICSE.2015.200',13,3,'IEEE','IEEE Conferences',0),(199,'Load Testing Large-Scale Software Systems',2,955,956,'Large-scale software systems (e.g., Amazon and Dropbox) must be load tested to ensure that they can service thousands or millions of concurrent requests every day. In this technical briefing, we will describe the state of research and practices in the area of load testing. We will focus on the techniques used in the three phases of a load test: (1) designing a load test, (2) executing a load test, and (3) analyzing the results of a load test. This technical briefing is targeted at load testing practitioners and software engineering researchers interested in testing and analyzing the behavior of large-scale software systems.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203126','10.1109/ICSE.2015.304',12,0,'IEEE','IEEE Conferences',0),(200,'1st International Workshop on Big Data Software Engineering (BIGDSE 2015)',2,965,966,'Big Data is about extracting valuable information from data in order to use it in intelligent ways such as to revolutionize decision-making in businesses, science and society. BIGDSE 2015 discusses the link between Big Data and software engineering and critically looks into issues such as cost-benefit of big data.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203130','10.1109/ICSE.2015.308',2,0,'IEEE','IEEE Conferences',0),(201,'Software Engineering in Ferrari F1',2,3,3,'Summary form only given. The software and hardware development in Ferrari F1 is characterized by a very short cycle time. Typically during the in-season development, the fixes and new developments need to be addressed in few days, in order to be ready for the following race. At the same time the hardware, like new electronic control units or new devices need to be developed from one year to the other. In this scenario the validation procedures are very critical, because of the need to achieve the same results in a shorter time.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194555','10.1109/ICSE.2015.22',0,1,'IEEE','IEEE Conferences',0),(202,'JRebel.Android: Runtime Class- and Resource Reloading for Android',2,741,744,'Developers writing Android applications suffer from a dreadful redeploy time every time they need to test changes to the source code. While runtime class reloading systems are widely used for the underlying programming language, Java, there is currently no support for reloading code on the Android platform. This paper presents a new tool, JRebel.Android that enables automatic runtime class- and resource reloading capabilities for Android. The target of this paper is the Android developer as well as the researcher for which dynamic updating capabilities on mobile devices can serve as a basic building block within areas such as runtime maintenance or self-adaptive systems. JRebel.Android is able to reload classes in much less than 1 second, saving more than 91% of the total redeploy time for small apps, more than 95% for medium size apps, and even more for larger apps.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203057','10.1109/ICSE.2015.337',11,0,'IEEE','IEEE Conferences',0),(203,'Fast and Precise Statistical Code Completion',2,757,759,'The main problem we try to solve is API code completion which is both precise and works in real-time. We describe an efficient implementation of an N-gram language model combined with several smoothing methods and a completion algorithm based on beam search. We show that our system is both fast and precise using a thorough experimental evaluation. With optimal parameters we are able to find completions in milliseconds and the desired completion is in the top 3 suggestions in 89% of the time.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203061','10.1109/ICSE.2015.240',16,0,'IEEE','IEEE Conferences',0),(204,'The Art and Science of Analyzing Software Data; Quantitative Methods',2,959,960,'Using the tools of quantitative data science, software engineers that can predict useful information on new projects based on past projects. This tutorial reflects on the state-of-the-art in quantitative reasoning in this important field. This tutorial discusses the following: (a) when local data is scarce, we show how to adapt data from other organizations to local problems; (b) when working with data of dubious quality, we show how to prune spurious information; (c) when data or models seem too complex, we show how to simplify data mining results; (d) when the world changes, and old models need to be updated, we show how to handle those updates; (e) when the effect is too complex for one model, we show to how reason over ensembles.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203128','10.1109/ICSE.2015.306',4,2,'IEEE','IEEE Conferences',0),(205,'8th International Workshop on Cooperative and Human Aspects of Software Engineering (CHASE 2015)',2,969,970,'Software is created for and with a wide range of stakeholders, from customers to management, from value-added providers to customer service personnel. These stakeholders work with teams of software engineers to develop and evolve software systems that support their activities. All of these people and their interactions are central to software development. Thus, it is crucial to investigate the dynamic and frequently changing Cooperative and Human Aspects of Software Engineering (CHASE), both before and after deployment, in order to understand current software practices, processes, and tools. In turn, this enables us to design tools and support mechanisms that improve software creation, software maintenance, and customer communication.Researchers and practitioners have long recognized the need to investigate these aspects, however, their articles are scattered across conferences and communities. This workshop will provide a unified forum for discussing high quality research studies, models, methods, and tools for human and cooperative aspects of software engineering. This will be the 8th in a series of workshops, which continue to be a meeting place for the academic, industrial, and practitioner communities interested in this area, and will give opportunities to present and discuss works-in-progress.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203132','10.1109/ICSE.2015.309',0,0,'IEEE','IEEE Conferences',0),(206,'Smart Programming Playgrounds',2,607,610,'Modern IDEs contain sophisticated components for inferring missing types, correcting bad syntax and completing partial expressions in code, but they are limited to the context that is explicitly defined in a project\'s configuration. These tools are ill-suited for quick prototyping of incomplete code snippets, such as those found on the Web in Q&A forums or walk-through tutorials, since such code snippets often assume the availability of external dependencies and may even contain implicit references to an execution environment that provides data or compute services. We propose an architecture for smart programming playgrounds that can facilitate rapid prototyping of incomplete code snippets through a semi-automatic context resolution that involves identifying static dependencies, provisioning external resources on the cloud and injecting resource bindings to handles in the original code fragment. Such a system could be potentially useful in a range of different scenarios, from sharing code snippets on the Web to experimenting with new ideas during traditional software development.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203024','10.1109/ICSE.2015.204',12,0,'IEEE','IEEE Conferences',0),(207,'Mining Temporal Properties of Data Invariants',2,751,753,'System specifications are important in maintaining program correctness, detecting bugs, understanding systems and guiding test case generation. Often, these specifications are not explicitly written by developers. If we want to use them for analysis, we need to obtain them through other methods; for example, by mining them out of program behavior. Several tools exist to mine data invariants and temporal properties from program traces, but few examine the temporal relationships between data invariants. An example of this kind of relationship would be \'the return value of the method isFull? is false until the field size reaches the value capacity\'. We propose a data-temporal property miner, Quarry, which mines Linear Temporal Logic (LTL) relations of arbitrary length and complexity between Daikon-style data invariants. We infer data invariants from systems using Daikon, recompose these data invariants into sequences, and mine temporal properties over these sequences. Our preliminary results suggest that this method may recover important system properties.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203059','10.1109/ICSE.2015.238',21,2,'IEEE','IEEE Conferences',0),(208,'Enabling Testing of Android Apps',2,763,765,'Existing approaches for automated testing of An- droid apps are designed to achieve different goals and exhibit some pros and cons that should be carefully considered by developers and testers. For instance, random testing (RT) provides a high ratio of infeasible inputs or events, and test cases generated with RT and systematic exploration-based testing (SEBT) are not representative of natural (i.e., real) application usage scenarios. In addition, collecting test scripts for automated testing is expensive. We address limitations of existing tools for GUI-based testing of Android apps in a novel hybrid approach called T+. Our approach is based on a novel framework, which is aimed at generating actionable test cases for different testing goals. The framework also enables GUI-based testing without expensive test scripts collection for the stakeholders.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203063','10.1109/ICSE.2015.242',14,6,'IEEE','IEEE Conferences',0),(209,'2nd International Workshop on Context for Software Development (CSD 2015)',2,973,974,'The goal of this one-day workshop is to bring together researchers interested in techniques and tools that leverage context information that accumulates around development activities. Developers continuously make use of context to make decisions, coordinate their work, understand the purpose behind their tasks, and understand how their tasks fit with the rest of the project. However, there is little research on defining what context is, how we can model it, and how we can use those models to better support software development at large. This workshop brings together scholars interested in identifying, gathering and modelling context information in software development, as well as discussing its applications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203134','10.1109/ICSE.2015.311',3,0,'IEEE','IEEE Conferences',0),(210,'Code Repurposing as an Assessment Tool',2,295,298,'Code repurposing is often used for system development and to learn both APIs and techniques. Repurposing code typically requires that you understand the code first. This makes it an excellent candidate as an assessment tool in computer science and software engineering education. This technique might have a special application in combatting plagiarism. This paper discusses experiences using code repurposing as an assessment tool in different courses and with different sections.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202975','10.1109/ICSE.2015.158',7,2,'IEEE','IEEE Conferences',0),(211,'Qualitative Analysis of Knowledge Transfer in Pair Programming',2,855,858,'Knowledge transfer in the context of pair programming is both a desired effect and a necessary precondition. There is no detailed understanding yet of how effective and efficient knowledge transfer in this particular context actually works. My qualitative research is concerned with the analysis of professional software developer\'s sessions to capture their specific knowledge transfer skill in the form of comprehensible, relevant, and practical patterns.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203098','10.1109/ICSE.2015.277',16,1,'IEEE','IEEE Conferences',0),(212,'Evolution-Aware Monitoring-Oriented Programming',2,615,618,'Monitoring-Oriented Programming (MOP) helps develop more reliable software by means of monitoring against formal specifications. While MOP showed promising results, all prior research has focused on checking a single version of software. We propose to extend MOP to support multiple software versions and thus be more relevant in the context of rapid software evolution. Our approach, called eMOP, is inspired by regression test selection -- a well studied, evolution-centered technique. The key idea in eMOP is to monitor only the parts of code that changed between versions. We illustrate eMOP by means of a running example, and show the results of preliminary experiments. eMOP opens up a new line of research on MOP -- it can significantly improve usability and performance when applied across multiple versions of software and is complementary to algorithmic MOP advances on a single version.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203026','10.1109/ICSE.2015.206',23,4,'IEEE','IEEE Conferences',0),(213,'Commit Bubbles',2,631,634,'Developers who use version control are expected to produce systematic commit histories that show well-defined steps with logical forward progress. Existing version control tools assume that developers also write code systematically. Unfortunately, the process by which developers write source code is often evolutionary, or as-needed, rather than systematic. Our contribution is a fragment-oriented concept called Commit Bubbles that will allow developers to construct systematic commit histories that adhere to version control best practices with less cognitive effort, and in a way that integrates with their as-needed coding workflows.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203030','10.1109/ICSE.2015.210',22,3,'IEEE','IEEE Conferences',0),(214,'Towards Model Driven Architecture and Analysis of System of Systems Access Control',2,867,870,'Nowadays there is growing awareness of the importance of Systems of Systems (SoS) which are large-scale systems composed of complex systems. SoS possess specific properties when compared with monolithic complex systems, in particular: operational independence, managerial independence, evolutionary development, emergent behavior and geographic distribution. One of the current main challenges is the impact of these properties on SoS security modeling and analysis. In this research proposal, we introduce a new method incorporating a process, a language and a software architectural tool to model, analyze and predict security architectural alternatives of SoS. Thus security will be taken into account as soon as possible in the life cycle of the SoS, making it less expensive.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203101','10.1109/ICSE.2015.280',19,3,'IEEE','IEEE Conferences',0),(215,'Textual Analysis for Code Smell Detection',2,769,771,'The negative impact of smells on the quality of a software systems has been empirical investigated in several studies. This has recalled the need to have approaches for the identification and the removal of smells. While approaches to remove smells have investigated the use of both structural and conceptual information extracted from source code, approaches to identify smells are based on structural information only. In this paper, we bridge the gap analyzing to what extent conceptual information, extracted using textual analysis techniques, can be used to identify smells in source code. The proposed textual-based approach for detecting smells in source code, coined as TACO (Textual Analysis for Code smell detectiOn), has been instantiated for detecting the Long Method smell and has been evaluated on three Java open source projects. The results indicate that TACO is able to detect between 50% and 77% of the smell instances with a precision ranging between 63% and 67%. In addition, the results show that TACO identifies smells that are not identified by approaches based on solely structural information.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203065','10.1109/ICSE.2015.244',32,7,'IEEE','IEEE Conferences',0),(216,'7th International Workshop on Modeling in Software Engineering (MiSE 2015)',2,985,986,'Models are an important tool in conquering the increasing complexity of modern software systems. Key industries are strategically directing their development environments towards more extensive use of modeling techniques. MiSE 2015 aimed to understand, through critical analysis, the current and future uses of models in the engineering of software-intensive systems. The MiSE workshop series has proven to be an effective forum for discussing modeling techniques from both the MDE and software engineering perspectives. An important goal of this workshop is to foster exchange between these two communities. In 2015 the focus was on considering the current state of tool support and the challenges that need to be addressed to improve the maturity of tools. There was also analysis of successful applications of modeling techniques in specific application domains, with attempts to determine how the participants\' experiences can be carried over to other domains.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203140','10.1109/ICSE.2015.317',0,0,'IEEE','IEEE Conferences',0),(217,'Optimising Energy Consumption of Design Patterns',2,623,626,'Software design patterns are widely used in software engineering to enhance productivity and maintainability.However, recent empirical studies revealed the high energy overhead in these patterns. Our vision is to automatically detect and transform design patterns during compilation for better energy efficiency without impacting existing coding practices. In this paper, we propose compiler transformations for two design patterns, Observer and Decorator, and perform an initial evaluation of their energy efficiency.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203028','10.1109/ICSE.2015.208',20,15,'IEEE','IEEE Conferences',0),(218,'Safe Evolution Patterns for Software Product Lines',2,875,878,'Despite a global recognition of the problem, and massive investment from researchers and practitioners, the evolution of complex software systems is still a major challenge for today\'s architects and developers. In the context of product lines, or highly configurable systems, variability in the implementation and design makes many of the pre-existing challenges even more difficult to tackle. Many approaches and tools have been designed, but developers still miss the tools and methods enabling safe evolution of complex, variable systems. In this paper, we present our research plans toward this goal: making the evolution of software product lines safer. We show, by use of two concrete examples of changes that occurred in Linux, that simple heuristics can be applied to facilitate change comprehension and avoid common mistakes, without relying on heavy tooling. Based on those observations, we present the steps we intend to take to build a framework to regroup and classify changes, run simple checks, and eventually increase the quality of code deliveries affecting the variability model, mapping and implementation of software product lines.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203103','10.1109/ICSE.2015.282',17,0,'IEEE','IEEE Conferences',0),(219,'Understanding Conflicts Arising from Collaborative Development',2,775,777,'When working in a collaborative development environment, developers implement tasks separately. Consequently, during the integration process, one might have to deal with conflicting changes. Previous studies indicate that conflicts occur frequently and impair developers\' productivity. Such evidence motivates the development of tools that try to tackle this problem. However, despite the existing evidence, there are still many unanswered questions. The goal of this research is to investigate conflict characteristics in practice through empirical studies and use this body of knowledge to improve strategies that support software developers working collaboratively.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203067','10.1109/ICSE.2015.246',8,1,'IEEE','IEEE Conferences',0),(220,'Post-Dominator Analysis for Precisely Handling Implicit Flows',2,787,789,'Most web applications today use JavaScript for including third-party scripts, advertisements etc., which pose a major security threat in the form of confidentiality and integrity violations. Dynamic information flow control helps address this issue of information stealing. Most of the approaches over-approximate when unstructured control flow comes into picture, thereby raising a lot of false alarms. We utilize the post-dominator analysis technique to determine the context of the program at a given point and prove that this approach is the most precise technique to handle implicit flows.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203071','10.1109/ICSE.2015.250',13,0,'IEEE','IEEE Conferences',0),(221,'4th International Workshop on Green and Sustainable Software (GREENS 2015)',2,981,982,'Engineering green software-intensive systems is critical in our drive towards a sustainable, smarter planet. The goal of green software engineering is to apply green principles to the design and operation of software-intensive systems. Green and self-greening software systems have tremendous potential to decrease energy consumption. Moreover, enterprise software can and should be re-thought to address sustainability issues using innovative business models, processes, and incentives. Monitoring and measuring the greenness of software is critical towards the notion of sustainable and green software. Demonstrating improvement is paramount for users to achieve and affect change. Thus, the theme of GREENS 2015 is Towards a Green Software Body of Knowledge. The GREENS workshop series brings together researchers and practitioners to discuss both the state-of-the-art and state-of-the-practice in green software, including novel ideas, research challenges, methods, experiences, and tools to support the engineering of sustainable and energy efficient software systems.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203138','10.1109/ICSE.2015.315',0,0,'IEEE','IEEE Conferences',0),(222,'5th International Workshop on Product LinE Approaches in Software Engineering PLE for a Sustainable Society (PLEASE 2015)',2,989,990,'This paper summarizes the motivation, objectives, and format of the 5th International Workshop on Product LinE Approaches in Software Engineering (PLEASE15). The main goal of the PLEASE workshop series is to encourage and promote the adoption of Software Product Line Engineering. This year\'s edition focuses on the link between software product line engineering (SPLE) and new challenges posed by emerging societal trends. Towards this end, we invited reports on (1) opportunities posed by societal challenges for SPLE research and practice and (2) concrete solutions exemplifying application of SPLE techniques to societal challenges.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203142','10.1109/ICSE.2015.319',5,0,'IEEE','IEEE Conferences',0),(223,'Towards a Practical Security Analysis Methodology',2,883,886,'The research community has proposed numerous techniques to perform security-oriented analyses based on a software design model. Such a formal analysis can provide precise security guarantees to the software designer, and facilitate the discovery of subtle flaws. Nevertheless, using such techniques in practice poses a big challenge for the average software designer, due to the narrow scope of each technique, the heterogeneous set of modelling languages that are required, and the analysis results that are often hard to interpret. Within the course of our research, we intend to provide practitioners with an integrated, easy-to-use modelling and analysis environment that enables them to work on a broad range of common security concerns without leaving the software design\'s level of abstraction.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203105','10.1109/ICSE.2015.283',24,0,'IEEE','IEEE Conferences',0),(224,'Code Reviews Do Not Find Bugs. How the Current Code Review Best Practice Slows Us Down',2,27,28,'Because of its many uses and benefits, code reviews are a standard part of the modern software engineering workflow. Since they require involvement of people, code reviewing is often the longest part of the code integration activities. Using experience gained at Microsoft and with support of data, we posit (1) that code reviews often do not find functionality issues that should block a code submission; (2) that effective code reviews should be performed by people with specific set of skills; and (3) that the social aspect of code reviews cannot be ignored. We find that we need to be more sophisticated with our guidelines for the code review workflow. We show how our findings from code reviewing practice influence our code review tools at Microsoft. Finally, we assert that, due to its costs, code reviewing practice is a topic deserving to be better understood, systematized and applied to software engineering workflow with more precision than the best practice currently prescribes.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202946','10.1109/ICSE.2015.131',6,15,'IEEE','IEEE Conferences',0),(225,'Deep Representations for Software Engineering',2,781,783,'Deep learning subsumes algorithms that automatically learn compositional representations. The ability of these models to generalize well has ushered in tremendous advances in many fields. We propose that software engineering (SE) research is a unique opportunity to use these transformative approaches. Our research examines applications of deep architectures such as recurrent neural networks and stacked restricted Boltzmann machines to SE tasks.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203069','10.1109/ICSE.2015.248',45,1,'IEEE','IEEE Conferences',0),(226,'Poster: Static Detection of Configuration-Dependent Bugs in Configurable Software',2,795,796,'Configurable software systems enable developers to configure at compile time a single variant of the system to tailor it towards specific environments and features. Although traditional static analysis tools can assist developers in software development and maintenance, they can only run on a concrete configuration of a configurable software system. Thus, it is necessary to derive many configurations so that the configuration-specific parts of the source code can be checked. To avoid this tedious and error-prone process, we propose an approach to automatically derive a set of configurations that cover as many combinations of configuration-specific blocks of code or source files as possible. We represent a C program with CPP directives (e.g., #ifdef) with a CPP control-flow graph (CPP-CFG) in which CPP expressions are condition nodes and #ifdef blocks are statement nodes. We then explore possible paths on CPP-CFG with dynamic symbolic execution and depth-first search algorithms, and correspondingly, producing possible combinations of concrete blocks of C code, on which an existing static analysis tool can run. Our preliminary evaluation on a benchmark of configuration-dependent bugs on Linux shows that our approach can detect more bugs than a state-of-the-art tool.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203073','10.1109/ICSE.2015.252',4,0,'IEEE','IEEE Conferences',0),(227,'Bootstrapping Mobile App Development',2,657,660,'Modern IDEs provide limited support for developers when starting a new data-driven mobile app. App developers are currently required to write copious amounts of boilerplate code, scripts, organise complex directories, and author actual functionality. Although this scenario is ripe for automation, current tools are yet to address it adequately. In this paper we present RAPPT, a tool that generates the scaffolding of a mobile app based on a high level description specified in a Domain Specific Language (DSL). We demonstrate the feasibility of our approach by an example case study and feedback from a professional development team. Demo at: https://www.youtube.com/watch?v=ffquVgBYpLM.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203036','10.1109/ICSE.2015.216',11,10,'IEEE','IEEE Conferences',0),(228,'scvRipper: Video Scraping Tool for Modeling Developers\' Behavior Using Interaction Data',2,673,676,'Screen-capture tool can record a user\'s interaction with software and application content as a stream of screenshots which is usually stored in certain video format. Researchers have used screen-captured videos to study the programming activities that the developers carry out. In these studies, screen-captured videos had to be manually transcribed to extract software usage and application content data for the study purpose. This paper presents a computer-vision based video scraping tool (called scvRipper) that can automatically transcribe a screen-captured video into time-series interaction data according to the analyst\'s need. This tool can address the increasing need for automatic behavioral data collection methods in the studies of human aspects of software engineering.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203040','10.1109/ICSE.2015.220',16,3,'IEEE','IEEE Conferences',0),(229,'Mining Patterns of Sensitive Data Usage',2,891,894,'When a user downloads an Android application from a market, she does not know much about its actual behavior. A brief description, a set of screenshots, and the list of permissions, which give a high level intuition of what the application might be doing, are all the user sees before installing and running the application on his device. These elements are not enough to decide whether the application is secure, and for sure they do not indicate whether it might violate the user\'s privacy by leaking some sensitive data. The goal of my thesis is to employ both static and dynamic taint analyses to gather information on how Android applications use sensitive data. The main hypothesis of this work is that malicious and benign mobile applications differ in how they use sensitive data, and consequently information flow can be used effectively to identify malware.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203107','10.1109/ICSE.2015.285',14,1,'IEEE','IEEE Conferences',0),(230,'A Declarative Foundation for Comprehensive History Querying',2,907,910,'Researchers in the field of Mining Software Repositories perform studies about the evolution of software projects. To this end, they use the version control system storing the changes made to a single software project. Such studies are concerned with the source code characteristics in one particular revision, the commit data for that revision, how the code evolves over time and what concrete, fine-grained changes were applied to the source code between two revisions. Although tools exist to analyse an individual concern, scripts and manual work is required to combine these tools to perform a single experiment. We present a general-purpose history querying tool named QwalKeko that enables expressing these concerns in a single uniform language, and having them detected in a git repository. We have validated our work by means of replication studies as well as through MSR studies of our own.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203111','10.1109/ICSE.2015.289',19,3,'IEEE','IEEE Conferences',0),(231,'Poster: Interactive and Collaborative Source Code Annotation',2,799,800,'Software documentation plays an important role in sharing the knowledge behind source code between distributed programmers. Good documentation makes source code easier to understand; on the other hand, developers have to constantly update the documentation whenever the source code changes. Developers will benefit from an automated tool that simplifies keeping documentation up-to-date and facilitates collaborative editing. In this paper, we explore the concept of collaborative code annotation by combining the idea from crowdsourcing. We introduce Cumiki, a web-based collaborative annotation tool that makes it easier for crowds of developers to collaboratively create the up-to-date documentation. This paper describes the user interface, the mechanism, and its implementation, and discusses the possible usage scenarios.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203075','10.1109/ICSE.2015.254',7,2,'IEEE','IEEE Conferences',0),(232,'2nd International Workshop on Requirements Engineering and Testing (RET 2015)',2,997,998,'The RET (Requirements Engineering and Testing) workshop provides a meeting point for researchers and practitioners from the two separate fields of Requirements Engineering (RE) and Testing. The goal is to improve the connection and alignment of these two areas through an exchange of ideas, challenges, practices, experiences and results. The long term aim is to build a community and a body of knowledge within the intersection of RE and Testing. One of the main outputs of the 1st workshop was a collaboratively constructed map of the area of RET showing the topics relevant to RET for these. The 2nd workshop will continue in the same interactive vein and include a keynote, paper presentations with ample time for discussions, and a group exercise. For true impact and relevance this cross-cutting area requires contribution from both RE and Testing, and from both researchers and practitioners. For that reason we welcome a range of paper contributions from short experience papers to full research papers that both clearly cover connections between the two fields.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203146','10.1109/ICSE.2015.351',4,1,'IEEE','IEEE Conferences',0),(233,'2nd International Workshop on Software Engineering Methods in Spreadsheets (SEMS 2015)',2,1005,1006,'Spreadsheets are heavily used in industry, becausethey are easily written and adjusted, using an intuitive visual interface. They often start out as simple tools; however, over time spreadsheets can become increasingly complex, up to the point where they become complicated and inflexible. In many ways, spreadsheet are similar to software: both concern the storage and manipulation of data and the presentation of results to the user. Because of this similarity, many methods and techniques from software engineering can be applied to spreadsheets. The role of SEMS, the International Workshop on Software Engineering Methods in Spreadsheets is to explore the possibilities of applying successful methods from software engineering to spreadsheets. Some, like testing and visualization, have been tried before and can be built upon. For methods that have not yet been tried on spreadsheets, SEMS will serve as a platform for early feedback. The SEMS program included an industrial keynote, \'spreadsheet stories\' (success or failure), short and long research papers,a good mix of industrial and academic researchers, as well as lively discussion and debate.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203150','10.1109/ICSE.2015.325',0,0,'IEEE','IEEE Conferences',0),(234,'The ECCO Tool: Extraction and Composition for Clone-and-Own',2,665,668,'Software reuse has become mandatory for companies to compete and a wide range of reuse techniques are available today. However, ad hoc practices such as copying existing systems and customizing them to meet customer-specific needs are still pervasive, and are generically called clone-and-own. We have developed a conceptual framework to support this practice named ECCO that stands for Extraction and Composition for Clone-and-Own. In this paper we present our Eclipse-based tool to support this approach. Our tool can automatically locate reusable parts from previously developed products and subsequently compose a new product from a selection of desired features. The tools demonstration video can be found here: http://youtu.be/N6gPekuxU6o.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203038','10.1109/ICSE.2015.218',9,12,'IEEE','IEEE Conferences',0),(235,'Automated Program Repair in an Integrated Development Environment',2,681,684,'We present the integration of the AutoFix automated program repair technique into the EiffelStudio Development Environment. AutoFix presents itself like a recommendation system capable of automatically finding bugs and suggesting fixes in the form of source-code patches. Its performance suggests usage scenarios where it runs in the background or during work interruptions, displaying fix suggestions as they become available. This is a contribution towards the vision of semantic Integrated Development Environments, which offer powerful automated functionality within interfaces familiar to developers. A screencast highlighting the main features of AutoFix can be found at: http://youtu.be/Ff2ULiyL-80.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203042','10.1109/ICSE.2015.222',12,5,'IEEE','IEEE Conferences',0),(236,'Towards Generation of Software Development Tasks',2,915,918,'The presence of well defined fine-grained sub-tasks is important to the development process: having a fine-grained task context has been shown to allow developers to more efficiently resume work. However, determining how to break a high level task down into sub-tasks is not always straightforward. Sometimes developers lack experience, and at other times, the task definition is not clear enough to afford confident decomposition. In my research I intend to show that by using syntactic mining of past task descriptions and their decomposition, I can provide automatically derived sub-task suggestions to afford more confident task decomposition by developers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203113','10.1109/ICSE.2015.291',16,0,'IEEE','IEEE Conferences',0),(237,'Poster: Filtering Code Smells Detection Results',2,803,804,'Many tools for code smell detection have been developed, providing often different results. This is due to the informal definition of code smells and to the subjective interpretation of them. Usually, aspects related to the domain, size, and design of the system are not taken into account when detecting and analyzing smells. These aspects can be used to filter out the noise and achieve more relevant results. In this paper, we propose different filters that we have identified for five code smells. We provide two kind of filters, Strong and Weak Filters, that can be integrated as part of a detection approach.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203077','10.1109/ICSE.2015.256',3,8,'IEEE','IEEE Conferences',0),(238,'Poster: Automatically Fixing Real-World JavaScript Performance Bugs',2,811,812,'Programs often suffer from poor performance that can be fixed by relatively simple changes. Currently, developers either manually identify and fix such performance problems, or they rely on compilers to optimize their code. Unfortunately, manually fixing performance bugs is non-trivial, and compilers are limited to a predefined set of optimizations. This paper presents an approach for automatically finding and fixing performance bugs in JavaScript programs. To focus our work on relevant problems, we study 37 real-world performance bug fixes from eleven popular JavaScript projects and identify several recurring fix patterns. Based on the results of the study, we present a static analysis that identifies occurrences of common fix patterns and a fix generation technique that proposes to transform a given program into a more efficient program. Applying the fix generation technique to three libraries with known performance bugs yields fixes that are equal or equivalent to those proposed by the developers, and that lead to speedups between 10% and 25%.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203081','10.1109/ICSE.2015.260',6,2,'IEEE','IEEE Conferences',0),(239,'1st International Workshop on Software Engineering for Smart Cyber-Physical Systems (SEsCPS 2015)',2,1009,1010,'Cyber-physical system (CPS) have been recognized as a top-priority in research and development. The innovations sought for CPS demand them to deal effectively with dynamicity of their environment, to be scalable, adaptive, tolerant to threats, etc. -- i.e. they have to be smart. Although approaches in software engineering (SE) exist that individually meet these demands, their synergy to address the challenges of smart CPS (sCPS) in a holistic manner remains an open challenge. The workshop focuses on software engineering challenges for sCPS. The goals are to increase the understanding of problems of SE for sCPS, study foundational principles for engineering sCPS, and identify promising SE solutions for sCPS. Based on these goals, the workshop aims to formulate a research agenda for SE of sCPS.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203152','10.1109/ICSE.2015.326',8,3,'IEEE','IEEE Conferences',0),(240,'Supporting Scientific SE Process Improvement',2,923,926,'The increasing complexity of scientific software can result in significant impacts on the research itself. In traditional software development projects, teams adopt historical best practices into their development processes to mitigate the risk of such problems. In contrast, the gap that has formed between the traditional and scientific software communities leaves scientists to rely on only their own experience when facing software process improvement (SPI) decisions. Rather than expect scientists to become software engineering (SE) experts or the SE community to learn all of the intricacies involved in scientific software development projects, we seek a middle ground. The Scientific Software Process Improvement Framework (SciSPIF) will allow scientists to self-drive their own SPI efforts while leveraging the collective experiences of their peers and linking their concerns to established SE best practices. This proposal outlines the known challenges of scientific software development, relevant concepts from traditional SE research, and our planned methodology for collecting the data required to construct SciSPIF while staying grounded in the actual goals and concerns of the scientists.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203115','10.1109/ICSE.2015.293',28,1,'IEEE','IEEE Conferences',0),(241,'Poster: Segmentation Based Online Performance Problem Diagnosis',2,807,808,'Currently, the performance problems of software systems gets more and more attentions. Among various diagnosis methods based on system traces, principal component analysis (PCA) based methods are widely used due to the high accuracy of the diagnosis results and requiring no specific domain knowledge. However, according to our experiments, we have validated several shortcomings existed in PCA-based methods, including requiring traces with a same call sequence, inefficiency when the traces are long, and missing performance problems. To cope with these issues, we introduce a segmentation based online diagnosis method in this poster.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203079','10.1109/ICSE.2015.258',6,1,'IEEE','IEEE Conferences',0),(242,'Poster: Is Carmen Better than George? Testing the Exploratory Tester Using HCI Techniques',2,815,816,'Exploratory software testing is an activity which can be carried out by both untrained and formally trained testers. In this paper, we propose using Human Computer Interaction (HCI) techniques to carry out a study of exploratory testing strategies used by the two groups of testers. This data will be used to make recommendations to companies with regards to the mix of skills and training required for testing teams.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203083','10.1109/ICSE.2015.262',7,2,'IEEE','IEEE Conferences',0),(243,'Free Hugs -- Praising Developers for Their Actions',2,555,558,'Developing software is a complex, intrinsically intellectual, and therefore ephemeral activity, also due to the intangible nature of the end product, the source code. There is a thin red line between a productive development session, where a developer actually does something useful and productive, and a session where the developer essentially produces \'fried air\', pieces of code whose quality and usefulness are doubtful at best. We believe that well-thought mechanisms of gamification built on fine-grained interaction information mined from the IDE can crystallize and reward good coding behavior. We present our preliminary experience with the design and implementation of a micro-gamification layer built into an object-oriented IDE, which at the end of each development session not only helps the developer to understand what he actually produced, but also praises him in case the development session was productive. Building on this, we envision an environment where the IDE reflects on the deeds of the developers and by providing a historical view also helps to track and reward long-term growth in terms of development skills, not dissimilar from the mechanics of role-playing games.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203011','10.1109/ICSE.2015.342',17,2,'IEEE','IEEE Conferences',0),(244,'MU-MMINT: An IDE for Model Uncertainty',2,697,700,'Developers have to work with ever-present design-time uncertainty, i.e., Uncertainty about selecting among alternative design decisions. However, existing tools do not support working in the presence of uncertainty, forcing developers to either make provisional, premature decisions, or to avoid using the tools altogether until uncertainty is resolved. In this paper, we present a tool, called MU-MMINT, that allows developers to express their uncertainty within software artifacts and perform a variety of model management tasks such as reasoning, transformation and refinement in an interactive environment. In turn, this allows developers to defer the resolution of uncertainty, thus avoiding having to undo provisional decisions. See the companion video: http://youtu.be/kAWUm-iFatM.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203046','10.1109/ICSE.2015.226',17,7,'IEEE','IEEE Conferences',0),(245,'Ekstazi: Lightweight Test Selection',2,713,716,'Regression testing is a crucial, but potentially time-consuming, part of software development. Regression test selection (RTS), which runs only a subset of tests, was proposed over three decades ago as a promising way to speed up regression testing. However, RTS has not been widely adopted in practice. We propose EKSTAZI , a lightweight RTS tool, that can integrate well with testing frameworks and build systems, increasing the chance for adoption. EKSTAZI tracks dynamic dependencies of tests on files and requires no integration with version-control systems. We implemented EKSTAZI for Java+JUnit and Scala+ScalaTest, and evaluated it on 615 revisions of 32 open-source projects (totaling almost 5M LOC). The results show that EKSTAZI reduced the end-to-end testing time by 32% on average compared to executing all tests. EKSTAZI has been adopted for day-to-day use by several Apache developers. The demo video for EKSTAZI can be found at http://www.youtube.com/watch?v=jE8K5_UCP28.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203050','10.1109/ICSE.2015.230',20,15,'IEEE','IEEE Conferences',0),(246,'Verification of Android Applications',2,931,934,'This study investigates an alternative approach to analyze Android applications using model checking. We develop an extension to Java Path Finder (JPF) called JPF-Android to verify Android applications outside of the Android platform. JPF is a powerful Java model checker and analysis engine that is very effective at detecting corner-case and hard-to-find errors using its fine-grained analysis capabilities. JPF-Android provides a simplified model of the Android application framework on which an Android application can run and it can generate input events or parse an input script containing sequences of input events to drive the execution of the application. JPF-Android traverses all execution paths of the application by simulating these input events and can detect common property violations such as deadlocks and runtime exceptions in Android applications. It also introduces user defined execution specifications called Checklists to verify the flow of application execution.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203117','10.1109/ICSE.2015.295',12,0,'IEEE','IEEE Conferences',0),(247,'Agile Project Management: From Self-Managing Teams to Large-Scale Development',2,945,946,'Agile software development represents a new approach for planning and managing software projects. It puts less emphasis on up-front plans and strict control and relies more on informal collaboration, coordination, and learning. This briefing provides a characterization and definition of agile project management based on extensive studies of large-scale industrial projects. It explains the circumstances behind the change from traditional management with its focus on direct supervision and standardization of work processes, to the newer, agile focus on self-managing teams, including its opportunities and benefits, but also its complexity and challenges. The main focus of the briefing is the four principles of agile project management: minimum critical specification, autonomous teams, redundancy, and feedback and learning. The briefing is intended for researchers, practitioners and educators in software engineering, especially project managers. For researchers, an updated state of the art will be uncovered, and the presentation will be based on current best evidence. For practitioners, principles, processes, and key success factors will be outlined and a successful large-scale case study of agile project management will be presented. For educators, the briefing will provide the basis for developing course material.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203121','10.1109/ICSE.2015.299',1,2,'IEEE','IEEE Conferences',0),(248,'Poster: ProNat: An Agent-Based System Design for Programming in Spoken Natural Language',2,819,820,'The emergence of natural language interfaces has led to first attempts of programming in natural language. We present ProNat, a tool for script-like programming in spoken natural language (SNL). Its agent-based architecture unifies deep natural language understanding (NLU) with modular software design. ProNat focuses on the extraction of processing flows and control structures from spoken utterances. For evaluation we have begun to build a speech corpus. First experiments are conducted in the domain of domestic robotics, but ProNat\'s architecture makes domain acquisition easy. Test results with spoken utterances in ProNat seem promising, but much work has to be done to achieve deep NLU.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203085','10.1109/ICSE.2015.264',12,7,'IEEE','IEEE Conferences',0),(249,'CACHECA: A Cache Language Model Based Code Suggestion Tool',2,705,708,'Nearly every Integrated Development Environment includes a form of code completion. The suggested completions (\'suggestions\') are typically based on information available at compile time, such as type signatures and variables in scope. A statistical approach, based on estimated models of code patterns in large code corpora, has been demonstrated to be effective at predicting tokens given a context. In this demo, we present CACHECA, an Eclipse plug in that combines the native suggestions with a statistical suggestion regime. We demonstrate that a combination of the two approaches more than doubles Eclipse\'s suggestion accuracy. A video demonstration is available at https://www.youtube.com/watch?v=3INk0N3JNtc.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203048','10.1109/ICSE.2015.228',8,12,'IEEE','IEEE Conferences',0),(250,'StressCloud: A Tool for Analysing Performance and Energy Consumption of Cloud Applications',2,721,724,'Finding the best deployment configuration that maximises energy efficiency while guaranteeing system performance of cloud applications is an extremely challenging task. It requires the evaluation of system performance and energy consumption under a wide variety of realistic workloads and deployment configurations. This paper demonstrates StressCloud, an automatic performance and energy consumption analysis tool for cloud applications in real-world cloud environments. StressCloud supports 1) the modelling of realistic cloud application workloads, 2) the automatic generation and running of load tests, and 3) the profiling of system performance and energy consumption.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203052','10.1109/ICSE.2015.232',10,5,'IEEE','IEEE Conferences',0),(251,'The Green Lab: Experimentation in Software Energy Efficiency',2,941,942,'Software energy efficiency is a research topic where experimentation is widely adopted. Nevertheless, current studies and research approaches struggle to find generalizable findings that can be used to build a consistent knowledge base for energy-efficient software. To this end, we will discuss how to combine the traditional hypothesis-driven (top-down) approach with a bottom-up discovery approach. In this technical briefing, participants will learn the challenges that characterize the research in software energy efficiency. They will experience the complexity in this field and its implications for experimentation.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203119','10.1109/ICSE.2015.297',8,13,'IEEE','IEEE Conferences',0),(252,'The Use of Text Retrieval and Natural Language Processing in Software Engineering',2,949,950,'This technical briefing presents the state of the art Text Retrieval and Natural Language Processing techniques used in Software Engineering and discusses their applications in the field.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203123','10.1109/ICSE.2015.301',0,2,'IEEE','IEEE Conferences',0),(253,'Poster: Conquering Uncertainty in Java Programming',2,823,824,'Uncertainty in programming is one of the challenging issues to be tackled, because it is error-prone for many programmers to temporally avoid uncertain concerns only using simple language constructs such as comments and conditional statements. This paper proposes ucJava, a new Java programming environment for conquering uncertainty. Our environment provides a modular programming style for uncertainty and supports test-driven development taking uncertainty into consideration.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203087','10.1109/ICSE.2015.266',7,2,'IEEE','IEEE Conferences',0),(254,'Poster: Tierless Programming in JavaScript',2,831,832,'Whereas \'responsive\' web applications already offered a more desktop-like experience, there is an increasing user demand for \'rich\' web applications (RIAs) that offer collaborative and even off-line functionality. Realizing these qualities requires distributing previously centralized application logic and state vertically from the server to a client tier (e.g., for desktop-like and off-line client functionality), and horizontally between instances of the same tier (e.g., for collaborative client functionality and for scaling of resource-starved services). Both bring about the essential complexity of distributing application assets and maintaining their consistency, along with the accidental complexity of reconciling a myriad of heterogenous tier-specific technology. Tierless programming languages enable developing web applications as a single artefact that is automatically split in tier-specific code - resulting in a development process akin to that of a desktop application. This relieves developers of distribution and consistency concerns, as well as the need to align different tier-specific technologies. However, programmers still have to adopt a new and perhaps esoteric language. We therefore advocate developing tierless programs in a general-purpose language instead. In this poster, we introduce our approach to tierless programming in JavaScript. We expand upon our previous work by identifying development challenges arising from this approach that could be resolved through tool support.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203091','10.1109/ICSE.2015.270',8,1,'IEEE','IEEE Conferences',0),(255,'Incorporating Human Intention into Self-Adaptive Systems',2,571,574,'Self-adaptive systems are fed with contextual information from the environments in which the systems operate,from within themselves, and from the users. Traditional self-adaptive systems research has focused on inputs of systems performance, resources, exception, and error recovery that drive systems\' reaction to their environments. The intelligent ability ofthese self-adaptive systems is impoverished without knowledge ofa user\'s covert attention (thoughts, emotions, feelings). As a result, it is difficult to build effective systems that anticipate and react to users\' needs as projected by covert behavior. This paperpresents the preliminary research results on capturing users\'intention through neural input, and in reaction, commanding actions from software systems (e.g., load an application) based on human intention. Further, systems can self-adapt and refine their behaviors driven by such human covert behavior. The long-term research goal is to incorporate and synergize human neural input.Thus establishing software systems with a self-adaptive capability to \'feel\' and \'anticipate\' users intentions and put the human in the loop.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203015','10.1109/ICSE.2015.196',21,2,'IEEE','IEEE Conferences',0),(256,'6th International Workshop on Emerging Trends in Software Metrics (WETSoM 2015)',2,1021,1022,'WETSoM is a gathering of researchers and practitioners to discuss the progress on software metrics knowledge. Motivations for this workshop include the low impact that software metrics have on current software development and the increased interest in research. The goals of this workshop include critically examining the evidence for the effectiveness of existing metrics and identifying new directions for metrics. Evidence for existing metrics includes how the metrics have been used in practice and studies showing their effectiveness. Identifying new directions includes use of new theories, such as complex network theory, on which to base metrics.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203158','10.1109/ICSE.2015.347',0,0,'IEEE','IEEE Conferences',0),(257,'Ariadne: Topology Aware Adaptive Security for Cyber-Physical Systems',2,729,732,'This paper presents Ariadne, a tool for engineering topology aware adaptive security for cyber-physical systems. It allows security software engineers to model security requirements together with the topology of the operational environment. This model is then used at runtime to perform speculative threat analysis to reason about the consequences that topological changes arising from the movement of agents and assets can have on the satisfaction of security requirements. Our tool also identifies an adaptation strategy that applies security controls when necessary to prevent potential security requirements violations.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203054','10.1109/ICSE.2015.234',5,11,'IEEE','IEEE Conferences',0),(258,'Reactive Programming: A Walkthrough',2,953,954,'Over the last few years, Reactive Programming has emerged as the trend to support the development of reactive software through dedicated programming abstractions. Reactive Programming has been increasingly investigated in the programming languages community and it is now gaining the interest of practitioners. Conversely, it has received so far less attention from the software engineering community. This technical briefing bridges this gap through an accurate overview of Reactive Programming, discussing the available frameworks and outlining open research challenges with an emphasis on cross-field research opportunities.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203125','10.1109/ICSE.2015.303',11,5,'IEEE','IEEE Conferences',0),(259,'Poster: An Efficient Equivalence Checking Method for Petri Net Based Models of Programs',2,827,828,'The initial behavioural specification of any software programs goes through significant optimizing and parallelizing transformations, automated and also human guided, before being mapped to an architecture. Establishing validity of these transformations is crucial to ensure that they preserve the original behaviour. PRES+ model (Petri net based Representation of Embedded Systems) encompassing data processing is used to model parallel behaviours. Being value based with inherent scope of capturing parallelism, PRES+ models depict such data dependencies more directly; accordingly, they are likely to be more convenient as the intermediate representations (IRs) of both the source and the transformed codes for translation validation than strictly sequential variable-based IRs like Finite State Machines with Data path (FSMDs) (which are essentially sequential control flow graphs (CFGs)). In this work, a path based equivalence checking method for PRES+ models is presented.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203089','10.1109/ICSE.2015.268',7,5,'IEEE','IEEE Conferences',0),(260,'Poster: Reasoning Based on Imperfect Context Data in Adaptive Security',2,835,836,'Enabling software systems to adjust their protection in continuously changing environments with imperfect context information is a grand challenging problem. The issue of uncertain reasoning based on imperfect information has been overlooked in traditional logic programming with classical negation when applied to dynamic systems. This paper sketches a non-monotonic approach based on Answer Set Programming to reason with imperfect context data in adaptive security where there is little or no knowledge about certainty of the actions and events.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203093','10.1109/ICSE.2015.272',5,4,'IEEE','IEEE Conferences',0),(261,'VERMEER: A Tool for Tracing and Explaining Faulty C Programs',2,737,740,'We present VERMEER, a new automated debugging tool for C. VERMEER combines two functionalities: (1) a dynamic tracer that produces a linearized trace from a faulty C program and a given test input; and (2) a static analyzer that explains why the trace fails. The tool works in phases that simplify the input program to a linear trace, which is then analyzed using an automated theorem prover to produce the explanation. The output of each phase is a valid C program. VERMEER is able to produce useful explanations of non trivial traces for real C programs within a few seconds. The tool demo can be found at http://youtu.be/E5lKHNJVerU.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203056','10.1109/ICSE.2015.236',16,1,'IEEE','IEEE Conferences',0),(262,'Profiling Kernels Behavior to Improve CPU / GPU Interactions',2,754,756,'Most modern computer and mobile devices have a graphical processing unit (GPU) available for any general purpose computation. GPU supports a programming model that is radically different from traditional sequential programming. As such, programming GPU is known to be hard and error prone, despite the large number of available APIs and dedicated programming languages. In this paper we describe a profiling technique that reports on the interaction between a CPU and GPUs. The resulting execution profile may then reveal anomalies and suboptimal situations, in particular due to an improper memory configuration. Our profiler has been effective at identifying suboptimal memory allocation usage in one image processing application.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203060','10.1109/ICSE.2015.239',9,0,'IEEE','IEEE Conferences',0),(263,'Big(ger) Data in Software Engineering',2,957,958,'\'Big Data\' analytics has become the next hot topic for most companies - from financial institutions to technology companies to service providers. Likewise in software engineering, data collected about the development of software, the operation of the software in the field, and the users feedback on software have been used before. However, collecting and analyzing this information across hundreds of thousands or millions of software projects gives us the unique ability to reason about the ecosystem at large, and software in general. At no time in history has there been easier access to extremely powerful computational resources as it is today, thanks to the advances in cloud computing, both from the technology and business perspectives. In this technical briefing, we will present the state-of-the-art with respect to the research carried out in the area of big data analytics in software engineering research.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203127','10.1109/ICSE.2015.305',2,0,'IEEE','IEEE Conferences',0),(264,'3rd International Workshop on Conducting Empirical Studies in Industry (CESI 2015)',2,967,968,'Few would deny today the importance of empirical studies in the field of Software Engineering (SE) and, indeed, an increasing number of studies are being conducted involving the software industry. While literature abounds on empirical procedures, relatively little is known about the dynamics and complexity of conducting empirical studies in the software industry. What are the impediments and how to best handle them? This driver underlies the organisation of the third in a series of workshops, CESI 2015. Apart from structured presentations and discussions from academic and industry participants, this workshop (like predecessor workshops) includes a \'wall of ideas\' session where all participants asynchronously post their ideas on the wall, literally, which are then analysed. As a tangible output, the workshop\'s discussions will be summarised in a post-workshop report.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203131','10.1109/ICSE.2015.345',0,0,'IEEE','IEEE Conferences',0),(265,'How and When to Transfer Software Engineering Research via Extensions',2,239,240,'It is often reported that there is a large gap between software engineering research and practice, with little transfer from research to practice. While this is true in general, one transfer technique is increasingly breaking down this barrier: extensions to integrated development environments (IDEs). With the proliferation of app stores for IDEs and increasing transfer effort from researchers several research-based extensions have seen significant adoption. In this talk we\'ll discuss our experience transferring code search research, which currently is in the top 5% of Visual Studio extensions with over 13,000 downloads, as well as other research techniques transferred via extensions such as NCrunch, FindBugs, Code Recommenders, Mylyn, and Instasearch. We\'ll use the lessons learned from our transfer experience to provide case study evidence as to best practices for successful transfer, supplementing it with the quantitative evidence offered by app store and usage data across the broader set of extensions. The goal of this 30 minute talk is to provide researchers with a realistic view on which research techniques can be transferred to practice as well as concrete steps to execute such a transfer.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202968','10.1109/ICSE.2015.152',14,2,'IEEE','IEEE Conferences',0),(266,'Industry/University Collaboration in Software Engineering Education: Refreshing and Retuning Our Strategies',2,273,275,'This panel session will explore strategies for industry/university collaboration in software engineering education. Specific discussion topics will include new strategies for successful industry/university collaboration, exploration of reasons why some of the old strategies no longer work, and regional/geographical differences noted by the international set of panelists. The panel hopes to identify new promising strategies for such collaborations. Specific industry representatives will be invited to attend and participate in the discussion.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202972','10.1109/ICSE.2015.156',10,2,'IEEE','IEEE Conferences',0),(267,'Understanding the Software Fault Introduction Process',2,843,846,'Testing and debugging research revolves around faults, yet we have a limited understanding of the processes by which faults are introduced and removed. Previous work in this area has focused on describing faults rather than explaining the introduction and removal processes, meaning that a great deal of testing and debugging research depends on assumptions that have not been empirically validated. We propose a three-phase project to develop an explanatory theory of the fault introduction process and describe how the project will be completed.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203095','10.1109/ICSE.2015.274',16,0,'IEEE','IEEE Conferences',0),(268,'Dynamic Safety Cases for Through-Life Safety Assurance',2,587,590,'We describe dynamic safety cases, a novel operationalization of the concept of through-life safety assurance, whose goal is to enable proactive safety management. Using an example from the aviation systems domain, we motivate our approach, its underlying principles, and a lifecycle. We then identify the key elements required to move towards a formalization of the associated framework.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203019','10.1109/ICSE.2015.199',17,16,'IEEE','IEEE Conferences',0),(269,'A Unified Framework for the Comprehension of Software\'s Time',2,603,606,'The dimension of time in software appears in both program execution and software evolution. Much research has been devoted to the understanding of either program execution or software evolution, but these two research communities have developed tools and solutions exclusively in their respective context. In this paper, we claim that a common comprehension framework should apply to the time dimension of software. We formalize this as a meta-model that we instantiate and apply to the two different comprehension problems.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203023','10.1109/ICSE.2015.203',19,0,'IEEE','IEEE Conferences',0),(270,'Mining the Metadata -- and Its Consequences',2,4,5,'Traditionally metadata, the who, when, where of a phone call, the IP address, time, date of an Internet connection, has been viewed as deserving of less privacy than the contents of the communication. But ubiquitous computing and communication has changed that equation, and such transactional information has become increasingly revelatory. In this talk, I will discuss how metadata is used in all sorts of investigations, from malware to malfeasance. I will also discuss how the ubiquity of metadata must mean a change in our approaches to it.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194556','10.1109/ICSE.2015.23',13,1,'IEEE','IEEE Conferences',0),(271,'FormTester: Effective Integration of Model-Based and Manually Specified Test Cases',2,745,748,'Whilst Model Based Testing (MBT) is an improvement over manual test specification, the leap from it to MBT can be hard. Only recently MBT tools for Web applications have emerged that can recover models from existing manually specified test cases. However, there are further requirements for supporting both MBT and manually specified tests. First, we need support for the generation of test initialization procedures. Also, we want to identify areas of the system that are not testable due to defects. We present Form Tester, a new MBT tool addressing these limitations. An evaluation with real Web applications shows that Form Tester helps to reduce the time spent on developing test cases.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203058','10.1109/ICSE.2015.237',9,0,'IEEE','IEEE Conferences',0),(272,'A Combined Technique of GUI Ripping and Input Perturbation Testing for Android Apps',2,760,762,'Mobile applications have become an integral part of the daily lives of millions of users, thus making necessary to ensure their security and reliability. Moreover the increasing number of mobile applications with rich Graphical User Interfaces (GUI) creates a growing need for automated techniques of GUI Testing for mobile applications. In this paper, the GUI Ripping Technique is combined with the Input Perturbation Testing to improve the quality of Android Application Testing. The proposed technique, based on a systematic and automatic exploration of the behavior of Android applications, creates a model of the explored GUI and then uses it to generate the perturbed text inputs. The technique was evaluated on many Android apps and its results were compared with random input tests.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203062','10.1109/ICSE.2015.241',16,5,'IEEE','IEEE Conferences',0),(273,'1st International Workshop on Complex faUlts and Failures in LargE Software Systems (COUFLESS 2015)',2,971,972,'COUFLESS is a one-day workshop that starts with keynote speaker, Prof. Kishor S. Trivedi from Duke University, North Carolina, USA whose talk\'s title is titled: \'Why Does Software Fail and What Should be Done About It?\'聽聽聽A total of 15 papers were submitted to COUFLESS with 53 authors from nine countries and each paper received at least three reviews by the 26 members of the program committee from 11 countries, making it a truly International Workshop. After a long discussion, 11 papers were accepted with the acceptance rate of 73%. Accepted papers address the issues of localizing and debugging complex faults in large-scale software applications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203133','10.1109/ICSE.2015.310',0,0,'IEEE','IEEE Conferences',0),(274,'Scalability Studies on Selective Mutation Testing',2,851,854,'Mutation testing is a test method which is designed to evaluate a test suite\'s quality. Due to the expensive cost of mutation testing, selective mutation testing was first proposed in 1991 by Mathur, in which a subset of mutants are selected aiming to achieve the same effectiveness as the whole set of mutants in evaluating the quality of test suites. Though selective mutation testing has been widely investigated in recent years, many people still doubt if it can suit well for large programs. Realizing that none of the existing work has systematically studied the scalability of selective mutation testing, I plan to work on the scalability of selective mutation testing through several studies.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203097','10.1109/ICSE.2015.276',20,1,'IEEE','IEEE Conferences',0),(275,'Capsule-Oriented Programming',2,611,614,'鈥淓xplicit concurrency should be abolished from all higher-level programming languages (i.e. everything except - perhaps- plain machine code.).鈥� Dijkstra [1] (paraphrased). A promising class of concurrency abstractions replaces explicit concurrency mechanisms with a single linguistic mechanism that combines state and control and uses asynchronous messages for communications, e.g. active objects or actors, but that doesn\'t remove the hurdle of understanding non-local control transfer. What if the programming model enabled programmers to simply do what they do best, that is, to describe a system in terms of its modular structure and write sequential code to implement the operations of those modules and handles details of concurrency? In a recently sponsored NSF project we are developing such a model that we call capsule-oriented programming and its realization in the Panini project. This model favors modularity over explicit concurrency, encourages concurrency correctness by construction, and exploits modular structure of programs to expose implicit concurrency.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203025','10.1109/ICSE.2015.205',33,6,'IEEE','IEEE Conferences',0),(276,'Statistical Learning and Software Mining for Agent Based Simulation of Software Evolution',2,863,866,'In the process of software development it is of high interest for a project manager to gain insights about the ongoing process and possible development trends at several points in time. Substantial factors influencing this process are, e.g., the constellation of the development team, the growth and complexity of the system, and the error-proneness of software entities. For this purpose we build an agent based simulation tool which predicts the future of a project under given circumstances, stored in parameters, which control the simulation process. We estimate these parameters with the help of software mining. Our work exposed the need for a more fine-grained model for the developer behavior. Due to this we create a learning model, which helps us to understand the contribution behavior of developers and, thereby, to determine simulation parameters close to reality. In this paper we present our agent based simulation model for software evolution and describe how methods from statistical learning and data mining serves us to estimate suitable simulation parameters.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203100','10.1109/ICSE.2015.279',17,4,'IEEE','IEEE Conferences',0),(277,'An Approach to Detect Android Antipatterns',2,766,768,'Mobile applications are becoming complex software systems that must be developed quickly and evolve regularly to fit new user requirements and execution contexts. However, addressing these constraints may result in poor design choices, known as antipatterns, which may degrade software quality and performance. Thus, the automatic detection of antipatterns is an important activity that eases the future maintenance and evolution tasks. Moreover, it helps developers to refactor their applications and thus, to improve their quality. While antipatterns are well-known in object-oriented applications, their study in mobile applications is still in their infancy. In this paper, we presents a tooled approach, called Paprika, to analyze Android applications and to detect object-oriented and Android-specific antipatterns from binaries of applications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203064','10.1109/ICSE.2015.243',22,7,'IEEE','IEEE Conferences',0),(278,'2nd International Workshop on Crowd Sourcing in Software Engineering (CSI-SE 2015)',2,975,976,'Crowdsourcing is increasingly revolutionizing the ways in which software is engineered. Programmers increasingly crowdsource answering their questions through Q&A sites. Non-programmers may contribute human-intelligence to development projects, by, for example, usability testing software or even play games with a purpose to implicitly construct formal specifications. Crowdfunding helps to democratize decisions about what software to build. Software engineering researchers may even benefit from new opportunities to evaluate their work with real developers by recruiting developers from the crowd. CSI- SE will inform the software engineering community of current techniques and trends in crowdsourcing, discuss the application of crowdsourcing to software engineering to date, and identify new opportunities to apply crowdsourcing to solve software engineering problems.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203135','10.1109/ICSE.2015.312',0,0,'IEEE','IEEE Conferences',0),(279,'DIETs: Recommender Systems for Mobile API Developers',2,859,862,'The increasing number of posts related to mobile app development indicates unaddressed problems in the usage of mobile APIs. Arguing that these problems result from in- adequate documentation and shortcomings in the design and implementation of the APIs, the goal of this research is to develop and evaluate two developers\' issues elimination tools (DIETs) for mobile API developers to diminish the problems of mobile applications (apps) development.After categorizing the problems, we investigate their causes, by exploring the relationships between the topics and trends of posts on Stack Overflow, the app developers\' experience, the API and test code, and its changes. The results of these studies will be used to develop two DIETs that support API developers to improve the documentation, design, and implementation of their APIs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203099','10.1109/ICSE.2015.278',20,0,'IEEE','IEEE Conferences',0),(280,'Combining Mastery Learning with Project-Based Learning in a First Programming Course: An Experience Report',2,315,318,'One of the challenges in teaching a first programming course is that in the same course, the students must learn basic programming techniques and high level abstraction abilities, and the application of those techniques and concepts in problem solving and (engineering) design. To confront this challenge, in previous years, we have included a project-based learning phase at the end of our course to encourage the acquisition of high level design and creativity. To address some of the shortcomings of our previous editions, we have recently included a mastery phase to the course. While project-based learning is suitable for teaching high-level skills that require design and creativity and prepare the students for the study of software engineering, mastery-based learning is suitable for concrete skills such as basic programming tasks. Our particular innovation is to allow students into the project phase only if they have demonstrated a minimum predefined competency level in programming. The combination of the two approaches seems to address most of the requirements of a first programming course. We present our motivation for combining the two pedagogical techniques and our experience with the course.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202980','10.1109/ICSE.2015.163',10,4,'IEEE','IEEE Conferences',0),(281,'A Unified Approach to Automatic Testing of Architectural Constraints',2,871,874,'Architectural decisions are often encoded in the form of constraints and guidelines. Non-functional requirements can be ensured by checking the conformance of the implementation against this kind of invariant. Conformance checking is often a costly and error-prone process that involves the use of multiple tools, differing in effectiveness, complexity and scope of applicability. To reduce the overall effort entailed by this activity, we propose a novel approach that supports verification of human-readable declarative rules through the use of adapted off-the-shelf tools. Our approach consists of a rule specification DSL, called Dicto, and a tool coordination framework, called Probo. The approach has been implemented in a soon to be evaluated prototype.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203102','10.1109/ICSE.2015.281',16,0,'IEEE','IEEE Conferences',0),(282,'The Future of Software Engineering (SEIP Keynote)',2,3,3,'Summary form only given. No matter what future we may envision, it relies on software that has not yet been written. Even now, software-intensive systems have woven themselves into the interstitial spaces of civilization, and we as individuals and as a species have slowly surrendered ourselves to computing. Looking back, we can identify several major and distinct styles whereby we have built such systems. We have come a long way, and even today, we certainly can name a number of best practices for software development that yield systems of quality. However, by no means can we stand still: the nature of the systems we build continues to change, and as they collectively weave themselves into our live, we must attend not only to the technical elements of software development, we must also attend to human needs. In this presentation we will look at the history of software engineering and offer some grand challenges for the future.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202943','10.1109/ICSE.2015.128',0,0,'IEEE','IEEE Conferences',0),(283,'A Large Scale Study of License Usage on GitHub',2,772,774,'The open source community relies upon licensing in order to govern the distribution, modification, and reuse of existing code. These licenses evolve to better suit the requirements of the development communities and to cope with unaddressed or new legal issues. In this paper, we report the results of a large empirical study conducted over the change history of 16,221 open source Java projects mined from Git Hub. Our study investigates how licensing usage and adoption changes over a period of ten years. We consider both the distribution of license usage within projects of a rapidly growing forge and the extent that new versions of licenses are introduced in these projects.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203066','10.1109/ICSE.2015.245',16,10,'IEEE','IEEE Conferences',0),(284,'Automatic Categorization of Software Libraries Using Bytecode',2,784,786,'Automatic software categorization is the task of assigning categories or tags to software libraries in order to summarize their functionality. Correctly assigning these categories is essential to ensure that relevant libraries can be easily retrieved by developers from large repositories. Current categorization approaches rely on the semantics reflected in the source code, or use supervised machine learning techniques, which require a set of labeled software as a training data. These approaches fail when such information is not available. We propose a novel unsupervised approach for the automatic categorization of Java libraries, which uses the bytecode of a library in order to determine its category. We show that the approach is able to successfully categorize libraries from the Apache Foundation Repository.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203070','10.1109/ICSE.2015.249',11,1,'IEEE','IEEE Conferences',0),(285,'7th International Workshop on Principles of Engineering Service-Oriented and Cloud Systems (PESOS 2015)',2,987,988,'PESOS has established itself as a forum that brings together software engineering researchers and practitioners working in the areas of service-oriented systems to discuss research challenges, new developments and applications, as well as methods, techniques, experiences, and tools to support engineering, evolution and adaptation of service-oriented systems. The technical advances and growing adoption of Cloud computing is creating new challenges for the PESOS the software services community to explore the approaches to better engineer software systems that are designed, developed, operated and governed in the context of the Cloud. We again attracted high-quality submissions on a diverse set of relevant topics such as better approaches to engineering service-based collaborative systems, Infrastructure as a Service (IaaS), Platform as a Service (PaaS), and Software as a Service (SaaS) models of cloud computing and associated software quality attributes. PESOS 2015 will continue to be the key forum for collecting case studies and artifacts for educators and researchers in this area.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203141','10.1109/ICSE.2015.318',0,0,'IEEE','IEEE Conferences',0),(286,'Mining Software Repositories for Social Norms',2,627,630,'Social norms facilitate coordination and cooperation among individuals, thus enable smoother functioning of social groups such as the highly distributed and diverse open source software development (OSSD) communities. In these communities, norms are mostly implicit and hidden in huge records of human-interaction information such as emails, discussions threads, bug reports, commit messages and even source code. This paper aims to introduce a new line of research on extracting social norms from the rich data available in software repositories. Initial results include a study of coding convention violations in JEdit, Argo UML and Glassfish projects. It also presents a new life-cycle model for norms in OSSD communities and demonstrates how a number of norms extracted from the Python development community follow this life-cycle model.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203029','10.1109/ICSE.2015.209',8,4,'IEEE','IEEE Conferences',0),(287,'Bixie: Finding and Understanding Inconsistent Code',2,645,648,'We present Bixie, a tool to detect inconsistencies in Java code. Bixie detectsinconsistent code at a higher precision than previous tools and provides novelfault localization techniques to explain why code is inconsistent. Wedemonstrate the usefulness of Bixie on over one million lines of code, showthat it can detect inconsistencies at a low false alarm rate, and fix a numberof inconsistencies in popular open-source projects. Watch our Demo at http://youtu.be/QpsoUBJMxhk.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203033','10.1109/ICSE.2015.213',12,1,'IEEE','IEEE Conferences',0),(288,'Strategies for Prioritizing Test Cases Generated Through Model-Based Testing Approaches',2,879,882,'Software testing is expensive and time consuming,especially for complex software. In order to deal with the costof testing, researchers develop Model-Based Testing (MBT). InMBT, test cases are generated automatically and a drawback isa huge generated test suite. Our research aims at studying the Test Case Prioritization problem in MBT context. So far, we already evaluated the influence of the model structure and the characteristics of the test cases that fail. Results suggest that the former does not affect significantly the performance of techniques, however, the latter indeed represents a major impact. Therefore, a worthy information in this context might be an expert who knows the crucial parts of the software, thus we propose the first version of a prioritization technique that considers hints from the expert and the distance notion in order to prioritize test cases. Evaluation and tuning of the technique are ongoing, but preliminary evaluation reveals promising results.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203104','10.1109/ICSE.2015.338',27,2,'IEEE','IEEE Conferences',0),(289,'Casper: Using Ghosts to Debug Null Deferences with Dynamic Causality Traces',2,790,791,'Fixing software errors requires understanding their root cause. In this paper, we introduce \'causality traces\'\', they are specially crafted execution traces augmented with the information needed to reconstruct a causal chain from a root cause to an execution error. We propose an approach and a tool, called Casper, for dynamically constructing causality traces for null dereference errors. The core idea of Casper is to inject special values, called \'ghosts\', into the execution stream to construct the causality trace at runtime. We evaluate our contribution by providing and assessing the causality traces of 14 real null dereference bugs collected over six large, popular open-source projects.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203072','10.1109/ICSE.2015.251',3,0,'IEEE','IEEE Conferences',0),(290,'4th SEMAT Workshop on General Theory of Software Engineering (GTSE 2015)',2,983,984,'General theories explain the fundamental phenomena that constitute a research domain. They apply across a domain and often integrate many theories and concepts into a single cohesive view. While general theories are extremely important for education and research coordination, and common in many disciplines (e.g. sociology, criminology, electrical engineering, biology, physics), software engineering lacks a well-accepted general theory. The General Theory of Software Engineering workshop seeks to rectify this situation by promoting theory development in software engineering. The fourth workshop in this series, held in conjunction with the International Conference on Software Engineering, displayed a promising trend toward more theory development papers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203139','10.1109/ICSE.2015.316',16,0,'IEEE','IEEE Conferences',0),(291,'ViDI: The Visual Design Inspector',2,653,656,'We present ViDI (Visual Design Inspector), a novel code review tool which focuses on quality concerns and design inspection as its cornerstones. It leverages visualization techniques to represent the reviewed software and augments the visualization with the results of quality analysis tools. To effectively understand the contribution of a reviewer in terms of the impact of her changes on the overall system quality, ViDI supports the recording and further inspection of reviewing sessions. ViDI is an advanced prototype which we will soon release to the Pharo open-source community.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203035','10.1109/ICSE.2015.215',11,2,'IEEE','IEEE Conferences',0),(292,'Measuring Software Developers\' Perceived Difficulty with Biometric Sensors',2,887,890,'As a developer works on a change task, he or she might perceive some parts of the task as easy and other parts as being very difficult. Currently, little is known about when a developer experiences different difficulty levels, although being able to assess these difficulty levels would be helpful for many reasons. For instance, a developer\'s perceived difficulty might be used to determine the likelihood of a bug being introduced into the code or the quality of the code a developer is working with. In psychology, biometric measurements, such as electro-dermal activity or heart rate, have already been extensively used to assess a person\'s mental state and emotions, but only little research has been conducted to investigate how these sensors can be used in the context of software engineering. In our research we want to take advantage of the insights gained in these psychological studies and investigate whether such biometric sensors can be used to measure developers\' perceived difficulty while working on a change task and support them in their work.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203106','10.1109/ICSE.2015.284',33,2,'IEEE','IEEE Conferences',0),(293,'Poster: Improving Cloud-Based Continuous Integration Environments',2,797,798,'We propose a novel technique for improving the efficiency of cloud-based continuous integration development environments. Our technique identifies repetitive, expensive and time-consuming setup activities that are required to run integration and system tests in the cloud, and consolidates them into preconfigured testing virtual machines such that the overall costs of test execution are minimized. We create such testing machines by reconfiguring and opportunistically snapshotting the virtual machines already registered in the cloud.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203074','10.1109/ICSE.2015.253',6,3,'IEEE','IEEE Conferences',0),(294,'3rd International Workshop on Release Engineering (RELENG 2015)',2,995,996,'Release engineering deals with all activities inbetween regular development and actual usage of asoftware product by the end user, i.e., integration, build, testexecution, packaging and delivery of software. Although re-search on this topic goes back for decades, the increasing heterogeneity and variability of software products along withthe recent trend to reduce the release cycle to days or even hoursstarts to question some of the common beliefs and practicesof the field. For example, a project like Mozilla Firefox releasesevery 6 weeks, generating updates for dozens of existing Fire-fox versions on 5 desktop, 2 mobile and 3 mobile desktopplatforms, each of which for more than 80 locales. In this con-text, the International Workshop on Release Engineering(RELENG) aims to provide a highly interactive forum for re-searchers and practitioners to address the challenges of, findsolutions for and share experiences with release engineering, and to build connections between the various communities.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203145','10.1109/ICSE.2015.321',11,0,'IEEE','IEEE Conferences',0),(295,'Source Code Curation on StackOverflow: The Vesperin System',2,661,664,'The past few years have witnessed the rise of software question and answer sites like StackOverflow, where developers can pose detailed coding questions and receive quality answers. Developers using these sites engage in a complex code foraging process of understanding and adapting the code snippets they encounter. We introduce the notion of source code curation to cover the act of discovering some source code of interest, cleaning and transforming (refining) it, and then presenting it in a meaningful and organized way. In this paper, we present Vesperin, a source code curation system geared towards curating Java code examples on StackOverflow.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203037','10.1109/ICSE.2015.217',12,1,'IEEE','IEEE Conferences',0),(296,'Search-Based Migration of Model Variants to Software Product Line Architectures',2,895,898,'Software Product Lines (SPLs) are families of related software systems developed for specific market segments or domains. Commonly, SPLs emerge from sets of existing variants when their individual maintenance becomes infeasible. However, current approaches for SPL migration do not support design models, are partially automated, or do not reflect constraints from SPL domains. To tackle these limitations, the goal of this doctoral research plan is to propose an automated approach to the SPL migration process at the design level. This approach consists of three phases: detection, analysis and transformation. It uses as input the class diagrams and lists of features for each system variant, and relies on search-based algorithms to create a product line architecture that best captures the variability present in the variants. Our expected contribution is to support the adoption of SPL practices in companies that face the scenario of migrating variants to SPLs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203108','10.1109/ICSE.2015.286',24,0,'IEEE','IEEE Conferences',0),(297,'An Integrated Multi-Agent-Based Simulation Approach to Support Software Project Management',2,911,914,'Software projects often do not accomplish what is expected. They fail to comply with the planned schedule, cost more than predicted, or are simply not completed at all owing to issues such as bad planning, a poorly chosen team or an incorrect definition of the tasks to be performed. Although simulation methods and tools have been introduced to alleviate these problems, there is a lack of simulation approaches that integrate software project knowledge, software development processes, project-related situation-awareness, and learning techniques to help project managers to make more informed decisions and hence reach successful conclusions with software projects. In addition, in order to be more proactive, such approaches need to provide simulations based on both static and dynamic situation-awareness data, support (self-)adaptive project planning and execution, and recommend remedial courses of action when real-time project anomalies occur. In this context, this PhD research aims to create an integrated multi-agent-based simulation to support software project management in a more comprehensive way.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203112','10.1109/ICSE.2015.290',11,2,'IEEE','IEEE Conferences',0),(298,'Poster: Discovering Code Dependencies by Harnessing Developer\'s Activity',2,801,802,'Monitoring software developer\'s interactions in an integrated development environment is sought for revealing new information about developers and developed software. In this paper we present an approach for identifying potential source code dependencies solely from interaction data. We identify three kinds of potential dependencies and additionally assign them to developer\'s activity as well, to reveal detailed task-related connections in the source code. Interaction data as a source allow us to identify these candidates for dependencies even for dynamically typed programming languages, or across multiple languages in the source code. After first evaluations and positive results we continue with collecting data in professional environment of Web developers, and evaluating our approach.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203076','10.1109/ICSE.2015.255',7,4,'IEEE','IEEE Conferences',0),(299,'Poster: Symbolic Execution of MPI Programs',2,809,810,'MPI is widely used in high performance computing. In this extended abstract, we report our current status of analyzing MPI programs. Our method can provide coverage of both input and non-determinism for MPI programs with mixed blocking and non-blocking operations. In addition, to improve the scalability further, a deadlock-oriented guiding method for symbolic execution is proposed. We have implemented our methods, and the preliminary experimental results are promising.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203080','10.1109/ICSE.2015.259',7,1,'IEEE','IEEE Conferences',0),(300,'Second International Workshop on Software Architecture and Metrics (SAM 2015)',2,999,1000,'Software engineers and architects of complex software systems need to balance hard quality attribute requirements while at the same time manage risks and make decisions with a system-wide and long-lasting impact. To achieve these tasks efficiently, they need quantitative information about design-time and run-time system aspects through usable and quick tools. While there is body of work focusing on code quality and metrics, their applicability at the design and architecture level and at scale are inconsistent and not proven. We are interested in exploring whether architecture can assist with better contextualizing existing system and code quality and metrics approaches. Furthermore, we ask whether we need additional architecture-level metrics to make progress and whether something as complex and subtle as software architecture can be quantified. The goal of this workshop is to discuss progress, gather empirical evidence, and identify priorities for a research agenda on architecture and metrics in the software engineering field.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203147','10.1109/ICSE.2015.346',6,2,'IEEE','IEEE Conferences',0),(301,'2nd International Workshop on Software Engineering Research and Industrial Practice (SER&IP 2015)',2,1007,1008,'Differing perceptions and expectations are obstaclesto collaboration between software engineering (SE) researchersand practitioners: Researchers often have a view thatpractitioners are reluctant to share real data. Practitionersbelieve that researchers are mostly working on topics which aredivorced from real industrial needs. Researchers believe thatpractitioners are looking for quick fixes. Practitioners have aview that case studies in research do not represent thecomplexities of real projects. Researchers may expect a few yearsto do research on a problem whereas practitioners expect a quicksolution that pays off immediately.Researchers and practitioners need to identify the gaps and todiscover the ways to collaborate to strengthen SE research andindustrial practice (IP). The main purpose of this workshop is tobring together researchers and practitioners to discuss thecurrent state of SE research and IP and to enhance collaborationbetween them. The SER&IP 2015 workshop provided a platformto share success stories of SE research-practice partnerships aswell as to discuss the challenges, through a day-long agenda ofkeynotes, paper presentations and round table discussions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203151','10.1109/ICSE.2015.352',5,0,'IEEE','IEEE Conferences',0),(302,'Extract Package Refactoring in ARIES',2,669,672,'Software evolution often leads to the degradation of software design quality. In Object-Oriented (OO) systems, this often results in packages that are hard to understand and maintain, as they group together heterogeneous classes with unrelated responsibilities. In such cases, state-of-the-art re-modularization tools solve the problem by proposing a new organization of the existing classes into packages. However, as indicated by recent empirical studies, such approaches require changing thousands of lines of code to implement the new recommended modularization. In this demo, we present the implementation of an Extract Package refactoring approach in ARIES (Automated Refactoring In EclipSe), a tool supporting refactoring operations in Eclipse. Unlike state-of-the-art approaches, ARIES automatically identifies and removes single low-cohesive packages from software systems, which represent localized design flaws in the package organization, with the aim to incrementally improve the overall quality of the software modularisation.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203039','10.1109/ICSE.2015.219',7,2,'IEEE','IEEE Conferences',0),(303,'FLEXISKETCH TEAM: Collaborative Sketching and Notation Creation on the Fly',2,685,688,'When software engineers collaborate, they frequently use whiteboards or paper for sketching diagrams. This is fast and flexible, but the resulting diagrams cannot be interpreted by software modeling tools. We present FLEXISKETCH TEAM, a tool solution consisting of a significantly extended version of our previous, single-user FLEXISKETCH tool for Android devices and a new desktop tool. Our solution for collaborative, model-based sketching of free-form diagrams allows users to define and re-use diagramming notations on the fly. Several users can work simultaneously on the same model sketch with multiple tablets. The desktop tool provides a shared view of the drawing canvas which can be projected onto an electronic whiteboard. Preliminary results from an exploratory study show that our tool motivates meeting participants to actively take part in sketching as well as defining ad-hoc notations.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203043','10.1109/ICSE.2015.223',19,7,'IEEE','IEEE Conferences',0),(304,'Contributor\'s Performance, Participation Intentions, Its Influencers and Project Performance',2,919,922,'Software project performance largely depends on the software development team. Studies have shown that interest and activity levels of contributors at any time significantly affect project success measures. This dissertation provides suggestions to enhance contributors\' performance and participation intentions to help improve project performance. To do so, we mine historical data in software repositories from a two-pronged approach: 1) To assess contributors\' performance to identify strengths and areas of improvement. 2) To measure the influence of factors on contributors\' participation and performance, and provide suggestions that help advance contributor\'s engagement. The methodology used in this study leverage empirical techniques, both quantitative and qualitative, to conduct the analysis. We believe that the insights presented here will help contributors improve their performance. Also, we expect managers and business analysts to benefit from the suggestions to revise factors that negatively influence contributors\' engagement and hence improve project performance.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203114','10.1109/ICSE.2015.292',35,0,'IEEE','IEEE Conferences',0),(305,'Poster: Enhancing Partition Testing through Output Variation',2,805,806,'A major test case generation approach is to divide the input domain into disjoint partitions, from which test cases can be selected. However, we observe that in some traditional approaches to partition testing, the same partition may be associated with different output scenarios. Such an observation implies that the partitioning of the input domain may not be precise enough for effective software fault detection. To solve this problem, partition testing should be fine-tuned to additionally use the information of output scenarios in test case generation, such that these test cases are more fine-grained not only with respect to the input partitions but also from the perspective of output scenarios.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203078','10.1109/ICSE.2015.257',5,0,'IEEE','IEEE Conferences',0),(306,'Poster: Dynamic Analysis Using JavaScript Proxies',2,813,814,'JavaScript has become a popular programming language. However, its highly dynamic nature encumbers static analysis for quality assurance purposes. Only dynamic techniques such as concolic testing seem to cope. Often, these involve an instrumentation phase in which source code is extended with analysis-specific concerns. The corresponding implementations represent a duplication of engineering efforts. To facilitate developing dynamic analyses for JavaScript, we introduce Aran; a general-purpose JavaScript instrumenter that takes advantage of proxies, a recent addition to the JavaScript reflection APIs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203082','10.1109/ICSE.2015.261',9,1,'IEEE','IEEE Conferences',0),(307,'SE4HPCS\'15: The 2015 International Workshop on Software Engineering for High Performance Computing in Science',2,1003,1004,'HPC software is developed and used in a wide variety of scientific domains including nuclear physics, computational chemistry, crash simulation, satellite data processing, fluid dynamics, climate modeling, bioinformatics, and vehicle development. The increase in the importance of this software motivates the need to identify and understand appropriate software engineering (SE) practices for HPC architectures. Because of the variety of the scientific domains addressed using HPC, existing SE tools and techniques developed for the business/IT community are often not efficient or effective. Appropriate SE solutions must account for the salient characteristics of the HPC, research oriented development environment. This situation creates a need for members of the SE community to interact with members of the scientific and HPC communities to address this need. This workshop facilitates that collaboration by bringing together members of the SE, the scientific, and the HPC communities to share perspectives and present findings relevant to research, practice, and education. A significant portion of the workshop is devoted to focused interaction among the participants with the goal of generating a research agenda to improve tools, techniques, and experimental methods regarding SE for HPC science.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203149','10.1109/ICSE.2015.324',7,0,'IEEE','IEEE Conferences',0),(308,'Varis: IDE Support for Embedded Client Code in PHP Web Applications',2,693,696,'In software development, IDE services are used to assist developers in programming tasks. In dynamic web applications, however, since the client-side code is embedded in the server-side program as string literals, providing IDE services for such embedded code is challenging. We introduce Varis, a tool that provides services on the embedded client-side code. We perform symbolic execution on a PHP program to approximate its output and parse it into a VarDOM that compactly represents all its DOM variations. Using the VarDOM, we implement various types of IDE services for embedded client code including syntax highlighting, code completion, and \'find declaration\'.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203045','10.1109/ICSE.2015.225',10,3,'IEEE','IEEE Conferences',0),(309,'Software Requirements Patterns - A State of the Art and the Practice',2,943,944,'Software requirement patterns are an increasingly popular approach to knowledge reuse in the requirements engineering phase. Several research proposals have been formulated in the last years, and this technical briefing presents them. Beyond that, a report on the current adoption of these proposals (or any other ad-hoc approach) in industry is presented. This state of the practice will show that the need to pave the road to successful adoption still persists.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203120','10.1109/ICSE.2015.298',16,1,'IEEE','IEEE Conferences',0),(310,'Poster: VIBeS, Transition System Mutation Made Easy',2,817,818,'Mutation testing is an established technique used to evaluate the quality of a set of test cases. As model-based testing took momentum, mutation techniques were lifted to the model level. However, as for code mutation analysis, assessing test cases on a large set of mutants can be costly. In this paper, we introduce the Variability-Intensive Behavioural teSting (VIBeS) framework. Relying on Featured Transition Systems (FTSs), we represent all possible mutants in a single model constrained by a feature model for mutant (in)activation. This allow to assess all mutants in a single test case execution. We present VIBeS implementation steps and the DSL we defined to ease model-based mutation analysis.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203084','10.1109/ICSE.2015.263',8,4,'IEEE','IEEE Conferences',0),(311,'StriSynth: Synthesis for Live Programming',2,701,704,'Motivated by applications in automating repetitive file manipulations, we present a tool called StriSynth, which allows end-users to perform transformations over data using examples. Based on provided examples, our tool automatically generates scripts for non-trivial file manipulations. Although the current focus of StriSynth are file manipulations, it implements a more general string transformation framework. This framework builds on and further extends the functionality of Flash Fill -- a Microsoft Excel extension for string transformations. An accompanying video to this paper is available at the following website http://youtu.be/kkDZphqIdFM.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203047','10.1109/ICSE.2015.227',11,4,'IEEE','IEEE Conferences',0),(312,'TesMa and CATG: Automated Test Generation Tools for Models of Enterprise Applications',2,717,720,'We present CATG, an open-source concolic test generation tool for Java and its integration with TesMa, a model-based testing tool which automatically generates test cases from formal design documents. TesMa takes as input a set of design documents of an application under test. The design documents are provided in the form of database table definitions, process-flow diagrams, and screen definitions. From these design documents, TesMa creates Java programs for the feasible execution scenarios of the application. CATG performs concolic testing on these Java programs to generate suitable databases and test inputs required to test the application under test. A demo video of the tool is available at https://www.youtube.com/watch?v=9lEvPwR7g-Q.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203051','10.1109/ICSE.2015.231',8,8,'IEEE','IEEE Conferences',0),(313,'A Security Practices Evaluation Framework',2,935,938,'Software development teams need guidance on choosing security practices so they can develop code securely. The academic and practitioner literature on software development security practices is large, and expanding. However, published empirical evidence for security practice use in software development is limited and fragmented, making choosing appropriate practices difficult. Measurement frameworks offer a tool for collecting and comparing software engineering data. The goal of this work is to aid software practitioners in evaluating security practice use in the development process by defining and validating a measurement framework for software development security practice use and outcomes. We define the Security Practices Evaluation Framework (SP-EF), a measurement framework for software development security practices. SP-EF supports evidence-based practice selection. To enable comparison of practices across publications and projects, we define an ontology of software development security practices. We evaluate the framework and ontology on historical data and industrial projects.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203118','10.1109/ICSE.2015.296',13,1,'IEEE','IEEE Conferences',0),(314,'Software Engineering for Privacy in-the-Large',2,947,948,'There will be an estimated 35 zettabytes (35 脳 1021) of digital records worldwide by the year 2020. This effectively amounts to privacy management on an ultra-large-scale. In this briefing, we discuss the privacy challenges posed by such an ultra-large-scale ecosystem - we term this 鈥淧rivacy in the Large鈥�. We will contrast existing approaches to privacy management, reflect on their strengths and limitations in this regard and outline key software engineering research and practice challenges to be addressed in the future.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203122','10.1109/ICSE.2015.300',15,1,'IEEE','IEEE Conferences',0),(315,'[Journal First] Augmenting and Structuring User Queries to Support Efficient Free-Form Code Search',1,945,945,'Source code terms such as method names and variable types are often different from conceptual words mentioned in a search query. This vocabulary mismatch problem can make code search inefficient. In this paper, we present Code voCaBulary (CoCaBu), an approach to resolving the vocabulary mismatch problem when dealing with free-form code search queries. Our approach leverages common developer questions and the associated expert answers to augment user queries with the relevant, but missing, structural code entities in order to improve the performance of matching relevant code examples within large code repositories. To instantiate this approach, we build GitSearch, a code search engine, on top of GitHub and Stack Overflow Q&A data. We evaluate GitSearch in several dimensions to demonstrate that (1) its code search results are correct with respect to user-accepted answers; (2) the results are qualitatively better than those of existing Internet-scale code search engines; (3) our engine is competitive against web search engines, such as Google, in helping users solve programming tasks; and (4) GitSearch provides code examples that are acceptable or interesting to the community as answers for Stack Overflow questions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453173','10.1145/3180155.3182513',0,1,'IEEE','IEEE Conferences',0),(316,'[Journal First] Effect Sizes and their Variance for AB/BA Crossover Design Studies',1,420,420,'We addressed the issues related to repeated measures experimental design such as an AB/BA crossover design (where each participant uses each method) that have been neither discussed nor addressed in the software engineering literature. Firstly, there are potentially two different standardized mean difference effect sizes that can be calculated, depending on whether the mean difference is standardized by the pooled within groups variance or the within-participants variance. Hence, we provided equations for non-standardized and standardized effect sizes and explained the need for two different types of standardized effect size, one for the repeated measures and one that would be equivalent to an independent groups design. Secondly, as for any estimated parameters and also for the purposes of undertaking meta-analysis, it is necessary to calculate the variance of the standardized mean difference effect sizes (which is not the same as the variance of the study). Hence, we provided formulas for the small sample size effect size variance and the medium sample size approximation to the effect size variance, for both types of standardized effect size. We also presented the model underlying the AB/BA crossover design and provided two examples (an empirical analysis of the real data set by Scanniello, as well as simulated data) to demonstrate how to construct the two standardized mean difference effect sizes and their variances, both from standard descriptive statistics and from the outputs provided by the linear mixed model package lme4 in R. A conclusion is that crossover designs should be considered (instead of between groups design) only if: 路 previous research has suggested that 蟻 is greater than zero and preferably greater than 0.25; 路 there is either strong theoretical argument, or empirical evidence from a well-powered study, that the period by technique interaction is negligible. Summarizing, our journal first paper [3]: (1) Presents the formulas needed to calculate both non-standardized and standardized mean difference effect sizes for AB/BA crossover designs (see Section 4 and 5 of our paper [3]). (2) Presents the formulas needed to estimate the variances of the non-standardized and standardized effect sizes which in the later cases need to be appropriate for the small to medium sample sizes commonly used in software engineering crossover designs (see Section 5 of our paper [3]). (3) Explains how to calculate the effect sizes and their variances both from the descriptive statistics that should be reported and from the raw data (see Section 6 of our paper [3]). It is worth mentioning that we based our formulas on our own corrections to the formulas presented earlier by Curtin et al. [1]. Our corrections for the variances of standardized weighted mean difference of an AB/BA cross-over trial were accepted by the author of the original formulas (Curtin), submitted jointly as a letter to Editor of Statistics in Medicine to assure the widespread (also beyond the software engineering domain) adoption of the corrected formulas, and accepted [2]. We proposed an alternative formulation of the standardized effect size for individual difference effects that is comparable with the standardized effect size commonly used for pretest/posttest studies. We also corrected the small sample size and moderate sample size variances reported by Curtin et al. for both the individual difference effect size and the standardized effect size comparable to independent groups trials, showing the derivation of the formulas from the variance of at-variable. Using these results, researchers can now correctly calculate standardized effect size variances, allowing the calculation of confidence intervals for AB/BA cross-over trials, which in turn provides a direct link to null hypothesis testing and supports meta-analysis. Meta-analysts can now validly aggregate together results from independent groups, pretest/posttest and AB/BA cross-over trials. Last but not least, the presented contributions allow corrections of previously reported results.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453101','10.1145/3180155.3182556',0,0,'IEEE','IEEE Conferences',0),(317,'Enlightened Debugging',1,82,92,'Numerous automated techniques have been proposed to reduce the cost of software debugging, a notoriously time-consuming and human-intensive activity. Among these techniques, Statistical Fault Localization (SFL) is particularly popular. One issue with SFL is that it is based on strong, often unrealistic assumptions on how developers behave when debugging. To address this problem, we propose Enlighten, an interactive, feedback-driven fault localization technique. Given a failing test, Enlighten (1) leverages SFL and dynamic dependence analysis to identify suspicious method invocations and corresponding data values, (2) presents the developer with a query about the most suspicious invocation expressed in terms of inputs and outputs, (3) encodes the developer feedback on the correctness of individual data values as extra program specifications, and (4) repeats these steps until the fault is found. We evaluated Enlighten in two ways. First, we applied Enlighten to 1,807 real and seeded faults in 3 open source programs using an automated oracle as a simulated user; for over 96% of these faults, Enlighten required less than 10 interactions with the simulated user to localize the fault, and a sensitivity analysis showed that the results were robust to erroneous responses. Second, we performed an actual user study on 4 faults with 24 participants and found that participants who used Enlighten performed significantly better than those not using our tool, in terms of both number of faults localized and time needed to localize the faults.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453065','10.1145/3180155.3180242',0,2,'IEEE','IEEE Conferences',0),(318,'[Journal First] What Makes a Great Manager of Software Engineers?',1,701,701,'Having great managers is as critical to success as having a good team or organization. A great manager is seen as fuelling the team they manage, enabling it to use its full potential. Though software engineering research studies factors that may affect the performance and productivity of software engineers and teams (like tools and skill), it has overlooked the software engineering manager. On the one hand, experts are questioning how the abundant work in management applies to software engineering. On the other hand, practitioners are looking to researchers for evidence-based guidance on how to manage software teams. We conducted a mixed methods empirical study to investigate what manager attributes developers and engineering managers perceive important and why. We present a conceptual framework of manager attributes, and find that technical skills are not the sign of greatness for an engineering manager. Through statistical analysis we identify how engineers and managers relate in their views, and how software engineering differs from other knowledge work groups.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453140','10.1145/3180155.3182525',0,0,'IEEE','IEEE Conferences',0),(319,'[Journal First] An Empirical Study on the Interplay Between Semantic Coupling and Co-change of Software Classes',1,432,432,'The evolution of software systems is an inevitable process which has to be managed effectively to enhance software quality. Change impact analysis (CIA) is a technique that identifies impact sets, i.e., the set of classes that require correction as a result of a change made to a class or artefact. These sets can also be considered as ripple effects and typically non-local: changes propagate to different parts of a system. Two classes are considered logically coupled if they have co-changed in the past; past research has shown that the precision of CIA techniques increases if logical and semantic coupling (i.e., the extent to which the lexical content of two classes is related) are both considered. However, the relationship between semantic and logical coupling of software artefacts has not been extensively studied and no dependencies established between these two types of coupling. Are two often co-changed artefacts also strongly connected from a semantic point of view? Are two semantically similar artefacts bound to co-change in the future? Answering those questions would help increase the precision of CIA. It would also help software maintainers to focus on a smaller subset of artefacts more likely to co-evolve in the future. This study investigated the relationship between semantic and logical coupling. Using Chi-squared statistical tests, we identified similarities in semantic coupling using class corpora and class identifiers. We then computed Spearman\'s rank correlation between semantic and logical coupling metrics for class pairs to detect whether semantic and logical relationships co-varied in OO software. Finally, we investigated the overlap between semantic and logical relationships by identifying the proportion of classes linked through both coupling types. Our empirical study and results were based on seventy-nine open-source software projects. Results showed that: (a) measuring the semantic similarity of classes by using their identifiers is computationally efficient; (b) using identifier-based coupling can be used interchangeably with semantic similarity based on their corpora, albeit not always; (c) no correlation between the strengths of semantic and change coupling was found. Finally, (d) a directional relationship between the two was identified; 70% of semantic dependencies are linked through change coupling but not vice versa. Based on our findings, we conclude that identifying more efficient methods of semantic coupling computation as well as a directional relationship between semantic and change dependencies could help to improve CIA methods that integrate semantic coupling information. This may also help to reveal implicit dependencies not captured by static source code analysis.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453103','10.1145/3180155.3190833',0,0,'IEEE','IEEE Conferences',0),(320,'[Journal First] MAHAKIL: Diversity Based Oversampling Approach to Alleviate the Class Imbalance Issue in Software Defect Prediction',1,699,699,'This study presents MAHAKIL, a novel and efficient synthetic oversampling approach for software defect datasets that is based on the chromosomal theory of inheritance. Exploiting this theory, MAHAKIL interprets two distinct sub-classes as parents and generates a new instance that inherits different traits from each parent and contributes to the diversity within the data distribution. We extensively compare MAHAKIL with five other sampling approaches using 20 releases of defect datasets from the PROMISE repository and five prediction models. Our experiments indicate that MAHAKIL improves the prediction performance for all the models and achieves better and more significant pf values than the other oversampling approaches, based on robust statistical tests.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453138','10.1145/3180155.3182520',0,1,'IEEE','IEEE Conferences',0),(321,'[Journal First] Does Syntax Highlighting Help Programming Novices?',1,704,704,'Background: Program comprehension is an important skill for programmers - extending and debugging existing source code is part of the daily routine. Syntax highlighting is one of the most common tools used to support developers in understanding algorithms. However, most research in this area originates from a time when programmers used a completely different tool chain. Objective: We examined the influence of syntax highlighting on novices\' ability to comprehend source code. Additional analyses cover the influence of task type and programming experience on the code comprehension ability itself and its relation to syntax highlighting. Method: We conducted a controlled experiment with 390 undergraduate students in an introductory Java programming course. We measured the correctness with which they solved small coding tasks. Each test subject received some tasks with syntax highlighting and some without. Results: The data provided no evidence that syntax highlighting improves novices\' ability to comprehend source code. Limitations: There are very few similar experiments and it is unclear as of yet which factors impact the effectiveness of syntax highlighting. One major limitation may be the types of tasks chosen for this experiment. Conclusion: The results suggest that syntax highlighting squanders a feedback channel from the IDE to the programmer that can be used more effectively.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453142','10.1145/3180155.3182554',0,0,'IEEE','IEEE Conferences',0),(322,'DetReduce: Minimizing Android GUI Test Suites for Regression Testing',1,445,455,'In recent years, several automated GUI testing techniques for Android apps have been proposed. These tools have been shown to be effective in achieving good test coverage and in finding bugs without human intervention. Being automated, these tools typically run for a long time (say, for several hours), either until they saturate test coverage or until a testing time budget expires. Thus, these automated tools are not good at generating concise regression test suites that could be used for testing in incremental development of the apps and in regression testing. We propose a heuristic technique that helps create a small regression test suite for an Android app from a large test suite generated by an automated Android GUI testing tool. The key insight behind our technique is that if we can identify and remove some common forms of redundancies introduced by existing automated GUI testing tools, then we can drastically lower the time required to minimize a GUI test suite. We have implemented our algorithm in a prototype tool called DetReduce. We applied DetReduce to several Android apps and found that DetReduce reduces a test-suite by an average factor of16.9脳 in size and14.7脳 in running time. We also found that for a test suite generated by running SwiftHand and a randomized test generation algorithm for 8 hours, DetReduce minimizes the test suite in an average of 14.6 hours.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453105','10.1145/3180155.3180173',0,2,'IEEE','IEEE Conferences',0),(323,'Roles and Impacts of Hands-on Software Architects in Five Industrial Case Studies',1,117,127,'Whether software architects should also code is an enduring question. In order to satisfy performance, security, reliability and other quality concerns, architects need to compare and carefully choose a combination of architectural patterns, styles or tactics. Then later in the development cycle, these architectural choices must be implemented completely and correctly so there will not be any drift from envisioned design. In this paper, we use data analytics-based techniques to study five large-scale software systems, examining the impact and the role of software architects who write code on software quality. Our quantitative study is augmented with a follow-up interview of architects. This paper provides empirical evidence for supporting the pragmatic opinions that architects should write code. Our analysis shows that implementing architectural tactics is more complex than delivering functionality, tactics are more error prone than software functionalities, and the architects tend to introduce fewer bugs into the implementation of architectural tactics compared to the developers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453069','10.1145/3180155.3180234',0,0,'IEEE','IEEE Conferences',0),(324,'Open Source Barriers to Entry, Revisited: A Sociotechnical Perspective',1,1004,1015,'Research has revealed that significant barriers exist when entering Open-Source Software (OSS) communities and that women disproportionately experience such barriers. However, this research has focused mainly on social/cultural factors, ignoring the environment itself - the tools and infrastructure. To shed some light onto how tools and infrastructure might somehow factor into OSS barriers to entry, we conducted a field study with five teams of software professionals, who worked through five use-cases to analyze the tools and infrastructure used in their OSS projects. These software professionals found tool/infrastructure barriers in 7% to 71% of the use-case steps that they analyzed, most of which are tied to newcomer barriers that have been established in the literature. Further, over 80% of the barrier types they found include attributes that are biased against women.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453179','10.1145/3180155.3180241',0,8,'IEEE','IEEE Conferences',0),(325,'Prioritizing Browser Environments for Web Application Test Execution',1,468,479,'When testing client-side web applications, it is important to consider different web-browser environments. Different properties of these environments such as web-browser types and underlying platforms may cause a web application to exhibit different types of failures. As web applications evolve, they must be regression tested across these different environments. Because there are many environments to consider this process can be expensive, resulting in delayed feedback about failures in applications. In this work, we propose six techniques for providing a developer with faster feedback on failures when regression testing web applications across different web-browser environments. Our techniques draw on methods used in test case prioritization; however, in our case we prioritize web-browser environments, based on information on recent and frequent failures. We evaluated our approach using four non-trivial and popular open-source web applications. Our results show that our techniques outperform two baseline methods, namely, no ordering and random ordering, in terms of the cost-effectiveness. The improvement rates ranged from -12.24% to 39.05% for no ordering, and from -0.04% to 45.85% for random ordering.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453107','10.1145/3180155.3180244',0,0,'IEEE','IEEE Conferences',0),(326,'[Journal First] Studying the Dialogue Between Users and Developers of Free Apps in the Google Play Store',1,164,164,'The popularity of mobile apps continues to grow over the past few years. Mobile app stores, such as the Google Play Store and Apple\'s App Store provide a unique user feedback mechanism to app developers through app reviews. In the Google Play Store (and most recently in the Apple App Store), developers are able to respond to such user feedback. Over the past years, mobile app reviews have been studied excessively by researchers. However, much of prior work (including our own prior work) incorrectly assumes that reviews are static in nature and that users never update their reviews. In a recent study, we started analyzing the dynamic nature of the review-response mechanism. Our previous study showed that responding to a review often has a positive effect on the rating that is given by the user to an app. In this paper [1], we revisit our prior finding in more depth by studying 4.5 million reviews with 126,686 responses of 2,328 top free-to-download apps in the Google Play Store. One of the major findings of our paper is that the assumption that reviews are static is incorrect. In particular, we find that developers and users in some cases use this response mechanism as a rudimentary user support tool, where dialogues emerge between users and developers through updated reviews and responses. Even though the messages are often simple, we find instances of as many as ten user-developer back-and-forth messages that occur via the response mechanism. Using a mixed-effect model, we identify that the likelihood of a developer responding to a review increases as the review rating gets lower or as the review content gets longer. In addition, we identify four patterns of developers: 1) developers who primarily respond to only negative reviews, 2) developers who primarily respond to negative reviews or to reviews based on their content, 3) developers who primarily respond to reviews which are posted shortly after the latest release of their app, and 4) developers who primarily respond to reviews which are posted long after the latest release of their app. We perform a qualitative analysis of developer responses to understand what drives developers to respond to a review. We manually analyzed a statistically representative random sample of 347 reviews with responses of the top ten apps with the highest number of developer responses. We identify seven drivers that make a developer respond to a review, of which the most important ones are to thank the users for using the app and to ask the user for more details about the reported issue. Our findings show that it can be worthwhile for app owners to respond to reviews, as responding may lead to an increase in the given rating. In addition, our findings show that studying the dialogue between users and developers provides valuable insights that can lead to improvements in the app store and the user support process. The main contributions of this paper are as follows: (1) Our paper is the first work to demonstrate the dynamic nature of reviews. (2) Furthermore, we are the first to demonstrate a peculiar use of the app-review platforms as a user support medium. (3) In addition, our work is the first work to deeply explore developer responses in a systematic manner. (4) Finally, our classification of developer-responses highlights the value of providing canned or even automated responses in next generation app-review platforms.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453075','10.1145/3180155.3182523',0,0,'IEEE','IEEE Conferences',0),(327,'[Journal First] The Scent of a Smell: An Extensive Comparison Between Textual and Structural Smells',1,740,740,'Code smells are symptoms of poor design or implementation choices that have a negative effect on several aspects of software maintenance and evolution, such as program comprehension or change-and fault-proneness. This is why researchers have spent a lot of effort on devising methods that help developers to automatically detect them in source code. Almost all the techniques presented in literature are based on the analysis of structural properties extracted from source code, although alternative sources of information (e.g., textual analysis) for code smell detection have also been recently investigated. Nevertheless, some studies have indicated that code smells detected by existing tools based on the analysis of structural properties are generally ignored (and thus not refactored) by the developers. In this paper, we aim at understanding whether code smells detected using textual analysis are perceived and refactored by developers in the same or different way than code smells detected through structural analysis. To this aim, we set up two different experiments. We have first carried out a software repository mining study to analyze how developers act on textually or structurally detected code smells. Subsequently, we have conducted a user study with industrial developers and quality experts in order to qualitatively analyze how they perceive code smells identified using the two different sources of information. Results indicate that textually detected code smells are easier to identify and for this reason they are considered easier to refactor with respect to code smells detected using structural properties. On the other hand, the latter are often perceived as more severe, but more difficult to exactly identify and remove.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453146','10.1145/3180155.3182530',0,0,'IEEE','IEEE Conferences',0),(328,'Inferring Hierarchical Motifs from Execution Traces',1,776,787,'Program comprehension is a necessary step for performing many software engineering tasks. Dynamic analysis is effective in producing execution traces that assist comprehension. Traces are rich sources of information regarding the behaviour of a program. However, it is challenging to gain insight from traces due to their overwhelming amount of data and complexity. We propose a generic technique for facilitating comprehension by inferring recurring execution motifs. Inspired by bioinformatics, motifs are patterns in traces that are flexible to small changes in execution, and are captured in a hierarchical model. The hierarchical nature of the model provides an overview of the behaviour at a high-level, while preserving the execution details and intermediate levels in a structured manner. We design a visualization that allows developers to observe and interact with the model. We implement our approach in an open-source tool, called Sabalan, and evaluate it through a user experiment. The results show that using Sabalan improves developers\' accuracy in performing comprehension tasks by 54%.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453150','10.1145/3180155.3180216',0,3,'IEEE','IEEE Conferences',0),(329,'[Journal First] A Comparative Study to Benchmark Cross-Project Defect Prediction Approaches',1,1063,1063,'Cross-Project Defect Prediction (CPDP) as a means to focus quality assurance of software projects was under heavy investigation in recent years. However, within the current state-of-the-art it is unclear which of the many proposals performs best due to a lack of replication of results and diverse experiment setups that utilize different performance metrics and are based on different underlying data. Within this article, we provide a benchmark for CPDP. We replicate 24 approaches proposed by researchers between 2008 and 2015 and evaluate their performance on software products from five different data sets. Based on our benchmark, we determined that an approach proposed by Camargo Cruz and Ochimizu (2009) based on data standardization performs best and is always ranked among the statistically significant best results for all metrics and data sets. Approaches proposed by Turhan et al. (2009), Menzies et al. (2011), and Watanabe et al. (2008) are also nearly always among the best results. Moreover, we determined that predictions only seldom achieve a high performance of 0.75 recall, precision, and accuracy. Thus, CPDP still has not reached a point where the performance of the results is sufficient for the application in practice.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453185','10.1145/3180155.3182542',4,0,'IEEE','IEEE Conferences',0),(330,'[Journal First] Correctness Attraction: A Study of Stability of Software Behavior Under Runtime Perturbation',1,481,481,'Can the execution of software be perturbed without breaking the correctness of the output? In this paper, we devise a protocol to answer this question from a novel perspective. In an experimental study, we observe that many perturbations do not break the correctness in ten subject programs. We call this phenomenon \'correctness attraction\'. The uniqueness of this protocol is that it considers a systematic exploration of the perturbation space as well as perfect oracles to determine the correctness of the output. To this extent, our findings on the stability of software under execution perturbations have a level of validity that has never been reported before in the scarce related work. A qualitative manual analysis enables us to set up the first taxonomy ever of the reasons behind correctness attraction.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453109','10.1145/3180155.3182548',0,0,'IEEE','IEEE Conferences',0),(331,'The Good, the Bad and the Ugly: A Study of Security Decisions in a Cyber-Physical Systems Game',1,496,496,'Motivation: The security of any system is a direct consequence of stakeholders\' decisions regarding security requirements and their relative prioritisation. Such decisions are taken with varying degrees of expertise in security. In some organisations - particularly those with resources - these are the preserve of computer (or information) security teams. In others - typically smaller organisations - the computing services team may be charged with the responsibility. Often managers have a role to play as guardians of business targets and goals. Be it common workplace practices or strategic decision making, security decisions underpin not only the initial security requirements and their prioritisation but also the adaptation and evolution of these requirements as new business or security contexts arise. However, little is currently understood about how these various demographics approach cyber security decisions and the strategies and approaches that underpin those decisions. What are the typical decision patterns, if any, the consequences of such patterns and their impact (positive or negative) on the security of the system in question? Nor is there any substantial understanding of how the strategies and decision patterns of these different groups contrast. Is security expertise necessarily an advantage when making security decisions in a given context? Answers to these questions are key to understanding the \'how\' and \'why\' behind security decision processes. The Game: In this talk [1], we present a tabletop game - Decisions and Disruptions (D-D) [2] - as a means to investigate these very questions. The game tasks a group of players with managing the security of a small utility company while facing a variety of threats. The game provides a requirements sandbox in which players can experiment with threats, learn about decision making and its consequences, and reflect on their own perception of risk. The game is intentionally kept short - 2 hours - and simple enough to be played without prior training. A cyber-physical infrastructure, depicted through a Lego(R) board, makes the game easy to understand and accessible to players from varying backgrounds and security expertise, without being too trivial a setting for security experts. Key insights: We played D-D with 43 players divided into homogeneous groups (group sizes of 2-6 players): 4 groups of security experts, 4 groups of non-technical managers and 4 groups of general computer scientists. Such observations should, of course, not be generalised, however, the substantial sample size enables in-depth qualitative analysis. Our analysis reveals a number of novel insights regarding security decisions of our three demographics: - Strategies: Security experts had a strong interest in advanced technological solutions and tended to neglect intelligence gathering, to their own detriment: some security expert teams achieved poor results in the game. Managers, too, were technology-driven and focused on data protection while neglecting human factors more than other groups. Computer scientists tended to balance human factors and intelligence gathering with technical solutions, and achieved the best results of the three demographics. - Decision Processes: Technical experience significantly changes the way players think. Teams with little technical experience had shallow, intuition-driven discussions with few concrete arguments. Technical teams, and the most experienced in particular, had much richer debates, driven by concrete scenarios, anecdotes from experience, and procedural thinking. Security experts showed a high confidence in their decisions - despite some of them having bad consequences - while the other groups tended to doubt their own skills - even when they were playing good games. - Patterns: A number of characteristic plays could be identified, some good (balance between priorities, open-mindedness, and adapting strategies based on inputs that challenge one\'s pre-conceptions), some bad (excessive focus on particular issues, confidence in charismatic leaders), some ugly (\'tunnel vision\' syndrome by over-confident players). These patterns are documented and discussed in the full paper - showing the virtue of the positive ones, discouraging the negative ones, and inviting the readers to do their own introspection. Conclusion: D-D complements existing work on gamification as a means to improve security awareness, education, and training. Beyond the analysis of the security decisions of the three demographics, there is a definite educational and awareness-raising aspect to D-D (as noted consistently by players in all our subject groups). Game boxes will be brought to the conference for demonstration purposes, and the audience will be invited to experiment with D-D themselves, make their own decisions, and reflect on their own perception of security.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453113','10.1145/3180155.3182549',0,1,'IEEE','IEEE Conferences',0),(332,'Leveraging Program Analysis to Reduce User-Perceived Latency in Mobile Applications',1,176,186,'Reducing network latency in mobile applications is an effective way of improving the mobile user experience and has tangible economic benefits. This paper presents PALOMA, a novel client-centric technique for reducing the network latency by prefetching HTTP requests in Android apps. Our work leverages string analysis and callback control-flow analysis to automatically instrument apps using PALOMA\'s rigorous formulation of scenarios that address \'what\' and \'when\' to prefetch. PALOMA has been shown to incur significant runtime savings (several hundred milliseconds per prefetchable HTTP request), both when applied on a reusable evaluation benchmark we have developed and on real applications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453077','10.1145/3180155.3180249',0,4,'IEEE','IEEE Conferences',0),(333,'[Journal First] Journal First Presentation of an Experience Report on Applying Software Testing Academic Results in Industry: We Need Usable Automated Test Generation',1,1065,1065,'What is the impact of software engineering research on current practices in industry? In this paper, I report on my direct experience as a PhD/post-doc working in software engineering research projects, and then spending the following five years as an engineer in two different companies (the first one being the same I worked in collaboration with during my post-doc). Given a background in software engineering research, what cutting-edge techniques and tools from academia did I use in my daily work when developing and testing the systems of these companies? Regarding validation and verification (my main area of research), the answer is rather short: as far as I can tell, only FindBugs. In this paper, I report on why this was the case, and discuss all the challenging, complex open problems we face in industry and which somehow are \'neglected\' in the academic circles. In particular, I will first discuss what actual tools I could use in my daily work, such as JaCoCo and Selenium. Then, I will discuss the main open problems I faced, particularly related to environment simulators, unit and web testing. After that, popular topics in academia are presented, such as UML, regression and mutation testing. Their lack of impact on the type of projects I worked on in industry is then discussed. Finally, from this industrial experience, I provide my opinions about how this situation can be improved, in particular related to how academics are evaluated, and advocate for a greater involvement into open-source projects.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453187','10.1145/3180155.3182555',0,0,'IEEE','IEEE Conferences',0),(334,'[Journal First] Are Vulnerabilities Discovered and Resolved Like Other Defects?',1,498,498,'Software defect data has long been used to drive software development process improvement. If security defects (i.e., vulnerabilities) are discovered and resolved by different software development practices than non-security defects, the knowledge of that distinction could be applied to drive process improvement. The goal of this research is to support technical leaders in making security-specific software development process improvements by analyzing the differences between the discovery and resolution of defects versus that of vulnerabilities. We extend Orthogonal Defect Classification (ODC), a scheme for classifying software defects to support software development process improvement, to study process-related differences between vulnerabilities and defects, creating ODC + Vulnerabilities (ODC+V). We applied ODC+V to classify 583 vulnerabilities and 583 defects across 133 releases of three open-source projects (Firefox, phpMyAdmin, and Chrome). Compared with defects, vulnerabilities are found later in the development cycle and are more likely to be resolved through changes to conditional logic. In Firefox, vulnerabilities are resolved 33% more quickly than defects. From a process improvement perspective, these results indicate opportunities may exist for more efficient vulnerability detection and resolution. We found ODC+V\'s property of associating vulnerability and defect discovery and resolution events with their software development process contexts helpful for gaining insight into three open source software projects. The addition of the SecurityImpact attribute, in particular, brought visibility into when threat types are discovered during the development process. We would expect use of ODC+V (and of base ODC) periodically over time to be helpful for steering software development projects toward their quality assurance goals.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453115','10.1145/3180155.3182553',0,0,'IEEE','IEEE Conferences',0),(335,'Hybrid Regression Test Selection',1,199,209,'Regression testing is crucial but can be extremely costly. Regression Test Selection (RTS) aims to reduce regression testing cost by only selecting and running the tests that may be affected by code changes. To date, various RTS techniques analyzing at different granularities (e.g., at the basic-block, method, and file levels) have been proposed. RTS techniques working on finer granularities may be more precise in selecting tests, while techniques working on coarser granularities may have lower overhead. According to a recent study, RTS at the file level (FRTS) can have less overall testing time compared with a finer grained technique at the method level, and represents state-of-the-art RTS. In this paper, we present the first hybrid RTS approach, HyRTS, that analyzes at multiple granularities to combine the strengths of traditional RTS techniques at different granularities. We implemented the basic HyRTS technique by combining the method and file granularity RTS. The experimental results on 2707 revisions of 32 projects, totalling over 124 Million LoC, demonstrate that HyRTS outperforms state-of-the-art FRTS significantly in terms of selected test ratio and the offline testing time. We also studied the impacts of each type of method-level changes, and further designed two new HyRTS variants based on the study results. Our additional experiments show that transforming instance method additions/deletions into file-level changes produces an even more effective HyRTS variant that can significantly outperform FRTS in both offline and online testing time.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453079','10.1145/3180155.3180198',0,9,'IEEE','IEEE Conferences',0),(336,'Inheritance Usage Patterns in Open-Source Systems',1,245,255,'This research investigates how object-oriented inheritance is actually used in practice. The aim is to close the gap between inheritance guidance and inheritance practice. It is based on detailed analyses of 2440 inheritance hierarchies drawn from 14 open-source systems. The original contributions made by this paper concern pragmatic assessment of inheritance hierarchy design quality. The findings show that inheritance is very widely used but that most of the usage patterns that occur in practice are simple in structure. They are so simple that they may not require much inheritance-specific design consideration. On the other hand, the majority of classes defined using inheritance actually appear within a relatively small number of large, complex hierarchies. While some of these large hierarchies appear to have a consistent structure, often based on a problem domain model or a design pattern, others do not. Another contribution is that the quality of hierarchies, especially the large problematic ones, may be assessed in practice based on size, shape, and the definition and invocation of novel methods - all properties that can be detected automatically.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453083','10.1145/3180155.3180168',0,0,'IEEE','IEEE Conferences',0),(337,'[Journal First] Analyzing a Decade of Linux System Calls',1,267,267,'Over the past 25 years, thousands of developers have contributed more than 18 million lines of code (LOC) to the Linux kernel. As the Linux kernel forms the central part of various operating systems that are used by millions of users, the kernel must be continuously adapted to the changing demands and expectations of these users. The Linux kernel provides its services to an application through system calls. The combined set of all system calls forms the essential Application Programming Interface (API) through which an application interacts with the kernel. In this paper, we conduct an empirical study of 8,770 changes that were made to Linux system calls during the last decade (i.e., from April 2005 to December 2014). In particular, we study the size of the changes, and we manually identify the type of changes and bug fixes that were made. Our analysis provides an overview of the evolution of the Linux system calls over the last decade. We find that there was a considerable amount of technical debt in the kernel, that was addressed by adding a number of sibling calls (i.e., 26% of all system calls). In addition, we find that by far, the ptraceand signal handling system calls are the most challenging to maintain. Our study can be used by developers who want to improve the design and ensure the successful evolution of their own kernel APIs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453085','10.1145/3180155.3182518',0,0,'IEEE','IEEE Conferences',0),(338,'The Evolution of Requirements Practices in Software Startups',1,823,833,'We use Grounded Theory to study the evolution of requirements practices of 16 software startups as they grow and introduce new products and services. These startups operate in a dynamic environment, with significant time and market pressure, and rarely have time for systematic requirements analysis. Our theory describes the evolution of practice along six dimensions that emerged as relevant to their requirements activities: requirements artefacts, knowledge management, requirements-related roles, planning, technical debt and product quality. Beyond the relationships among the dimensions, our theory also explains the turning points that drove the evolution along these dimensions. These changes are reactive, rather than planned, suggesting an overall pragmatic lightness, i.e., flexibility, in the startups\' evolution towards engineering practices for requirements. Our theory organises knowledge about evolving requirements practice in maturing startups, and provides practical insights for startups\' assessing their own evolution as they face challenges to their growth. Our research also suggests that a startup\'s evolution along the six dimensions is not fundamental to its success, but has significant effects on their product, their employees and the company.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453156','10.1145/3180155.3180158',0,1,'IEEE','IEEE Conferences',0),(339,'Collaborative Model-Driven Software Engineering: A Classification Framework and a Research Map [Extended Abstract]',1,535,535,'This proposal is about a study we recently published in the IEEE Transaction of Software Engineering journal [4]. Context: Collaborative software engineering (CoSE) deals with methods, processes and tools for enhancing collaboration, communication, and co-ordination (3C) among team members. CoSE can be employed to conceive different kinds of artifacts during the development and evolution of software systems. For instance, when focusing on software design, multiple stakeholders with different expertise and responsibility collaborate on the system design. Model-Driven Software Engineering (MDSE) provides suitable techniques and tools for specifying, manipulating, and analyzing modeling artifacts including metamodels, models, and transformations. Collaborative MDSE consists of methods or techniques in which multiple stakeholders manage, collaborate, and are aware of each others\' work on a set of shared models. A collaborative MDSE approach is composed of three main complementary dimensions: (i) a model management infrastructure for managing the life cycle of the models, (ii) a set of collaboration means for allowing involved stakeholders to work on the modelling artifacts collaboratively, and (iii) a set of communication means for allowing involved stakeholders to exchange, share, and communicate information within the team. Collaborative MDSE is attracting several research efforts from different research areas (e.g., model-driven engineering, global software engineering, etc.), resulting in a variegated scientific body of knowledge on the topic. Objective: In this study we aim at identifying, classifying, and understanding existing collaborative MDSE approaches. More specifically, our goal is to assess (i) the key characteristics of collaborative MDSE approaches (e.g., model editing environments, model versioning mechanisms, model repositories, support for communication and decision making), (ii) their faced challenges and limitations, and (iii) the interest of researchers in collaborative MDSE approaches over time and their focus on the three dimensions of collaborative MDSE. Method: In order to achieve this, we designed and conducted a systematic mapping study on collaborative MDSE. Starting from over 3,000 potentially relevant studies, we applied a rigorous selection procedure resulting in 106 selected papers, further clustered into 48 primary studies, along a time span of nineteen years. A suitable classification framework has been empirically defined and rigorously applied for extracting key information from each selected study. We collated, summarized, and analyzed extracted data by applying scientifically sound data synthesis techniques. Results: In addition to a number of specific insights, our analysis revealed the following key findings: (i) there is a growing scientific interest on collaborative MDSE in the last years; (ii) multi-view modeling, validation support, reuse, and branching are more rarely covered with respect to other aspects about collaborative MDSE; (iii) different primary studies focus differently on individual dimensions of collaborative MDSE (i.e., model management, collaboration, and communication); (iv) most approaches are language-specific, with a prominence of UML-based approaches; (v) few approaches support the interplay between synchronous and asynchronous collaboration. Conclusion: This study gives a solid foundation for a thorough identification and comparison of existing and future approaches for collaborative MDSE. Those results can be used by both researchers and practitioners for identifying existing research/technical gaps to attack, better scoping their own contributions to the field, or better understanding or refining existing ones.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453119','10.1145/3180155.3182543',0,0,'IEEE','IEEE Conferences',0),(340,'[Journal First] Are Fix-Inducing Changes a Moving Target?: A Longitudinal Case Study of Just-in-Time Defect Prediction',1,560,560,'Just-In-Time (JIT) models identify fix-inducing code changes. JIT models are trained using techniques that assume that past fix-inducing changes are similar to future ones. However, this assumption may not hold, e.g., as system complexity tends to accrue, expertise may become more important as systems age. In this paper, we study JIT models as systems evolve. Through a longitudinal case study of 37,524 changes from the rapidly evolving Qt and OpenStack systems, we find that fluctuations in the properties of fix-inducing changes can impact the performance and interpretation of JIT models. More specifically: (a) the discriminatory power (AUC) and calibration (Brier) scores of JIT models drop considerably one year after being trained; (b) the role that code change properties (e.g., Size, Experience) play within JIT models fluctuates over time; and (c) those fluctuations yield over- and underestimates of the future impact of code change properties on the likelihood of inducing fixes. To avoid erroneous or misleading predictions, JIT models should be retrained using recently recorded data (within three months). Moreover, quality improvement plans should be informed by JIT models that are trained using six months (or more) of historical data, since they are more resilient to period-specific fluctuations in the importance of code change properties.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453123','10.1145/3180155.3182514',0,1,'IEEE','IEEE Conferences',0),(341,'Metamorphic Testing of RESTful Web APIs',1,882,882,'Web Application Programming Interfaces (APIs) specify how to access services and data over the network, typically using Web services. Web APIs are rapidly proliferating as a key element to foster reusability, integration, and innovation, enabling new consumption models such as mobile or smart TV apps. Companies such as Facebook, Twitter, Google, eBay or Netflix receive billions of API calls every day from thousands of different third-party applications and devices, which constitutes more than half of their total traffic. As Web APIs are progressively becoming the cornerstone of software integration, their validation is getting more critical. In this context, the fast detection of bugs is of utmost importance to increase the quality of internal products and third-party applications. However, testing Web APIs is challenging mainly due to the difficulty to assess whether the output of an API call is correct, i.e., the oracle problem. For instance, consider the Web API of the popular music streaming service Spotify. Suppose a search for albums with the query \'redhouse\' returning 21 total matches: Is this output correct? Do all the albums in the result set contain the keyword? Are there any albums containing the keyword not included in the result set? Answering these questions is difficult, even with small result sets, and often infeasible when the results are counted by thousands or millions. Metamorphic testing alleviates the oracle problem by providing an alternative when the expected output of a test execution is complex or unknown. Rather than checking the output of an individual program execution, metamorphic testing checks whether multiple executions of the program under test fulfil certain necessary properties called metamorphic relations. For instance, consider the following metamorphic relation in Spotify: two searches for albums with the same query should return the same number of total results regardless of the size of pagination. Suppose that a new Spotify search is performed using the exact same query as before and increasing the maximum number of results per page from 20 (default value) to 50: This search returns 27 total albums (6 more matches than in the previous search), which reveals a bug. This is an example of a real and reproducible fault detected using the approach presented in this paper and reported to Spotify. According to Spotify developers, it was a regression fault caused by a fix with undesired side effects. In this paper [1], we present a metamorphic testing approach for the automated detection of faults in RESTful Web APIs (henceforth also referred to as simply Web APIs). We introduce the concept of metamorphic relation output patterns. A Metamorphic Relation Output Pattern (MROP) defines an abstract output relation typically identified in Web APIs, regardless of their application domain. Each MROP is defined in terms of set operations among test outputs such as equality, union, subset, or intersection. MROPs provide a helpful guide for the identification of metamorphic relations, broadening the scope of our work beyond a particular Web API. Based on the notion of MROP, a methodology is proposed for the application of the approach to any Web API following the REST architectural pattern. The approach was evaluated in several steps. First, we used the proposed methodology to identify 33 metamorphic relations in four Web APIs developed by undergraduate students. All the relations are instances of the proposed MROPs. Then, we assessed the effectiveness of the identified relations at revealing 317 automatically seeded faults (i.e., mutants) in the APIs under test. As a result, 302 seeded faults were detected, achieving a mutation score of 95.3%. Second, we evaluated the approach using real Web APIs and faults. In particular, we identified 20 metamorphic relations in the Web API of Spotify and 40 metamorphic relations in the Web API of YouTube. Each metamorphic relation was implemented and automatically executed using both random and manual test data. In total, 469K metamorphic tests were generated. As a result, 21 metamorphic relations were violated, and 11 issues revealed and reported (3 issues in Spotify and 8 issues in YouTube). To date, 10 of the reported issues have been either confirmed by the API developers or reproduced by other users supporting the effectiveness of our approach.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453162','10.1145/3180155.3182528',0,0,'IEEE','IEEE Conferences',0),(342,'On the Dichotomy of Debugging Behavior Among Programmers',1,572,583,'Debugging is an inevitable activity in most software projects, often difficult and more time-consuming than expected, giving it the nickname the \'dirty little secret of computer science.\' Surprisingly, we have little knowledge on how software engineers debug software problems in the real world, whether they use dedicated debugging tools, and how knowledgeable they are about debugging. This study aims to shed light on these aspects by following a mixed-methods research approach. We conduct an online survey capturing how 176 developers reflect on debugging. We augment this subjective survey data with objective observations on how 458 developers use the debugger included in their integrated development environments (IDEs) by instrumenting the popular Eclipse and IntelliJ IDEs with the purpose-built plugin WatchDog 2.0. To clarify the insights and discrepancies observed in the previous steps, we followed up by conducting interviews with debugging experts and regular debugging users. Our results indicate that IDE-provided debuggers are not used as often as expected, as \'printf debugging\' remains a feasible choice for many programmers. Furthermore, both knowledge and use of advanced debugging features are low. These results call to strengthen hands-on debugging experience in computer science curricula and have already refined the implementation of modern IDE debuggers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453125','10.1145/3180155.3180175',0,2,'IEEE','IEEE Conferences',0),(343,'[Journal First] Challenges and Pitfalls on Surveying Evidence in the Software Engineering Technical Literature: An Exploratory Study with Novices',1,1194,1194,'The evidence-based software engineering approach advocates the use of evidence from empirical studies to support the decisions on the adoption of software technologies by practitioners in the software industry. To this end, many guidelines have been proposed to contribute to the execution and repeatability of literature reviews, and to the confidence of their results, especially regarding systematic literature reviews (SLR). To investigate similarities and differences, and to characterize the challenges and pitfalls of the planning and generated results of SLR research protocols dealing with the same research question and performed by similar teams of novice researchers in the context of the software engineering field. We qualitatively compared (using Jaccard and Kappa coefficients) and evaluated (using DARE) same goal SLR research protocols and outcomes undertaken by similar research teams. Seven similar SLR protocols regarding quality attributes for use cases executed in 2010 and 2012 enabled us to observe unexpected differences in their planning and execution. Even when the participants reached some agreement in the planning, the outcomes were different. The research protocols and reports allowed us to observe six challenges contributing to the divergences in the results: researchers\' inexperience in the topic, researchers\' inexperience in the method, lack of clearness and completeness of the papers, lack of a common terminology regarding the problem domain, lack of research verification procedures, and lack of commitment to the SLR. According to our findings, it is not possible to rely on results of SLRs performed by novices. Also, similarities at a starting or intermediate step during different SLR executions may not directly translate to the next steps, since non-explicit information might entail differences in the outcomes, hampering the repeatability and confidence of the SLR process and results. Although we do have expectations that the presence and follow-up of a senior researcher can contribute to increasing SLRs\' repeatability, this conclusion can only be drawn upon the existence of additional studies on this topic. Yet, systematic planning, transparency of decisions and verification procedures are key factors to guarantee the reliability of SLRs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453200','10.1145/3180155.3182557',0,0,'IEEE','IEEE Conferences',0),(344,'Understanding the Factors for Fast Answers in Technical Q&A Websites: An Empirical Study of Four Stack Exchange Websites',1,884,884,'Technical questions and answers (Q&A) websites accumulate a significant amount of knowledge from users. Developers are especially active on these Q&A websites, since developers are constantly facing new development challenges that require help from other experts. Over the years, Q&A website designers have derived several incentive systems (e.g., gamification) to encourage users to answer questions that are posted by others. However, the current incentive systems primarily focus on the quantity and quality of the answers instead of encouraging the rapid answering of questions. Improving the speed of getting an answer can significantly improve the user experience and increase user engagement on such Q&A websites. In this paper [1], we study the factors for fast answers on such Q&A websites. Our goal is to explore how one may improve the current incentive systems to motivate fast answering of questions. We use a logistic regression model to analyze 46 factors along four dimensions (i.e., question, asker, answer, and answerer dimension) in order to understand the relationship between the studied factors and the needed time to get an accepted answer. The question dimension calculates various textual and readability features of a question, as well as the popularity and difficulty of the question\'s tags. The asker dimension calculates the reputation of an asker and his/her historical tendency to get answers. The answer dimension computes textual features from the text of the accepted answer. The answerer dimension computes the historical activity level of the answerer who answered the question. We conduct our study on the four most popular (i.e., with the most questions) Q&A Stack Exchange websites: Stack Overflow, Mathematics, Ask Ubuntu, and Superuser. We find that (i) factors in the answerer dimension have the strongest effect on the needed time to get an accepted answer, after controlling for other factors; (ii) the current incentive system does not recognize non-frequent answerers who often answer questions which frequent answerers are not able to answer well. Such questions that are answered by non-frequent answerers are as important as those that are answered by frequent answerers; (iii) the current incentive system motivates frequent answerers well, but such frequent answerers tend to answer short questions. Our findings suggest that the designers of Q&A website should improve their incentive systems to motivate non-frequent answerers to be more active and to answer questions faster, in order to shorten the waiting time for an answer (especially for questions that require specific knowledge that frequent answerers might not possess). In addition, the question answering incentive system needs to factor in the value and difficulty of answering the questions (e.g., by providing more rewards to harder questions or questions that remain unanswered for a long period of time).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453164','10.1145/3180155.3182521',0,3,'IEEE','IEEE Conferences',0),(345,'Towards Practical Program Repair with On-demand Candidate Generation',1,12,23,'Effective program repair techniques, which modify faulty programs to fix them with respect to given test suites, can substantially reduce the cost of manual debugging. A common repair approach is to iteratively first generate candidate programs with possible bug fixes and then validate them against the given tests until a candidate that passes all the tests is found. While this approach is conceptually simple, due to the potentially high number of candidates that need to first be generated and then be compiled and tested, existing repair techniques that embody this approach have relatively low effectiveness, especially for faults at a fine granularity. To tackle this limitation, we introduce a novel repair technique, SketchFix, which generates candidate fixes on demand (as needed) during the test execution. Instead of iteratively re-compiling and re-executing each actual candidate program, SketchFix translates faulty programs to sketches, i.e., partial programs with \'holes\', and compiles each sketch once which may represent thousands of concrete candidates. With the insight that the space of candidates can be reduced substantially by utilizing the runtime behaviors of the tests, SketchFix lazily initializes the candidates of the sketches while validating them against the test execution. We experimentally evaluate SketchFix on the Defects4J benchmark and the experimental results show that SketchFix works particularly well in repairing bugs with expression manipulation at the AST node-level granularity compared to other program repair techniques. Specifically, SketchFix correctly fixes 19 out of 357 defects in 23 minutes on average using the default setting. In addition, SketchFix finds the first repair with 1.6% of re-compilations (#compiled sketches/#candidates) and 3.0% of re-executions out of all repair candidates.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453056','10.1145/3180155.3180245',0,13,'IEEE','IEEE Conferences',0),(346,'Reducer-Based Construction of Conditional Verifiers',1,1182,1193,'Despite recent advances, software verification remains challenging. To solve hard verification tasks, we need to leverage not just one but several different verifiers employing different technologies. To this end, we need to exchange information between verifiers. Conditional model checking was proposed as a solution to exactly this problem: The idea is to let the first verifier output a condition which describes the state space that it successfully verified and to instruct the second verifier to verify the yet unverified state space using this condition. However, most verifiers do not understand conditions as input. In this paper, we propose the usage of an off-the-shelf construction of a conditional verifier from a given traditional verifier and a reducer. The reducer takes as input the program to be verified and the condition, and outputs a residual program whose paths cover the unverified state space described by the condition. As a proof of concept, we designed and implemented one particular reducer and composed three conditional model checkers from the three best verifiers at SV-COMP 2017. We defined a set of claims and experimentally evaluated their validity. All experimental data and results are available for replication.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453199','10.1145/3180155.3180259',0,0,'IEEE','IEEE Conferences',0),(347,'Data Scientists in Software Teams: State of the Art and Challenges',1,585,585,'The demand for analyzing large scale telemetry, machine, and quality data is rapidly increasing in software industry. Data scientists are becoming popular within software teams. For example, Facebook, LinkedIn and Microsoft are creating a new career path for data scientists. In this paper, we present a large-scale survey with 793 professional data scientists at Microsoft to understand their educational background, problem topics that they work on, tool usages, and activities. We cluster these data scientists based on the time spent for various activities and identify 9 distinct clusters of data scientists and their corresponding characteristics. We also discuss the challenges that they face and the best practices they share with other data scientists. Our study finds several trends about data scientists in the software engineering context at Microsoft, and should inform managers on how to leverage data science capability effectively within their teams.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453127','10.1145/3180155.3182515',0,0,'IEEE','IEEE Conferences',0),(348,'Secure Coding Practices in Java: Challenges and Vulnerabilities',1,372,383,'The Java platform and its third-party libraries provide useful features to facilitate secure coding. However, misusing them can cost developers time and effort, as well as introduce security vulnerabilities in software. We conducted an empirical study on StackOverflow posts, aiming to understand developers\' concerns on Java secure coding, their programming obstacles, and insecure coding practices. We observed a wide adoption of the authentication and authorization features provided by Spring Security - a third-party framework designed to secure enterprise applications. We found that programming challenges are usually related to APIs or libraries, including the complicated cross-language data handling of cryptography APIs, and the complex Java-based or XML-based approaches to configure Spring Security. In addition, we reported multiple security vulnerabilities in the suggested code of accepted answers on the StackOverflow forum. The vulnerabilities included disabling the default protection against Cross-Site Request Forgery (CSRF) attacks, breaking SSL/TLS security through bypassing certificate validation, and using insecure cryptographic hash functions. Our findings reveal the insufficiency of secure coding assistance and documentation, as well as the huge gap between security theory and coding practices.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453095','10.1145/3180155.3180201',0,6,'IEEE','IEEE Conferences',0),(349,'Identifying Design Problems in the Source Code: A Grounded Theory',1,921,931,'The prevalence of design problems may cause re-engineering or even discontinuation of the system. Due to missing, informal or outdated design documentation, developers often have to rely on the source code to identify design problems. Therefore, developers have to analyze different symptoms that manifest in several code elements, which may quickly turn into a complex task. Although researchers have been investigating techniques to help developers in identifying design problems, there is little knowledge on how developers actually proceed to identify design problems. In order to tackle this problem, we conducted a multi-trial industrial experiment with professionals from 5 software companies to build a grounded theory. The resulting theory offers explanations on how developers identify design problems in practice. For instance, it reveals the characteristics of symptoms that developers consider helpful. Moreover, developers often combine different types of symptoms to identify a single design problem. This knowledge serves as a basis to further understand the phenomena and advance towards more effective identification techniques.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453170','10.1145/3180155.3180239',0,3,'IEEE','IEEE Conferences',0),(350,'[Journal First] Do Automated Program Repair Techniques Repair Hard and Important Bugs?',1,25,25,'The full version of this article is: Manish Motwani, Sandhya Sankaranarayanan, Rene Just, and Yuriy Brun, \'Do Automated Program Repair Techniques Repair Hard and Important Bugs?\' in Empirical Software Engineering, http://dx.doi.org/10.1007/s10664-017-9550-0.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453058','10.1145/3180155.3182533',0,0,'IEEE','IEEE Conferences',0),(351,'EARMO: An Energy-Aware Refactoring Approach for Mobile Apps',1,59,59,'With millions of smartphones sold every year, the development of mobile apps has grown substantially. The battery power limitation of mobile devices has push developers and researchers to search for methods to improve the energy efficiency of mobile apps. We propose a multiobjective refactoring approach to automatically improve the architecture of mobile apps, while controlling for energy efficiency. In this extended abstract we briefly summarize our work.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453062','10.1145/3180155.3182524',0,0,'IEEE','IEEE Conferences',0),(352,'When Not to Comment: Questions and Tradeoffs with API Documentation for C++ Projects',1,643,653,'Without usable and accurate documentation of how to use an API, developers can find themselves deterred from reusing relevant code. In C++, one place developers can find documentation is in a header file. When information is missing, they may look at the corresponding implementation code. To understand what\'s missing from C++ API documentation and the factors influencing whether it will be fixed, we conducted a mixed-methods study involving two experience sampling surveys with hundreds of developers at the moment they visited implementation code, interviews with 18 of those developers, and interviews with 8 API maintainers. In many cases, updating documentation may provide only limited value for developers, while requiring effort maintainers don\'t want to invest. We identify a set of questions maintainers and tool developers should consider when improving API-level documentation.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453133','10.1145/3180155.3180176',0,1,'IEEE','IEEE Conferences',0),(353,'Search-Based Test Data Generation for SQL Queries',1,1220,1230,'Database-centric systems strongly rely on SQL queries to manage and manipulate their data. These SQL commands can range from very simple selections to queries that involve several tables, subqueries, and grouping operations. And, as with any important piece of code, developers should properly test SQL queries. In order to completely test a SQL query, developers need to create test data that exercise all possible coverage targets in a query, e.g., JOINs and WHERE predicates. And indeed, this task can be challenging and time-consuming for complex queries. Previous studies have modeled the problem of generating test data as a constraint satisfaction problem and, with the help of SAT solvers, generate the required data. However, such approaches have strong limitations, such as partial support for queries with JOINs, subqueries, and strings (which are commonly used in SQL queries). In this paper, we model test data generation for SQL queries as a search-based problem. Then, we devise and evaluate three different approaches based on random search, biased random search, and genetic algorithms (GAs). The GA, in particular, uses a fitness function based on information extracted from the physical query plan of a database engine as search guidance. We then evaluate each approach in 2,135 queries extracted from three open source software and one industrial software system. Our results show that GA is able to completely cover 98.6% of all queries in the dataset, requiring only a few seconds per query. Moreover, it does not suffer from the limitations affecting state-of-the art techniques.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453204','10.1145/3180155.3180202',0,2,'IEEE','IEEE Conferences',0),(354,'Large-Scale Analysis of Framework-Specific Exceptions in Android Apps',1,408,419,'Mobile apps have become ubiquitous. For app developers, it is a key priority to ensure their apps\' correctness and reliability. However, many apps still suffer from occasional to frequent crashes, weakening their competitive edge. Large-scale, deep analyses of the characteristics of real-world app crashes can provide useful insights to guide developers, or help improve testing and analysis tools. However, such studies do not exist - this paper fills this gap. Over a four-month long effort, we have collected 16,245 unique exception traces from 2,486 open-source Android apps, and observed that framework-specific exceptions account for the majority of these crashes. We then extensively investigated the 8,243 framework-specific exceptions (which took six person-months): (1) identifying their characteristics (e.g., manifestation locations, common fault categories), (2) evaluating their manifestation via state-of-the-art bug detection techniques, and (3) reviewing their fixes. Besides the insights they provide, these findings motivate and enable follow-up research on mobile apps, such as bug detection, fault localization and patch generation. In addition, to demonstrate the utility of our findings, we have optimized Stoat, a dynamic testing tool, and implemented ExLocator, an exception localization tool, for Android apps. Stoat is able to quickly uncover three previously-unknown, confirmed/fixed crashes in Gmail and Google+; ExLocator is capable of precisely locating the root causes of identified exceptions in real-world apps. Our substantial dataset is made publicly available to share with and benefit the community.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453100','10.1145/3180155.3180222',0,12,'IEEE','IEEE Conferences',0),(355,'From UI Design Image to GUI Skeleton: A Neural Machine Translator to Bootstrap Mobile GUI Implementation',1,665,676,'A GUI skeleton is the starting point for implementing a UI design image. To obtain a GUI skeleton from a UI design image, developers have to visually understand UI elements and their spatial layout in the image, and then translate this understanding into proper GUI components and their compositions. Automating this visual understanding and translation would be beneficial for bootstraping mobile GUI implementation, but it is a challenging task due to the diversity of UI designs and the complexity of GUI skeletons to generate. Existing tools are rigid as they depend on heuristically-designed visual understanding and GUI generation rules. In this paper, we present a neural machine translator that combines recent advances in computer vision and machine translation for translating a UI design image into a GUI skeleton. Our translator learns to extract visual features in UI images, encode these features\' spatial layouts, and generate GUI skeletons in a unified neural network framework, without requiring manual rule development. For training our translator, we develop an automated GUI exploration method to automatically collect large-scale UI data from real-world applications. We carry out extensive experiments to evaluate the accuracy, generality and usefulness of our approach.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453135','10.1145/3180155.3180240',0,8,'IEEE','IEEE Conferences',0),(356,'Does the Propagation of Artifact Changes Across Tasks Reflect Work Dependencies?',1,397,407,'Developers commonly define tasks to help coordinate software development efforts--whether they be feature implementation, refactoring, or bug fixes. Developers establish links between tasks to express implicit dependencies that needs explicit handling--dependencies that often require the developers responsible for a given task to assess how changes in a linked task affect their own work and vice versa (i.e., change propagation). While seemingly useful, it is unknown if change propagation indeed coincides with task links. No study has investigated to what extent change propagation actually occurs between task pairs and whether it is able to serve as a metric for characterizing the underlying task dependency. In this paper, we study the temporal relationship between developer reading and changing of source code in relationship to task links. We identify seven situations that explain the varying correlation of change propagation with linked task pairs and find six motifs describing when change propagation occurs between non-linked task pairs. Our paper demonstrates that task links are indeed useful for recommending which artifacts to monitor for changes, which developers to involve in a task, or which tasks to inspect.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453099','10.1145/3180155.3180185',0,2,'IEEE','IEEE Conferences',0),(357,'Automated Refactoring of OCL Constraints with Search',1,1243,1243,'Object Constraint Language (OCL) constraints are typically used for providing precise semantics to models developed with the Unified Modeling Language (UML). When OCL constraints evolve in a regular basis, it is essential that they are easy to understand and maintain. For instance, in cancer registries, to ensure the quality of cancer data, more than one thousand medical rules are defined and evolve regularly. Such rules can be specified with OCL. It is, therefore, important to ensure the understandability and maintainability of medical rules specified with OCL. To tackle such a challenge, we propose an automated search-based OCL constraint refactoring approach (SBORA) by defining and applying three OCL quality metrics (Complexity, Coupling, and Cohesion) and four semantics-preserving refactoring operators (i.e., Context Change, Swap, Split and Merge) which are encoded as potential solutions for search algorithms. A solution is therefore an optimal sequence of refactoring operators, which are sequentially applied to the original set of OCL constraints to automatically obtain a semantically equivalent set of OCL constraints with better understandability and maintainability in terms of Complexity, Coupling, and Cohesion. We evaluate SBORA along with six commonly used multi-objective search algorithms (e.g., Indicator-Based Evolutionary Algorithm (IBEA)) by employing four case studies from different domains: healthcare (i.e., cancer registry system from Cancer Registry of Norway (CRN)), Oil&Gas (i.e., subsea production systems), warehouse (i.e., handling systems), and an open source case study named SEPA. Results show: 1) IBEA achieves the best performance among all the search algorithms and 2) the refactoring approach along with IBEA can manage to reduce on average 29.25% Complexity and 39% Coupling and improve 47.75% Cohesion, as compared to the original OCL constraint set from CRN. To further test the performance of SBORA, we also applied it to refactor an OCL constraint set specified on the UML 2.3 metamodel and we obtained encouraging results. Furthermore, we conducted a controlled experiment with 96 subjects and results show that the understandability and maintainability of the original constraint set can be improved significantly from the perspectives of the 96 participants of the controlled experiment.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453206','10.1145/3180155.3182546',0,0,'IEEE','IEEE Conferences',0),(358,'[Journal First] Experiences and Challenges in Building a Data Intensive System for Data Migration',1,93,93,'Recent analyses[2, 4, 5] report that many sectors of our economy and society are more and more guided by data-driven decision processes (e.g., health care, public administrations, etc.). As such, Data Intensive (DI) applications are becoming more and more important and critical. They must be fault-tolerant, they should scale with the amount of data, and be able to elastically leverage additional resources as and when these last ones are provided [3]. Moreover, they should be able to avoid data drops introduced in case of sudden overloads and should offer some Quality of Service (QoS) guarantees. Ensuring all these properties is, per se, a challenge, but it becomes even more difficult for DI applications, given the large amount of data to be managed and the significant level of parallelism required for its components. Even if today some technological frameworks are available for the development of such applications (for instance, think of Spark, Storm, Flink), we still lack solid software engineering approaches to support their development and, in particular, to ensure that they offer the required properties in terms of availability, throughput, data loss, etc. In fact, at the time of writing, identifying the right solution can require several rounds of experiments and the adoption of many different technologies. This implies the need for highly skilled persons and the execution of experiments with large data sets and a large number of resources, and, consequently, a significant amount of time and budget. To experiment with currently available approaches, we performed an action research experiment focusing on developing- testing-reengineering a specific DI application, Hegira4Cloud, that migrates data between widely used NoSQL databases, including so-called Database as a Service (DaaS), as well as on-premise databases. This is a representative DI system because it has to handle large volumes of data with different structures and has to guarantee that some important characteristics, in terms of data types and transactional properties, are preserved. Also, it poses stringent requirements in terms of correctness, high performance, fault tolerance, and fast and effective recovery. In our action research, we discovered that the literature offered some high level design guidelines for DI applications, as well as some tools to support modelling and QoS analysis/simulation of complex architectures, however the available tools were not yet. suitable to support DI systems. Moreover, we realized that the available big data frameworks we could have used were not flexible enough to cope with all possible application-specific aspects of our system. Hence, to achieve the desired level of performance, fault tolerance and recovery, we had to adopt a time-consuming, experiment-based approach [1, 6], which, in our case, consisted of three iterations: (1) the design and implementation of a Mediation Data Model capable of managing data extracted from different databases, together with a first monholitical prototype of Hegira4Cloud; (2) the improvement of performance of our prototype when managing and transferring huge amounts of data; (3) the introduction of fault-tolerant data extraction and management mechanisms, which are independent from the targeted databases. Among the others, an important issue that has forced us to reiterate in the development of Hegira4Cloud concerned the DaaS we interfaced with. In particular these DaaS, which are well-known services with a large number of users: (1) were missing detailed information regarding the behaviour of their APIs; (2) did not offer a predictable service; (3) were suffering of random downtimes not correlated with the datasets we were experimenting with. In this journal first presentation, we describe our experience and the issues we encountered that led to some important decisions during the software design and engineering process. Also, we analyse the state of the art of software design and verification tools and approaches in the light of our experience, and identify weaknesses, alternative design approaches and open challenges that could generate new research in these areas. More details can be found in the journal publication.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453066','10.1145/3180155.3182534',0,0,'IEEE','IEEE Conferences',0),(359,'[Journal First] Sentiment Polarity Detection for Software Development',1,128,128,'The role of sentiment analysis is increasingly emerging to study software developers\' emotions by mining crowd-generated content within software repositories and information sources. With a few notable exceptions, empirical software engineering studies have exploited off-the-shelf sentiment analysis tools. However, such tools have been trained on non-technical domains and general-purpose social media, thus resulting in misclassifications of technical jargon and problem reports. In particular, Jongeling et al. show how the choice of the sentiment analysis tool may impact the conclusion validity of empirical studies because not only these tools do not agree with human annotation of developers\' communication channels, but they also disagree among themselves. Our goal is to move beyond the limitations of off-the-shelf sentiment analysis tools when applied in the software engineering domain. Accordingly, we present Senti4SD, a sentiment polarity classifier for software developers\' communication channels. Senti4SD exploits a suite of lexicon-based, keyword-based, and semantic features for appropriately dealing with the domain-dependent use of a lexicon. We built a Distributional Semantic Model (DSM) to derive the semantic features exploited by Senti4SD. Specifically, we ran word2vec on a collection of over 20 million documents from Stack Overflow, thus obtaining word vectors that are representative of developers\' communication style. The classifier is trained and validated using a gold standard of 4,423 Stack Overflow posts, including questions, answers, and comments, which were manually annotated for sentiment polarity. We release the full lab package, which includes both the gold standard and the emotion annotation guidelines, to ease the execution of replications as well as new studies on emotion awareness in software engineering. To inform future research on word embedding for text categorization and information retrieval in software engineering, the replication kit also includes the DSM. Results. The contribution of the lexicon-based, keyword-based, and semantic features is assessed by our empirical evaluation leveraging different feature settings. With respect to SentiStrength, a mainstream off-the-shelf tool that we use as a baseline, Senti4SD reduces the misclassifications of neutral and positive posts as emotionally negative. Furthermore, we provide empirical evidence of better performance also in presence of a minimal set of training documents.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453070','10.1145/3180155.3182519',0,0,'IEEE','IEEE Conferences',0),(360,'Redefining Prioritization: Continuous Prioritization for Continuous Integration',1,688,698,'Continuous integration (CI) development environments allow soft-ware engineers to frequently integrate and test their code. While CI environments provide advantages, they also utilize non-trivial amounts of time and resources. To address this issue, researchers have adapted techniques for test case prioritization (TCP) to CI environments. To date, however, the techniques considered have operated on test suites, and have not achieved substantial improvements. Moreover, they can be inappropriate to apply when system build costs are high. In this work we explore an alternative: prioritization of commits. We use a lightweight approach based on test suite failure and execution history that is highly efficient; our approach \'continuously\' prioritizes commits that are waiting for execution in response to the arrival of each new commit and the completion of each previously scheduled commit. We have evaluated our approach on three non-trivial CI data sets. Our results show that our approach can be more effective than prior techniques.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453137','10.1145/3180155.3180213',0,1,'IEEE','IEEE Conferences',0),(361,'[Journal First] Older Adults and Hackathons: A Qualitative Study',1,702,703,'Globally observed trends in aging indicate that older adults constitute a growing share of the population and an increasing demographic in the modern technologies marketplace. Therefore, it has become important to address the issue of participation of older adults in the process of developing solutions suitable for their group. In this study, we approached this topic by organizing a hackathon involving teams of young programmers and older adult participants. In our paper we describe a case study of that hackathon, in which our objective was to motivate older adults to participate in software engineering processes. Based on our results from an array of qualitative methods, we propose a set of good practices that may lead to improved older adult participation in similar events and an improved process of developing apps that target older adults.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453141','10.1145/3180155.3182547',0,0,'IEEE','IEEE Conferences',0),(362,'DeFlaker: Automatically Detecting Flaky Tests',1,433,444,'Developers often run tests to check that their latest changes to a code repository did not break any previously working functionality. Ideally, any new test failures would indicate regressions caused by the latest changes. However, some test failures may not be due to the latest changes but due to non-determinism in the tests, popularly called flaky tests. The typical way to detect flaky tests is to rerun failing tests repeatedly. Unfortunately, rerunning failing tests can be costly and can slow down the development cycle. We present the first extensive evaluation of rerunning failing tests and propose a new technique, called DeFlaker, that detects if a test failure is due to a flaky test without rerunning and with very low runtime overhead. DeFlaker monitors the coverage of latest code changes and marks as flaky any newly failing test that did not execute any of the changes. We deployed DeFlaker live, in the build process of 96 Java projects on TravisCI, and found 87 previously unknown flaky tests in 10 of these projects. We also ran experiments on project histories, where DeFlaker detected 1,874 flaky tests from 4,846 failures, with a low false alarm rate (1.5%). DeFlaker had a higher recall (95.5% vs. 23%) of confirmed flaky tests than Maven\'s default flaky test detector.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453104','10.1145/3180155.3180164',0,7,'IEEE','IEEE Conferences',0),(363,'Identifying Features in Forks',1,105,116,'Fork-based development has been widely used both in open source communities and in industry, because it gives developers flexibility to modify their own fork without affecting others. Unfortunately, this mechanism has downsides: When the number of forks becomes large, it is difficult for developers to get or maintain an overview of activities in the forks. Current tools provide little help. We introduce INFOX, an approach to automatically identify non-merged features in forks and to generate an overview of active forks in a project. The approach clusters cohesive code fragments using code and network-analysis techniques and uses information-retrieval techniques to label clusters with keywords. The clustering is effective, with 90% accuracy on a set of known features. In addition, a human-subject evaluation shows that INFOX can provide actionable insight for developers of forks.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453068','10.1145/3180155.3180205',0,3,'IEEE','IEEE Conferences',0),(364,'Automated Repair of Mobile Friendly Problems in Web Pages',1,140,150,'Mobile devices have become a primary means of accessing the Internet. Unfortunately, many websites are not designed to be mobile friendly. This results in problems such as unreadable text, cluttered navigation, and content over owing a device\'s viewport; all of which can lead to a frustrating and poor user experience. Existing techniques are limited in helping developers repair these mobile friendly problems. To address this limitation of prior work, we designed a novel automated approach for repairing mobile friendly problems in web pages. Our empirical evaluation showed that our approach was able to successfully resolve mobile friendly problems in 95% of the evaluation subjects. In a user study, participants preferred our repaired versions of the subjects and also considered the repaired pages to be more readable than the originals.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453072','10.1145/3180155.3180262',0,3,'IEEE','IEEE Conferences',0),(365,'[Journal First] On the Use of Hidden Markov Model to Predict the Time to Fix Bugs',1,700,700,'A significant amount of time is spent by software developers in investigating bug reports. It is useful to indicate when a bug report will be closed, since it would help software teams to prioritise their work. Several studies have been conducted to address this problem in the past decade. Most of these studies have used the frequency of occurrence of certain developer activities as input attributes in building their prediction models. However, these approaches tend to ignore the temporal nature of the occurrence of these activities. In this paper, a novel approach using Hidden Markov models (HMMs) and temporal sequences of developer activities is proposed. The approach is empirically demonstrated in a case study using eight years of bug reports collected from the Firefox project.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453139','10.1145/3180155.3182522',0,0,'IEEE','IEEE Conferences',0),(366,'Do Programmers Work at Night or During the Weekend?',1,705,715,'Abnormal working hours can reduce work health, general well-being, and productivity, independent from a profession. To inform future approaches for automatic stress and overload detection, this paper establishes empirically collected measures of the work patterns of software engineers. To this aim, we perform the first largescale study of software engineers\' working hours by investigating the time stamps of commit activities of 86 large open source software projects, both containing hired and volunteer developers. We find that two thirds of software engineers mainly follow typical office hours, empirically established to be from 10h to 18h, and do not usually work during nights and weekends. Large variations between projects and individuals exist. Surprisingly, we found no support that project maturation would decrease abnormal working hours. In the Firefox case study, we found that hired developers work more during office hours while seniority, either in terms of number of commits or job status, did not impact working hours. We conclude that the use of working hours or timestamps of work products for stress detection requires establishing baselines at the level of individuals.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453143','10.1145/3180155.3180193',0,2,'IEEE','IEEE Conferences',0),(367,'Context-Aware Conversational Developer Assistants',1,993,1003,'Building and maintaining modern software systems requires developers to perform a variety of tasks that span various tools and information sources. The crosscutting nature of these development tasks requires developers to maintain complex mental models and forces them (a) to manually split their high-level tasks into low-level commands that are supported by the various tools, and (b) to (re) establish their current context in each tool. In this paper we present Devy, a Conversational Developer Assistant (CDA) that enables developers to focus on their high-level development tasks. Devy reduces the number of manual, often complex, low-level commands that developers need to perform, freeing them to focus on their high-level tasks. Specifically, Devy infers high-level intent from developer\'s voice commands and combines this with an automatically-generated context model to determine appropriate workflows for invoking low-level tool actions; where needed, Devy can also prompt the developer for additional information. Through a mixed methods evaluation with 21 industrial developers, we found that Devy provided an intuitive interface that was able to support many development tasks while helping developers stay focused within their development environment. While industrial developers were largely supportive of the automation Devy enabled, they also provided insights into several other tasks and workflows CDAs could support to enable them to better focus on the important parts of their development tasks.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453178','10.1145/3180155.3180238',0,4,'IEEE','IEEE Conferences',0),(368,'[Journal First] On the Diffuseness and the Impact on Maintainability of Code Smells: A Large Scale Empirical Investigation',1,482,482,'Code smells are symptoms of poor design and implementation choices that may hinder code comprehensibility and maintainability. Despite the effort devoted by the research community in studying code smells, the extent to which code smells in software systems affect software maintainability remains still unclear. In this paper we present a large scale empirical investigation on the diffuseness of code smells and their impact on code change- and fault-proneness. The study was conducted across a total of 395 releases of 30 open source projects and considering 17,350 manually validated instances of 13 different code smell types. The results show that smells characterized by long and/or complex code (e.g., Complex Class) are highly diffused, and that smelly classes have a higher change- and fault-proneness than smell-free classes.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453110','10.1145/3180155.3182532',0,0,'IEEE','IEEE Conferences',0),(369,'[Journal First] Overfitting in Semantics-Based Automated Program Repair',1,163,163,'The primary goal of Automated Program Repair (APR) is to automatically fix buggy software, to reduce the manual bug-fix burden that presently rests on human developers. Existing APR techniques can be generally divided into two families: semantics-vs. heuristics-based. Semantics-based APR uses symbolic execution and test suites to extract semantic constraints, and uses program synthesis to synthesize repairs that satisfy the extracted constraints. Heuristic-based APR generates large populations of repair candidates via source manipulation, and searches for the best among them. Both families largely rely on a primary assumption that a program is correctly patched if the generated patch leads the program to pass all provided test cases. Patch correctness is thus an especially pressing concern. A repair technique may generate overfitting patches, which lead a program to pass all existing test cases, but fails to generalize beyond them. In this work, we revisit the overfitting problem with a focus on semantics-based APR techniques, complementing previous studies of the overfitting problem in heuristics-based APR. We perform our study using IntroClass and Codeflaws benchmarks, two datasets well-suited for assessing repair quality, to systematically characterize and understand the nature of overfitting in semantics-based APR. We find that similar to heuristics-based APR, overfitting also occurs in semantics-based APR in various different ways.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453074','10.1145/3180155.3182536',0,2,'IEEE','IEEE Conferences',0),(370,'Self-Hiding Behavior in Android Apps: Detection and Characterization',1,728,739,'Applications (apps) that conceal their activities are fundamentally deceptive; app marketplaces and end-users should treat such apps as suspicious. However, due to its nature and intent, activity concealing is not disclosed up-front, which puts users at risk. In this paper, we focus on characterization and detection of such techniques, e.g., hiding the app or removing traces, which we call \'self hiding behavior\' (SHB). SHB has not been studied per se - rather it has been reported on only as a byproduct of malware investigations. We address this gap via a study and suite of static analyses targeted at SH in Android apps. Specifically, we present (1) a detailed characterization of SHB, (2) a suite of static analyses to detect such behavior, and (3) a set of detectors that employ SHB to distinguish between benign and malicious apps. We show that SHB ranges from hiding the app\'s presence or activity to covering an app\'s traces, e.g., by blocking phone calls/text messages or removing calls and messages from logs. Using our static analysis tools on a large dataset of 9,452 Android apps (benign as well as malicious) we expose the frequency of 12 such SH behaviors. Our approach is effective: it has revealed that malicious apps employ 1.5 SHBs per app on average. Surprisingly, SH behavior is also employed by legitimate (\'benign\') apps, which can affect users negatively in multiple ways. When using our approach for separating malicious from benign apps, our approach has high precision and recall (combined F-measure = 87.19%). Our approach is also efficient, with analysis typically taking just 37 seconds per app. We believe that our findings and analysis tool are beneficial to both app marketplaces and end-users.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453145','10.1145/3180155.3180214',0,2,'IEEE','IEEE Conferences',0),(371,'[Journal First] Analyzing the Effects of Test Driven Development in GitHub',1,1062,1062,'Testing is an integral part of the software development lifecycle, approached with varying degrees of rigor by different process models. Agile process models recommend Test Driven Development (TDD) as a key practice for reducing costs and improving code quality. The objective of this work is to perform a cost-benefit analysis of this practice. Previous work by Fucci et al. engaged in laboratory studies of developers actively engaged in test-driven development practices. Fucci et al. found little difference between test-first behaviour of TDD and test-later behaviour. To that end, we opted to conduct a study about TDD behaviours in the \'wild\' rather than in the laboratory. Thus we have conducted a comparative analysis of GitHub repositories that adopts TDD to a lesser or greater extent, in order to determine how TDD affects software development productivity and software quality. We classified GitHub repositories archived in 2015 in terms of how rigorously they practiced TDD, thus creating a TDD spectrum. We then matched and compared various subsets of these repositories on this TDD spectrum with control sets of equal size. The control sets were samples from all GitHub repositories that matched certain characteristics, and that contained at least one test file. We compared how the TDD sets differed from the control sets on the following characteristics: number of test files, average commit velocity, number of bug-referencing commits, number of issues recorded, usage of continuous integration, number of pull requests, and distribution of commits per author. We found that Java TDD projects were relatively rare. In addition, there were very few significant differences in any of the metrics we used to compare TDD-like and non-TDD projects; therefore, our results do not reveal any observable benefits from using TDD.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453184','10.1145/3180155.3182535',0,0,'IEEE','IEEE Conferences',0),(372,'[Journal First] An Empirical Study of Early Access Games on the Steam Platform',1,480,480,'\'Early access\' is a release strategy for software that allows consumers to purchase an unfinished version of the software. In turn, consumers can influence the software development process by giving developers early feedback. This early access model has become increasingly popular through digital distribution platforms, such as Steam which is the most popular distribution platform for games. The plethora of options offered by Steam to communicate between developers and game players contribute to the popularity of the early access model. The early access model made a name for itself through several successful games, such as the DayZ game. The multiplayer survival-based game reached 400,000 sales during its first week as an early access game. However, the benefits of the early access model have been questioned as well. For instance, the Spacebase DF-9 game abandoned the early access stage unexpectedly, disappointing many players of the game. Shortly after abandoning the early access stage and terminating the development, twelve employees were laid off including the programmer and project lead. In this paper, we conduct an empirical study on 1,182 Early Access Games (EAGs) on the Steam platform to understand the characteristics, advantages and limitations of the early access model. We find that 15% of the games on Steam make use of the early access model, with the most popular EAG having as many as 29 million owners. 88% of the EAGs are classified by their developers as so-called \'indie\' games, indicating that most EAGs are developed by individual developers or small studios. We study the interaction between players and developers of EAGs and the Steam platform. We observe that on the one hand, developers update their games more frequently in the early access stage. On the other hand, the percentage of players that review a game during its early access stage is lower than the percentage of players that review the game after it leaves the early access stage. However, the average rating of the reviews is much higher during the early access stage, suggesting that players are more tolerant of imperfections in the early access stage. The positive review rate does not correlate with the length or the game update frequency of the early access stage. In addition, we discuss several learned lessons from the failure of an early access game. The main learned lesson from this failure is that the communication between the game developer and the players of the EAG is crucial. Players enjoy getting involved in the development of an early access game and they get emotionally involved in the decision-making about the game. Based on our findings, we suggest game developers to use the early access model as a method for eliciting early feedback and more positive reviews to attract additional new players. In addition, our findings suggest that developers can determine their release schedule without worrying about the length of the early access stage and the game update frequency during the early access stage.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453108','10.1145/3180155.3182512',0,0,'IEEE','IEEE Conferences',0),(373,'ENTRUST: Engineering Trustworthy Self-Adaptive Software with Dynamic Assurance Cases',1,495,495,'Software systems are increasingly expected to cope with variable workloads, component failures and other uncertainties through self-adaptation. As such, self-adaptive software has been the subject of intense research over the past decade. Our work focuses on the use of self-adaptive software in applications with strict functional and non-functional requirements. These applications need compelling assurances that the software continues to meet its requirements while it reconfigures its architecture and parameters at runtime. To address this need, we introduce an end-to-end methodology for the ENgineering of TRUstworthy Self-adaptive sofTware (ENTRUST).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453112','10.1145/3180155.3182540',0,0,'IEEE','IEEE Conferences',0),(374,'[Journal First] A Comparison of Program Comprehension Strategies by Blind and Sighted Programmers',1,788,788,'Programmers who are blind use a screen reader to speak source code one word at a time, as though the code were text. This process of reading is in stark contrast to sighted programmers, who skim source code rapidly with their eyes. At present, it is not known whether the difference in these processes has effects on the program comprehension gained from reading code. These effects are important because they could reduce both the usefulness of accessibility tools and the generalizability of software engineering studies to persons with low vision. In this paper, we present an empirical study comparing the program comprehension of blind and sighted programmers. We found that both blind and sighted programmers prioritize reading method signatures over other areas of code. Both groups obtained an equal and high degree of comprehension, despite the different reading processes.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453151','10.1145/3180155.3182544',0,0,'IEEE','IEEE Conferences',0),(375,'[Journal First] MSeer 鈥� An Advanced Technique for Locating Multiple Bugs in Parallel',1,1064,1064,'In practice, a program may contain multiple bugs. The simultaneous presence of these bugs may deteriorate the effectiveness of existing fault-localization techniques to locate program bugs. While it is acceptable to use all failed and successful tests to identify suspicious code for programs with exactly one bug, it is not appropriate to use the same approach for programs with multiple bugs because the due-to relationship between failed tests and underlying bugs cannot be easily identified. One solution is to generate fault-focused clusters by grouping failed tests caused by the same bug into the same clusters. We propose MSeer - an advanced fault localization technique for locating multiple bugs in parallel. Our major contributions include the use of (1) a revised Kendall tau distance to measure the distance between two failed tests, (2) an innovative approach to simultaneously estimate the number of clusters and assign initial medoids to these clusters, and (3) an improved K-medoids clustering algorithm to better identify the due-to relationship between failed tests and their corresponding bugs. Case studies on 840 multiple-bug versions of seven programs suggest that MSeer performs better in terms of effectiveness and efficiency than two other techniques for locating multiple bugs in parallel.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453186','10.1145/3180155.3182552',0,0,'IEEE','IEEE Conferences',0),(376,'[Journal First] Lightweight, Obfuscation-Resilient Detection and Family Identification of Android Malware',1,497,497,'The number of malicious Android apps has been and continues to increase rapidly. These malware can damage or alter other files or settings, install additional applications, obfuscate their behaviors, propagate quickly, and so on. To identify and handle such malware, a security analyst can significantly benefit from identifying the family to which a malicious app belongs rather than only detecting if an app is malicious. To address these challenges, we present a novel machine learning-based Android malware detection and family-identification approach, RevealDroid, that operates without the need to perform complex program analyses or extract large sets of features. RevealDroid\'s selected features leverage categorized Android API usage, reflection-based features, and features from native binaries of apps. We assess RevealDroid for accuracy, efficiency, and obfuscation resilience using a large dataset consisting of more than 54,000 malicious and benign apps. Our experiments show that RevealDroid achieves an accuracy of 98% in detection of malware and an accuracy of 95% in determination of their families. We further demonstrate RevealDroid\'s superiority against state-of-the-art approaches.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453114','10.1145/3180155.3182551',0,0,'IEEE','IEEE Conferences',0),(377,'Do You Remember This Source Code?',1,764,775,'Being familiar with the source code of a program comprises knowledge about its purpose, structure, and details. Consequently, familiarity is an important factor in many contexts of software development, especially for maintenance and program comprehension. As a result, familiarity is considered to some extent in many different approaches, for example, to model costs or to identify experts. Still, all approaches we are aware of require a manual assessment of familiarity and empirical analyses of forgetting in software development are missing. In this paper, we address this issue with an empirical study that we conducted with 60 open-source developers. We used a survey to receive information on the developers\' familiarity and analyze the responses based on data we extract from their used version control systems. The results show that forgetting is an important factor when considering familiarity and program comprehension of developers. We find that a forgetting curve is partly applicable for software development, investigate three factors - the number of edits, ratio of owned code, and tracking behavior - that can impact familiarity with code, and derive a general memory strength for our participants. Our findings can be used to scope approaches that have to consider familiarity and they provide insights into forgetting in the context of software development.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453149','10.1145/3180155.3180215',0,1,'IEEE','IEEE Conferences',0),(378,'How not to Structure Your Database-Backed Web Applications: A Study of Performance Bugs in the Wild',1,800,810,'Many web applications use databases for persistent data storage, and using Object Relational Mapping (ORM) frameworks is a common way to develop such database-backed web applications. Unfortunately, developing efficient ORM applications is challenging, as the ORM framework hides the underlying database query generation and execution. This problem is becoming more severe as these applications need to process an increasingly large amount of persistent data. Recent research has targeted specific aspects of performance problems in ORM applications. However, there has not been any systematic study to identify common performance anti-patterns in real-world such applications, how they affect resulting application performance, and remedies for them. In this paper, we try to answer these questions through a comprehensive study of 12 representative real-world ORM applications. We generalize 9 ORM performance anti-patterns from more than 200 performance issues that we obtain by studying their bug-tracking systems and profiling their latest versions. To prove our point, we manually fix 64 performance issues in their latest versions and obtain a median speedup of 2脳 (and up to 39脳 max) with fewer than 5 lines of code change in most cases. Many of the issues we found have been confirmed by developers, and we have implemented ways to identify other code fragments with similar issues as well.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453153','10.1145/3180155.3180194',0,2,'IEEE','IEEE Conferences',0),(379,'[Journal First] ChangeLocator: Locate Crash-Inducing Changes Based on Crash Reports',1,536,536,'Software crashes are severe manifestations of software bugs. Debugging crashing bugs is tedious and time-consuming. Understanding software changes that induce a crashing bug can provide useful contextual information for bug fixing and is highly demanded by developers. Locating the bug inducing changes is also useful for automatic program repair, since it narrows down the root causes and reduces the search space of bug fix location. However, currently there are no systematic studies on locating the software changes to a source code repository that induce a crashing bug reflected by a bucket of crash reports. To tackle this problem, we first conducted an empirical study on characterizing the bug inducing changes for crashing bugs (denoted as crashinducing changes). We also propose ChangeLocator, a method to automatically locate crash-inducing changes for a given bucket of crash reports. We base our approach on a learning model that uses features originated from our empirical study and train the model using the data from the historical fixed crashes. We evaluated ChangeLocator with six release versions of Netbeans project. The results show that it can locate the crash-inducing changes for 44.7%, 68.5%, and 74.5% of the bugs by examining only top 1, 5 and 10 changes in the recommended list, respectively. It significantly outperforms the existing state-of-the-art approach.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453120','10.1145/3180155.3182516',0,0,'IEEE','IEEE Conferences',0),(380,'[Journal First] Empirical Study on the Discrepancy Between Performance Testing Results from Virtual and Physical Environments',1,822,822,'Large software systems often undergo performance tests to ensure their capability to handle expected loads. These performance tests often consume large amounts of computing resources and time since heavy loads need to be generated. Making it worse, the ever evolving eld requires frequent updates to the performance testing environment. In practice, virtual machines (VMs) are widely exploited to provide exible and less costly environments for performance tests. However, the use of VMs may introduce confounding overhead (e.g., a higher than expected memory utilization with unstable I/O tra c) to the testing environment and lead to unre-alistic performance testing results. Yet, little research has studied the impact on test results of using VMs in performance testing activities. To evaluate the discrepancy between the performance testing results from virtual and physical environments, we perform a case study on two open source systems - namely Dell DVD Store (DS2) and CloudStore. We conduct the same performance tests in both virtual and physical environments and compare the performance testing results based on the three aspects that are typically examined for performance testing results: 1) single performance metric (e.g. CPU Time from virtual environment vs. CPU Time from physical environment), 2) the relationship among performance metrics (e.g. correlation between CPU and I/O) and 3) performance models that are built to predict system performance. Our results show that 1) A single metric from virtual and physical environments do not follow the same distribution, hence practitioners cannot simply use a scaling factor to compare the performance between environments, 2) correlations among performance metrics in virtual environments are different from those in physical environments 3) statistical models built based on the performance metrics from virtual environments are different from the models built from physical environments suggesting that practitioners cannot use the performance testing results across virtual and physical environments. In order to assist the practitioners leverage performance testing results in both environments, we investigate ways to reduce the discrepancy. We find that such discrepancy can be reduced by normalizing performance metrics based on deviance. Overall, we suggest that practitioners should not use the performance testing results from virtual environment with the simple assumption of straightforward performance overhead. Instead, practitioners should consider leveraging normalization techniques to reduce the discrepancy before examining performance testing results from virtual and physical environments.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453155','10.1145/3180155.3182527',0,0,'IEEE','IEEE Conferences',0),(381,'A Posteriori Typing for Model-Driven Engineering: Concepts, Analysis, and Applications',1,1136,1136,'Model-Driven Engineering (MDE) is a software engineering paradigm where models are actively used to specify, test, simulate, analyse and maintain the systems to be built, among other activities. Models can be defined using general-purpose modelling languages like the UML, but for particular domains, the use of domain-specific languages is pervasive. Either way, models must conform to a meta-model which defines their abstract syntax. In MDE, the definition of model management operations - often typed over project-specific meta-models - is recurrent. However, even if two operations are similar, they must be developed from scratch whenever they are applied to instances of different meta-models. This is so as operations defined (i.e., typed) over a meta-model cannot be directly reused for another. Part of this difficulty of reuse is because classes in meta-models are used in two ways: as templates to create objects and as static classifiers for them. These two aspects are inherently tied in most meta-modelling approaches, which results in unnecessarily rigid systems and hinders reusability of MDE artefacts. To enhance flexibility and reuse in MDE, we propose an approach to decouple object creation from typing [1]. The approach relies on standard mechanisms for object creation, and proposes the notion of a posteriori typing as a means to retype objects and enable multiple, partial, dynamic typings. A posteriori typing enhances flexibility because it allows models to be retyped with respect to other meta-models. Hence, we distinguish between creation meta-models used to construct models, and role meta-models into which models are retyped. This permits unanticipated reuse, as a model management operation defined for a role meta-model can be reused as-is with models built using a different creation meta-model, once such models are reclassified. Moreover, our approach permits expressing some types of bidirectional model transformations by reclassification. The transformations defined as reclassifications have better performance than the equivalent ones defined with traditional transformation languages, because reclassification does not require creating new objects. In [1], we propose two mechanisms to define a posteriori typings: type-level (mappings between meta-models) and instance-level (set of model queries). The paper presents the underlying theory and type correctness criteria of both mechanisms, defines some analysis methods, identifies practical restrictions for retyping specifications, and demonstrates the feasibility of the approach by an implementation atop our meta-modelling tool MetaDepth. We also explore application scenarios of a posteriori typing (to define transformations, for model transformation reuse, and to improve transformation expressiveness by dynamic type change), and present an experiment showing the potential performance gains when expressing transformations as retypings.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453194','10.1145/3180155.3182545',0,0,'IEEE','IEEE Conferences',0),(382,'Efficient Sampling of SAT Solutions for Testing',1,549,559,'In software and hardware testing, generating multiple inputs which satisfy a given set of constraints is an important problem with applications in fuzz testing and stimulus generation. However, it is a challenge to perform the sampling efficiently, while generating a diverse set of inputs which satisfy the constraints. We developed a new algorithm QuickSampler which requires a small number of solver calls to produce millions of samples which satisfy the constraints with high probability. We evaluate QuickSampler on large real-world benchmarks and show that it can produce unique valid solutions orders of magnitude faster than other state-of-the-art sampling tools, with a distribution which is reasonably close to uniform in practice.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453122','10.1145/3180155.3180248',0,2,'IEEE','IEEE Conferences',0),(383,'Precise Concolic Unit Testing of C Programs Using Extended Units and Symbolic Alarm Filtering',1,315,326,'Automated unit testing reduces manual effort to write unit test drivers/stubs and generate unit test inputs. However, automatically generated unit test drivers/stubs raise false alarms because they often over-approximate real contexts of a target function f and allow infeasible executions off. To solve this problem, we have developed a concolic unit testing technique CONBRIO. To provide realistic context to f, it constructs an extended unit of f that consists of f and closely relevant functions to f. Also, CONBRIO filters out a false alarm by checking feasibility of a corresponding symbolic execution path with regard to f\'s symbolic calling contexts obtained by combining symbolic execution paths of f\'s closely related predecessor functions. In the experiments on the crash bugs of 15 real-world C programs, CONBRIO shows both high bug detection ability (i.e. 91.0% of the target bugs detected) and high precision (i.e. a true to false alarm ratio is 1:4.5). Also, CONBRIO detects 14 new bugs in 9 target C programs studied in papers on crash bug detection techniques.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453090','10.1145/3180155.3180253',0,1,'IEEE','IEEE Conferences',0),(384,'Integrating Technical Debt Management and Software Quality Management Processes: A Framework and Field Tests',1,883,883,'Technical debt, defined as the maintenance obligations arising from shortcuts taken during the design, development, and deployment of software systems, has been shown to significantly impact the reliability and long-term evolution of software systems [1], [2]. Although academic research has moved beyond using technical debt only as a metaphor, and has begun compiling strong empirical evidence on the economic implications of technical debt, industry practitioners continue to find managing technical debt a challenging balancing act [3]. Despite the increasing awareness of the importance of managing technical debt in software product development, systematic processes for implementing technical debt management in software production have not been readily available. To address this gap, we developed and field tested a normative process framework that systematically incorporates steps for managing technical debt in commercial software production. The framework integrates processes required for technical debt management with existing software quality management processes prescribed by the project management body of knowledge (PMBOK) [4], and organizes the different processes for technical debt management under three steps: (1) make technical debt visible, (2) perform cost-benefit analysis, and (3) control technical debt. To implement the processes, we introduce a new artifact, called the technical debt register, which stores, for each software asset, the outstanding principal and the associated interest estimated for the technical debt embedded in the asset. The technical debt register also stores the desired control target for each software asset\'s technical debt, which is populated and used during the cost-benefit analysis and control target calculations. There are three main benefits from this integrated approach. First, it enables the uncovering of hidden technical debt embedded in systems. Established quality assurance and control practices can be utilized to effectively associate software defects with specific design and deployment decisions made by programmers. Such associations make technical debt visible to the team and thereby facilitate the quantification of debt-related principal and interest. Second, it helps to bridge the gaps that exist between the technical and economic assessments of technical debt, and aid in formulating actionable policies related to technical debt management. Finally, integrating technical debt management processes with established quality frameworks aids the wider adoption of emerging prescriptions for managing technical debt. We partnered with three commercial software product development organizations to implement the framework in real-world software production settings. All three organizations, irrespective of their varying software process maturity levels, were able to adopt the proposed framework and integrate the prescribed technical debt management processes with their existing software quality management processes. Our longitudinal data and case-study interviews indicate that the organizations were able to accrue economic benefits from the adoption and use of the integrated framework. And, based on our field study observations, we also identified a set of best practices that support the implementation and use of our framework: facilitating engagement between business and engineering stakeholders, adoption of policies based on a probabilistic analysis framework, and limiting process overheads.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453163','10.1145/3180155.3182529',0,0,'IEEE','IEEE Conferences',0),(385,'Debugging with Intelligence via Probabilistic Inference',1,1171,1181,'We aim to debug a single failing execution without the assistance from other passing/failing runs. In our context, debugging is a process with substantial uncertainty - lots of decisions have to be made such as what variables shall be inspected first. To deal with such uncertainty, we propose to equip machines with human-like intelligence. Specifically, we develop a highly automated debugging technique that aims to couple human-like reasoning (e.g., dealing with uncertainty and fusing knowledge) with program semantics based analysis, to achieve benefits from the two and mitigate their limitations. We model debugging as a probabilistic inference problem, in which the likelihood of each executed statement instance and variable being correct/faulty is modeled by a random variable. Human knowledge, human-like reasoning rules and program semantics are modeled as conditional probability distributions, also called probabilistic constraints. Solving these constraints identifies the most likely faulty statements. Our results show that the technique is highly effective. It can precisely identify root causes for a set of real-world bugs in a very small number of interactions with developers, much smaller than a recent proposal that does not encode human intelligence. Our user study also confirms that it substantially improves human productivity.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453198','10.1145/3180155.3180237',0,0,'IEEE','IEEE Conferences',0),(386,'Measuring Program Comprehension: A Large-Scale Field Study with Professionals',1,584,584,'This paper is published in IEEE Transaction on Software Engineering (DOI: 10.1109/TSE.2017.2734091). Comparing with previous programming comprehension studies that are usually in controlled settings or have a small number of participants, we perform a more realistic investigation of program comprehension activities. To do this, we extend our ActivitySpace framework to collect and analyze Human-Computer Interaction (HCI) data across many applications (not just the IDEs). We collect 3,148 working hour data from 78 professional developers in a field study. We follow Minelli et al.\'s approach to assign developers\' activities into four categories: navigation, editing, comprehension, and other. Then we measure comprehension time by calculating the time that developers spend on program comprehension. We find that on average developers spend ~58% of their time on program comprehension activities, and that they frequently use web browsers and document editors to perform program comprehension activities. We also investigate the impact of programming language, developers\' experience, and project phase on the time that is spent on program comprehension.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453126','10.1145/3180155.3182538',0,2,'IEEE','IEEE Conferences',0),(387,'Towards Reusing Hints from Past Fixes: An Exploratory Study on Thousands of Real Samples',1,885,885,'Researchers have recently proposed various automatic program repair (APR) approaches that reuse past fixes to fix new bugs. However, some fundamental questions, such as how new fixes overlap with old fixes, have not been investigated. Intuitively, the overlap between old and new fixes decides how APR approaches can construct new fixes with old ones. Based on this intuition, we systematically designed six overlap metrics, and performed an empirical study on 5,735 bug fixes to investigate the usefulness of past fixes when composing new fixes. For each bug fix, we created delta dependency graphs (i.e., program dependency graphs for code changes), and identified how bug fixes overlapped with each other in terms of the content, code structure, and identifier names of fixes. Our results show that if an APR approach composes new fixes by fully or partially reusing the content of past fixes, only 2.1% and 3.2% new fixes can be created from single or multiple past fixes in the same project, compared with 0.9% and 1.2% fixes created from past fixes across projects. However, if an APR approach composes new fixes by fully or partially reusing the code structure of past fixes, up to 41.3% and 29.7% new fixes can be created.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453165','10.1145/3180155.3182550',0,0,'IEEE','IEEE Conferences',0),(388,'[Journal First] A Correlation Study Between Automated Program Repair and Test-Suite Metrics',1,24,24,'Automated program repair has attracted attention due to its potential to reduce debugging cost. Prior works show the feasibility of automated repair, and the research focus is gradually shifting towards the quality of generated patches. One promising direction is to control the quality of generated patches by controlling the quality of test-suites used. In this paper, we investigate the question: \'\'Can traditional test-suite metrics used in software testing be used for automated program repair?\'\'. We empirically investigate the effectiveness of test-suite metrics (statement / branch coverage and mutation score) in controlling the reliability of repairs (the likelihood that repairs cause regressions). We conduct the largest-scale experiments to date with real-world software, and perform the first correlation study between test-suite metrics and the reliability of generated repairs. Our results show that by increasing test-suite metrics, the reliability of repairs tend to increase. Particularly, such trend is most strongly observed in statement coverage. This implies that traditional test-suite metrics used in software testing can also be used to improve the reliability of repairs in program repair.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453057','10.1145/3180155.3182517',0,0,'IEEE','IEEE Conferences',0),(389,'Online App Review Analysis for Identifying Emerging Issues',1,48,58,'Detecting emerging issues (e.g., new bugs) timely and precisely is crucial for developers to update their apps. App reviews provide an opportunity to proactively collect user complaints and promptly improve apps\' user experience, in terms of bug fixing and feature refinement. However, the tremendous quantities of reviews and noise words (e.g., misspelled words) increase the difficulties in accurately identifying newly-appearing app issues. In this paper, we propose a novel and automated framework IDEA, which aims to IDentify Emerging App issues effectively based on online review analysis. We evaluate IDEA on six popular apps from Google Play and Apple\'s App Store, employing the official app changelogs as our ground truth. Experiment results demonstrate the effectiveness of IDEA in identifying emerging app issues. Feedback from engineers and product managers shows that 88.9% of them think that the identified issues can facilitate app development in practice. Moreover, we have successfully applied IDEA to several products of Tencent, which serve hundreds of millions of users.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453061','10.1145/3180155.3180218',0,7,'IEEE','IEEE Conferences',0),(390,'Automatic Software Repair: A Survey',1,1219,1219,'Despite their growing complexity and increasing size, modern software applications must satisfy strict release requirements that impose short bug fixing and maintenance cycles, putting significant pressure on developers who are responsible for timely producing high-quality software. To reduce developers workload, repairing and healing techniques have been extensively investigated as solutions for efficiently repairing and maintaining software in the last few years. In particular, repairing solutions have been able to automatically produce useful fixes for several classes of bugs that might be present in software programs. A range of algorithms, techniques, and heuristics have been integrated, experimented, and studied, producing a heterogeneous and articulated research framework where automatic repair techniques are proliferating. This paper organizes the knowledge in the area by surveying a body of 108 papers about automatic software repair techniques, illustrating the algorithms and the approaches, comparing them on representative examples, and discussing the open challenges and the empirical evidence reported so far.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453203','10.1145/3180155.3182526',0,0,'IEEE','IEEE Conferences',0),(391,'[Journal First] Inference of Development Activities from Interaction with Uninstrumented Applications',1,897,897,'This paper is published in Journal of Empirical Software Engineering (DOI: 10.1007/s10664-017-9547-8). Studying developers\' behavior is crucial for designing effective techniques and tools to support developers\' daily work. However, there are two challenges in collecting and analyzing developers\' behavior data. First, instrumenting many software tools commonly used in real work settings (e.g., IDEs, web browsers) is difficult and requires significant resources. Second, the collected behavior data consist of low-level and fine-grained event sequences, which must be abstracted into high-level development activities for further analysis. To address these two challenges, we first use our ActivitySpace framework to improve the generalizability of the data collection. Then, we propose a Condition Random Field (CRF) based approach to segment and label the developers\' low-level actions into a set of basic, yet meaningful development activities. To evaluate our proposed approach, we deploy the ActivitySpace framework in an industry partner\'s company and collect the real working data from ten professional developers\' one-week work. We conduct an experiment with the collected data and a small number of initial human-labeled training data using the CRF model and the other three baselines (i.e., a heuristic-rules based method, a SVM classifier, and a random weighted classifier). The proposed CRF model achieves better performance (i.e., 0.728 accuracy and 0.672 macro-averaged F1-score) than the other three baselines.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453167','10.1145/3180155.3182537',0,0,'IEEE','IEEE Conferences',0),(392,'Predicting Future Developer Behavior in the IDE Using Topic Models',1,932,932,'Interaction data, gathered from developers\' daily clicks and key presses in the IDE, has found use in both empirical studies and in recommendation systems for software engineering. We observe that this data has several characteristics, common across IDEs: 1) exponentially distributed - some events or commands dominate the trace (e.g., cursor movement commands), while most other commands occur relatively infrequently; 2) noisy - the traces include spurious commands (or clicks), or unrelated events, that may not be important to the behavior of interest; 3) comprise of overlapping events and commands - specific commands can be invoked by separate mechanisms, and similar events can be triggered by different sources. These characteristics of this data are analogous to the characteristics of synonymy and polysemy in natural language corpora. Therefore, this paper (and presentation) presents a new modeling approach for this type of data, leveraging topic models typically applied to streams of natural language text.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453171','10.1145/3180155.3182541',0,0,'IEEE','IEEE Conferences',0),(393,'[Journal First] Privacy by Designers: Software Developers\' Privacy Mindset',1,396,396,'Privacy by design (PbD) is a policy measure that guides software developers to apply inherent solutions to achieve better privacy protection. For PbD to be a viable option, it is important to understand developers\' perceptions, interpretation and practices as to informational privacy (or data protection). To this end, we conducted in-depth interviews with 27 developers from different domains, who practice software design. Grounded analysis of the data revealed an interplay between several different forces affecting the way in which developers handle privacy concerns. Borrowing the schema of Social Cognitive Theory (SCT), we classified and analyzed the cognitive, organizational and behavioral factors that play a role in developers\' privacy decision making. Our findings indicate that developers use the vocabulary of data security to approach privacy challenges, and that this vocabulary limits their perceptions of privacy mainly to third-party threats coming from outside of the organization; that organizational privacy climate is a powerful means for organizations to guide developers toward particular practices of privacy; and that software architectural patterns frame privacy solutions that are used throughout the development process, possibly explaining developers\' preference of policy-based solutions to architectural solutions. Further, we show, through the use of the SCT schema for framing the findings of this study, how a theoretical model of the factors that influence developers\' privacy practices can be conceptualized and used as a guide for future research toward effective implementation of PbD.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453098','10.1145/3180155.3182531',0,0,'IEEE','IEEE Conferences',0),(394,'TypeDevil: Dynamic Type Inconsistency Analysis for JavaScript',2,314,324,'Dynamic languages, such as JavaScript, give programmers the freedom to ignore types, and enable them to write concise code in short time. Despite this freedom, many programs follow implicit type rules, for example, that a function has a particular signature or that a property has a particular type. Violations of such implicit type rules often correlate with problems in the program. This paper presents Type Devil, a mostly dynamic analysis that warns developers about inconsistent types. The key idea is to assign a set of observed types to each variable, property, and function, to merge types based in their structure, and to warn developers about variables, properties, and functions that have inconsistent types. To deal with the pervasiveness of polymorphic behavior in real-world JavaScript programs, we present a set of techniques to remove spurious warnings and to merge related warnings. Applying Type Devil to widely used benchmark suites and real-world web applications reveals 15 problematic type inconsistencies, including correctness problems, performance problems, and dangerous coding practices.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194584','10.1109/ICSE.2015.51',45,28,'IEEE','IEEE Conferences',0),(395,'Performance Analysis Using Subsuming Methods: An Industrial Case Study',2,149,158,'Large-scale object-oriented applications consist of tens of thousands of methods and exhibit highly complex runtime behaviour that is difficult to analyse for performance. Typical performance analysis approaches that aggregate performance measures in a method-centric manner result in thinly distributed costs and few easily identifiable optimisation opportunities. Subsuming methods analysis is a new approach that aggregates performance costs across repeated patterns of method calls that occur in the application\'s runtime behaviour. This allows automatic identification of patterns that are expensive and represent practical optimisation opportunities. To evaluate the practicality of this analysis with a real world large-scale object-oriented application we completed a case study with the developers of letterboxd.com - a social network website for movie goers. Using the results of the analysis we were able to rapidly implement changes resulting in a 54.8% reduction in CPU load and an 49.6% reduction in average response time.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202959','10.1109/ICSE.2015.143',27,5,'IEEE','IEEE Conferences',0),(396,'Design and Evaluation of a Customizable Multi-Domain Reference Architecture on Top of Product Lines of Self-Driving Heavy Vehicles - An Industrial Case Study',2,189,198,'Self-driving vehicles for commercial use cases like logistics or overcast mines increase their owners\' economic competitiveness. Volvo maintains, evolves, and distributes a vehicle control product line for different brands like Volvo Trucks, Renault, and Mack in more than 190 markets world-wide. From the different application domains of their customers originates the need for a multi-domain reference architecture concerned with transport mission planning, execution, and tracking on top of the vehicle control product line. This industrial case study is the first of its kind reporting about the systematic process to design such a reference architecture involving all relevant external and internal stakeholders, development documents, low level artifacts, and literature. Quantitative and qualitative metrics were applied to evaluate non-functional requirements on the reference architecture level before a concrete variant was evaluated using a Volvo FMX truck in an exemplary construction site setting.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202963','10.1109/ICSE.2015.147',64,2,'IEEE','IEEE Conferences',0),(397,'When App Stores Listen to the Crowd to Fight Bugs in the Wild',2,567,570,'App stores are digital distribution platforms that put available apps that run on mobile devices. Current stores are software repositories that deliver apps upon user requests. However, when an app has a bug, the store continues delivering defective apps until the developer uploads a fixed version, thus impacting on the reputation of both store and app developer. In this paper, we envision a new generation of app stores that: (a) reduce human intervention to maintain mobile apps; and (b) enhance store services with smart and autonomous functionalities to automatically increase the quality of the delivered apps. We sketch a prototype of our envisioned app store and we discuss the functionalities that current stores an enhance by incorporating automatic software repair techniques.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203014','10.1109/ICSE.2015.195',11,5,'IEEE','IEEE Conferences',0),(398,'Interdisciplinary Design Patterns for Socially Aware Computing',2,477,486,'The success of software applications that collect and process personal data does not only depend on technical aspects, but is also linked to social compatibility and user acceptance. It requires experts from different disciplines to ensure legal compliance, to foster the users\' trust, to enhance the usability of the application and to finally realize the application. Multidisciplinary requirements have to be formulated, interwoven and implemented. We advocate the use of interdisciplinary design patterns that capture the design know-how of typical, recurring features in socially aware applications with particular concern for socio-technical requirements. The proposed patterns address interdisciplinary concerns in a tightly interwoven manner and are intended to facilitate the development of accepted and acceptable applications that in particular deal with sensitive user context information.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202998','10.1109/ICSE.2015.180',32,7,'IEEE','IEEE Conferences',0),(399,'ChangeScribe: A Tool for Automatically Generating Commit Messages',2,709,712,'During software maintenances tasks, commit messages are an important source of information, knowledge, and documentation that developers rely upon. However, the number and nature of daily activities and interruptions can influence the quality of resulting commit messages. This formal demonstration paper presents ChangeScribe, a tool for automatically generating commit messages. ChangeScribe is available at http://www.cs.wm.edu/semeru/changescribe (Eclipse plugin, instructions, demos and the source code).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203049','10.1109/ICSE.2015.229',19,26,'IEEE','IEEE Conferences',0),(400,'What Makes a Great Software Engineer?',2,700,710,'Good software engineers are essential to the creation of good software. However, most of what we know about software-engineering expertise are vague stereotypes, such as \'excellent communicators\' and \'great teammates\'. The lack of specificity in our understanding hinders researchers from reasoning about them, employers from identifying them, and young engineers from becoming them. Our understanding also lacks breadth: what are all the distinguishing attributes of great engineers (technical expertise and beyond)? We took a first step in addressing these gaps by interviewing 59 experienced engineers across 13 divisions at Microsoft, uncovering 53 attributes of great engineers. We explain the attributes and examine how the most salient of these impact projects and teams. We discuss implications of this knowledge on research and the hiring and training of engineers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194618','10.1109/ICSE.2015.335',37,14,'IEEE','IEEE Conferences',0),(401,'Coexecutability for Efficient Verification of Data Model Updates',2,744,754,'Modern applications use back-end data stores for persistent data. Automated verification of the code that updates the data store would prevent bugs that can cause loss or corruption of data. In this paper, we focus on the most challenging part of this problem: automated verification of code that updates the data store and contains loops. Due to dependencies between loop iterations, verification of code that contains loops is a hard problem, and typically requires manual assistance in the form of loop invariants. We present a fully automated technique that improves verifiability of loops. We first define co execution, a method for modeling loop iterations that simplifies automated reasoning about loops. Then, we present a fully automated static program analysis that detects whether the behavior of a given loop can be modeled using co execution. We provide a customized verification technique for co executable loops that results in more effective verification. In our experiments we observed that, in 45% of cases, modeling loops using co execution reduces verification time between 1 and 4 orders of magnitude. In addition, the rate of inconclusive verification results in the presence of loops is reduced from 65% down to 24%, all without requiring loop invariants or any manual intervention.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194622','10.1109/ICSE.2015.87',32,4,'IEEE','IEEE Conferences',0),(402,'AutoCSP: Automatically Retrofitting CSP to Web Applications',2,336,346,'Web applications often handle sensitive user data, which makes them attractive targets for attacks such as cross-site scripting (XSS). Content security policy (CSP) is a content-restriction mechanism, now supported by all major browsers, that offers thorough protection against XSS. Unfortunately, simply enabling CSP for a web application would affect the application\'s behavior and likely disrupt its functionality. To address this issue, we propose AutoCSP, an automated technique for retrofitting CSP to web applications. AutoCSP (1) leverages dynamic taint analysis to identify which content should be allowed to load on the dynamically-generated HTML pages of a web application and (2) automatically modifies the server-side code to generate such pages with the right permissions. Our evaluation, performed on a set of real-world web applications, shows that AutoCSP can retrofit CSP effectively and efficiently.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194586','10.1109/ICSE.2015.53',31,12,'IEEE','IEEE Conferences',0),(403,'Morpheus: Variability-Aware Refactoring in the Wild',2,380,391,'Today, many software systems are configurable with conditional compilation. Just like any software system, configurable systems need to be refactored in their evolution, but their inherent variability induces an additional dimension of complexity that is not addressed well by current academic and industrial refactoring engines. To improve the state of the art, we propose a variability-aware refactoring approach that relies on a canonical variability representation and recent work on variability-aware analysis. The goal is to preserve the behavior of all variants of a configurable system, without compromising general applicability and scalability. To demonstrate practicality, we developed Morpheus, a sound, variability-aware refactoring engine for C code with preprocessor directives. We applied Morpheus to three substantial real-world systems (Busybox, OpenSSL, and SQLite) showing that it scales reasonably well, despite of its heavy reliance on satisfiability solvers. By extending a standard approach of testing refactoring engines with support for variability, we provide evidence for the correctness of the refactorings implemented.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194590','10.1109/ICSE.2015.57',62,16,'IEEE','IEEE Conferences',0),(404,'Avoiding Security Pitfalls with Functional Programming: A Report on the Development of a Secure XML Validator',2,209,218,'While the use of XML is pervading all areas of IT, security challenges arise when XML files are used to transfer security data such as security policies. To tackle this issue, we have developed a lightweight secure XML validator and have chosen to base the development on the strongly typed functional language OCaml. The initial development took place as part of the LaFoSec Study which aimed at investigating the impact of using functional languages for security. We then turned the validator into an industrial application, which was successfully evaluated at EAL4+ level by independent assessors. In this paper, we explain the challenges involved in processing XML data in a critical context, we describe our choices in designing a secure XML validator, and we detail how we used features of functional languages to enforce security requirements.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202965','10.1109/ICSE.2015.149',14,2,'IEEE','IEEE Conferences',0),(405,'An Initiative to Improve Reproducibility and Empirical Evaluation of Software Testing Techniques',2,575,578,'The current concern regarding quality of evaluation performed in existing studies reveals the need for methods and tools to assist in the definition and execution of empirical studies and experiments. However, when trying to apply general methods from empirical software engineering in specific fields, such as evaluation of software testing techniques, new obstacles and threats to validity appears, hindering researchers\' use of empirical methods. This paper discusses those issues specific for evaluation of software testing techniques and proposes an initiative for a collaborative effort to encourage reproducibility of experiments evaluating software testing techniques (STT). We also propose the development of a tool that enables automatic execution and analysis of experiments producing a reproducible research compendia as output that is, in turn, shared among researchers. There are many expected benefits from this Endeavour, such as providing a foundation for evaluation of existing and upcoming STT, and allowing researchers to devise and publish better experiments.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203016','10.1109/ICSE.2015.197',13,3,'IEEE','IEEE Conferences',0),(406,'Security Toolbox for Detecting Novel and Sophisticated Android Malware',2,733,736,'This paper presents a demo of our Security Toolbox to detect novel malware in Android apps. This Toolbox is developed through our recent research project funded by the DARPA Automated Program Analysis for Cybersecurity (APAC) project. The adversarial challenge (\'Red\') teams in the DARPA APAC program are tasked with designing sophisticated malware to test the bounds of malware detection technology being developed by the research and development (\'Blue\') teams. Our research group, a Blue team in the DARPA APAC program, proposed a \'human-in-the-loop program analysis\' approach to detect malware given the source or Java bytecode for an Android app. Our malware detection apparatus consists of two components: a general-purpose program analysis platform called Atlas, and a Security Toolbox built on the Atlas platform. This paper describes the major design goals, the Toolbox components to achieve the goals, and the workflow for auditing Android apps. The accompanying video illustrates features of the Toolbox through a live audit.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203055','10.1109/ICSE.2015.235',18,6,'IEEE','IEEE Conferences',0),(407,'A Programming Model for Sustainable Software',2,767,777,'This paper presents a novel energy-aware and temperature-aware programming model with first-class support for sustainability. A program written in the new language, named Eco, may adaptively adjusts its own behaviors to stay on a given (energy or temperature) budget, avoiding both deficit that would lead to battery drain or CPU overheating, and surplus that could have been used to improve the quality of results. Sustainability management in Eco is captured as a form of supply and demand matching, and the language runtime consistently maintains the equilibrium between supply and demand. Among the efforts of energy-adaptive and temperature-adaptive systems, Eco is distinctive in its role in bridging the programmer and the underlying system, and in particular, bringing both programmer knowledge and application-specific traits into energy optimization. Through a number of intuitive programming abstractions, Eco reduces challenging issues in this domain --- such as workload characterization and decision making in adaptation --- to simple programming tasks, ultimately offering fine-grained, programmable, and declarative sustainability to energy-efficient computing. Eco is an minimal extension to Java, and has been implemented as an open-source compiler. We validate the usefulness of Eco by upgrading real-world Java applications with energy awareness and temperature awareness.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194624','10.1109/ICSE.2015.89',41,12,'IEEE','IEEE Conferences',0),(408,'Work Practices and Challenges in Pull-Based Development: The Integrator\'s Perspective',2,358,368,'In the pull-based development model, the integrator has the crucial role of managing and integrating contributions. This work focuses on the role of the integrator and investigates working habits and challenges alike. We set up an exploratory qualitative study involving a large-scale survey of 749 integrators, to which we add quantitative data from the integrator\'s project. Our results provide insights into the factors they consider in their decision making process to accept or reject a contribution. Our key findings are that integrators struggle to maintain the quality of their projects and have difficulties with prioritizing contributions that are to be merged. Our insights have implications for practitioners who wish to use or improve their pull-based development process, as well as for researchers striving to understand the theoretical implications of the pull-based model in software development.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194588','10.1109/ICSE.2015.55',24,73,'IEEE','IEEE Conferences',0),(409,'When and Why Your Code Starts to Smell Bad',2,403,414,'In past and recent years, the issues related to managing technical debt received significant attention by researchers from both industry and academia. There are several factors that contribute to technical debt. One of these is represented by code bad smells, i.e., Symptoms of poor design and implementation choices. While the repercussions of smells on code quality have been empirically assessed, there is still only anecdotal evidence on when and why bad smells are introduced. To fill this gap, we conducted a large empirical study over the change history of 200 open source projects from different software ecosystems and investigated when bad smells are introduced by developers, and the circumstances and reasons behind their introduction. Our study required the development of a strategy to identify smell-introducing commits, the mining of over 0.5M commits, and the manual analysis of 9,164 of them (i.e., Those identified as smell-introducing). Our findings mostly contradict common wisdom stating that smells are being introduced during evolutionary tasks. In the light of our results, we also call for the need to develop a new generation of recommendation systems aimed at properly planning smell refactoring activities.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194592','10.1109/ICSE.2015.59',51,59,'IEEE','IEEE Conferences',0),(410,'A Field Study on Fostering Structural Navigation with Prodet',2,229,238,'Past studies show that developers who navigate code in a structural manner complete tasks faster and more correctly than those whose behavior is more opportunistic. The goal of this work is to move professional developers towards more effective program comprehension and maintenance habits by providing an approach that fosters structural code navigation. To this end, we created a Visual Studio plugin called Prodet that integrates an always-on navigable visualization of the most contextually relevant portions of the call graph. We evaluated the effectiveness of our approach by deploying it in a six week field study with professional software developers. The study results show a statistically significant increase in developers\' use of structural navigation after installing Prodet. The results also show that developers continuously used the filtered and navigable call graph over the three week period in which it was deployed in production. These results indicate the maturity and value of our approach to increase developers\' effectiveness in a practical and professional environment.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202967','10.1109/ICSE.2015.151',36,5,'IEEE','IEEE Conferences',0),(411,'Effectiveness of Persona with Personality Traits on Conceptual Design',2,263,272,'Conceptual design is an important skill in Software Engineering. Teaching conceptual design that can deliver a useful product is challenging, particularly when access to real users is limited. This study explores the effects of the use of Holistic Personas (i.e. a persona enriched with personality traits) on students\' performance in creating conceptual designs. Our results indicate that the students were able to identify the personality traits of personas and their ratings of the personalities match closely with the intended personalities. A majority of the participants stated that their designs were tailored to meet the needs of the given personas\' personality traits. Results suggest that the Holistic Personas can help students to take into account personality traits in the conceptual design process. Further studies are warranted to assess the value of incorporating Holistic Personas in conceptual design training for imparting skills of producing in-depth design by taking personalities into account.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202971','10.1109/ICSE.2015.155',38,8,'IEEE','IEEE Conferences',0),(412,'Automated Planning for Self-Adaptive Systems',2,839,842,'Self-adaptation has been proposed as a viable solution to alleviate the management burden that is induced by the dynamic nature and increasing complexity of computer systems. In this context, architectural-based self-adaptation has emerged as one of the most promising approaches to automatically manage such systems, resorting to a control loop that includes monitoring, analyzing, planning, and executing adequate actions. This work addresses the challenges of adaptation planning -the decision-making process for selecting an appropriate course of action- with a focus on the problem of provisioning automated mechanisms for assembling adaptation plans, as a means to enhance adaptive capabilities under uncertainty. To this purpose, adaptations are modeled in a hierarchical manner, defining primitive actions, guarded actions, and deliberate plans, which may guide the system towards a desired state.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203094','10.1109/ICSE.2015.273',26,0,'IEEE','IEEE Conferences',0),(413,'Fast Feedback Cycles in Empirical Software Engineering Research',2,583,586,'Background/Context: Gathering empirical knowledge is a time consuming task and the results from empirical studies often are soon outdated by new technological solutions. As a result, the impact of empirical results on software engineering practice is often not guaranteed.Objective/Aim: In this paper, we summarise the ongoing discussion on \'Empirical Software Engineering 2.0\' as a way to improve the impact of empirical results on industrial practices. We propose a way to combine data mining and analysis with domain knowledge to enable fast feedback cycles in empirical software engineering research.Method: We identify the key concepts on gathering fast feedback in empirical software engineering by following an experience-based line of reasoning by argument. Based on the identified key concepts, we design and execute a small proof of concept with a company to demonstrate potential benefits of the approach.Results: In our example, we observed that a simple double feedback mechanism notably increased the precision of the data analysis and improved the quality of the knowledge gathered.Conclusion: Our results serve as a basis to foster discussion and collaboration within the research community for a development of the idea.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203018','10.1109/ICSE.2015.198',22,4,'IEEE','IEEE Conferences',0),(414,'Information Transformation: An Underpinning Theory for Software Engineering',2,599,602,'Software engineering lacks underpinning scientific theories both for the software it produces and the processes by which it does so. We propose that an approach based on information theory can provide such a theory, or rather many theories. We envision that such a benefit will be realised primarily through research based on the quantification of information involved and a mathematical study of the limiting laws that arise. However, we also argue that less formal but more qualitative uses for information theory will be useful. The main argument in support of our vision is based on the fact that both a program and an engineering process to develop such a program are fundamentally processes that transform information. To illustrate our argument we focus on software testing and develop an initial theory in which a test suite is input/output adequate if it achieves the channel capacity of the program as measured by the mutual information between its inputs and its outputs. We outline a number of problems, metrics and concrete strategies for improving software engineering, based on information theoretical analyses. We find it likely that similar analyses and subsequent future research to detail them would be generally fruitful for software engineering.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203022','10.1109/ICSE.2015.202',20,4,'IEEE','IEEE Conferences',0),(415,'Revisiting the Impact of Classification Techniques on the Performance of Defect Prediction Models',2,789,800,'Defect prediction models help software quality assurance teams to effectively allocate their limited resources to the most defect-prone software modules. A variety of classification techniques have been used to build defect prediction models ranging from simple (e.g., Logistic regression) to advanced techniques (e.g., Multivariate Adaptive Regression Splines (MARS)). Surprisingly, recent research on the NASA dataset suggests that the performance of a defect prediction model is not significantly impacted by the classification technique that is used to train it. However, the dataset that is used in the prior study is both: (a) noisy, i.e., Contains erroneous entries and (b) biased, i.e., Only contains software developed in one setting. Hence, we set out to replicate this prior study in two experimental settings. First, we apply the replicated procedure to the same (known-to-be noisy) NASA dataset, where we derive similar results to the prior study, i.e., The impact that classification techniques have appear to be minimal. Next, we apply the replicated procedure to two new datasets: (a) the cleaned version of the NASA dataset and (b) the PROMISE dataset, which contains open source software developed in a variety of settings (e.g., Apache, GNU). The results in these new datasets show a clear, statistically distinct separation of groups of techniques, i.e., The choice of classification technique has an impact on the performance of defect prediction models. Indeed, contrary to earlier research, our results suggest that some classification techniques tend to produce defect prediction models that outperform others.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194626','10.1109/ICSE.2015.91',65,96,'IEEE','IEEE Conferences',0),(416,'Dynamic Generation of Likely Invariants for Multithreaded Programs',2,835,846,'We propose a new method for dynamically generating likely invariants from multithreaded programs.While existing invariant generation tools work well on sequential programs, they are ineffective at reasoning about multithreaded programs both in terms of the number of real invariants generated and in terms of their usefulness in helping programmers. We address this issue by developing a new dynamic invariant generator consisting of an LLVM based code instrumentation front end, a systematic thread interleaving explorer, and a customized invariant inference engine. We show that efficient interleaving exploration strategies can be used to generate a diversified set of executions with little runtime overhead. Furthermore, we show that focusing on a small subset of thread-local transition invariants is often sufficient for reasoning about the concurrency behavior of programs. We have evaluated our new method on a set of open-source multithreaded C/C++ benchmarks. Our experiments show that our method can generate invariants that are significantly higher in quality than the previous state-of-the-art.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194630','10.1109/ICSE.2015.95',58,4,'IEEE','IEEE Conferences',0),(417,'Mining Apps for Abnormal Usage of Sensitive Data',2,426,436,'What is it that makes an app malicious? One important factor is that malicious apps treat sensitive data differently from benign apps. To capture such differences, we mined 2,866 benign Android applications for their data flow from sensitive sources, and compare these flows against those found in malicious apps. We find that (a) for every sensitive source, the data ends up in a small number of typical sinks; (b) these sinks differ considerably between benign and malicious apps; (c) these differences can be used to flag malicious apps due to their abnormal data flow; and (d) malicious apps can be identified by their abnormal data flow alone, without requiring known malware samples. In our evaluation, our MUDFLOW prototype correctly identified 86.4% of all novel malware, and 90.1% of novel malware leaking sensitive data.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194594','10.1109/ICSE.2015.61',30,61,'IEEE','IEEE Conferences',0),(418,'Evolution of Software Development Strategies',2,243,252,'The development of discipline-specific cognitive and meta-cognitive skills is fundamental to the successful mastery of software development skills and processes. This development happens over time and is influenced by many factors, however its understanding by teachers is crucial in order to develop activities and materials to transform students from novice to expert software engineers. In this paper, we analyse the evolution of learning strategies of novice, first year students, to expert, final year students. We analyse reflections on software development processes from students in an introductory software development course, and compare them to those of final year students, in a distributed systems development course. Our study shows that computer science - specific strategies evolve as expected, with the majority of final year students including design before coding in their software development process, but that several areas still require scaffolding activities to assist in learning development.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202969','10.1109/ICSE.2015.153',40,1,'IEEE','IEEE Conferences',0),(419,'Novice Code Understanding Strategies during a Software Maintenance Assignment',2,276,284,'Existing efforts on teaching software maintenance have focussed on constructing adequate codebases that students with limited knowledge could maintain, with little focus on the learning outcomes of such exercises and of the approaches that students employ while performing maintenance. An analysis of the code understanding strategies employed by novice students as they perform software maintenance exercises is fundamental for the effective teaching of software maintenance. In this paper, we analyze the strategies employed by second year students in a maintenance exercise over a large codebase. We analyze student reflections on their code understanding, maintenance process and the use of tools. We show that students are generally capable of working with large codebases. Our study also finds that the majority of students follow a systematic approach to code understanding, but that their approach can be significantly improved through the use of tools and a better understanding of reverse engineering approaches.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202973','10.1109/ICSE.2015.341',20,1,'IEEE','IEEE Conferences',0),(420,'Scalable Formal Verification of UML Models',2,847,850,'UML (Unified Modeling Language) has been used for years in diverse domains. Its notations usually come with a reasonably well-defined syntax, but its semantics is left under-specified and open to different interpretations. This freedom hampers the formal verification of produced specifications and calls for more rigor and precision. This work aims to bridge this gap and proposes a flexible and modular formalization approach based on temporal logic. We studied the different interpretations for some of its constructs, and our framework allows one to assemble the semantics of interest by composing the selected formalizations for the different pieces. However, the formalization per-se is not enough. The verification process, in general, becomes slow and impossible -as the model grows in size. To tackle the scalability problem, this work also proposes a bit-vector-based encoding of LTL formulae. The first results witness a significant increase in the size of analyzable models, not only for our formalization of UML models, but also for numerous other models that can be reduced to bounded satisfiability checking of LTL formulae.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203096','10.1109/ICSE.2015.275',14,1,'IEEE','IEEE Conferences',0),(421,'Views on Internal and External Validity in Empirical Software Engineering',2,9,19,'Empirical methods have grown common in software engineering, but there is no consensus on how to apply them properly. Is practical relevance key? Do internally valid studies have any value? Should we replicate more to address the tradeoff between internal and external validity? We asked the community how empirical research should take place in software engineering, with a focus on the tradeoff between internal and external validity and replication, complemented with a literature review about the status of empirical research in software engineering. We found that the opinions differ considerably, and that there is no consensus in the community when to focus on internal or external validity and how to conduct and review replications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194557','10.1109/ICSE.2015.24',37,46,'IEEE','IEEE Conferences',0),(422,'Making System User Interactive Tests Repeatable: When and What Should We Control?',2,55,65,'System testing and invariant detection is usually conducted from the user interface perspective when the goal is to evaluate the behavior of an application as a whole. A large number of tools and techniques have been developed to generate and automate this process, many of which have been evaluated in the literature or internally within companies. Typical metrics for determining effectiveness of these techniques include code coverage and fault detection, however, with the assumption that there is determinism in the resulting outputs. In this paper we examine the extent to which a common set of factors such as the system platform, Java version, application starting state and tool harness configurations impact these metrics. We examine three layers of testing outputs: the code layer, the behavioral (or invariant) layer and the external (or user interaction) layer. In a study using five open source applications across three operating system platforms, manipulating several factors, we observe as many as 184 lines of code coverage difference between runs using the same test cases, and up to 96 percent false positives with respect to fault detection. We also see some a small variation among the invariants inferred. Despite our best efforts, we can reduce, but not completely eliminate all possible variation in the output. We use our findings to provide a set of best practices that should lead to better consistency and smaller differences in test outcomes, allowing more repeatable and reliable testing and experimentation.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194561','10.1109/ICSE.2015.28',40,9,'IEEE','IEEE Conferences',0),(423,'The Impact of Mislabelling on the Performance and Interpretation of Defect Prediction Models',2,812,823,'The reliability of a prediction model depends on the quality of the data from which it was trained. Therefore, defect prediction models may be unreliable if they are trained using noisy data. Recent research suggests that randomly-injected noise that changes the classification (label) of software modules from defective to clean (and vice versa) can impact the performance of defect models. Yet, in reality, incorrectly labelled (i.e., mislabelled) issue reports are likely non-random. In this paper, we study whether mislabelling is random, and the impact that realistic mislabelling has on the performance and interpretation of defect models. Through a case study of 3,931 manually-curated issue reports from the Apache Jackrabbit and Lucene systems, we find that: (1) issue report mislabelling is not random; (2) precision is rarely impacted by mislabelled issue reports, suggesting that practitioners can rely on the accuracy of modules labelled as defective by models that are trained using noisy data; (3) however, models trained on noisy data typically achieve 56%-68% of the recall of models trained on clean data; and (4) only the metrics in top influence rank of our defect models are robust to the noise introduced by mislabelling, suggesting that the less influential metrics of models that are trained on noisy data should not be interpreted or used to make decisions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194628','10.1109/ICSE.2015.93',51,33,'IEEE','IEEE Conferences',0),(424,'Graph-Based Statistical Language Model for Code',2,858,868,'n-gram statistical language model has been successfully applied to capture programming patterns to support code completion and suggestion. However, the approaches using n-gram face challenges in capturing the patterns at higher levels of abstraction due to the mismatch between the sequence nature in n-grams and the structure nature of syntax and semantics in source code. This paper presents GraLan, a graph-based statistical language model and its application in code suggestion. GraLan can learn from a source code corpus and compute the appearance probabilities of any graphs given the observed (sub)graphs. We use GraLan to develop an API suggestion engine and an AST-based language model, ASTLan. ASTLan supports the suggestion of the next valid syntactic template and the detection of common syntactic templates. Our empirical evaluation on a large corpus of open-source projects has shown that our engine is more accurate in API code suggestion than the state-of-the-art approaches, and in 75% of the cases, it can correctly suggest the API with only five candidates. ASTLan has also high accuracy in suggesting the next syntactic template and is able to detect many useful and common syntactic templates.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194632','10.1109/ICSE.2015.336',43,36,'IEEE','IEEE Conferences',0),(425,'DirectFix: Looking for Simple Program Repairs',2,448,458,'Recent advances in program repair techniques have raised the possibility of patching bugs automatically. For an automatically generated patch to be accepted by developers, it should not only resolve the bug but also satisfy certain human-related factors including readability and comprehensibility. In this paper, we focus on the simplicity of patches (the size of changes). We present a novel semantics-based repair method that generates the simplest patch such that the program structure of the buggy program is maximally preserved. To take into account the simplicity of repairs in an efficient way (i.e., Without explicitly enumerating each repair candidate for each fault location), our method fuses fault localization and repair generation into one step. We do so by leveraging partial Max SAT constraint solving and component-based program synthesis. We compare our prototype implementation, Direct Fix, with the state-of-the-art semantics-based repair tool Sem Fix, that performs fault localization before repair generation. In our experiments with SIR programs and GNU Coreutils, Direct Fix generates repairs that are simpler than those generated by Sem Fix. Since both Direct Fix and Sem Fix are test-driven repair tools, they can introduce regressions for other tests which do not drive the repair. We found that Direct Fix causes substantially less regression errors than Sem Fix.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194596','10.1109/ICSE.2015.63',40,79,'IEEE','IEEE Conferences',0),(426,'Automated Data Structure Generation: Refuting Common Wisdom',2,32,43,'Common wisdom in the automated data structure generation community states that declarative techniques have better usability than imperative techniques, while imperative techniques have better performance. We show that this reasoning is fundamentally flawed: if we go to the declarative limit and employ constraint logic programming (CLP), the CLP data structure generation has orders of magnitude better performance than comparable imperative techniques. Conversely, we observe and argue that when it comes to realistically complex data structures and properties, the CLP specifications become more obscure, indirect, and difficult to implement and understand than their imperative counterparts. We empirically evaluate three competing generation techniques, CLP, Korat, and UDITA, to validate these observations on more complex and interesting data structures than any prior work in this area. We explain why these observations are true, and discuss possible techniques for attaining the best of both worlds.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194559','10.1109/ICSE.2015.26',38,3,'IEEE','IEEE Conferences',0),(427,'Composite Constant Propagation: Application to Android Inter-Component Communication Analysis',2,77,88,'Many program analyses require statically inferring the possible values of composite types. However, current approaches either do not account for correlations between object fields or do so in an ad hoc manner. In this paper, we introduce the problem of composite constant propagation. We develop the first generic solver that infers all possible values of complex objects in an interprocedural, flow and context-sensitive manner, taking field correlations into account. Composite constant propagation problems are specified using COAL, a declarative language. We apply our COAL solver to the problem of inferring Android Inter-Component Communication (ICC) values, which is required to understand how the components of Android applications interact. Using COAL, we model ICC objects in Android more thoroughly than the state-of-the-art. We compute ICC values for 460 applications from the Play store. The ICC values we infer are substantially more precise than previous work. The analysis is efficient, taking slightly over two minutes per application on average. While this work can be used as the basis for many whole-program analyses of Android applications, the COAL solver can also be used to infer the values of composite objects in many other contexts.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194563','10.1109/ICSE.2015.30',0,42,'IEEE','IEEE Conferences',0),(428,'How Can I Use This Method?',2,880,890,'Code examples are small source code fragments whose purpose is to illustrate how a programming language construct, an API, or a specific function/method works. Since code examples are not always available in the software documentation, researchers have proposed techniques to automatically extract them from existing software or to mine them from developer discussions. In this paper we propose MUSE (Method USage Examples), an approach for mining and ranking actual code examples that show how to use a specific method. MUSE combines static slicing (to simplify examples) with clone detection (to group similar examples), and uses heuristics to select and rank the best examples in terms of reusability, understandability, and popularity. MUSE has been empirically evaluated using examples mined from six libraries, by performing three studies involving a total of 140 developers to: (i) evaluate the selection and ranking heuristics, (ii) provide their perception on the usefulness of the selected examples, and (iii) perform specific programming tasks using the MUSE examples. The results indicate that MUSE selects and ranks examples close to how humans do, most of the code examples (82%) are perceived as useful, and they actually help when performing programming tasks.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194634','10.1109/ICSE.2015.98',21,22,'IEEE','IEEE Conferences',0),(429,'relifix: Automated Repair of Software Regressions',2,471,482,'Regression occurs when code changes introduce failures in previously passing test cases. As software evolves, regressions may be introduced. Fixing regression errors manually is time-consuming and error-prone. We propose an approach of automated repair of software regressions, called relifix, that considers the regression repair problem as a problem of reconciling problematic changes. Specifically, we derive a set of code transformations obtained from our manual inspection of 73 real software regressions; this set of code transformations uses syntactical information from changed statements. Regression repair is then accomplished via a search over the code transformation operators - which operator to apply, and where. Our evaluation compares the repairability of relifix with GenProg on 35 real regression errors. relifix repairs 23 bugs, while GenProg only fixes five bugs. We also measure the likelihood of both approaches in introducing new regressions given a reduced test suite. Our experimental results shows that our approach is less likely to introduce new regressions than GenProg.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194598','10.1109/ICSE.2015.65',55,28,'IEEE','IEEE Conferences',0),(430,'Improving Student Group Work with Collaboration Patterns: A Case Study',2,303,306,'Group work skills are essential for Computer Scientists and especially Software Engineers. Group work is included in most CS curricula in order to support students in acquiring these skills. During group work, problems can occur related to a variety of factors, such as unstable group constellations or (missing) instructor support. Students need to find strategies for solving or preventing such problems. Student collaboration patterns offer a way of supporting students by providing problem-solving strategies that other students have already applied successfully. In this work we describe how student collaboration patterns were applied in an interdisciplinary software engineering project, and show that their application was generally experienced as helpful by the students.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202977','10.1109/ICSE.2015.160',13,0,'IEEE','IEEE Conferences',0),(431,'Collaborative and Cooperative-Learning in Software Engineering Courses',2,319,322,'Collaborative learning is a key component of software engineering (SE) courses in most undergraduate computing curricula. Thus these courses include fairly intensive team projects, the intent being to ensure that not only do students develop an understanding of key software engineering concepts and practices, but also develop the skills needed to work effectively in large design and development teams. But there is a definite risk in collaborative learning in that there is a potential that individual learning gets lost in the focus on the team\'s success in completing the project (s). While the team\'s success is indeed the primary goal of an industrial SE team, ensuring individual learning is obviously an essential goal of SE courses. We have developed a novel approach that exploits the affordances of mobile and web technologies to help ensure that individual students in teams in SE courses develop a thorough understanding of the relevant concepts and practices while working on team projects, indeed, that the team contributes in an essential manner to the learning of each member of the team. We describe the learning theory underlying our approach, provide some details concerning the prototype implementation of a tool based on the approach, and describe how we are using it in an SE course in our program.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202981','10.1109/ICSE.2015.164',14,2,'IEEE','IEEE Conferences',0),(432,'Leveraging Informal Documentation to Summarize Classes and Methods in Context',2,639,642,'Critical information related to a software developer\'scurrent task is trapped in technical developer discussions,bug reports, code reviews, and other software artefacts. Muchof this information pertains to the proper use of code elements(e.g., methods and classes) that capture vital problem domainknowledge. To understand the purpose of these code elements, software developers must either access documentation and online posts and understand the source code or peruse a substantial amount of text. In this paper, we use the context that surrounds code elements in StackOverflow posts to summarize the use and purpose of code elements. To provide focus to our investigation, we consider the generation of summaries for library identifiers discussed in StackOverflow. Our automatic summarization approach was evaluated on a sample of 100 randomly-selected library identifiers with respect to a benchmark of summaries provided by two annotators. The results show that the approach attains an R-precision of 54%, which is appropriate given the diverse ways in which code elements can be used.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203032','10.1109/ICSE.2015.212',22,11,'IEEE','IEEE Conferences',0),(433,'A Flexible and Non-intrusive Approach for Computing Complex Structural Coverage Metrics',2,506,516,'Software analysis tools and techniques often leverage structural code coverage information to reason about the dynamic behavior of software. Existing techniques instrument the code with the required structural obligations and then monitor the execution of the compiled code to report coverage. Instrumentation based approaches often incur considerable runtime overhead for complex structural coverage metrics such as Modified Condition/Decision (MC/DC). Code instrumentation, in general, has to be approached with great care to ensure it does not modify the behavior of the original code. Furthermore, instrumented code cannot be used in conjunction with other analyses that reason about the structure and semantics of the code under test. In this work, we introduce a non-intrusive preprocessing approach for computing structural coverage information. It uses a static partial evaluation of the decisions in the source code and a source-to-bytecode mapping to generate the information necessary to efficiently track structural coverage metrics during execution. Our technique is flexible; the results of the preprocessing can be used by a variety of coverage-driven software analysis tasks, including automated analyses that are not possible for instrumented code. Experimental results in the context of symbolic execution show the efficiency and flexibility of our non- intrusive approach for computing code coverage information.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194601','10.1109/ICSE.2015.68',40,3,'IEEE','IEEE Conferences',0),(434,'Truth in Advertising: The Hidden Cost of Mobile Ads for Software Developers',2,100,110,'The \'free app\' distribution model has been extremely popular with end users and developers. Developers use mobile ads to generate revenue and cover the cost of developing these free apps. Although the apps are ostensibly free, they in fact do come with hidden costs. Our study of 21 real world Android apps shows that the use of ads leads to mobile apps that consume significantly more network data, have increased energy consumption, and require repeated changes to ad related code. We also found that complaints about these hidden costs are significant and can impact the ratings given to an app. Our results provide actionable information and guidance to software developers in weighing the tradeoffs of incorporating ads into their mobile apps.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194565','10.1109/ICSE.2015.32',46,42,'IEEE','IEEE Conferences',0),(435,'Enron\'s Spreadsheets and Related Emails: A Dataset and Analysis',2,7,16,'Spreadsheets are used extensively in business processes around the world and as such, are a topic of research interest. Over the past few years, many spreadsheet studies have been performed on the EUSES spreadsheet corpus. While this corpus has served the spreadsheet community well, the spreadsheets it contains are mainly gathered with search engines and might therefore not represent spreadsheets used in companies. This paper presents an analysis of a new dataset, extracted from the Enron email archive, containing over 15,000 spreadsheets used within the Enron Corporation. In addition to the spreadsheets, we also present an analysis of the associated emails, where we look into spreadsheet-specific email behavior. Our analysis shows that 1) 24% of Enron spreadsheets with at least one formula contain an Excel error, 2) there is little diversity in the functions used in spreadsheets: 76% of spreadsheets in the presented corpus use the same 15 functions and, 3) the spreadsheets are substantially more smelly than the EUSES corpus, especially in terms of long calculation chains. Regarding the emails, we observe that spreadsheets 1) are a frequent topic of email conversation with 10% of emails either referring to or sending spreadsheets and 2) the emails are frequently discussing errors in and updates to spreadsheets.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202944','10.1109/ICSE.2015.129',39,29,'IEEE','IEEE Conferences',0),(436,'CARAMEL: Detecting and Fixing Performance Problems That Have Non-Intrusive Fixes',2,902,912,'Performance bugs are programming errors that slow down program execution. While existing techniques can detect various types of performance bugs, a crucial and practical aspect of performance bugs has not received the attention it deserves: how likely are developers to fix a performance bug? In practice, fixing a performance bug can have both benefits and drawbacks, and developers fix a performance bug only when the benefits outweigh the drawbacks. Unfortunately, for many performance bugs, the benefits and drawbacks are difficult to assess accurately. This paper presents CARAMEL, a novel static technique that detects and fixes performance bugs that have non-intrusive fixes likely to be adopted by developers. Each performance bug detected by CARAMEL is associated with a loop and a condition. When the condition becomes true during the loop execution, all the remaining computation performed by the loop is wasted. Developers typically fix such performance bugs because these bugs waste computation in loops and have non-intrusive fixes: when some condition becomes true dynamically, just break out of the loop. Given a program, CARAMEL detects such bugs statically and gives developers a potential source-level fix for each bug. We evaluate CARAMEL on real-world applications, including 11 popular Java applications (e.g., Groovy, Log4J, Lucene, Struts, Tomcat, etc) and 4 widely used C/C++ applications (Chromium, GCC, Mozilla, and My SQL). CARAMEL finds 61 new performance bugs in the Java applications and 89 new performance bugs in the C/C++ applications. Based on our bug reports, developers so far have fixed 51 and 65 performance bugs in the Java and C/C++ applications, respectively. Most of the remaining bugs are still under consideration by developers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194636','10.1109/ICSE.2015.100',62,40,'IEEE','IEEE Conferences',0),(437,'Dynamic Data Flow Testing of Object Oriented Systems',2,947,958,'Data flow testing has recently attracted new interest in the context of testing object oriented systems, since data flow information is well suited to capture relations among the object states, and can thus provide useful information for testing method interactions. Unfortunately, classic data flow testing, which is based on static analysis of the source code, fails to identify many important data flow relations due to the dynamic nature of object oriented systems. In this paper, we propose a new technique to generate test cases for object oriented software. The technique exploits useful inter-procedural data flow information extracted dynamically from execution traces for object oriented systems. The technique is designed to enhance an initial test suite with test cases that exercise complex state based method interactions. The experimental results indicate that dynamic data flow testing can indeed generate test cases that exercise relevant behaviors otherwise missed by both the original test suite and by test suites that satisfy classic data flow criteria.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194640','10.1109/ICSE.2015.104',66,9,'IEEE','IEEE Conferences',0),(438,'Masters-Level Software Engineering Education and the Enriched Student Context',2,311,314,'Currently, adult higher education software engineering pedagogy isolates the student in a controlled environment during delivery, with application of their learning temporally distant from their professional practice. Delivering software engineering teaching that is immediately relevant to professional practice remains an open challenge. In this paper, we discuss a new pedagogical model which addresses this problem by embedding the validation of the student\'s learning within their rich professional context. We discuss our experience of applying the model to the design and delivery of a new post-graduate software development module, a core component in our new software engineering Masters qualification at the Open University, UK, a market leader in adult higher education at a distance.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202979','10.1109/ICSE.2015.162',9,1,'IEEE','IEEE Conferences',0),(439,'System Thinking: Educating T-Shaped Software Engineers',2,333,342,'With respect to system thinking, a T-shaped person is one who has technical depth in at least one aspect of the system\'s content, and a workable level of understanding of a fair number of the other system aspects. Many pure computer science graduates are strongly I-shaped, with a great deal of depth in software technology, but little understanding of the other disciplines involved in such areas as business, medicine, transportation, or Internets of Things. This leaves them poorly prepared to participate in the increasing numbers of projects involving multi-discipline system thinking, and in strong need of software skills. We have developed and evolved an MS-level software engineering curriculum that enables CS majors to become considerably more T-shaped than when they entered. It includes courses in software management and economics, human-computer interaction, embedded software systems, systems and software requirements, architecture, and V&V, and a two-semester, real-client team project course that gives students experience in applying these skills. We find via feedback on the students\' internships and job experiences that they and their employers have high rates of success in job offers and job performance.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202983','10.1109/ICSE.2015.166',15,1,'IEEE','IEEE Conferences',0),(440,'TaskNav: Task-Based Navigation of Software Documentation',2,649,652,'To help developers navigate documentation, we introduce Task Nav, a tool that automatically discovers and indexes task descriptions in software documentation. With Task Nav, we conceptualize tasks as specific programming actions that have been described in the documentation. Task Nav presents these extracted task descriptions along with concepts, code elements, and section headers in an auto-complete search interface. Our preliminary evaluation indicates that search results identified through extracted task descriptions are more helpful to developers than those found through other means, and that they help bridge the gap between documentation structure and the information needs of software developers. Video: https://www.youtube.com/watch?v=opnGYmMGnqY.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203034','10.1109/ICSE.2015.214',16,8,'IEEE','IEEE Conferences',0),(441,'A Genetic Algorithm for Detecting Significant Floating-Point Inaccuracies',2,529,539,'It is well-known that using floating-point numbers may inevitably result in inaccurate results and sometimes even cause serious software failures. Safety-critical software often has strict requirements on the upper bound of inaccuracy, and a crucial task in testing is to check whether significant inaccuracies may be produced. The main existing approach to the floating-point inaccuracy problem is error analysis, which produces an upper bound of inaccuracies that may occur. However, a high upper bound does not guarantee the existence of inaccuracy defects, nor does it give developers any concrete test inputs for debugging. In this paper, we propose the first metaheuristic search-based approach to automatically generating test inputs that aim to trigger significant inaccuracies in floating-point programs. Our approach is based on the following two insights: (1) with FPDebug, a recently proposed dynamic analysis approach, we can build a reliable fitness function to guide the search; (2) two main factors - the scales of exponents and the bit formations of significands - may have significant impact on the accuracy of the output, but in largely different ways. We have implemented and evaluated our approach over 154 real-world floating-point functions. The results show that our approach can detect significant inaccuracies in the subjects.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194603','10.1109/ICSE.2015.70',34,13,'IEEE','IEEE Conferences',0),(442,'Automated Decomposition of Build Targets',2,123,133,'A (build) target specifies the information that is needed to automatically build a software artifact. This paper focuses on underutilized targets - an important dependency problem that we identified at Google. An underutilized target is one with files not needed by some of its dependents. Underutilized targets result in less modular code, overly large artifacts, slow builds, and unnecessary build and test triggers. To mitigate these problems, programmers decompose underutilized targets into smaller targets. However, manually decomposing a target is tedious and error-prone. Although we prove that finding the best target decomposition is NP-hard, we introduce a greedy algorithm that proposes a decomposition through iterative unification of the strongly connected components of the target. Our tool found that 19,994 of 40,000 Java library targets at Google can be decomposed to at least two targets. The results show that our tool is (1) efficient because it analyzes a target in two minutes on average and (2) effective because for each of 1,010 targets, it would save at least 50% of the total execution time of the tests triggered by the target.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194567','10.1109/ICSE.2015.34',53,8,'IEEE','IEEE Conferences',0),(443,'Gray Computing: An Analysis of Computing with Background JavaScript Tasks',2,167,177,'Websites routinely distribute small amounts of work to visitors\' browsers in order to validate forms, render animations, and perform other computations. This paper examines the feasibility, cost effectiveness, and approaches for increasing the workloads offloaded to web visitors\' browsers in order to turn them into a large-scale distributed data processing engine, which we term gray computing. Past research has looked primarily at either non-browser based volunteer computing or browser-based volunteer computing where the visitors keep their browsers open to a single web page for a long period of time. This paper provides a deep analysis of the architectural, cost effectiveness, user experience, performance, security, and other issues of gray computing distributed data processing engines with high heterogeneity, non-uniform page view times, and high computing pool volatility.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194571','10.1109/ICSE.2015.38',26,3,'IEEE','IEEE Conferences',0),(444,'Automatic and Continuous Software Architecture Validation',2,59,68,'Software systems tend to suffer from architectural problems as they are being developed. While modern software development methodologies such as Agile and Dev-Ops suggest different ways of assuring code quality, very little attention is paid to maintaining high quality of the architecture of the evolving systems. By detecting and alerting about violations of the intended software architecture, one can often avoid code-level bad smells such as spaghetti code. Typically, if one wants to reason about the software architecture, the burden of first defining the intended architecture falls on the developer\'s shoulders. This includes definition of valid and invalid dependencies between software components. However, the developers are seldom familiar with the entire software system, which makes this task difficult, time consuming and error-prone. We propose and implement a solution for automatic detection of architectural violations in software artifacts. The solution, which utilizes a number of predefined and user-defined patterns, does not require prior knowledge of the system or its intended architecture. We propose to leverage this solution as part of the nightly build process used by development teams, thus achieving continuous automatic validation of the system\'s software architecture. As we show in multiple open-source and proprietary cases, a small set of predefined patterns can detect architectural violations as they are introduced over the course of development, and also capture deterioration in existing architectural problems. By evaluating the tool on relatively large open-source projects, we also validate its scalability and practical applicability to large software systems.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202950','10.1109/ICSE.2015.135',44,2,'IEEE','IEEE Conferences',0),(445,'Does the Failing Test Execute a Single or Multiple Faults? An Approach to Classifying Failing Tests',2,924,935,'Debugging is an indispensable yet frustrating activity in software development and maintenance. Thus, numerous techniques have been proposed to aid this task. Despite the demonstrated effectiveness and future potential of these techniques, many of them have the unrealistic single-fault failure assumption. To alleviate this problem, we propose a technique that can be used to distinguish failing tests that executed a single fault from those that executed multiple faults in this paper. The technique suitably combines information from (i) a set of fault localization ranked lists, each produced for a certain failing test and (ii) the distance between a failing test and the passing test that most resembles it to achieve this goal. An experiment on 5 real-life medium-sized programs with 18, 920 multiple-fault versions, which are shipped with number of faults ranging from 2 to 8, has been conducted to evaluate the technique. The results indicate that the performance of the technique in terms of evaluation measures precision, recall, and F-measure is promising. In addition, for the identified failing tests that executed a single fault, the technique can also properly cluster them.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194638','10.1109/ICSE.2015.102',46,1,'IEEE','IEEE Conferences',0),(446,'Engineering Sustainability Through Language',2,501,504,'As our understanding and care for sustainability concerns increases, so does the demand for incorporating these concerns into software. Yet, existing programming language constructs are not well-aligned with concepts of the sustainability domain. This undermines what we term technical sustainability of the software due to (i) increased complexity in programming of such concerns and (ii) continuous code changes to keep up with changes in (environmental, social, legal and other) sustainability-related requirements. In this paper we present a proof-of-concept approach on how technical sustainability support for new and existing concerns can be provided through flexible language-level programming. We propose to incorporate sustainability-related behaviour into programs through micro-languages enabling such behaviour to be updated and/or redefined as and when required.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203001','10.1109/ICSE.2015.183',17,5,'IEEE','IEEE Conferences',0),(447,'Educating Software Engineering Managers - Revisited What Software Project Managers Need to Know Today',2,353,359,'In 2003, the original paper with this title was published as part of CSEET 2003. It focused on resolving communication issues between software project managers and developers and introduced a corporate strategy based means of evaluating software engineers. Now, more than a decade later, we could benefit from what we have learned in other fields about managing people involved in knowledge work and how to improve our success in software development. But are we? This paper is intended to present what Software Engineering students can be taught today that will help them to be successful as software project managers now and in the future. It is based on the premise that effective software project managers are not born but made through education.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202985','10.1109/ICSE.2015.168',54,4,'IEEE','IEEE Conferences',0),(448,'Borrowing from the Crowd: A Study of Recombination in Software Design Competitions',2,551,562,'One form of crowdsourcing is the competition, which poses an open call for competing solutions. Commercial systems such as TopCoder have begun to explore the application of competitions to software development, but have important limitations diminishing the potential benefits drawn from the crowd. In particular, they employ a model of independent work that ignores the opportunity for designs to arise from the ideas of multiple designers. In this paper, we examine the potential for software design competitions to incorporate recombination, in which competing designers are given the designs of others and encouraged to use them to revise their own designs. To explore this, we conducted two software design competitions in which participants were asked to produce both an initial and a revised design, drawing on lessons learned from the crowd. We found that, in both competitions, all participants borrowed ideas and most improved the quality of their designs. Our findings demonstrate the potential benefits of recombination in software design and suggest several ways in which software design competitions can be improved.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194605','10.1109/ICSE.2015.72',40,16,'IEEE','IEEE Conferences',0),(449,'Data-Delineation in Software Binaries and its Application to Buffer-Overrun Discovery',2,145,155,'Detecting memory-safety violations in binaries is complicated by the lack of knowledge of the intended data layout, i.e., the locations and sizes of objects. We present lightweight, static, heuristic analyses for recovering the intended layout of data in a stripped binary. Comparison against DWARF debugging information shows high precision and recall rates for inferring source-level object boundaries. On a collection of benchmarks, our analysis eliminates a third to a half of incorrect object boundaries identified by an IDA Pro-inspired heuristic, while retaining nearly all valid object boundaries. In addition to measuring their accuracy directly, we evaluate the effect of using the recovered data for improving the precision of static buffer-overrun detection in the defect-detection tool CodeSonar/x86. We demonstrate that CodeSonar\'s false-positive rate drops by about 80% across our internal evaluation suite for the tool, while our approximation of CodeSonar\'s recall only degrades about 25%.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194569','10.1109/ICSE.2015.36',29,6,'IEEE','IEEE Conferences',0),(450,'Symbolic Model Checking of Product-Line Requirements Using SAT-Based Methods',2,189,199,'Product line (PL) engineering promotes the development of families of related products, where individual products are differentiated by which optional features they include. Modelling and analyzing requirements models of PLs allows for early detection and correction of requirements errors -- including unintended feature interactions, which are a serious problem in feature-rich systems. A key challenge in analyzing PL requirements is the efficient verification of the product family, given that the number of products is too large to be verified one at a time. Recently, it has been shown how the high-level design of an entire PL, that includes all possible products, can be compactly represented as a single model in the SMV language, and model checked using the NuSMV tool. The implementation in NuSMV uses BDDs, a method that has been outperformed by SAT-based algorithms. In this paper we develop PL model checking using two leading SAT-based symbolic model checking algorithms: IMC and IC3. We describe the algorithms, prove their correctness, and report on our implementation. Evaluating our methods on three PL models from the literature, we demonstrate an improvement of up to 3 orders of magnitude over the existing BDD-based method.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194573','10.1109/ICSE.2015.40',0,5,'IEEE','IEEE Conferences',0),(451,'Empirically Detecting False Test Alarms Using Association Rules',2,39,48,'Applying code changes to software systems and testing these code changes can be a complex task that involves many different types of software testing strategies, e.g. system and integration tests. However, not all test failures reported during code integration are hinting towards code defects. Testing large systems such as the Microsoft Windows operating system requires complex test infrastructures, which may lead to test failures caused by faulty tests and test infrastructure issues. Such false test alarms are particular annoying as they raise engineer attention and require manual inspection without providing any benefit. The goal of this work is to use empirical data to minimize the number of false test alarms reported during system and integration testing. To achieve this goal, we use association rule learning to identify patterns among failing test steps that are typically for false test alarms and can be used to automatically classify them. A successful classification of false test alarms is particularly valuable for product teams as manual test failure inspection is an expensive and time-consuming process that not only costs engineering time and money but also slows down product development. We evaluating our approach on system and integration tests executed during Windows 8.1 and Microsoft Dynamics AX development. Performing more than 10,000 classifications for each product, our model shows a mean precision between 0.85 and 0.90 predicting between 34% and 48% of all false test alarms.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202948','10.1109/ICSE.2015.133',44,18,'IEEE','IEEE Conferences',0),(452,'SPF: A Middleware for Social Interaction in Mobile Proximity Environments',2,79,88,'Smart interconnected devices are changing our lives and are turning conventional spaces into smart ones. Physical proximity, a key enabler of social interactions in the old days is not exploited by smart solutions, where the social dimension is always managed through the Internet. This paper aims to blend the two forces and proposes the idea of social smart space, where modern technologies can help regain and renew social interactions, and where proximity is seen as enabler for dedicated and customized functionality provided by users to users. A Social Proximity Framework (SPF) provides the basis for the creation of this new flavor of smart spaces. Two different versions of the SPF, based on different communication infrastructures, help explain the characteristics of the different components, and show how the SPF can benefit from emerging connection-less communication protocols. A first assessment of the two implementations concludes the paper.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202952','10.1109/ICSE.2015.137',19,2,'IEEE','IEEE Conferences',0),(453,'AppCivist - A Service-Oriented Software Platform for Socially Sustainable Activism',2,515,518,'The increased adoption of mobile devices and social networking is drastically changing the way people monitor and share knowledge about their environment. Here, information and communication technologies (ICT) offer significant new ways to support social activism in cities by providing residents with new digital tools to articulate projects and mobilize activities. However, the development of ICT for activism is still in its infancy, with activists using basic tools stitched together in an ad hoc manner for their needs. Still, Internet-based technologies and related software architectures feature various enablers for civic action beyond base social networking. To that end, this paper discusses the vision and initial details of AppCivist, a platform that builds on cross-domain research among social scientists and computer scientists to revisit service-oriented architecture and relevant services to further social activism. We discuss the ICT challenges inherent in this project and present our recent work to address them.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203003','10.1109/ICSE.2015.185',9,5,'IEEE','IEEE Conferences',0),(454,'Concurrent Software Engineering and Robotics Education',2,370,379,'This paper presents a new, multidisciplinary robotics programming course, reports initial results, and describes subsequent improvements. With equal emphasis on software engineering and robotics, the course teaches students how software engineering applies to robotics. Students learn independently and interactively and gain hands-on experience by implementing robotics algorithms on a real robot. To understand the effects of the course, we conducted an exit and an 8-month survey and measured software quality of the students\' solutions. The analysis shows that the hands-on experience helped everyone learn and retain robotics well, but the students\' knowledge gain in software engineering depended on their prior programming knowledge. Based on these findings, we propose improvements to the course. Lastly, we reflect our experience on andragogy, minimalism, and interactive learning.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202987','10.1109/ICSE.2015.169',30,2,'IEEE','IEEE Conferences',0),(455,'Does Outside-In Teaching Improve the Learning of Object-Oriented Programming?',2,408,417,'Object-oriented programming (OOP) is widely used in the software industry and university introductory courses today. Following the structure of most textbooks, such courses frequently are organised starting with the concepts of imperative and structured programming and only later introducing OOP. An alternative approach is to begin directly with OOP following the Outside-In teaching method as proposed by Meyer. Empirical results for the effects of Outside-In teaching on students and lecturers are sparse, however. We describe the conceptual design and empirical evaluation of two OOP introductory courses from different universities based on Outside-In teaching. The evaluation results are compared to those from a third course serving as the control group, which was taught OOP the \'traditional\' way. We evaluate the initial motivation and knowledge of the participants and the learning outcomes. In addition, we analyse results of the end term exams and qualitatively analyse the results of interviews with the lecturers and tutors. Regarding the learning outcomes, the results show no significant differences between the Outside-In and the \'traditional\' teaching method. In general, students found it harder to solve and implement algorithmic problems than to understand object oriented (OO) concepts. Students taught OOP by the Outside-In method, however, were less afraid that they would not pass the exam at the end of term and understood the OO paradigm more quickly. Therefore, the Outside-In method is no silver bullet for teaching OOP regarding the learning outcomes but has positive effects on motivation and interest.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202991','10.1109/ICSE.2015.173',21,1,'IEEE','IEEE Conferences',0),(456,'Open Source-Style Collaborative Development Practices in Commercial Projects Using GitHub',2,574,585,'Researchers are currently drawn to study projects hosted on GitHub due to its popularity, ease of obtaining data, and its distinctive built-in social features. GitHub has been found to create a transparent development environment, which together with a pull request-based workflow, provides a lightweight mechanism for committing, reviewing and managing code changes. These features impact how GitHub is used and the benefits it provides to teams\' development and collaboration. While most of the evidence we have is from GitHub\'s use in open source software (OSS) projects, GitHub is also used in an increasing number of commercial projects. It is unknown how GitHub supports these projects given that GitHub\'s workflow model does not intuitively fit the commercial development way of working. In this paper, we report findings from an online survey and interviews with GitHub users on how GitHub is used for collaboration in commercial projects. We found that many commercial projects adopted practices that are more typical of OSS projects including reduced communication, more independent work, and self-organization. We discuss how GitHub\'s transparency and popular workflow can promote open collaboration, allowing organizations to increase code reuse and promote knowledge sharing across their teams.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194607','10.1109/ICSE.2015.74',49,21,'IEEE','IEEE Conferences',0),(457,'DASE: Document-Assisted Symbolic Execution for Improving Automated Software Testing',2,620,631,'We propose and implement a new approach, Document-Assisted Symbolic Execution (DASE), to improve automated test generation and bug detection. DASE leverages natural language processing techniques and heuristics to analyze program documentation to extract input constraints automatically. DASE then uses the input constraints to guide symbolic execution to focus on inputs that are semantically more important.We evaluated DASE on 88 programs from 5 mature real-world software suites: COREUTILS, FINDUTILS, GREP, BINUTILS, and ELFTOOLCHAIN. DASE detected 12 previously unknown bugs that symbolic execution without input constraints failed to detect, 6 of which have already been confirmed by the developers. In addition, DASE increases line coverage, branch coverage, and call coverage by 14.2 -- 120.3%, 2.3 -- 167.7%, and 16.9 -- 135.2% respectively, which are 6.0 -- 21.1 percentage points (pp), 1.6 -- 18.9 pp, and 2.8 -- 20.1 pp increases. The accuracies of input constraint extraction are 97.8 -- 100%.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194611','10.1109/ICSE.2015.78',61,8,'IEEE','IEEE Conferences',0),(458,'On the Architecture-Driven Development of Software-Intensive Systems-of-Systems',2,899,902,'Nowadays, complex software-intensive systems have resulted from the integration of heterogeneous independent systems, thus leading to a new class of systems called Systems-of-Systems (SoS). As in any system, SoS architectures have been regarded as an important element for determining their success. However, the state of the art reveals shortcomings that contribute to compromise the quality of these systems, as their inherent characteristics (such as emergent behavior and evolutionary development) are often not properly addressed. In this context, this PhD research aims at investigating how SoS software architectures can be used to model and evolve these systems. As main contribution, an architecture-centric approach for developing software-intensive SoS with focus on the formal specification and dynamic reconfiguration of their architectures is proposed. Such an approach mainly intends to contribute to fill some of the relevant existing gaps regarding the development of software-intensive SoS driven by their software architectures.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203109','10.1109/ICSE.2015.287',18,0,'IEEE','IEEE Conferences',0),(459,'Tempura: Temporal Dimension for IDEs',2,212,222,'Modern integrated development environments (IDEs) make many software engineering tasks easier by providing automated programming support such as code completion and navigation. However, such support -- and therefore IDEs as awhole -- operate on one revision of the code at a time, and leave handling of code history to external tools or plugins, such asEGit for Eclipse. For example, when a method is removed froma class, developers can no longer find the method through code completion. This forces developers to manually switch across different revisions or resort to using external tools when they need to learn about previous code revisions.We propose a novel approach of adding a temporal dimensionto IDEs, enabling code completion and navigation to operate on multiple revisions of code at a time. We previously introduced the idea of temporal code completion and navigation,and presented a vision for how that idea may be realized.This paper realizes that vision by implementing and evaluatinga prototype tool called Tempura. We describe our algorithmfor processing and indexing historical code information from repositories for Tempura, and demonstrate Tempura\'s scalability with three large Eclipse projects. We also evaluate Tempura\'s usability through a controlled user study. The study participantslearned about the code history with more accuracy when usingTempura compared to EGit. Although the sample size was notlarge enough to provide strong statistical significance, the resultsshow a promising outlook for our approach.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194575','10.1109/ICSE.2015.42',44,0,'IEEE','IEEE Conferences',0),(460,'Online Defect Prediction for Imbalanced Data',2,99,108,'Many defect prediction techniques are proposed to improve software reliability. Change classification predicts defects at the change level, where a change is the modifications to one file in a commit. In this paper, we conduct the first study of applying change classification in practice. We identify two issues in the prediction process, both of which contribute to the low prediction performance. First, the data are imbalanced -- there are much fewer buggy changes than clean changes. Second, the commonly used cross-validation approach is inappropriate for evaluating the performance of change classification. To address these challenges, we apply and adapt online change classification, resampling, and updatable classification techniques to improve the classification performance. We perform the improved change classification techniques on one proprietary and six open source projects. Our results show that these techniques improve the precision of change classification by 12.2-89.5% or 6.4 -- 34.8 percentage points (pp.) on the seven projects. In addition, we integrate change classification in the development process of the proprietary project. We have learned the following lessons: 1) new solutions are needed to convince developers to use and believe prediction results, and prediction results need to be actionable, 2) new and improved classification algorithms are needed to explain the prediction results, and insensible and unactionable explanations need to be filtered or refined, and 3) new techniques are needed to improve the relatively low precision.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202954','10.1109/ICSE.2015.139',53,51,'IEEE','IEEE Conferences',0),(461,'Managing Emergent Ethical Concerns for Software Engineering in Society',2,523,526,'This paper presents an initial framework for managing emergent ethical concerns during software engineering in society projects. We argue that such emergent considerations can neither be framed as absolute rules about how to act in relation to fixed and measurable conditions. Nor can they be addressed by simply framing them as non-functional requirements to be satisficed. Instead, a continuous process is needed that accepts the \'messiness\' of social life and social research, seeks to understand complexity (rather than seek clarity), demands collective (not just individual) responsibility and focuses on dialogue over solutions. The framework has been derived based on retrospective analysis of ethical considerations in four software engineering in society projects in three different domains.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203005','10.1109/ICSE.2015.187',13,2,'IEEE','IEEE Conferences',0),(462,'Software Design Studio: A Practical Example',2,389,397,'We have been generally successful for transferring software engineering knowledge to industry through various forms of education. However, many challenges in software engineering training remain. A key amongst these is how best to energise software engineering education with real-world software engineering practices. This paper describes our experience of delivering a radically different approach based on the notion of a Software Design Studio. The Software Design Studio is both a lab for students engaged in conceiving, designing and developing software products as well as an approach for teaching software engineering in the lab which emphasizes practical hands-on work and experimentation. The feedback on the Software Design Studio -- from both staff and students -- has been outstanding. Although the programme is designed as a small, elite programme there is interest to see if the teaching methods can be transferred across to the much larger undergraduate programme in Computer Science. In this paper, we provide a detailed description of how our studio works in practice so that others, thinking of tak-ing a studio or studio-inspired approach, can use in designing their own courses.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202989','10.1109/ICSE.2015.171',15,6,'IEEE','IEEE Conferences',0),(463,'In Search of the Emotional Design Effect in Programming',2,428,434,'A small number of recent studies have suggested that learning is enhanced when the illustrations in instructional materials are designed to appeal to the learners\' emotions through the use of color and the personification of key elements. We sought to replicate this emotional design effect in the context of introductory object-oriented programming (OOP). In this preliminary study, a group of freshmen studied a text on objects which was illustrated using anthropomorphic graphics while a control group had access to abstract graphics. We found no significant difference in the groups\' scores on a comprehension post-test, but the experimental group spent substantially less time on the task than the control group. Among those participants who had no prior programming experience, the materials inspired by emotional design were perceived as less intelligible and appealing and led to lower self-reported concentration levels. Although this result does not match the pattern of results from earlier studies, it shows that the choice of illustrations in learning materials matters and calls for more research that addresses the limitations of this preliminary study.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202993','10.1109/ICSE.2015.175',21,5,'IEEE','IEEE Conferences',0),(464,'Interactive Synthesis Using Free-Form Queries',2,689,692,'We present a new code assistance tool for integrated development environments. Our system accepts free-form queries allowing a mixture of English and Java as an input, and produces Java code fragments that take the query into account and respect syntax, types, and scoping rules of Java as well as statistical usage patterns. The returned results need not have the structure of any previously seen code fragment. As part of our system we have constructed a probabilistic context free grammar for Java constructs and library invocations, as well as an algorithm that uses a customized natural language processing tool chain to extract information from free-form text queries. The evaluation results show that our technique can tolerate much of the flexibility present in natural language, and can also be used to repair incorrect Java expressions that contain useful information about the developer\'s intent. Our demo video is available at http://youtu.be/tx4-XgAZkKU.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203044','10.1109/ICSE.2015.224',28,8,'IEEE','IEEE Conferences',0),(465,'Tricorder: Building a Program Analysis Ecosystem',2,598,608,'Static analysis tools help developers find bugs, improve code readability, and ensure consistent style across a project. However, these tools can be difficult to smoothly integrate with each other and into the developer workflow, particularly when scaling to large codebases. We present Tricorder, a program analysis platform aimed at building a data-driven ecosystem around program analysis. We present a set of guiding principles for our program analysis tools and a scalable architecture for an analysis platform implementing these principles. We include an empirical, in-situ evaluation of the tool as it is used by developers across Google that shows the usefulness and impact of the platform.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194609','10.1109/ICSE.2015.76',43,50,'IEEE','IEEE Conferences',0),(466,'Regular Property Guided Dynamic Symbolic Execution',2,643,653,'A challenging problem in software engineering is to check if a program has an execution path satisfying a regular property. We propose a novel method of dynamic symbolic execution (DSE) to automatically find a path of a program satisfying a regular property. What makes our method distinct is when exploring the path space, DSE is guided by the synergy of static analysis and dynamic analysis to find a target path as soon as possible. We have implemented our guided DSE method for Java programs based on JPF and WALA, and applied it to 13 real-world open source Java programs, a total of 225K lines of code, for extensive experiments. The results show the effectiveness, efficiency, feasibility and scalability of the method. Compared with the pure DSE on the time to find the first target path, the average speedup of the guided DSE is more than 258X when analyzing the programs that have more than 100 paths.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194613','10.1109/ICSE.2015.80',53,13,'IEEE','IEEE Conferences',0),(467,'Cascade: A Universal Programmer-Assisted Type Qualifier Inference Tool',2,234,245,'Type qualifier inference tools usually operate in batch mode and assume that the program must not be changed except to add the type qualifiers. In practice, programs must be changed to make them type-correct, and programmers must understand them. Cascade is an interactive type qualifier inference tool that is easy to implement and universal (i.e., it can work for any type qualifier system for which a checker is implemented). It shows that qualifier inference can achieve better results by involving programmers rather than relying solely on automation.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194577','10.1109/ICSE.2015.44',46,2,'IEEE','IEEE Conferences',0),(468,'IccTA: Detecting Inter-Component Privacy Leaks in Android Apps',2,280,291,'Shake Them All is a popular \'Wallpaper\' application exceeding millions of downloads on Google Play. At installation, this application is given permission to (1) access the Internet (for updating wallpapers) and (2) use the device microphone (to change background following noise changes). With these permissions, the application could silently record user conversations and upload them remotely. To give more confidence about how Shake Them All actually processes what it records, it is necessary to build a precise analysis tool that tracks the flow of any sensitive data from its source point to any sink, especially if those are in different components. Since Android applications may leak private data carelessly or maliciously, we propose IccTA, a static taint analyzer to detect privacy leaks among components in Android applications. IccTA goes beyond state-of-the-art approaches by supporting inter- component detection. By propagating context information among components, IccTA improves the precision of the analysis. IccTA outperforms existing tools on two benchmarks for ICC-leak detectors: DroidBench and ICC-Bench. Moreover, our approach detects 534 ICC leaks in 108 apps from MalGenome and 2,395 ICC leaks in 337 apps in a set of 15,000 Google Play apps.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194581','10.1109/ICSE.2015.48',51,187,'IEEE','IEEE Conferences',0),(469,'A Large-Scale Technology Evaluation Study: Effects of Model-based Analysis and Testing',2,119,128,'Besides model-based development, model-based quality assurance and the tighter integration of static and dynamic quality assurance activities are becoming increasingly relevant in the development of software-intensive systems. Thus, this paper reports on an empirical study aimed at investigating the promises regarding quality improvements and cost savings. The evaluation comprises data from 13 industry case studies conducted during a three-year large-scale research project in the transportation domain (automotive, avionics, rail system). During the evaluation, we identified major goals and strategies associated with (integrated) model-based analysis and testing and evaluated the improvements achieved. The aggregated results indicate an average cost reduction of between 29% and 34% for verification and validation and of between 22% and 32% for defect removal. Compared with these cost savings, improvements regarding test coverage (~8%), number of remaining defects (~13%), and time to market (~8%) appear less noticeable.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202956','10.1109/ICSE.2015.141',36,1,'IEEE','IEEE Conferences',0),(470,'An Industrial Case Study on the Automated Detection of Performance Regressions in Heterogeneous Environments',2,159,168,'A key goal of performance testing is the detection of performance degradations (i.e., regressions) compared to previous releases. Prior research has proposed the automation of such analysis through the mining of historical performance data (e.g., CPU and memory usage) from prior test runs. Nevertheless, such research has had limited adoption in practice. Working with a large industrial performance testing lab, we noted that a major hurdle in the adoption of prior work (including our own work) is the incorrect assumption that prior tests are always executed in the same environment (i.e., labs). All too often, tests are performed in heterogenous environments with each test being run in a possibly different lab with different hardware and software configurations. To make automated performance regression analysis techniques work in industry, we propose to model the global expected behaviour of a system as an ensemble (combination) of individual models, one for each successful previous test run (and hence configuration). The ensemble of models of prior test runs are used to flag performance deviations (e.g., CPU counters showing higher usage) in new tests. The deviations are then aggregated using simple voting or more advanced weighting to determine whether the counters really deviate from the expected behaviour or whether it was simply due to an environment-specific variation. Case studies on two open-source systems and a very large scale industrial application show that our weighting approach outperforms a state-of-the-art environment-agnostic approach. Feedback from practitioners who used our approach over a 4 year period (across several major versions) has been very positive.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202960','10.1109/ICSE.2015.144',37,14,'IEEE','IEEE Conferences',0),(471,'Cognitively Sustainable ICT with Ubiquitous Mobile Services - Challenges and Opportunities',2,531,540,'Information and Communication Technology (ICT) has led to an unprecedented development in almost all areas of human life. It forms the basis for what is called \'the cognitive revolution\' -- a fundamental change in the way we communicate, feel, think and learn based on an extension of individual information processing capacities by communication with other people through technology. This so-called \'extended cognition\' shapes human relations in a radically new way. It is accompanied by a decrease of shared attention and affective presence within closely related groups. This weakens the deepest and most important bonds, that used to shape human identity. Sustainability, both environmental and social (economic, technological, political and cultural) is one of the most important issues of our time. In connection with \'extended cognition\' we have identified a new, basic type of social sustainability that everyone takes for granted, and which we claim is in danger due to our changed ways of communication. We base our conclusion on a detailed analysis of the current state of the practice and observed trends. The contribution of our article consists of identifying cognitive sustainability and explaining its central role for all other aspects of sustainability, showing how it relates to the cognitive revolution, its opportunities and challenges. Complex social structures with different degrees of proximity have always functioned as mechanisms behind belongingness and identity. To create a long-term cognitive sustainability, we need to rethink and design new communication technologies that support differentiated and complex social relationships.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203007','10.1109/ICSE.2015.189',54,3,'IEEE','IEEE Conferences',0),(472,'Teaching Software Architecture to Undergraduate Students: An Experience Report',2,445,454,'Software architecture lies at the heart of system thinking skills for software. Teaching software architecture requires contending with the problem of how to make the learning realistic -- most systems which students can learn quickly are too simple for them to express architectural issues. We address here the ten years\' history of teaching an undergraduate software architecture course, as a part of a bachelor\'s program in software engineering. Included are descriptions of what we perceive the realistic goals to be, of teaching software architecture at this level. We go on to analyze the successes and issues of various approaches we have taken over the years. We finish with recommendations for others who teach this same subject, either as a standalone undergraduate course or integrated into a software engineering course.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202995','10.1109/ICSE.2015.177',18,8,'IEEE','IEEE Conferences',0),(473,'Are Students Representatives of Professionals in Software Engineering Experiments?',2,666,676,'Background: Most of the experiments in software engineering (SE) employ students as subjects. This raises concerns about the realism of the results acquired through students and adaptability of the results to software industry. Aim: We compare students and professionals to understand how well students represent professionals as experimental subjects in SE research. Method: The comparison was made in the context of two test-driven development experiments conducted with students in an academic setting and with professionals in a software organization. We measured the code quality of several tasks implemented by both subject groups and checked whether students and professionals perform similarly in terms of code quality metrics. Results: Except for minor differences, neither of the subject groups is better than the other. Professionals produce larger, yet less complex, methods when they use their traditional development approach, whereas both subject groups perform similarly when they apply a new approach for the first time. Conclusion: Given a carefully scoped experiment on a development approach that is new to both students and professionals, similar performances are observed. Further investigation is necessary to analyze the effects of subject demographics and level of experience on the results of SE experiments.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194615','10.1109/ICSE.2015.82',30,59,'IEEE','IEEE Conferences',0),(474,'A Synergistic Analysis Method for Explaining Failed Regression Tests',2,257,267,'We propose a new automated debugging method for regression testing based on a synergistic application of both dynamic and semantic analysis. Our method takes a failure- inducing test input, a buggy program, and an earlier correct version of the same program, and computes a minimal set of code changes responsible for the failure, as well as explaining how the code changes lead to the failure. Although this problem has been the subject of intensive research in recent years, existing methods are rarely adopted by developers in practice since they do not produce sufficiently accurate fault explanations for real applications. Our new method is significantly faster and more accurate than existing methods for explaining failed regression tests in real applications, due to its synergistic analysis framework that iteratively applies both dynamic analysis and a constraint solver based semantic analysis to leverage their complementary strengths. We have implemented our new method in a software tool based on the LLVMcompiler and the KLEE symbolic virtual machine. Our experiments on large real Linux applications show that the new method is both efficient and effective in practice.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194579','10.1109/ICSE.2015.46',38,5,'IEEE','IEEE Conferences',0),(475,'AppContext: Differentiating Malicious and Benign Mobile App Behaviors Using Context',2,303,313,'Mobile malware attempts to evade detection during app analysis by mimicking security-sensitive behaviors of benign apps that provide similar functionality (e.g., sending SMS messages), and suppressing their payload to reduce the chance of being observed (e.g., executing only its payload at night). Since current approaches focus their analyses on the types of security-sensitive resources being accessed (e.g., network), these evasive techniques in malware make differentiating between malicious and benign app behaviors a difficult task during app analysis. We propose that the malicious and benign behaviors within apps can be differentiated based on the contexts that trigger security-sensitive behaviors, i.e., the events and conditions that cause the security-sensitive behaviors to occur. In this work, we introduce AppContext, an approach of static program analysis that extracts the contexts of security-sensitive behaviors to assist app analysis in differentiating between malicious and benign behaviors. We implement a prototype of AppContext and evaluate AppContext on 202 malicious apps from various malware datasets, and 633 benign apps from the Google Play Store. AppContext correctly identifies 192 malicious apps with 87.7% precision and 95% recall. Our evaluation results suggest that the maliciousness of a security-sensitive behavior is more closely related to the intention of the behavior (reflected via contexts) than the type of the security-sensitive resources that the behavior accesses.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194583','10.1109/ICSE.2015.50',51,65,'IEEE','IEEE Conferences',0),(476,'Improving Predictability, Efficiency and Trust of Model-Based Proof Activity',2,139,148,'We report on our industrial experience in using formal methods for the analysis of safety-critical systems developed in a model-based design framework. We first highlight the formal proof workflow devised for the verification and validation of embedded systems developed in Matlab/Simulink. In particular, we show that there is a need to: determine the compatibility of the model to be analysed with the proof engine, establish whether the model facilitates proof convergence or when optimisation is required, and avoid over-specification when specifying the hypotheses constraining the inputs of the model during analysis. We also stress on the importance of having a certain harness over the proof activity and present a set of tools we developed to achieve this purpose. Finally, we give a list of best practices, methods and any necessary tools aiming at guaranteeing the validity of the verification results obtained.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202958','10.1109/ICSE.2015.142',15,0,'IEEE','IEEE Conferences',0),(477,'A Case Study in Locating the Architectural Roots of Technical Debt',2,179,188,'Our recent research has shown that, in large-scale software systems, defective files seldom exist alone. They are usually architecturally connected, and their architectural structures exhibit significant design flaws which propagate bugginess among files. We call these flawed structures the architecture roots, a type of technical debt that incurs high maintenance penalties. Removing the architecture roots of bugginess requires refactoring, but the benefits of refactoring have historically been difficult for architects to quantify or justify. In this paper, we present a case study of identifying and quantifying such architecture debts in a large-scale industrial software project. Our approach is to model and analyze software architecture as a set of design rule spaces (DRSpaces). Using data extracted from the project\'s development artifacts, we were able to identify the files implicated in architecture flaws and suggest refactorings based on removing these flaws. Then we built economic models of the before and (predicted) after states, which gave the organization confidence that doing the refactorings made business sense, in terms of a handsome return on investment.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202962','10.1109/ICSE.2015.146',33,27,'IEEE','IEEE Conferences',0),(478,'Virtual Reality in Software Engineering: Affordances, Applications, and Challenges',2,547,550,'Software engineers primarily interact with source code using a keyboard and mouse, and typically view software on a small number of 2D monitors. This interaction paradigm does not take advantage of many affordances of natural human movement and perception. Virtual reality (VR) can use these affordances more fully than existing developer environments to enable new creative opportunities and potentially result in higher productivity, lower learning curves, and increased user satisfaction. This paper describes the affordances offered by VR, demonstrates the benefits of VR and software engineering in prototypes for live coding and code review, and discusses future work, open questions, and the challenges of VR.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203009','10.1109/ICSE.2015.191',21,17,'IEEE','IEEE Conferences',0),(479,'A Vision of Crowd Development',2,563,566,'Crowdsourcing has had extraordinary success in solving a diverse set of problems, ranging from digitization of libraries and translation of the Internet, to scientific challenges such as classifying elements in the galaxy or determining the 3D shape of an enzyme. By leveraging the power of the masses, it is feasible to complete tasks in mere days and sometimes even hours, and to take on tasks that were previously impossible because of their sheer scale. Underlying the success of crowdsourcing is a common theme - the microtask. By breaking down the overall task at hand into microtasks providing short, self-contained pieces of work, work can be performed independently, quickly, and in parallel - enabling numerous and often untrained participants to chip in. This paper puts forth a research agenda, examining the question of whether the same kinds of successes that microtask crowdsourcing is having in revolutionizing other domains can be brought to software development. That is, we ask whether it is possible to push well beyond the open source paradigm, which still relies on traditional, coarse-grained tasks, to a model in which programming proceeds through microtasks performed by vast numbers of crowd developers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203013','10.1109/ICSE.2015.194',20,12,'IEEE','IEEE Conferences',0),(480,'Sustainability Design and Software: The Karlskrona Manifesto',2,467,476,'Sustainability has emerged as a broad concern for society. Many engineering disciplines have been grappling with challenges in how we sustain technical, social and ecological systems. In the software engineering community, for example, maintainability has been a concern for a long time. But too often, these issues are treated in isolation from one another. Misperceptions among practitioners and research communities persist, rooted in a lack of coherent understanding of sustainability, and how it relates to software systems research and practice. This article presents a cross-disciplinary initiative to create a common ground and a point of reference for the global community of research and practice in software and sustainability, to be used for effectively communicating key issues, goals, values and principles of sustainability design for software-intensive systems.The centrepiece of this effort is the Karlskrona Manifesto for Sustainability Design, a vehicle for a much needed conversation about sustainability within and beyond the software community, and an articulation of the fundamental principles underpinning design choices that affect sustainability. We describe the motivation for developing this manifesto, including some considerations of the genre of the manifesto as well as the dynamics of its creation. We illustrate the collaborative reflective writing process and present the current edition of the manifesto itself. We assess immediate implications and applications of the articulated principles, compare these to current practice, and suggest future steps.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202997','10.1109/ICSE.2015.179',52,45,'IEEE','IEEE Conferences',0),(481,'Stuck and Frustrated or in Flow and Happy: Sensing Developers\' Emotions and Progress',2,688,699,'Software developers working on change tasks commonly experience a broad range of emotions, ranging from happiness all the way to frustration and anger. Research, primarily in psychology, has shown that for certain kinds of tasks, emotions correlate with progress and that biometric measures, such as electro-dermal activity and electroencephalography data, might be used to distinguish between emotions. In our research, we are building on this work and investigate developers\' emotions, progress and the use of biometric measures to classify them in the context of software change tasks. We conducted a lab study with 17 participants working on two change tasks each. Participants were wearing three biometric sensors and had to periodically assess their emotions and progress. The results show that the wide range of emotions experienced by developers is correlated with their perceived progress on the change tasks. Our analysis also shows that we can build a classifier to distinguish between positive and negative emotions in 71.36% and between low and high progress in 67.70% of all cases. These results open up opportunities for improving a developer\'s productivity. For instance, one could use such a classifier for providing recommendations at opportune moments when a developer is stuck and making no progress.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194617','10.1109/ICSE.2015.334',69,43,'IEEE','IEEE Conferences',0),(482,'Specifying Event-Based Systems with a Counting Fluent Temporal Logic',2,733,743,'Fluent linear temporal logic is a formalism for specifying properties of event-based systems, based on propositions called fluents, defined in terms of activating and deactivating events. In this paper, we propose complementing the notion of fluent by the related concept of counting fluent. As opposed to the boolean nature of fluents, counting fluents are numerical values, that enumerate event occurrences, and allow us to specify naturally some properties of reactive systems. Although by extending fluent linear temporal logic with counting fluents we obtain an undecidable, strictly more expressive formalism, we develop a sound (but incomplete) model checking approach for the logic, that reduces to traditional temporal logic model checking, and allows us to automatically analyse properties involving counting fluents, on finite event-based systems. Our experiments, based on relevant models taken from the literature, show that: (i) counting fluent temporal logic is better suited than traditional temporal logic for expressing properties in which the number of occurrences of certain events is relevant, and (ii) our model checking approach on counting fluent specifications is more efficient and scales better than model checking equivalent fluent temporal logic specifications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194621','10.1109/ICSE.2015.86',34,2,'IEEE','IEEE Conferences',0),(483,'Detecting Inconsistencies in JavaScript MVC Applications',2,325,335,'Higher demands for more reliable and maintainable JavaScript-based web applications have led to the recent development of MVC (Model-View-Controller) frameworks. One of the main advantages of using these frameworks is that they abstract out DOM API method calls, which are one of the leading causes of web application faults, due to their often complicated interaction patterns. However, MVC frameworks are susceptible to inconsistencies between the identifiers and types of variables and functions used throughout the application. In response to this problem, we introduce a formal consistency model for web applications made using MVC frameworks. We propose an approach -- called Aurebesh -- that automatically detects inconsistencies in such applications. We evaluate Aurebesh by conducting a fault injection experiment and by running it on real applications. Our results show that Aurebesh is accurate, with an overall recall of 96.1% and a precision of 100%. It is also useful in detecting bugs, allowing us to find 15 real-world bugs in applications built on Angular JS, a popular MVC framework.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194585','10.1109/ICSE.2015.52',35,11,'IEEE','IEEE Conferences',0),(484,'Approximating Attack Surfaces with Stack Traces',2,199,208,'Security testing and reviewing efforts are a necessity for software projects, but are time-consuming and expensive to apply. Identifying vulnerable code supports decision-making during all phases of software development. An approach for identifying vulnerable code is to identify its attack surface, the sum of all paths for untrusted data into and out of a system. Identifying the code that lies on the attack surface requires expertise and significant manual effort. This paper proposes an automated technique to empirically approximate attack surfaces through the analysis of stack traces. We hypothesize that stack traces from user-initiated crashes have several desirable attributes for measuring attack surfaces. The goal of this research is to aid software engineers in prioritizing security efforts by approximating the attack surface of a system via stack trace analysis. In a trial on Windows 8, the attack surface approximation selected 48.4% of the binaries and contained 94.6% of known vulnerabilities. Compared with vulnerability prediction models (VPMs) run on the entire codebase, VPMs run on the attack surface approximation improved recall from .07 to .1 for binaries and from .02 to .05 for source files. Precision remained at .5 for binaries, while improving from .5 to .69 for source files.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202964','10.1109/ICSE.2015.148',44,17,'IEEE','IEEE Conferences',0),(485,'The Role of Design Thinking and Physical Prototyping in Social Software Engineering',2,487,496,'Social Software Engineering (Social SE), that is SE aiming to promote positive social change, is a rapidly emerging area. Here, software and digital artefacts are seen as tools for social change, rather than end products or \'solutions\'. Moreover, Social SE requires a sustained buy-in from a range of stakeholders and end-users working in partnership with multidisciplinary software development teams often at a distance. This context poses new challenges to software engineering: it requires both an agile approach for handling uncertainties in the software development process, and the application of participatory, creative design processes to bridge the knowledge asymmetries and the geographical distances in the partnership. This paper argues for the role of design thinking in Social SE and highlights its implications for software engineering in general. It does so by reporting on the contributions that design thinking - and in particular physical design - has brought to (1) the problem space definition, (2) user requirements capture and (3) system feature design of a renewable energy forecasting system developed in partnership with a remote Scottish Island community.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202999','10.1109/ICSE.2015.181',41,8,'IEEE','IEEE Conferences',0),(486,'Efficient Scalable Verification of LTL Specifications',2,711,721,'Linear Temporal Logic (LTL) has been used in computer science for decades to formally specify programs, systems, desired properties, and relevant behaviors. This paper presents a novel, efficient technique for verifying LTL specifications in a fully automated way. Our technique belongs to the category of Bounded Satisfiability Checking approaches, where LTL formulae are encoded as formulae of another decidable logic that can be solved through modern satisfiability solvers. The target logic in our approach is Bit-Vector Logic. We present our novel encoding, show its correctness, and experimentally compare it against existing encodings implemented in well-known formal verification tools.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194619','10.1109/ICSE.2015.84',28,5,'IEEE','IEEE Conferences',0),(487,'Assert Use in GitHub Projects',2,755,766,'Asserts have long been a strongly recommended (if non-functional) adjunct to programs. They certainly don\'t add any user-evident feature value; and it can take quite some skill and effort to devise and add useful asserts. However, they are believed to add considerable value to the developer. Certainly, they can help with automated verification; but even in the absence of that, claimed advantages include improved understandability, maintainability, easier fault localization and diagnosis, all eventually leading to better software quality. We focus on this latter claim, and use a large dataset of asserts in C and C++ programs to explore the connection between asserts and defect occurrence. Our data suggests a connection: functions with asserts do have significantly fewer defects. This indicates that asserts do play an important role in software quality; we therefore explored further the factors that play a role in assertion placement: specifically, process factors (such as developer experience and ownership) and product factors, particularly interprocedural factors, exploring how the placement of assertions in functions are influenced by local and global network properties of the callgraph. Finally, we also conduct a differential analysis of assertion use across different application domains.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194623','10.1109/ICSE.2015.88',50,13,'IEEE','IEEE Conferences',0),(488,'How Much Up-Front? A Grounded theory of Agile Architecture',2,347,357,'The tension between software architecture and agility is not well understood by agile practitioners or researchers. If an agile software team spends too little time designing architecture up-front then the team faces increased risk and higher chance of failure, if the team spends too much time the delivery of value to the customer is delayed, and responding to change can become extremely difficult. This paper presents a grounded theory of agile architecture that describes how agile software teams answer the question of how much upfront architecture design effort is enough. This theory, based on grounded theory research involving 44 participants, presents six forces that affect the team\'s context and five strategies that teams use to help them determine how much effort they should put into up-front design.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194587','10.1109/ICSE.2015.54',54,10,'IEEE','IEEE Conferences',0),(489,'Does Automated Refactoring Obviate Systematic Editing?',2,392,402,'When developers add features and fix bugs, they often make systematic edits-similar edits to multiple locations. Systematic edits may indicate that developers should instead refactor to eliminate redundancy. This paper explores this question by designing and implementing a fully automated refactoring tool called RASE, which performs clone removal. RASE (1) extracts common code guided by a systematic edit; (2) creates new types and methods as needed; (3) parameterizes differences in types, methods, variables, and expressions; and (4) inserts return objects and exit labels based on control and data flow. To our knowledge, this functionality makes RASE the most advanced refactoring tool for automated clone removal. We evaluate RASE with real-world systematic edits and compare to method based clone removal. RASE successfully performs clone removal in 30 of 56 method pairs (n=2) and 20 of 30 method groups (n鈮�3) with systematic edits. We find that scoping refactoring based on systematic edits (58%), rather than the entire method (33%), increases the applicability of automated clone removal. Automated refactoring is not feasible in the other 42% cases, which indicates that automated refactoring does not obviate the need for systematic editing.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194591','10.1109/ICSE.2015.58',34,5,'IEEE','IEEE Conferences',0),(490,'\'Should We Move to Stack Overflow?\' Measuring the Utility of Social Media for Developer Support',2,219,228,'Stack Overflow is an enormously popular question-and-answer web site intended for software developers to help each other with programming issues. Some software projects aimed at developers (for example, application programming interfaces, application engines, cloud services, development frameworks, and the like) are closing their self-supported developer discussion forums and mailing lists and instead directing developers to use special-purpose tags on Stack Overflow. The goals of this paper are to document the main reasons given for moving developer support to Stack Overflow, and then to collect and analyze data from a group of software projects that have done this, in order to show whether the expected quality of support was actually achieved. The analysis shows that for all four software projects in this study, two of the desired quality indicators, developer participation and response time, did show improvements on Stack Overflow as compared to mailing lists and forums. However, we also found several projects that moved back from Stack Overflow, despite achieving these desired improvements. The results of this study are applicable to a wide variety of software projects that provide developer support using social media.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202966','10.1109/ICSE.2015.150',18,18,'IEEE','IEEE Conferences',0),(491,'Drawing Insight from Student Perceptions of Reflective Design Learning',2,253,262,'While design and designing are core elements in computer science and software engineering, conventional curricular structures do not adequately support design learning. Current methods tend to isolate the study of design within specific subject matter and lack a strong emphasis on reflection. This paper reports on insights and lessons learned from a user study in the context of ongoing work on developing an educational intervention that better supports design learning with a particular emphasis on learner-driven reflection. Insights drawn from this study relate to general aspects of design learning, such as the importance of collaborative reflection and the impact of learner perceptions regarding their abilities, as well as to specific improvements to our approach.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202970','10.1109/ICSE.2015.154',15,1,'IEEE','IEEE Conferences',0),(492,'Inferring Behavioral Specifications from Large-scale Repositories by Leveraging Collective Intelligence',2,579,582,'Despite their proven benefits, useful, comprehensible, and efficiently checkable specifications are not widely available. This is primarily because writing useful, non-trivial specifications from scratch is too hard, time consuming, and requires expertise that is not broadly available. Furthermore, the lack of specifications for widely-used libraries and frameworks, caused by the high cost of writing specifications, tends to have a snowball effect. Core libraries lack specifications, which makes specifying applications that use them expensive. To contain the skyrocketing development and maintenance costs of high assurance systems, this self-perpetuating cycle must be broken. The labor cost of specifying programs can be significantly decreased via advances in specification inference and synthesis, and this has been attempted several times, but with limited success. We believe that practical specification inference and synthesis is an idea whose time has come. Fundamental breakthroughs in this area can be achieved by leveraging the collective intelligence available in software artifacts from millions of open source projects. Fine-grained access to such data sets has been unprecedented, but is now easily available. We identify research directions and report our preliminary results on advances in specification inference that can be had by using such data sets to infer specifications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203017','10.1109/ICSE.2015.339',39,2,'IEEE','IEEE Conferences',0),(493,'On Architectural Diversity of Dynamic Adaptive Systems',2,595,598,'We introduce a novel concept of ``architecture diversity\'\' for adaptive systems and posit that increased diversity has an inverse correlation with adaptation costs. We propose an index to quantify diversity and a static method to estimate the adaptation cost, and conduct an initial experiment on an exemplar cloud-based system which reveals the posited correlation.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203021','10.1109/ICSE.2015.201',8,1,'IEEE','IEEE Conferences',0),(494,'A Comparative Study of Programming Languages in Rosetta Code',2,778,788,'Sometimes debates on programming languages are more religious than scientific. Questions about which language is more succinct or efficient, or makes developers more productive are discussed with fervor, and their answers are too often based on anecdotes and unsubstantiated beliefs. In this study, we use the largely untapped research potential of Rosetta Code, a code repository of solutions to common programming tasks in various languages, which offers a large data set for analysis. Our study is based on 7\'087 solution programs corresponding to 745 tasks in 8 widely used languages representing the major programming paradigms (procedural: C and Go, object-oriented: C# and Java, functional: F# and Haskell, scripting: Python and Ruby). Our statistical analysis reveals, most notably, that: functional and scripting languages are more concise than procedural and object-oriented languages, C is hard to beat when it comes to raw speed on large inputs, but performance differences over inputs of moderate size are less pronounced and allow even interpreted languages to be competitive, compiled strongly-typed languages, where more defects can be caught at compile time, are less prone to runtime failures than interpreted or weakly-typed languages. We discuss implications of these results for developers, language designers, and educators.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194625','10.1109/ICSE.2015.90',32,25,'IEEE','IEEE Conferences',0),(495,'Build It Yourself! Homegrown Tools in a Large Software Company',2,369,379,'Developers sometimes take the initiative to build toolsto solve problems they face. What motivates developers to buildthese tools? What is the value for a company? Are the tools builtuseful for anyone besides their creator? We conducted a qualitativestudy of tool building, adoption, and impact within Microsoft. Thispaper presents our findings on the extrinsic and intrinsic factorslinked to toolbuilding, the value of building tools, and the factorsassociated with tool spread. We find that the majority of developersbuild tools. While most tools never spread beyond their creator\'steam, most have more than one user, and many have more than onecollaborator. Organizational cultures that are receptive towardstoolbuilding produce more tools, and more collaboration on tools.When nurtured and spread, homegrown tools have the potential tocreate significant impact on organizations.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194589','10.1109/ICSE.2015.56',27,6,'IEEE','IEEE Conferences',0),(496,'Learning to Log: Helping Developers Make Informed Logging Decisions',2,415,425,'Logging is a common programming practice of practical importance to collect system runtime information for postmortem analysis. Strategic logging placement is desired to cover necessary runtime information without incurring unintended consequences (e.g., Performance overhead, trivial logs). However, in current practice, there is a lack of rigorous specifications for developers to govern their logging behaviours. Logging has become an important yet tough decision which mostly depends on the domain knowledge of developers. To reduce the effort on making logging decisions, in this paper, we propose a \'learning to log\' framework, which aims to provide informative guidance on logging during development. As a proof of concept, we provide the design and implementation of a logging suggestion tool, Log Advisor, which automatically learns the common logging practices on where to log from existing logging instances and further leverages them for actionable suggestions to developers. Specifically, we identify the important factors for determining where to log and extract them as structural features, textual features, and syntactic features. Then, by applying machine learning techniques (e.g., Feature selection and classifier learning) and noise handling techniques, we achieve high accuracy of logging suggestions. We evaluate Log Advisor on two industrial software systems from Microsoft and two open-source software systems from Git Hub (totally 19.1M LOC and 100.6K logging statements). The encouraging experimental results, as well as a user study, demonstrate the feasibility and effectiveness of our logging suggestion tool. We believe our work can serve as an important first step towards the goal of \'learning to log\'.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194593','10.1109/ICSE.2015.60',48,40,'IEEE','IEEE Conferences',0),(497,'Automated Modularization of GUI Test Cases',2,44,54,'Test cases that drive an application under test via its graphical user interface (GUI) consist of sequences of steps that perform actions on, or verify the state of, the application user interface. Such tests can be hard to maintain, especially if they are not properly modularized - that is, common steps occur in many test cases, which can make test maintenance cumbersome and expensive. Performing modularization manually can take up considerable human effort. To address this, we present an automated approach for modularizing GUI test cases. Our approach consists of multiple phases. In the first phase, it analyzes individual test cases to partition test steps into candidate subroutines, based on how user-interface elements are accessed in the steps. This phase can analyze the test cases only or also leverage execution traces of the tests, which involves a cost-accuracy tradeoff. In the second phase, the technique compares candidate subroutines across test cases, and refines them to compute the final set of subroutines. In the last phase, it creates callable subroutines, with parameterized data and control flow, and refactors the original tests to call the subroutines with context-specific data and control parameters. Our empirical results, collected using open-source applications, illustrate the effectiveness of the approach.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194560','10.1109/ICSE.2015.27',33,1,'IEEE','IEEE Conferences',0),(498,'LACE2: Better Privacy-Preserving Data Sharing for Cross Project Defect Prediction',2,801,811,'Before a community can learn general principles, it must share individual experiences. Data sharing is the fundamental step of cross project defect prediction, i.e. the process of using data from one project to predict for defects in another. Prior work on secure data sharing allowed data owners to share their data on a single-party basis for defect prediction via data minimization and obfuscation. However the studied method did not consider that bigger data required the data owner to share more of their data. In this paper, we extend previous work with LACE2 which reduces the amount of data shared by using multi-party data sharing. Here data owners incrementally add data to a cache passed among them and contribute \'interesting\' data that are not similar to the current content of the cache. Also, before data owner i passes the cache to data owner j, privacy is preserved by applying obfuscation algorithms to hide project details. The experiments of this paper show that (a) LACE2 is comparatively less expensive than the single-party approach and (b) the multi-party approach of LACE2 yields higher privacy than the prior approach without damaging predictive efficacy (indeed, in some cases, LACE2 leads to better defect predictors).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194627','10.1109/ICSE.2015.92',44,25,'IEEE','IEEE Conferences',0),(499,'GPredict: Generic Predictive Concurrency Analysis',2,847,857,'Predictive trace analysis (PTA) is an effective approach for detecting subtle bugs in concurrent programs. Existing PTA techniques, however, are typically based on adhoc algorithms tailored to low-level errors such as data races or atomicity violations, and are not applicable to high-level properties such as \'a resource must be authenticated before use\' and \'a collection cannot be modified when being iterated over\'. In addition, most techniques assume as input a globally ordered trace of events, which is expensive to collect in practice as it requires synchronizing all threads. In this paper, we present GPredict: a new technique that realizes PTA for generic concurrency properties. Moreover, GPredict does not require a global trace but only the local traces of each thread, which incurs much less runtime overhead than existing techniques. Our key idea is to uniformly model violations of concurrency properties and the thread causality as constraints over events. With an existing SMT solver, GPredict is able to precisely predict property violations allowed by the causal model. Through our evaluation using both benchmarks and real world applications, we show that GPredict is effective in expressing and predicting generic property violations. Moreover, it reduces the runtime overhead of existing techniques by 54% on DaCapo benchmarks on average.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194631','10.1109/ICSE.2015.96',40,12,'IEEE','IEEE Conferences',0),(500,'Tracking Static Analysis Violations over Time to Capture Developer Characteristics',2,437,447,'Many interesting questions about the software quality of a code base can only be answered adequately if fine-grained information about the evolution of quality metrics over time and the contributions of individual developers is known. We present an approach for tracking static analysis violations (which are often indicative of defects) over the revision history of a program, and for precisely attributing the introduction and elimination of these violations to individual developers. As one application, we demonstrate how this information can be used to compute ``fingerprints\'\' of developers that reflect which kinds of violations they tend to introduce or to fix. We have performed an experimental study on several large open-source projects written in different languages, providing evidence that these fingerprints are well-defined and capture characteristic information about the coding habits of individual developers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194595','10.1109/ICSE.2015.62',38,6,'IEEE','IEEE Conferences',0),(501,'Learning Global Agile Software Engineering Using Same-Site and Cross-Site Teams',2,285,294,'We describe an experience in teaching global software engineering (GSE) using distributed Scrum augmented with industrial best practices. Our unique instructional technique had students work in both same-site and cross-site teams to contrast the two modes of working. The course was a collaboration between Aalto University, Finland and University of Victoria, Canada. Fifteen Canadian and eight Finnish students worked on a single large project, divided into four teams, working on interdependent user stories as negotiated with the industrial product owner located in Finland. Half way through the course, we changed the teams so each student worked in both a local and a distributed team. We studied student learning using a mixed-method approach including 14 post-course interviews, pre-course and Sprint questionnaires, observations, meeting recordings, and repository data from git and Flow dock, the primary communication tool. Our results show no significant differences between working in distributed vs. Non-distributed teams, suggesting that Scrum helps alleviate many GSE problems. Our post-course interviews and survey data allows us to explain this effect, we found that students over time learned to better self-select tasks with less inter-team dependencies, to communicate more, and to work better in teams.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202974','10.1109/ICSE.2015.157',28,11,'IEEE','IEEE Conferences',0),(502,'Developing and Evaluating Software Engineering Process Theories',2,20,31,'A process theory is an explanation of how an entity changes and develops. While software engineering is fundamentally concerned with how software artifacts change and develop, little research explicitly builds and empirically evaluates software engineering process theories. This lack of theory obstructs scientific consensus by focusing the academic community on methods. Methods inevitably oversimplify and over-rationalize reality, obfuscating crucial phenomena including uncertainty, problem framing and illusory requirements. Better process theories are therefore needed to ground software engineering in empirical reality. However, poor understanding of process theory issues impedes research and publication. This paper therefore attempts to clarify the nature and types of process theories, explore their development and provide specific guidance for their empirically evaluation.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194558','10.1109/ICSE.2015.25',74,5,'IEEE','IEEE Conferences',0),(503,'ZoomIn: Discovering Failures by Detecting Wrong Assertions',2,66,76,'Automatic testing, although useful, is still quite ineffective against faults that do not cause crashes or uncaught exceptions. In the majority of the cases automatic tests do not include oracles, and only in some cases they incorporate assertions that encode the observed behavior instead of the intended behavior, that is if the application under test produces a wrong result, the synthesized assertions will encode wrong expectations that match the actual behavior of the application. In this paper we present Zoom In, a technique that extends the fault-revealing capability of test case generation techniques from crash-only faults to faults that require non-trivial oracles to be detected. Zoom In exploits the knowledge encoded in the manual tests written by developers and the similarity between executions to automatically determine an extremely small set of suspicious assertions that are likely wrong and thus worth manual inspection. Early empirical results show that Zoom In has been able to detect 50% of the analyzed non-crashing faults in the Apache Commons Math library requiring the inspection of less than 1.5% of the assertions automatically generated by EvoSuite.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194562','10.1109/ICSE.2015.29',35,2,'IEEE','IEEE Conferences',0),(504,'ReCBuLC: Reproducing Concurrency Bugs Using Local Clocks',2,824,834,'Multi-threaded programs play an increasingly important role in current multi-core environments. Exposing concurrency bugs and debugging such multi-threaded programs have become quite challenging due to their inherent non-determinism. In order to eliminate such non-determinism, many approaches such as record-and-replay and other similar bug reproducing systems have been proposed. However, those approaches often suffer significant performance degradation because they require a large amount of recorded information and/or long analysis and replay time. In this paper, we propose an effective approach, ReCBuLC, to take advantage of the hardware clocks available on modern processors. The key idea is to reduce the recording overhead and analyzing events\' global order by using time stamps recorded in each thread. Those timestamps are used to determine the global orders of shared accesses. To avoid the large overhead incurred in accessing system-wide global clock, we opt to use local per-core clocks that incur much less access overhead. We then propose techniques to resolve differences among local clocks and obtain an accurate global event order. By using per-core clocks, state-of-the-art bug reproducing systems such as PRES and CLAP can reduce the recording overheads by 1% ~ 85%, and the analysis time by 84.66% ~ 99.99%, respectively.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194629','10.1109/ICSE.2015.94',30,6,'IEEE','IEEE Conferences',0),(505,'Discovering Information Explaining API Types Using Text Classification',2,869,879,'Many software development tasks require developers to quickly learn a subset of an Application Programming Interface (API). API learning resources are crucial for helping developers learn an API, but the knowledge relevant to a particular topic of interest may easily be scattered across different documents, which makes finding the necessary information more challenging. This paper proposes an approach to discovering tutorial sections that explain a given API type. At the core of our approach, we classify fragmented tutorial sections using supervised text classification based on linguistic and structural features. Experiments conducted on five tutorials show that our approach is able to discover sections explaining an API type with precision between 0.69 and 0.87 (depending on the tutorial) when trained and tested on the same tutorial. When trained and tested across tutorials, we obtained a precision between 0.74 and 0.94 and lower recall values.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194633','10.1109/ICSE.2015.97',31,26,'IEEE','IEEE Conferences',0),(506,'Safe Memory-Leak Fixing for C Programs',2,459,470,'Automatic bug fixing has become a promising direction for reducing manual effort in debugging. However, general approaches to automatic bug fixing may face some fundamental difficulties. In this paper, we argue that automatic fixing of specific types of bugs can be a useful complement. This paper reports our first attempt towards automatically fixing memory leaks in C programs. Our approach generates only safe fixes, which are guaranteed not to interrupt normal execution of the program. To design such an approach, we have to deal with several challenging problems such as inter-procedural leaks, global variables, loops, and leaks from multiple allocations. We propose solutions to all the problems and integrate the solutions into a coherent approach. We implemented our inter-procedural memory leak fixing into a tool named Leak Fix and evaluated Leak Fix on 15 programs with 522k lines of code. Our evaluation shows that Leak Fix is able to successfully fix a substantial number of memory leaks, and Leak Fix is scalable for large applications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194597','10.1109/ICSE.2015.64',48,21,'IEEE','IEEE Conferences',0),(507,'Remote Development and Distance Delivery of Innovative Courses: Challenges and Opportunities',2,299,302,'The Rochester Institute of Technology (RIT) offers programs of study at several of RIT\'s international campuses: Dubrovnik and Zagreb (Croatia), Dubai (United Arab Emirates) and Priatina (Kosovo). At RIT Croatia, some courses are delivered as distance education courses using Polycom, a video conferencing system, supported by other online education tools. Although distance learning methods and tools provide an effective way to offer instructions remotely, delivering a course that emphasizes team-based software development, with laboratory exercises and in-class team activities, creates new challenges that need to be addressed. This paper discusses the authors\' experiences with the remote development and delivery of one of those courses - the SWEN-383 Software Design Principles and Patterns course in the Information Technology program at RIT Croatia. The paper first explains the role and need for offering this particular course. It then discusses how the collaborative development of this new course was conducted between the U.S. And the Croatian campuses, including remote delivery from Zagreb to Dubrovnik. The paper concludes with observations and suggestions for those who may engage in such a project in the future.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202976','10.1109/ICSE.2015.159',11,1,'IEEE','IEEE Conferences',0),(508,'Towards Explicitly Elastic Programming Frameworks',2,619,622,'It is a widely held view that software engineers should not be \'burdened\' with the responsibility of making their application components elastic, and that elasticity should be either be implicit and automatic in the programming framework; or that it is the responsibility of the cloud provider\'s operational staff (DevOps) to make distributed applications written for dedicated clusters elastic and execute them on cloud environments. In this paper, we argue the opposite - we present a case for explicit elasticity, where software engineers are given the flexibility to explicitly engineer elasticity into their distributed applications. We present several scenarios where elasticity retrofitted to applications by DevOps is ineffective, present preliminary empirical evidence that explicit elasticity improves efficiency, and argue for elastic programming languages and frameworks to reduce programmer effort in engineering elastic distributed applications. We also present a bird\'s eye view of ongoing work on two explicitly elastic programming frameworks - Elastic Thrift (based on Apache Thrift) and Elastic Java, an extension of Java with support for explicit elasticity.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203027','10.1109/ICSE.2015.207',16,2,'IEEE','IEEE Conferences',0),(509,'Rapid Multi-Purpose, Multi-Commit Code Analysis',2,635,638,'Existing code- and software evolution studies typically operate on the scale of a few revisions of a small number of projects, mostly because existing tools are unsuited for performing large-scale studies. We present a novel approach, which can be used to analyze an arbitrary number of revisions of a software project simultaneously and which can be adapted for the analysis of mixed-language projects. It lays the foundation for building high-performance code analyzers for a variety of scenarios. We show that for one particular scenario, namely code metric computation, our prototype outperforms existing tools by multiple orders of magnitude when analyzing thousands of revisions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203031','10.1109/ICSE.2015.211',16,6,'IEEE','IEEE Conferences',0),(510,'No PAIN, No Gain? The Utility of PArallel Fault INjections',2,494,505,'Software Fault Injection (SFI) is an established technique for assessing the robustness of a software under test by exposing it to faults in its operational environment. Depending on the complexity of this operational environment, the complexity of the software under test, and the number and type of faults, a thorough SFI assessment can entail (a) numerous experiments and (b) long experiment run times, which both contribute to a considerable execution time for the tests. In order to counteract this increase when dealing with complex systems, recent works propose to exploit parallel hardware to execute multiple experiments at the same time. While Parallel fault Injections (PAIN) yield higher experiment throughput, they are based on an implicit assumption of non-interference among the simultaneously executing experiments. In this paper we investigate the validity of this assumption and determine the trade-off between increased throughput and the accuracy of experimental results obtained from PAIN experiments.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194600','10.1109/ICSE.2015.67',77,10,'IEEE','IEEE Conferences',0),(511,'Static Control-Flow Analysis of User-Driven Callbacks in Android Applications',2,89,99,'Android software presents many challenges for static program analysis. In this work we focus on the fundamental problem of static control-flow analysis. Traditional analyses cannot be directly applied to Android because the applications are framework-based and event-driven. We consider user-event-driven components and the related sequences of callbacks from the Android framework to the application code, both for lifecycle callbacks and for event handler callbacks. We propose a program representation that captures such callback sequences. This representation is built using context-sensitive static analysis of callback methods. The analysis performs graph reachability by traversing context-compatible interprocedural control-flow paths and identifying statements that may trigger callbacks, as well as paths that avoid such statements. We also develop a client analysis that builds a static model of the application\'s GUI. Experimental evaluation shows that this context-sensitive approach leads to substantial precision improvements, while having practical cost.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194564','10.1109/ICSE.2015.31',45,49,'IEEE','IEEE Conferences',0),(512,'Hercules: Reproducing Crashes in Real-World Application Binaries',2,891,901,'Binary analysis is a well-investigated area in software engineering and security. Given real-world program binaries, generating test inputs which cause the binaries to crash is crucial. Generation of crashing inputs has many applications including off-line analysis of software prior to deployment, or online analysis of software patches as they are inserted. In this work, we present a method for generating inputs which reach a given \'potentially crashing\' location. Such potentially crashing locations can be found by a separate static analysis (or by gleaning crash reports submitted by internal / external users) and serve as the input to our method. The test input generated by our method serves as a witness of the crash. Our method is particularly suited for binaries of programs which take in complex structured inputs. Experiments on real-life applications such as the Adobe Reader and the Windows Media Player demonstrate that our Hercules tool built on selective symbolic execution engine S2E can generate crashing inputs within few hours, where symbolic approaches (as embodied by S2E) or blackbox fuzzing approaches (as embodied by the commercial tool PeachFuzzer) failed.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194635','10.1109/ICSE.2015.99',31,6,'IEEE','IEEE Conferences',0),(513,'The Art of Testing Less without Sacrificing Quality',2,483,493,'Testing is a key element of software development processes for the management and assessment of product quality. In most development environments, the software engineers are responsible for ensuring the functional correctness of code. However, for large complex software products, there is an additional need to check that changes do not negatively impact other parts of the software and they comply with system constraints such as backward compatibility, performance, security etc. Ensuring these system constraints may require complex verification infrastructure and test procedures. Although such tests are time consuming and expensive and rarely find defects they act as an insurance process to ensure the software is compliant. However, long lasting tests increasingly conflict with strategic aims to shorten release cycles. To decrease production costs and to improve development agility, we created a generic test selection strategy called THEO that accelerates test processes without sacrificing product quality. THEO is based on a cost model, which dynamically skips tests when the expected cost of running the test exceeds the expected cost of removing it. We replayed past development periods of three major Microsoft products resulting in a reduction of 50% of test executions, saving millions of dollars per year, while maintaining product quality.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194599','10.1109/ICSE.2015.66',31,25,'IEEE','IEEE Conferences',0),(514,'Teaching Software Systems Thinking at The Open University',2,307,310,'The Open University is a distance-based higher education institution. Most of our students are in employment and study from home, contacting their tutor and fellow students via e-mail and discussion forums. In this paper, we describe our undergraduate and postgraduate modules in the software systems area, how we teach them at a distance, and our focus on shifting our students\' minds into a reflective, critical, holistic socio-technical view of software systems that is relevant to their particular professional contexts.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202978','10.1109/ICSE.2015.161',14,1,'IEEE','IEEE Conferences',0),(515,'Using GSwE2009 for the Evaluation of a Master Degree in Software Engineering in the Universidad de la Rep煤blica',2,323,332,'This paper presents an adoption and adaptation of the Curriculum Guidelines for Graduate Degree Programs in Software Engineering (GSwE2009) proposed by the IEEE-CS and the ACM for the creation of a curriculum for a Master\'s degree in software engineering at the Universidad de la Rep煤blica (Uruguay). A method for evaluating contents and its application is also presented. This evaluation allows us to know the obtained thematic coverage, effort and balance. It also provides information that enables the detection of numerous opportunities for the improvement in the implementation of the program.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202982','10.1109/ICSE.2015.165',19,2,'IEEE','IEEE Conferences',0),(516,'Combining Multi-Objective Search and Constraint Solving for Configuring Large Software Product Lines',2,517,528,'Software Product Line (SPL) feature selection involves the optimization of multiple objectives in a large and highly constrained search space. We introduce SATIBEA, that augments multi-objective search-based optimization with constraint solving to address this problem, evaluating it on five large real-world SPLs, ranging from 1,244 to 6,888 features with respect to three different solution quality indicators and two diversity metrics. The results indicate that SATIBEA statistically significantly outperforms the current state-of-the-art (p <; 0.01) for all five SPLs on all three quality indicators and with maximal effect size (葌12 = 1.0). We also present results that demonstrate the importance of combining constraint solving with search-based optimization and the significant improvement SATIBEA produces over pure constraint solving. Finally, we demonstrate the scalability of SATIBEA: within less than half an hour, it finds thousands of constraint-satisfying optimized software products, even for the largest SPL considered in the literature to date.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194602','10.1109/ICSE.2015.69',55,35,'IEEE','IEEE Conferences',0),(517,'Interactive Code Review for Systematic Changes',2,111,122,'Developers often inspect a diff patch during peer code reviews. Diff patches show low-level program differences per file without summarizing systematic changes -- similar, related changes to multiple contexts. We present Critics, an interactive approach for inspecting systematic changes. When a developer specifies code change within a diff patch, Critics allows developers to customize the change template by iteratively generalizing change content and context. By matching a generalized template against the codebase, it summarizes similar changes and detects potential mistakes. We evaluated Critics using two methods. First, we conducted a user study at Salesforce.com, where professional engineers used Critics to investigate diff patches authored by their own team. After using Critics, all six participants indicated that they would like Critics to be integrated into their current code review environment. This also attests to the fact that Critics scales to an industry-scale project and can be easily adopted by professional engineers. Second, we conducted a user study where twelve participants reviewed diff patches using Critics and Eclipse diff. The results show that human subjects using Critics answer questions about systematic changes 47.3% more correctly with 31.9% saving in time during code review tasks, in comparison to the baseline use of Eclipse diff. These results show that Critics should improve developer productivity in inspecting systematic changes during peer code reviews.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194566','10.1109/ICSE.2015.33',44,23,'IEEE','IEEE Conferences',0),(518,'Measuring Software Redundancy',2,156,166,'Redundancy is the presence of different elements with the same functionality. In software, redundancy is useful (and used) in many ways, for example for fault tolerance and reliability engineering, and in self-adaptive and self-checking programs. However, despite the many uses, we still do not know how to measure software redundancy to support a proper and effective design. If, for instance, the goal is to improve reliability, one might want to measure the redundancy of a solution to then estimate the reliability gained with that solution. Or one might compare alternative solutions to choose the one that expresses more redundancy and therefore, presumably, more reliability. We first formalize a notion of redundancy whereby two code fragments are considered redundant when they achieve the same functionality with different executions. On the basis of this abstract and general notion, we then develop a concrete method to obtain a meaningful quantitative measure of software redundancy. The results we obtain are very positive: we show, through an extensive experimental analysis, that it is possible to distinguish code that is only minimally different, from truly redundant code, and that it is even possible to distinguish low-level code redundancy from high-level algorithmic redundancy. We also show that the measurement is significant and useful for the designer, as it can help predict the effectiveness of techniques that exploit redundancy.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194570','10.1109/ICSE.2015.37',36,12,'IEEE','IEEE Conferences',0),(519,'An Empirical Study on Quality Issues of Production Big Data Platform',2,17,26,'Big Data computing platform has evolved to be a multi-tenant service. The service quality matters because system failure or performance slowdown could adversely affect business and user experience. There is few study in literature on service quality issues of production Big Data computing platform. In this paper, we present an empirical study on the service quality issues of Microsoft ProductA, which is a company-wide multi-tenant Big Data computing platform, serving thousands of customers from hundreds of teams. ProductA has a well-defined incident management process, which helps customers report and mitigate service quality issues on 24/7 basis. This paper explores the common symptom, causes and mitigation of service quality issues in Big Data computing. We conduct an empirical study on 210 real service quality issues in ProductA. Our major findings include (1) 21.0% of escalations are caused by hardware faults; (2) 36.2% are caused by system side defects; (3) 37.2% are due to customer side faults. We also studied the general diagnosis process and the commonly adopted mitigation solutions. Our findings can help improve current development and maintenance practice of Big Data computing platform, and motivate tool support.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202945','10.1109/ICSE.2015.130',30,7,'IEEE','IEEE Conferences',0),(520,'An Empirical Study on Real Bug Fixes',2,913,923,'Software bugs can cause significant financial loss and even the loss of human lives. To reduce such loss, developers devote substantial efforts to fixing bugs, which generally requires much expertise and experience. Various approaches have been proposed to aid debugging. An interesting recent research direction is automatic program repair, which achieves promising results, and attracts much academic and industrial attention. However, people also cast doubt on the effectiveness and promise of this direction. A key criticism is to what extent such approaches can fix real bugs. As only research prototypes for these approaches are available, it is infeasible to address the criticism by evaluating them directly on real bugs. Instead, in this paper, we design and develop BUGSTAT, a tool that extracts and analyzes bug fixes. With BUGSTAT\'s support, we conduct an empirical study on more than 9,000 real-world bug fixes from six popular Java projects. Comparing the nature of manual fixes with automatic program repair, we distill 15 findings, which are further summarized into four insights on the two key ingredients of automatic program repair: fault localization and faulty code fix. In addition, we provide indirect evidence on the size of the search space to fix real bugs and find that bugs may also reside in non-source files. Our results provide useful guidance and insights for improving the state-of-the-art of automatic program repair.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194637','10.1109/ICSE.2015.101',45,35,'IEEE','IEEE Conferences',0),(521,'On the Role of Value Sensitive Concerns in Software Engineering Practice',2,497,500,'The role of software systems on societal sustainability has generally not been the subject of substantive research activity. In this paper we examine the role of software engineering practice as an agent of change/impact for societal sustainability through the manifestation of value sensitive concerns. These concerns remain relatively neglected by software design processes except at early stages of user interface design. Here, we propose a conceptual model that can contribute to a translation of value sensitive design from its current focus in participatory design to one located in mainstream software engineering processes. Addressing this need will have an impact of societal sustainability and we outline some of the key research challenges for that journey.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203000','10.1109/ICSE.2015.182',22,9,'IEEE','IEEE Conferences',0),(522,'Transparently Teaching in the Context of Game-based Learning: the Case of SimulES-W',2,343,352,'This work presents a pedagogical proposal, in the context of game-based learning (GBL), that uses the concept of Transparency Pedagogy. As such, it aims to improve the quality of teaching, and the relationship between student, teacher and teaching methods. Transparency is anchored in the principle of information disclosure. In pedagogy, transparency emerges as an important issue that proposes to raise student awareness about the educational processes. Using GBL as an educational strategy we managed to make the game, a software, transparent. That is we made the inner processes of the game known to the students. As such, besides learning by playing, students had access to the game design, through intentional modeling. We collected evidence that, by disclosure of the information about the design, students better performed on learning software engineering.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202984','10.1109/ICSE.2015.167',40,4,'IEEE','IEEE Conferences',0),(523,'Learning Combinatorial Interaction Test Generation Strategies Using Hyperheuristic Search',2,540,550,'The surge of search based software engineering research has been hampered by the need to develop customized search algorithms for different classes of the same problem. For instance, two decades of bespoke Combinatorial Interaction Testing (CIT) algorithm development, our exemplar problem, has left software engineers with a bewildering choice of CIT techniques, each specialized for a particular task. This paper proposes the use of a single hyperheuristic algorithm that learns search strategies across a broad range of problem instances, providing a single generalist approach. We have developed a Hyperheuristic algorithm for CIT, and report experiments that show that our algorithm competes with known best solutions across constrained and unconstrained problems: For all 26 real-world subjects, it equals or outperforms the best result previously reported in the literature. We also present evidence that our algorithm\'s strong generic performance results from its unsupervised learning. Hyperheuristic search is thus a promising way to relocate CIT design intelligence from human to machine.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194604','10.1109/ICSE.2015.71',40,28,'IEEE','IEEE Conferences',0),(524,'Helping Developers Help Themselves: Automatic Decomposition of Code Review Changesets',2,134,144,'Code Reviews, an important and popular mechanism for quality assurance, are often performed on a change set, a set of modified files that are meant to be committed to a source repository as an atomic action. Understanding a code review is more difficult when the change set consists of multiple, independent, code differences. We introduce CLUSTERCHANGES, an automatic technique for decomposing change sets and evaluate its effectiveness through both a quantitative analysis and a qualitative user study.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194568','10.1109/ICSE.2015.35',28,34,'IEEE','IEEE Conferences',0),(525,'Automatic Documentation Generation via Source Code Summarization',2,903,906,'Programmers need software documentation. However, documentation is expensive to produce and maintain, and often becomes outdated over time. Programmers often lack the time and resources to write documentation. Therefore, automated solutions are desirable. Designers of automatic documentation tools are limited because there is not yet a clear understanding of what characteristics are important to generating high quality summaries. I propose three specific research objectives to improving automatic documentation generation. I propose to study the similarity between source code and summary. Second, I propose studying whether or not including contextual information about source code improves summary quality. Finally, I propose to study the problem of similarity in source code structure and source code documentation. This paper discusses my work on these three objectives towards my Ph.D. dissertation, including my preliminary and proposed work.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203110','10.1109/ICSE.2015.288',31,1,'IEEE','IEEE Conferences',0),(526,'Presence-Condition Simplification in Highly Configurable Systems',2,178,188,'For the analysis of highly configurable systems, analysis approaches need to take the inherent variability of these systems into account. The notion of presence conditions is central to such approaches. A presence condition specifies a subset of system configurations in which a certain artifact or a concern of interest is present (e.g., a defect associated with this subset). In this paper, we introduce and analyze the problem of presence-condition simplification. A key observation is that presence conditions often contain redundant information, which can be safely removed in the interest of simplicity and efficiency. We present a formalization of the problem, discuss application scenarios, compare different algorithms for solving the problem, and empirically evaluate the algorithms by means of a set of substantial case studies.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194572','10.1109/ICSE.2015.39',48,10,'IEEE','IEEE Conferences',0),(527,'Systematic Testing of Reactive Software with Non-Deterministic Events: A Case Study on LG Electric Oven',2,29,38,'Most home appliance devices such as electric ovens are reactive systems which repeat receiving a user input/event through an event handler, updating their internal state based on the input, and generating outputs. A challenge to test a reactive program is to check if the program correctly reacts to various non-deterministic sequence of events because an unexpected sequence of events may make the system fail due to the race conditions between the main loop and asynchronous event handlers. Thus, it is important to systematically generate/test various sequences of events by controlling the order of events and relative timing of event occurrences with respect to the main loop execution. In this paper, we report our industrial experience to solve the aforementioned problem by developing a systematic event generation framework based on concolic testing technique. We have applied the framework to a LG electric oven and detected several critical bugs including one that makes the oven ignore user inputs due to the illegal state transition.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202947','10.1109/ICSE.2015.132',17,1,'IEEE','IEEE Conferences',0),(528,'Comparing Software Architecture Recovery Techniques Using Accurate Dependencies',2,69,78,'Many techniques have been proposed to automatically recover software architectures from software implementations. A thorough comparison among the recovery techniques is needed to understand their effectiveness and applicability. This study improves on previous studies in two ways. First, we study the impact of leveraging more accurate symbol dependencies on the accuracy of architecture recovery techniques. Previous studies have not seriously considered how the quality of the input might affect the quality of the output for architecture recovery techniques. Second, we study a system (Chromium) that is substantially larger (9.7 million lines of code) than those included in previous studies. Obtaining the ground-truth architecture of Chromium involved two years of collaboration with its developers. As part of this work we developed a new sub module-based technique to recover preliminary versions of ground-truth architectures. The other systems that we study have been examined previously. In some cases, we have updated the ground-truth architectures to newer versions, and in other cases we have corrected newly discovered inconsistencies. Our evaluation of nine variants of six state-of-the-art architecture recovery techniques shows that symbol dependencies generally produce architectures with higher accuracies than include dependencies. Despite this improvement, the overall accuracy is low for all recovery techniques. The results suggest that (1) in addition to architecture recovery techniques, the accuracy of dependencies used as their inputs is another factor to consider for high recovery accuracy, and (2) more accurate recovery techniques are needed. Our results show that some of the studied architecture recovery techniques scale to the 10M lines-of-code range (the size of Chromium), whereas others do not.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202951','10.1109/ICSE.2015.136',33,21,'IEEE','IEEE Conferences',0),(529,'Trivial Compiler Equivalence: A Large Scale Empirical Study of a Simple, Fast and Effective Equivalent Mutant Detection Technique',2,936,946,'Identifying equivalent mutants remains the largest impediment to the widespread uptake of mutation testing. Despite being researched for more than three decades, the problem remains. We propose Trivial Compiler Equivalence (TCE) a technique that exploits the use of readily available compiler technology to address this long-standing challenge. TCE is directly applicable to real-world programs and can imbue existing tools with the ability to detect equivalent mutants and a special form of useless mutants called duplicated mutants. We present a thorough empirical study using 6 large open source programs, several orders of magnitude larger than those used in previous work, and 18 benchmark programs with hand-analysis equivalent mutants. Our results reveal that, on large real-world programs, TCE can discard more than 7% and 21% of all the mutants as being equivalent and duplicated mutants respectively. A human- based equivalence verification reveals that TCE has the ability to detect approximately 30% of all the existing equivalent mutants.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194639','10.1109/ICSE.2015.103',58,55,'IEEE','IEEE Conferences',0),(530,'Enabling the Definition and Enforcement of Governance Rules in Open Source Systems',2,505,514,'Governance rules in software development projects help to prioritize and manage their development tasks, and contribute to the long-term sustainability of the project by clarifying how core and external contributors should collaborate in order to advance the project during its whole lifespan. Despite their importance, specially in Open Source Software (OSS) projects, these rules are usually implicit or scattered in the project documentation/tools (e.g., Tracking-systems or forums), hampering the correct understanding of the development process. We propose to enable the explicit definition and enforcement of governance rules for OSS projects. We believe this brings several important benefits, including improvements in the transparency of the process, its traceability and the semi-automation of the governance itself. Our approach has been implemented on top of My Lyn, a project-management Eclipse plug-in supporting most popular tracking-systems.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203002','10.1109/ICSE.2015.184',29,0,'IEEE','IEEE Conferences',0),(531,'Contest Based Learning with Blending Software Engineering and Business Management: For Students\' High Motivation and High Practice Ability',2,360,369,'We began implementing contest-based learning with a blend of software engineering and business management 10 years ago. At first, a project subject was assigned. However, several problems occurred: For example, the students became absorbed in programming rather than design and analysis activities. Therefore, the curriculum changed from project subjects to contest-based learning. Business management, marketing, and accounting subjects were added to the new curriculum, and students made information technology (IT) business plans using their knowledge of software engineering and business management. The IT business plans were submitted to various contests held by public newspaper companies and the federation of economic organizations in Japan. As a result, in the 10 years of the contest-based learning implementation, 20 teams have received awards in various IT business plan contests. We investigated 10 persons who had experience submitting business plans. We confirmed that contest-based learning had clearer goals, such as to win the contest prize, compared to project-based learning. Further, the abilities to solve problems and to investigate increased more in comparison with lecture-style and project-style education.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202986','10.1109/ICSE.2015.340',10,1,'IEEE','IEEE Conferences',0),(532,'Code Hunt: Experience with Coding Contests at Scale',2,398,407,'Mastering a complex skill like programming takes many hours. In order to encourage students to put in these hours, we built Code Hunt, a game that enables players to program against the computer with clues provided as unit tests. The game has become very popular and we are now running worldwide contests where students have a fixed amount of time to solve a set of puzzles. This paper describes Code Hunt and the contest experience it offers. We then show some early results that demonstrate how Code Hunt can accurately discriminate between good and bad coders. The challenges of creating and selecting puzzles for contests are covered. We end up with a short description of our course experience, and some figures that show that Code Hunt is enjoyed by women and men alike.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202990','10.1109/ICSE.2015.172',20,19,'IEEE','IEEE Conferences',0),(533,'Chiminey: Reliable Computing and Data Management Platform in the Cloud',2,677,680,'The enabling of scientific experiments that are embarrassingly parallel, long running and data-intensive into a cloud-based execution environment is a desirable, though complex undertaking for many researchers. The management of such virtual environments is cumbersome and not necessarily within the core skill set for scientists and engineers. We present here Chiminey, a software platform that enables researchers to (i) run applications on both traditional high-performance computing and cloud-based computing infrastructures, (ii) handle failure during execution, (iii) curate and visualise execution outputs, (iv) share such data with collaborators or the public, and (v) search for publicly available data.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203041','10.1109/ICSE.2015.221',13,12,'IEEE','IEEE Conferences',0),(534,'From Developer Networks to Verified Communities: A Fine-Grained Approach',2,563,573,'Effective software engineering demands a coordinated effort. Unfortunately, a comprehensive view on developer coordination is rarely available to support software-engineering decisions, despite the significant implications on software quality, software architecture, and developer productivity. We present a fine-grained, verifiable, and fully automated approach to capture a view on developer coordination, based on commit information and source-code structure, mined from version-control systems. We apply methodology from network analysis and machine learning to identify developer communities automatically. Compared to previous work, our approach is fine-grained, and identifies statistically significant communities using order-statistics and a community-verification technique based on graph conductance. To demonstrate the scalability and generality of our approach, we analyze ten open-source projects with complex and active histories, written in various programming languages. By surveying 53 open-source developers from the ten projects, we validate the authenticity of inferred community structure with respect to reality. Our results indicate that developers of open-source projects form statistically significant community structures and this particular view on collaboration largely coincides with developers\' perceptions of real-world collaboration.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194606','10.1109/ICSE.2015.73',34,19,'IEEE','IEEE Conferences',0),(535,'Alloy*: A General-Purpose Higher-Order Relational Constraint Solver',2,609,619,'The last decade has seen a dramatic growth in the use of constraint solvers as a computational mechanism, not only for analysis of software, but also at runtime. Solvers are available for a variety of logics but are generally restricted to first-order formulas. Some tasks, however, most notably those involving synthesis, are inherently higher order; these are typically handled by embedding a first-order solver (such as a SAT or SMT solver) in a domain-specific algorithm. Using strategies similar to those used in such algorithms, we show how to extend a first-order solver (in this case Kodkod, a model finder for relational logic used as the engine of the Alloy Analyzer) so that it can handle quantifications over higher-order structures. The resulting solver is sufficiently general that it can be applied to a range of problems; it is higher order, so that it can be applied directly, without embedding in another algorithm; and it performs well enough to be competitive with specialized tools. Just as the identification of first-order solvers as reusable backends advanced the performance of specialized tools and simplified their architecture, factoring out higher-order solvers may bring similar benefits to a new class of tools.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194610','10.1109/ICSE.2015.77',43,31,'IEEE','IEEE Conferences',0),(536,'Lightweight Adaptive Filtering for Efficient Learning and Updating of Probabilistic Models',2,200,211,'Adaptive software systems are designed to cope with unpredictable and evolving usage behaviors and environmental conditions. For these systems reasoning mechanisms are needed to drive evolution, which are usually based on models capturing relevant aspects of the running software. The continuous update of these models in evolving environments requires efficient learning procedures, having low overhead and being robust to changes. Most of the available approaches achieve one of these goals at the price of the other. In this paper we propose a lightweight adaptive filter to accurately learn time-varying transition probabilities of discrete time Markov models, which provides robustness to noise and fast adaptation to changes with a very low overhead. A formal stability, unbiasedness and consistency assessment of the learning approach is provided, as well as an experimental comparison with state-of-the-art alternatives.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194574','10.1109/ICSE.2015.41',48,20,'IEEE','IEEE Conferences',0),(537,'Striving for Failure: An Industrial Case Study about Test Failure Prediction',2,49,58,'Software regression testing is an important, yet very costly, part of most major software projects. When regression tests run, any failures that are found help catch bugs early and smooth the future development work. The act of executing large numbers of tests takes significant resources that could, otherwise, be applied elsewhere. If tests could be accurately classified as likely to pass or fail prior to the run, it could save significant time while maintaining the benefits of early bug detection. In this paper, we present a case study to build a classifier for regression tests based on industrial software, Microsoft Dynamics AX. In this study, we examine the effectiveness of this classification as well as which aspects of the software are the most important in predicting regression test failures.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202949','10.1109/ICSE.2015.134',26,5,'IEEE','IEEE Conferences',0),(538,'Merits of Organizational Metrics in Defect Prediction: An Industrial Replication',2,89,98,'Defect prediction models presented in the literature lack generalization unless the original study can be replicated using new datasets and in different organizational settings. Practitioners can also benefit from replicating studies in their own environment by gaining insights and comparing their findings with those reported. In this work, we replicated an earlier study in order to investigate the merits of organizational metrics in building defect prediction models for large-scale enterprise software. We mined the organizational, code complexity, code churn and pre-release bug metrics of that large scale software and built defect prediction models for each metric set. In the original study, organizational metrics were found to achieve the highest performance. In our case, models based on organizational metrics performed better than models based on churn metrics but were outperformed by pre-release metric models. Further, we verified four individual organizational metrics as indicators for defects. We conclude that the performance of different metric sets in building defect prediction models depends on the project\'s characteristics and the targeted prediction level. Our replication of earlier research enabled assessing the validity and limitations of organizational metrics in a different context.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202953','10.1109/ICSE.2015.138',25,8,'IEEE','IEEE Conferences',0),(539,'SOA4DM: Applying an SOA Paradigm to Coordination in Humanitarian Disaster Response',2,519,522,'Despite efforts to achieve a sustainable state of control over the management of global crises, disasters are occurring with greater frequency, intensity, and affecting many more people than ever before while the resources to deal with them do not grow apace. As we enter 2015, with continued concerns that mega-crises may become the new normal, we need to develop novel methods to improve the efficiency and effectiveness of our management of disasters. Software engineering as a discipline has long had an impact on society beyond its role in the development of software systems. In fact, software engineers have been described as the developers of prototypes for future knowledge workers; tools such as Github and Stack Overflow have demonstrated applications beyond the domain of software engineering. In this paper, we take the potential influence of software engineering one-step further and propose using the software service engineering paradigm as a new approach to managing disasters. Specifically, we show how the underlying principles of service-oriented architectures (SOA) can be applied to the coordination of disaster response operations. We describe key challenges in coordinating disaster response and discuss how an SOA approach can address those challenges.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203004','10.1109/ICSE.2015.186',34,1,'IEEE','IEEE Conferences',0),(540,'The Development of a Dashboard Tool for Visualising Online Teamwork Discussions',2,380,388,'Many software development organisations today adopt global software engineering (GSE) and agile models, requiring software engineers to collaborate and develop software in flexible, distributed, online teams. However, many employers have expressed concern that graduates lack teamwork skills and one of the most commonly occurring problems with GSE models are issues with project management. Team managers and educators often oversee a number of teams and the large corpus of data, in combination with agile models, make it difficult to efficiently assess factors such as team role distribution and emotional climate. Current methods and tools for monitoring software engineering (SE) teamwork in both industry and education settings typically focus on member contributions, reflection, or product outcomes, which are limited in terms of real-time feedback and accurate behavioural analysis. We have created a dashboard that extracts and communicates team role distribution and team emotion information in real-time. Our proof of concept provides a real-time analysis of teamwork discussions and visualises team member emotions, the roles they have adopted and overall team sentiment during the course of a collaborative problem-solving project. We demonstrate and discuss how such a tool could be useful for SE team management and training and the development of teamwork skills in SE university courses.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202988','10.1109/ICSE.2015.170',41,7,'IEEE','IEEE Conferences',0),(541,'Active and Inductive Learning in Software Engineering Education',2,418,427,'If software engineering education is done in a traditional lecture-oriented style students have no other choice than believing that the solutions they are told actually work for a problem that they never encountered themselves. In order to overcome this problem, this paper describes an approach which allows students to better understand why software engineering and several of its core methods and techniques are needed, thus preparing them better for their professional life. This approach builds on active and inductive learning. Exercises that make students actively discover relevant software engineering issues are described in detail together with their pedagogical underpinning.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202992','10.1109/ICSE.2015.174',20,10,'IEEE','IEEE Conferences',0),(542,'Database-Backed Program Analysis for Scalable Error Propagation',2,586,597,'Software is rapidly increasing in size and complexity. Static analyses must be designed to scale well if they are to be usable with realistic applications, but prior efforts have often been limited by available memory. We propose a database-backed strategy for large program analysis based on graph algorithms, using a Semantic Web database to manage representations of the program under analysis. Our approach is applicable to a variety of interprocedural finite distributive subset (IFDS) dataflow problems; we focus on error propagation as a motivating example. Our implementation analyzes multi-million-line programs quickly and in just a fraction of the memory required by prior approaches. When memory alone is insufficient, our approach falls back on disk using several hybrid configurations tuned to put all available resources to good use.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194608','10.1109/ICSE.2015.75',75,6,'IEEE','IEEE Conferences',0),(543,'Compositional Symbolic Execution with Memoized Replay',2,632,642,'Symbolic execution is a powerful, systematic analysis that has received much visibility in the last decade. Scalability however remains a major challenge for symbolic execution. Compositional analysis is a well-known general purpose methodology for increasing scalability. This paper introduces a new approach for compositional symbolic execution. Our key insight is that we can summarize each analyzed method as a memoization tree that captures the crucial elements of symbolic execution, and leverage these memoization trees to efficiently replay the symbolic execution of the corresponding methods with respect to their calling contexts. Memoization trees offer a natural way to compose in the presence of heap operations, which cannot be dealt with by previous work that uses logical formulas as summaries for compositional symbolic execution. Our approach also enables efficient target oriented symbolic execution for error detection or program coverage. Initial experimental evaluation based on a prototype implementation in Symbolic Path Finder shows that our approach can be up to an order of magnitude faster than traditional non-compositional symbolic execution.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194612','10.1109/ICSE.2015.79',25,12,'IEEE','IEEE Conferences',0),(544,'Supporting Selective Undo in a Code Editor',2,223,233,'Programmers often need to revert some code to an earlier state, or restore a block of code that was deleted a while ago. However, support for this backtracking in modern programming environments is limited. Many of the backtracking tasks can be accomplished by having a selective undo feature in code editors, but this has major challenges: there can be conflicts among edit operations, and it is difficult to provide usable interfaces for selective undo. In this paper, we present AZURITE, an Eclipse plug-in that allows programmers to selectively undo fine-grained code changes made in the code editor. With AZURITE, programmers can easily perform backtracking tasks, even when the desired code is not in the undo stack or a version control system. AZURITE also provides novel user interfaces specifically designed for selective undo, which were iteratively improved through user feedback gathered from actual users in a preliminary field trial. A formal lab study showed that programmers can successfully use AZURITE, and were twice as fast as when limited to conventional features.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194576','10.1109/ICSE.2015.43',39,19,'IEEE','IEEE Conferences',0),(545,'An Information Retrieval Approach for Regression Test Prioritization Based on Program Changes',2,268,279,'Regression testing is widely used in practice for validating program changes. However, running large regression suites can be costly. Researchers have developed several techniques for prioritizing tests such that the higher-priority tests have a higher likelihood of finding bugs. A vast majority of these techniques are based on dynamic analysis, which can be precise but can also have significant overhead (e.g., for program instrumentation and test-coverage collection). We introduce a new approach, REPiR, to address the problem of regression test prioritization by reducing it to a standard Information Retrieval problem such that the differences between two program versions form the query and the tests constitute the document collection. REPiR does not require any dynamic profiling or static program analysis. As an enabling technology we leverage the open-source IR toolkit Indri. An empirical evaluation using eight open-source Java projects shows that REPiR is computationally efficient and performs better than existing (dynamic or static) techniques for the majority of subject systems.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194580','10.1109/ICSE.2015.47',67,25,'IEEE','IEEE Conferences',0),(546,'Measuring Dependency Freshness in Software Systems',2,109,118,'Modern software systems often make use of third-party components to speed-up development and reduce maintenance costs. In return, developers need to update to new releases of these dependencies to avoid, for example, security and compatibility risks. In practice, prioritizing these updates is difficult because the use of outdated dependencies is often opaque. In this paper we aim to make this concept more transparent by introducing metrics to quantify the use of recent versions of dependencies, i.e. The system\'s \'dependency freshness\'. We propose and investigate a system-level metric based on an industry benchmark. We validate the usefulness of the metric using interviews, analyze the variance of the metric through time, and investigate the relationship between outdated dependencies and security vulnerabilities. The results show that the measurements are considered useful, and that systems using outdated dependencies four times as likely to have security issues as opposed to systems that are up-to-date.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202955','10.1109/ICSE.2015.140',15,12,'IEEE','IEEE Conferences',0),(547,'Dementia and Social Sustainability: Challenges for Software Engineering',2,527,530,'Dementia is a serious threat to social sustainability. As life expectancy increases, more people are developing dementia. At the same time, demographic change is reducing the economically active part of the population. Care of people with dementia imposes great emotional and financial strain on sufferers, their families and society at large. In response, significant research resources are being focused on dementia. One research thread is focused on using computer technology to monitor people in at-risk groups to improve rates of early diagnosis. In this paper we provide an overview of dementia monitoring research and identify a set of scientific challenges for the engineering of dementia-monitoring software, with implications for other mental health self-management systems.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203006','10.1109/ICSE.2015.188',24,5,'IEEE','IEEE Conferences',0),(548,'CodeAware: Sensor-Based Fine-Grained Monitoring and Management of Software Artifacts',2,551,554,'Current continuous integration (CI) tools, although extensible, can be limiting in terms of flexibility. In particular, artifact analysis capabilities available through plug in mechanisms are both coarse-grained and centralized. To address this limitation, this paper introduces a new paradigm, Code Aware, for distributed and fine-grained artifact analysis. Code Aware is an ecosystem inspired by sensor networks, consisting of monitors and actuators, aimed at improving code quality and team productivity. Code ware\'s vision entails (a) the ability to probe software artifacts of any granularity and localization, from variables to classes or files to entire systems, (b) the ability to perform both static and dynamic analyses on these artifacts, and (c) the ability to describe targeted remediation actions, for example to notify interested developers, through automated actuators. We provide motivational examples for the use of Code Aware that leverage current CI solutions, sketch the architecture of its underlying ecosystem, and outline research challenges.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203010','10.1109/ICSE.2015.192',9,5,'IEEE','IEEE Conferences',0),(549,'Experiences in Developing and Delivering a Programme of Part-Time Education in Software and Systems Security',2,435,444,'We report upon our experiences in developing and delivering a programme of part-time education in Software and Systems Security at the University of Oxford. The MSc in Software and Systems Security is delivered as part of the Software Engineering Programme at Oxford - a collection of one-week intensive courses aimed at individuals who are responsible for the procurement, development, deployment and maintenance of large-scale software-based systems. We expect that our experiences will be useful to those considering a similar journey.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202994','10.1109/ICSE.2015.176',36,1,'IEEE','IEEE Conferences',0),(550,'Combining Symbolic Execution and Model Checking for Data Flow Testing',2,654,665,'Data flow testing (DFT) focuses on the flow of data through a program. Despite its higher fault-detection ability over other structural testing techniques, practical DFT remains a significant challenge. This paper tackles this challenge by introducing a hybrid DFT framework: (1) The core of our framework is based on dynamic symbolic execution (DSE), enhanced with a novel guided path search to improve testing performance, and (2) we systematically cast the DFT problem as reach ability checking in software model checking to complement our DSE-based approach, yielding a practical hybrid DFT technique that combines the two approaches\' respective strengths. Evaluated on both open source and industrial programs, our DSE-based approach improves DFT performance by 60~80% in terms of testing time compared with state-of-the-art search strategies, while our combined technique further reduces 40% testing time and improves data-flow coverage by 20% by eliminating infeasible test objectives. This combined approach also enables the cross-checking of each component for reliable and robust testing results.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194614','10.1109/ICSE.2015.81',61,7,'IEEE','IEEE Conferences',0),(551,'A Comprehensive Framework for the Development of Dynamic Smart Spaces',2,927,930,'The conception of reliable smart spaces requires a suitable and comprehensive framework for their design, implementation, testing, and deployment. Numerous solutions have been proposed to solve different aspects related to smart spaces, but we still lack a concrete framework that provides solutions suitable for the whole development life-cycle. This work aims to fill the gap and proposes a framework that provides: (i) well-defined abstractions for designing smart spaces, (ii) a middleware infrastructure to implement them and plug physical objects, (iii) a semantic layer to support heterogeneous elements, and (iv) plugs to integrate external simulators and be able to always work on \'complete\'\' systems in the different phases of the development.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203116','10.1109/ICSE.2015.294',11,1,'IEEE','IEEE Conferences',0),(552,'RECONTEST: Effective Regression Testing of Concurrent Programs',2,246,256,'Concurrent programs proliferate as multi-core technologies advance. The regression testing of concurrent programs often requires running a failing test for weeks before catching a faulty interleaving, due to the myriad of possible interleavings of memory accesses arising from concurrent program executions. As a result, the conventional approach that selects a sub-set of test cases for regression testing without considering interleavings is insufficient. In this paper we present RECONTEST to address the problem by selecting the new interleavings that arise due to code changes. These interleavings must be explored in order to uncover regression bugs. RECONTEST efficiently selects new interleavings by first identifying shared memory accesses that are affected by the changes, and then exploring only those problematic interleavings that contain at least one of these accesses. We have implemented RECONTEST as an automated tool and evaluated it using 13 real-world concurrent program subjects. Our results show that RECONTEST can significantly reduce the regression testing cost without missing any faulty interleavings induced by code changes.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194578','10.1109/ICSE.2015.45',49,10,'IEEE','IEEE Conferences',0),(553,'Do Security Patterns Really Help Designers?',2,292,302,'Security patterns are well-known solutions to security-specific problems. They are often claimed to benefit designers without much security expertise. We have performed an empirical study to investigate whether the usage of security patterns by such an audience leads to a more secure design, or to an increased productivity of the designers. Our study involved 32 teams of master students enrolled in a course on software architecture, working on the design of a realistically-sized banking system. Irrespective of whether the teams were using security patterns, we have not been able to detect a difference between the two treatment groups. However, the teams prefer to work with the support of security patterns.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194582','10.1109/ICSE.2015.49',20,16,'IEEE','IEEE Conferences',0),(554,'Metamorphic Model-Based Testing Applied on NASA DAT -- An Experience Report',2,129,138,'Testing is necessary for all types of systems, but becomes difficult when the tester cannot easily determine whether the system delivers the correct result or not. NASA\'s Data Access Toolkit allows NASA analysts to query a large database of telemetry data. Since the user is unfamiliar with the data and several data transformations can occur, it is impossible to determine whether the system behaves correctly or not in full scale production situations. Small scale testing was already conducted manually by other teams and unit testing was conducted on individual functions. However, there was still a need for full scale acceptance testing on a broad scale. We describe how we addressed this testing problem by applying the idea of metamorphic testing [1]. Specifically, we base it on equivalence of queries and by using the system itself for testing. The approach is implemented using a model-based testing approach in combination with a test data generation and test case outcome analysis strategy. We also discuss some of the issues that were detected using this approach.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202957','10.1109/ICSE.2015.348',12,27,'IEEE','IEEE Conferences',0),(555,'Industry Practices and Event Logging: Assessment of a Critical Software Development Process',2,169,178,'Practitioners widely recognize the importance of event logging for a variety of tasks, such as accounting, system measurements and troubleshooting. Nevertheless, in spite of the importance of the tasks based on the logs collected under real workload conditions, event logging lacks systematic design and implementation practices. The implementation of the logging mechanism strongly relies on the human expertise. This paper proposes a measurement study of event logging practices in a critical industrial domain. We assess a software development process at Selex ES, a leading Finmeccanica company in electronic and information solutions for critical systems. Our study combines source code analysis, inspection of around 2.3 millions log entries, and direct feedback from the development team to gain process-wide insights ranging from programming practices, logging objectives and issues impacting log analysis. The findings of our study were extremely valuable to prioritize event logging reengineering tasks at Selex ES.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202961','10.1109/ICSE.2015.145',31,22,'IEEE','IEEE Conferences',0),(556,'New Initiative: The Naturalness of Software',2,543,546,'This paper describes a new research consortium, studying the Naturalness of Software. This initiative is supported by a pair of grants by the US National Science Foundation, totaling $2,600,000: the first, exploratory (\'EAGER\') grant of $600,000 helped kickstart an inter-disciplinary effort, and demonstrate feasibility; a follow-on full grant of $2,000,000 was recently awarded. The initiative is led by the author, who is at UC Davis, and includes investigators from Iowa State University and Carnegie-Mellon University (Language Technologies Institute).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203008','10.1109/ICSE.2015.190',24,3,'IEEE','IEEE Conferences',0),(557,'How (Much) Do Developers Test?',2,559,562,'What do we know about software testing in the real world? It seems we know from Fred Brooks\' seminal work \'The Mythical Man-Month\' that 50% of project effort is spent on testing. However, due to the enormous advances in software engineering in the past 40 years, the question stands: Is this observation still true? In fact, was it ever true? The vision for our research is to settle the discussion about Brooks\' estimation once and for all: How much do developers test? Does developers\' estimation on how much they test match reality? How frequently do they execute their tests, and is there a relationship between test runtime and execution frequency? What are the typical reactions to failing tests? Do developers solve actual defects in the production code, or do they merely relax their test assertions? Emerging results from 40 software engineering students show that students overestimate their testing time threefold, and 50% of them test as little as 4% of their time, or less. Having proven the scalability of our infrastructure, we are now extending our case study with professional software engineers from open-source and industrial organizations.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203012','10.1109/ICSE.2015.193',14,20,'IEEE','IEEE Conferences',0),(558,'CS/SE Instructors Can Improve Student Writing without Reducing Class Time Devoted to Technical Content: Experimental Results',2,455,464,'The Computer Science and Software Engineering (CS/SE) profession reports that new college graduates lack the communication skills needed for personal and organizational success. Many CS/SE faculty may omit communication instruction from their courses because they do not want to reduce technical content. We experimented in a software-engineering-intensive second-semester programming course with strategies for improving students\' writing of black box test plans that included no instruction on writing the plans beyond the standard lecture on testing. The treatment version of the course used 1) a modified assignment that focused on the plan\'s readers, 2) a model plan students could consult online, and 3) a modified grading rubric that identified the readers\' needs. Three external raters found that students in the treatment sections outperformed students in the control sections on writing for five of nine criteria on rubrics for evaluating the plans and on the raters\' holistic impression of the students\' technical and communication abilities from the perspectives of a manager and a tester.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202996','10.1109/ICSE.2015.178',24,1,'IEEE','IEEE Conferences',0),(559,'Why Good Developers Write Bad Code: An Observational Case Study of the Impacts of Organizational Factors on Software Quality',2,677,687,'How can organizational factors such as structure and culture have an impact on the working conditions of developers? This study is based on ten months of observation of an in-house software development project within a large telecommunications company. The observation was conducted during mandatory weekly status meetings, where technical and managerial issues were raised and discussed. Preliminary results show that many decisions made under the pressure of certain organizational factors negatively affected software quality. This paper describes cases depicting the complexity of organizational factors and reports on ten issues that have had a negative impact on quality, followed by suggested avenues for corrective action.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194616','10.1109/ICSE.2015.83',26,11,'IEEE','IEEE Conferences',0),(560,'Empirical Study Towards a Leading Indicator for Cost of Formal Software Verification',2,722,732,'Formal verification can provide the highest degree of software assurance. Demand for it is growing, but there are still few projects that have successfully applied it to sizeable, real-world systems. This lack of experience makes it hard to predict the size, effort and duration of verification projects. In this paper, we aim to better understand possible leading indicators of proof size. We present an empirical analysis of proofs from the landmark formal verification of the seL4 microkernel and the two largest software verification proof developments in the Archive of Formal Proofs. Together, these comprise 15,018 individual lemmas and approximately 215,000 lines of proof script. We find a consistent quadratic relationship between the size of the formal statement of a property, and the final size of its formal proof in the interactive theorem prover Isabelle. Combined with our prior work, which has indicated that there is a strong linear relationship between proof effort and proof size, these results pave the way for effort estimation models to support the management of large-scale formal verification projects.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194620','10.1109/ICSE.2015.85',36,11,'IEEE','IEEE Conferences',0),(561,'Multi-objective Integer Programming Approaches for Solving Optimal Feature Selection Problem: A New Perspective on Multi-objective Optimization Problems in SBSE',1,1231,1242,'The optimal feature selection problem in software product line is typically addressed by the approaches based on Indicator-based Evolutionary Algorithm (IBEA). In this study, we first expose the mathematical nature of this problem - multi-objective binary integer linear programming. Then, we implement/propose three mathematical programming approaches to solve this problem at different scales. For small-scale problems (roughly, less than 100 features), we implement two established approaches to find all exact solutions. For medium-to-large problems (roughly, more than 100 features), we propose one efficient approach that can generate a representation of the entire Pareto front in linear time complexity. The empirical results show that our proposed method can find significantly more non-dominated solutions in similar or less execution time, in comparison with IBEA and its recent enhancement (i.e., IBED that combines IBEA and Differential Evolution).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453205','10.1145/3180155.3180257',55,1,'IEEE','IEEE Conferences',0),(562,'Nomen est Omen: Exploring and Exploiting Similarities between Argument and Parameter Names',5,1063,1073,'Programmer-provided identifier names convey information about the semantics of a program. This information can complement traditional program analyses in various software engineering tasks, such as bug finding, code completion, and documentation. Even though identifier names appear to be a rich source of information, little is known about their properties and their potential usefulness. This paper presents an empirical study of the lexical similarity between arguments and parameters of methods, which is one prominent situation where names can provide otherwise missing information. The study involves 60 real-world Java programs. We find that, for most arguments, the similarity is either very high or very low, and that short and generic names often cause low similarities. Furthermore, we show that inferring a set of low-similarity parameter names from one set of programs allows for pruning such names in another set of programs. Finally, the study shows that many arguments are more similar to thecorresponding parameter than any alternative argument available in the call site\'s scope. As applications of our findings, we present an anomaly detection technique that identifies 144 renaming opportunities and incorrect arguments in 14 programs, and a code recommendation system that suggests correct arguments with a precision of 83%.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886980','10.1145/2884781.2884841',33,8,'IEEE','IEEE Conferences',0),(563,'Finding and Analyzing Compiler Warning Defects',5,203,213,'Good compiler diagnostic warnings facilitate software development as they indicate likely programming mistakes or code smells. However, due to compiler bugs, the warnings may be erroneous, superfluous or missing, even for mature production compilers like GCC and Clang. In this paper, we (1) propose the first randomized differential testing technique to detect compiler warning defects and (2) describe our extensive evaluation in finding warning defects in widely-used C compilers.At the high level, our technique starts with generating random programs to trigger compilers to emit a variety of compiler warnings, aligns the warnings from different compilers, and identifies inconsistencies as potential bugs. We develop effective techniques to overcome three specific challenges: (1) How to generate random programs, (2) how to align textual warnings, and (3) how to reduce test programs for bug reporting?Our technique is very effective - we have found and reported 60 bugs for GCC (38 confirmed, assigned or fixed) and 39 for Clang (14 confirmed or fixed). This case study not only demonstrates our technique\'s effectiveness, but also highlights the need to continue improving compilers\' warning support, an essential, but rather neglected aspect of compilers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886904','10.1145/2884781.2884879',39,5,'IEEE','IEEE Conferences',0),(564,'A Combinatorial Approach for Exposing Off-Nominal Behaviors',1,910,920,'Off-nominal behaviors (ONBs) have been a major concern in the areas of embedded systems and safety-critical systems. To address ONB problems, some researchers have proposed model-based approaches that can expose ONBs by analyzing natural language requirements documents. While these approaches produced promising results, they require a lot of human effort and time. In this paper, to reduce human effort and time, we propose a combinatorial-based approach, Combinatorial Causal Component Model (Combi-CCM), which uses structured requirements patterns and combinations generated using the IPOG algorithm. We conducted an empirical study using several requirements documents to evaluate our approach, and our results indicate that the proposed approach can reduce human effort and time while maintaining the same ONB exposure ability obtained by the control techniques.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453169','10.1145/3180155.3180204',47,2,'IEEE','IEEE Conferences',0),(565,'Multi-objective Software Effort Estimation',5,619,630,'We introduce a bi-objective effort estimation algorithm that combines Confidence Interval Analysis and assessment of Mean Absolute Error. We evaluate our proposed algorithm on three different alternative formulations, baseline comparators and current state-of-the-art effort estimators applied to five real-world datasets from the PROMISE repository, involving 724 different software projects in total. The results reveal that our algorithm outperforms the baseline, state-of-the-art and all three alternative formulations, statistically significantly (p <; 0.001) and with large effect size (A12 鈮� 0.9) over all five datasets. We also provide evidence that our algorithm creates a new state-of-the-art, which lies within currently claimed industrial human-expert-based thresholds, thereby demonstrating that our findings have actionable conclusions for practicing software engineers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886939','10.1145/2884781.2884830',92,17,'IEEE','IEEE Conferences',0),(566,'Feature-Model Interfaces: The Highway to Compositional Analyses of Highly-Configurable Systems',5,667,678,'Today\'s software systems are often customizable by means of load-time or compile-time configuration options. These options are typically not independent and their dependencies can be specified by means of feature models. As many industrial systems contain thousands of options, the maintenance and utilization of feature models is a challenge for all stakeholders. In the last two decades, numerous approaches have been presented to support stakeholders in analyzing feature models. Such analyses are commonly reduced to satisfiability problems, which suffer from the growing number of options. While first attempts have been made to decompose feature models into smaller parts, they still require to compose all parts for analysis. We propose the concept of a feature-model interface that only consists of a subset of features, typically selected by experts, and hides all other features and dependencies. Based on a formalization of feature-model interfaces, we prove compositionality properties. We evaluate feature-model interfaces using a three-month history of an industrial feature model from the automotive domain with 18,616 features. Our results indicate performance benefits especially under evolution as often only parts of the feature model need to be analyzed again.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886943','10.1145/2884781.2884823',53,1,'IEEE','IEEE Conferences',0),(567,'When Testing Meets Code Review: Why and How Developers Review Tests',1,677,687,'Automated testing is considered an essential process for ensuring software quality. However, writing and maintaining high-quality test code is challenging and frequently considered of secondary importance. For production code, many open source and industrial software projects employ code review, a well-established software quality practice, but the question remains whether and how code review is also used for ensuring the quality of test code. The aim of this research is to answer this question and to increase our understanding of what developers think and do when it comes to reviewing test code. We conducted both quantitative and qualitative methods to analyze more than 300,000 code reviews, and interviewed 12 developers about how they review test files. This work resulted in an overview of current code reviewing practices, a set of identified obstacles limiting the review of test code, and a set of issues that developers would like to see improved in code review tools. The study reveals that reviewing test files is very different from reviewing production files, and that the navigation within the review itself is one of the main issues developers currently face. Based on our findings, we propose a series of recommendations and suggestions for the design of tools and future research.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453136','10.1145/3180155.3180192',0,3,'IEEE','IEEE Conferences',0),(568,'Revisiting Code Ownership and Its Relationship with Software Quality in the Scope of Modern Code Review',5,1039,1050,'Code ownership establishes a chain of responsibility for modules in large software systems. Although prior work uncovers a link between code ownership heuristics and software quality, these heuristics rely solely on the authorship of code changes. In addition to authoring code changes, developers also make important contributions to a module by reviewing code changes. Indeed, recent work shows that reviewers are highly active in modern code review processes, often suggesting alternative solutions or providing updates to the code changes. In this paper, we complement traditional code ownership heuristics using code review activity. Through a case study of six releases of the large Qt and OpenStack systems, we find that: (1) 67%-86% of developers did not author any code changes for a module, but still actively contributed by reviewing 21%-39% of the code changes, (2) code ownership heuristics that are aware of reviewing activity share a relationship with software quality, and (3) the proportion of reviewers without expertise shares a strong, increasing relationship with the likelihood of having post-release defects. Our results suggest that reviewing activity captures an important aspect of code ownership, and should be included in approximations of it in future studies.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886978','10.1145/2884781.2884852',55,11,'IEEE','IEEE Conferences',0),(569,'Automatically Generating Search Heuristics for Concolic Testing',1,1244,1254,'We present a technique to automatically generate search heuristics for concolic testing. A key challenge in concolic testing is how to effectively explore the program\'s execution paths to achieve high code coverage in a limited time budget. Concolic testing employs a search heuristic to address this challenge, which favors exploring particular types of paths that are most likely to maximize the final coverage. However, manually designing a good search heuristic is nontrivial and typically ends up with suboptimal and unstable outcomes. The goal of this paper is to overcome this shortcoming of concolic testing by automatically generating search heuristics. We define a class of search heuristics, namely a parameterized heuristic, and present an algorithm that efficiently finds an optimal heuristic for each subject program. Experimental results with open-source C programs show that our technique successfully generates search heuristics that significantly outperform existing manually-crafted heuristics in terms of branch coverage and bug-finding.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453207','10.1145/3180155.3180166',33,0,'IEEE','IEEE Conferences',0),(570,'Crowdsourcing Program Preconditions via a Classification Game',5,1086,1096,'Invariant discovery is one of the central problems in software verification. This paper reports on an approach that addresses this problem in a novel way; it crowdsources logical expressions for likely invariants by turning invariant discovery into a computer game. The game, called Binary Fission, employs a classification model. In it, players compose preconditions by separating program states that preserve or violate program assertions. The players have no special expertise in formal methods or programming, and are not specifically aware they are solving verification tasks. We show that Binary Fission players discover concise, general, novel, and human readable program preconditions. Our proof of concept suggests that crowdsourcing offers a feasible and promising path towards the practical application of verification technology.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886982','10.1145/2884781.2884865',30,1,'IEEE','IEEE Conferences',0),(571,'Energy Profiles of Java Collections Classes',5,225,236,'We created detailed profiles of the energy consumed by common operations done on Java List, Map, and Set abstractions. The results show that the alternative data types for these abstractions differ significantly in terms of energy consumption depending on the operations. For example, an ArrayList consumes less energy than a LinkedList if items are inserted at the middle or at the end, but consumes more energy than a LinkedList if items are inserted at the start of the list. To explain the results, we explored the memory usage and the bytecode executed during an operation. Expensive computation tasks in the analyzed bytecode traces appeared to have an energy impact, but memory usage did not contribute. We evaluated our profiles by using them to selectively replace Collections types used in six applications and libraries. We found that choosing the wrong Collections type, as indicated by our profiles, can cost even 300% more energy than the most efficient choice. Our work shows that the usage context of a data structure and our measured energy profiles can be used to decide between alternative Collections implementations.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886906','10.1145/2884781.2884869',54,22,'IEEE','IEEE Conferences',0),(572,'Overcoming Open Source Project Entry Barriers with a Portal for Newcomers',5,273,284,'Community-based Open Source Software (OSS) projects are usually self-organized and dynamic, receiving contributions from distributed volunteers. Newcomer are important to the survival, long-term success, and continuity of these communities. However, newcomers face many barriers when making their first contribution to an OSS project, leading in many cases to dropouts. Therefore, a major challenge for OSS projects is to provide ways to support newcomers during their first contribution. In this paper, we propose and evaluate FLOSScoach, a portal created to support newcomers to OSS projects. FLOSScoach was designed based on a conceptual model of barriers created in our previous work. To evaluate the portal, we conducted a study with 65 students, relying on qualitative data from diaries, self-efficacy questionnaires, and the Technology Acceptance Model. The results indicate that FLOSScoach played an important role in guiding newcomers and in lowering barriers related to the orientation and contribution process, whereas it was not effective in lowering technical barriers. We also found that FLOSScoach is useful, easy to use, and increased newcomers\' confidence to contribute. Our results can help project maintainers on deciding the points that need more attention in order to help OSS project newcomers overcome entry barriers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886910','10.1145/2884781.2884806',52,11,'IEEE','IEEE Conferences',0),(573,'Generalized Data Structure Synthesis',1,958,968,'Data structure synthesis is the task of generating data structure implementations from high-level specifications. Recent work in this area has shown potential to save programmer time and reduce the risk of defects. Existing techniques focus on data structures for manipulating subsets of a single collection, but real-world programs often track multiple related collections and aggregate properties such as sums, counts, minimums, and maximums. This paper shows how to synthesize data structures that track subsets and aggregations of multiple related collections. Our technique decomposes the synthesis task into alternating steps of query synthesis and incrementalization. The query synthesis step implements pure operations over the data structure state by leveraging existing enumerative synthesis techniques, specialized to the data structures domain. The incrementalization step implements imperative state modifications by re-framing them as fresh queries that determine what to change, coupled with a small amount of code to apply the change. As an added benefit of this approach over previous work, the synthesized data structure is optimized for not only the queries in the specification but also the required update operations. We have evaluated our approach in four large case studies, demonstrating that these extensions are broadly applicable.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453175','10.1145/3180155.3180211',0,1,'IEEE','IEEE Conferences',0),(574,'Sentiment Analysis for Software Engineering: How Far Can We Go?',1,94,104,'Sentiment analysis has been applied to various software engineering (SE) tasks, such as evaluating app reviews or analyzing developers\' emotions in commit messages. Studies indicate that sentiment analysis tools provide unreliable results when used out-of-the-box, since they are not designed to process SE datasets. The silver bullet for a successful application of sentiment analysis tools to SE datasets might be their customization to the specific usage context. We describe our experience in building a software library recommender exploiting crowdsourced opinions mined from Stack Overflow (e.g., what is the sentiment of developers about the usability of a library). To reach our goal, we retrained-on a set of 40k manually labeled sentences/words extracted from Stack Overflow-a state-of-the-art sentiment analysis tool exploiting deep learning. Despite such an effort- and time-consuming training process, the results were negative. We changed our focus and performed a thorough investigation of the accuracy of these tools on a variety of SE datasets. Our results should warn the research community about the strong limitations of current sentiment analysis tools.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453067','10.1145/3180155.3180195',0,10,'IEEE','IEEE Conferences',0),(575,'Semantic Program Repair Using a Reference Implementation',1,129,139,'Automated program repair has been studied via the use of techniques involving search, semantic analysis and artificial intelligence. Most of these techniques rely on tests as the correctness criteria, which causes the test overfitting problem. Although various approaches such as learning from code corpus have been proposed to address this problem, they are unable to guarantee that the generated patches generalize beyond the given tests. This work studies automated repair of errors using a reference implementation. The reference implementation is symbolically analyzed to automatically infer a specification of the intended behavior. This specification is then used to synthesize a patch that enforces conditional equivalence of the patched and the reference programs. The use of the reference implementation as an implicit correctness criterion alleviates overfitting in test-based repair. Besides, since we generate patches by semantic analysis, the reference program may have a substantially different implementation from the patched program, which distinguishes our approach from existing techniques for regression repair like Relifix. Our experiments in repairing the embedded Linux Busybox with GNU Coreutils as reference (and vice-versa) revealed that the proposed approach scales to real-world programs and enables the generation of more correct patches.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453071','10.1145/3180155.3180247',49,8,'IEEE','IEEE Conferences',0),(576,'Angelix: Scalable Multiline Program Patch Synthesis via Symbolic Analysis',5,691,701,'Since debugging is a time-consuming activity, automated program repair tools such as GenProg have garnered interest. A recent study revealed that the majority of GenProg repairs avoid bugs simply by deleting functionality. We found that SPR, a state-of-the-art repair tool proposed in 2015, still deletes functionality in their many \'plausible\' repairs. Unlike generate-and-validate systems such as GenProg and SPR, semantic analysis based repair techniques synthesize a repair based on semantic information of the program. While such semantics-based repair methods show promise in terms of quality of generated repairs, their scalability has been a concern so far. In this paper, we present Angelix, a novel semantics-based repair method that scales up to programs of similar size as are handled by search-based repair tools such as GenProg and SPR. This shows that Angelix is more scalable than previously proposed semantics based repair methods such as SemFix and DirectFix. Furthermore, our repair method can repair multiple buggy locations that are dependent on each other. Such repairs are hard to achieve using SPR and GenProg. In our experiments, Angelix generated repairs from large-scale real-world software such as wireshark and php, and these generated repairs include multi-location repairs. We also report our experience in automatically repairing the well-known Heartbleed vulnerability.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886945','10.1145/2884781.2884807',40,54,'IEEE','IEEE Conferences',0),(577,'Fixing Deadlocks via Lock Pre-Acquisitions',5,1109,1120,'Manual deadlock fixing is error-prone and time-consuming. Exist-ing generic approach (GA) simply inserts gate locks to fix dead-locks by serializing executions, which could introduce various new deadlocks and incur high runtime overhead. We propose a novel approach DFixer to fix deadlocks without introducing any new deadlocks by design. DFixer only selects one thread of a deadlock to pre-acquire a lock w together with another lock h, where before fixing, the deadlock occurs when the thread holds lock h and waits for lock w. As such, DFixer eliminates a hold-and-wait necessary condition, preventing the deadlock from occurring. The thread per-forming pre-acquisition is carefully selected such that no other syn-chronization exists in between the two original acquisitions. Other-wise, DFixer further introduces a context-aware conditional protect-ed by above lock w to guarantee the correctness of DFixer. The evaluation is on 20 deadlocks, including 17 from widely-used real-world C/C++ programs. It shows that DFixer successfully fixed all deadlocks. Whereas GA introduced 9 new deadlocks; a latest work Grail failed to fix 8 deadlocks and introduced 3 new deadlocks on others. On average, DFixer incurred only 2.1% overhead, where GA and Grail incurred 15.8% and 11.5% overhead, respectively.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886984','10.1145/2884781.2884819',64,5,'IEEE','IEEE Conferences',0),(578,'Automated Energy Optimization of HTTP Requests for Mobile Applications',5,249,260,'Energy is a critical resource for apps that run on mobile devices. Among all operations, making HTTP requests is one of the most energy consuming. Previous studies have shown that bundling smaller HTTP requests into a single larger HTTP request can be an effective way to improve energy efficiency of network communication, but have not defined an automated way to detect when apps can be bundled nor to transform the apps to do this bundling. In this paper we propose an approach to reduce the energy consumption of HTTP requests in Android apps by automatically detecting and then bundling multiple HTTP requests. Our approach first detects HTTP requests that can be bundled using static analysis, then uses a proxy based technique to bundle HTTP requests at runtime. We evaluated our approach on a set of real world marketplace Android apps. In this evaluation, our approach achieved an average energy reduction of 15% for the subject apps and did not impose a significant runtime overhead on the optimized apps.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886908','10.1145/2884781.2884867',54,29,'IEEE','IEEE Conferences',0),(579,'Automatically Learning Semantic Features for Defect Prediction',5,297,308,'Software defect prediction, which predicts defective code regions, can help developers find bugs and prioritize their testing efforts. To build accurate prediction models, previous studies focus on manually designing features that encode the characteristics of programs and exploring different machine learning algorithms. Existing traditional features often fail to capture the semantic differences of programs, and such a capability is needed for building accurate prediction models. To bridge the gap between programs\' semantics and defect prediction features, this paper proposes to leverage a powerful representation-learning algorithm, deep learning, to learn semantic representation of programs automatically from source code. Specifically, we leverage Deep Belief Network (DBN) to automatically learn semantic features from token vectors extracted from programs\' Abstract Syntax Trees (ASTs). Our evaluation on ten open source projects shows that our automatically learned semantic features significantly improve both within-project defect prediction (WPDP) and cross-project defect prediction (CPDP) compared to traditional features. Our semantic features improve WPDP on average by 14.7% in precision, 11.5% in recall, and 14.2% in F1. For CPDP, our semantic features based approach outperforms the state-of-the-art technique TCA+ with traditional features by 8.9% in F1.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886912','10.1145/2884781.2884804',70,60,'IEEE','IEEE Conferences',0),(580,'Automatically Finding Bugs in a Commercial Cyber-Physical System Development Tool Chain With SLforge',1,981,992,'Cyber-physical system (CPS) development tool chains are widely used in the design, simulation, and verification of CPS data-flow models. Commercial CPS tool chains such as MathWorks\' Simulink generate artifacts such as code binaries that are widely deployed in embedded systems. Hardening such tool chains by testing is crucial since formally verifying them is currently infeasible. Existing differential testing frameworks such as CyFuzz can not generate models rich in language features, partly because these tool chains do not leverage the available informal Simulink specifications. Furthermore, no study of existing Simulink models is available, which could guide CyFuzz to generate realistic models. To address these shortcomings, we created the first large collection of public Simulink models and used the collected models\' properties to guide random model generation. To further guide model generation we systematically collected semi-formal Simulink specifications. In our experiments on several hundred models, the resulting SLforge generator was more effective and efficient than the state-of-the-art tool CyFuzz. SLforge also found 8 new confirmed bugs in Simulink.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453177','10.1145/3180155.3180231',60,1,'IEEE','IEEE Conferences',0),(581,'To Preserve or Not to Preserve Invalid Solutions in Search-Based Software Engineering: A Case Study in Software Product Lines',1,1027,1038,'Multi-objective evolutionary algorithms (MOEAs) have been successfully applied for software product lines (SPLs) to search for optimal or near-optimal solutions that balance multiple objectives. However, MOEAs usually produce invalid solutions that violate the constraints predefined. As invalid solutions are unbuildable in practice, we debate the preservation of invalid solutions during the search. We conduct experiments on seven real-world SPLs, including five largest SPLs hitherto reported and two SPLs with realistic values and constraints of quality attributes. We identify three potential limitations of preserving invalid solutions. Furthermore, based on the state-of-the-art, we design five algorithm variants that adopt different evolutionary operators. By performance evaluation, we provide empirical guidance on how to preserve valid solutions. Our empirical study demonstrates that whether or not to preserve invalid solutions deserves more attention in the community, and in some cases, we have to preserve valid solutions all along the way.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453181','10.1145/3180155.3180163',78,0,'IEEE','IEEE Conferences',0),(582,'Static Automated Program Repair for Heap Properties',1,151,162,'Static analysis tools have demonstrated effectiveness at finding bugs in real world code. Such tools are increasingly widely adopted to improve software quality in practice. Automated Program Repair (APR) has the potential to further cut down on the cost of improving software quality. However, there is a disconnect between these effective bug-finding tools and APR. Recent advances in APR rely on test cases, making them inapplicable to newly discovered bugs or bugs difficult to test for deterministically (like memory leaks). Additionally, the quality of patches generated to satisfy a test suite is a key challenge. We address these challenges by adapting advances in practical static analysis and verification techniques to enable a new technique that finds and then accurately fixes real bugs without test cases. We present a new automated program repair technique using Separation Logic. At a high-level, our technique reasons over semantic effects of existing program fragments to fix faults related to general pointer safety properties: resource leaks, memory leaks, and null dereferences. The procedure automatically translates identified fragments into source-level patches, and verifies patch correctness with respect to reported faults. In this work we conduct the largest study of automatically fixing undiscovered bugs in real-world code to date. We demonstrate our approach by correctly fixing 55 bugs, including 11 previously undiscovered bugs, in 11 real-world projects.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453073','10.1145/3180155.3180250',0,3,'IEEE','IEEE Conferences',0),(583,'PAC Learning-Based Verification and Model Synthesis',5,714,724,'We introduce a novel technique for verification and model synthesis of sequential programs. Our technique is based on learning an approximate regular model of the set of feasible paths in a program, and testing whether this model contains an incorrect behavior. Exact learning algorithms require checking equivalence between the model and the program, which is a difficult problem, in general undecidable. Our learning procedure is therefore based on the framework of probably approximately correct (PAC) learning, which uses sampling instead, and provides correctness guarantees expressed using the terms error probability and confidence. Besides the verification result, our procedure also outputs the model with the said correctness guarantees. Obtained preliminary experiments show encouraging results, in some cases even outperforming mature software verifiers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886947','10.1145/2884781.2884860',23,1,'IEEE','IEEE Conferences',0),(584,'Multi-granular Conflict and Dependency Analysis in Software Engineering Based on Graph Transformation',1,716,727,'Conflict and dependency analysis (CDA) of graph transformation has been shown to be a versatile foundation for understanding interactions in many software engineering domains, including software analysis and design, model-driven engineering, and testing. In this paper, we propose a novel static CDA technique that is multi-granular in the sense that it can detect all conflicts and dependencies on multiple granularity levels. Specifically, we provide an efficient algorithm suite for computing binary, coarse-grained, and fine-grained conflicts and dependencies: Binary granularity indicates the presence or absence of conflicts and dependencies, coarse granularity focuses on root causes for conflicts and dependencies, and fine granularity shows each conflict and dependency in full detail. Doing so, we can address specific performance and usability requirements that we identified in a literature survey of CDA usage scenarios. In an experimental evaluation, our algorithm suite computes conflicts and dependencies rapidly. Finally, we present a user study, in which the participants found our coarse-grained results more understandable than the fine-grained ones reported in a state-of-the-art tool. Our overall contribution is twofold: (i) we significantly speed up the computation of fine-grained and binary CDA results and, (ii) complement them with coarse-grained ones, which offer usability benefits for numerous use cases.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453144','10.1145/3180155.3180258',0,0,'IEEE','IEEE Conferences',0),(585,'Locking Discipline Inference and Checking',5,1133,1144,'Concurrency is a requirement for much modern software, but the implementation of multithreaded algorithms comes at the risk of errors such as data races.Programmers can prevent data races by documenting and obeying a locking discipline, which indicates which locks must be held in order to access which data.This paper introduces a formal semantics for locking specifications that gives a guarantee of race freedom.A notable difference from most other semantics is that it is in terms of values (which is what the runtime system locks) rather than variables.The paper also shows how to express the formal semantics in two different styles of analysis:abstract interpretation and type theory.We have implemented both analyses, in tools that operate on Java.To the best of our knowledge, these are the first tools that can soundly infer and check a locking discipline for Java.Our experiments compare the implementations with one another and with annotations written by programmers, showing that the ambiguities and unsoundness of previous formulations are a problem in practice.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886986','10.1145/2884781.2884882',49,0,'IEEE','IEEE Conferences',0),(586,'Shadow of a Doubt: Testing for Divergences between Software Versions',5,1181,1192,'While developers are aware of the importance of comprehensively testing patches, the large effort involved in coming up with relevant test cases means that such testing rarely happens in practice. Furthermore, even when test cases are written to cover the patch, they often exercise the same behaviour in the old and the new version of the code. In this paper, we present a symbolic execution-based technique that is designed to generate test inputs that cover the new program behaviours introduced by a patch. The technique works by executing both the old and the new version in the same symbolic execution instance, with the old version shadowing the new one. During this combined shadow execution, whenever a branch point is reached where the old and the new version diverge, we generate a test case exercising the divergence and comprehensively test the new behaviours of the new version. We evaluate our technique on the Coreutils patches from the CoREBench suite of regression bugs, and show that it is able to generate test inputs that exercise newly added behaviours and expose some of the regression bugs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886990','10.1145/2884781.2884845',31,4,'IEEE','IEEE Conferences',0),(587,'Automated Parameter Optimization of Classification Techniques for Defect Prediction Models',5,321,332,'Defect prediction models are classifiers that are trained to identify defect-prone software modules. Such classifiers have configurable parameters that control their characteristics (e.g., the number of trees in a random forest classifier). Recent studies show that these classifiers may underperform due to the use of suboptimal default parameter settings. However, it is impractical to assess all of the possible settings in the parameter spaces. In this paper, we investigate the performance of defect prediction models where Caret - an automated parameter optimization technique - has been applied. Through a case study of 18 datasets from systems that span both proprietary and open source domains, we find that (1) Caret improves the AUC performance of defect prediction models by as much as 40 percentage points; (2) Caret-optimized classifiers are at least as stable as (with 35% of them being more stable than) classifiers that are trained using the default settings; and (3) Caret increases the likelihood of producing a top-performing classifier by as much as 83%. Hence, we conclude that parameter settings can indeed have a large impact on the performance of defect prediction models, suggesting that researchers should experiment with the parameters of the classification techniques. Since automated parameter optimization techniques like Caret yield substantially benefits in terms of performance improvement and stability, while incurring a manageable additional computational cost, they should be included in future defect prediction studies.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886914','10.1145/2884781.2884857',64,38,'IEEE','IEEE Conferences',0),(588,'Is \'Better Data\' Better Than \'Better Data Miners\'?',1,1050,1061,'We report and fix an important systematic error in prior studies that ranked classifiers for software analytics. Those studies did not (a) assess classifiers on multiple criteria and they did not (b) study how variations in the data affect the results. Hence, this paper applies (a) multi-performance criteria while (b) fixing the weaker regions of the training data (using SMOTUNED, which is an auto-tuning version of SMOTE). This approach leads to dramatically large increases in software defect predictions when applied in a 5*5 cross-validation study for 3,681 JAVA classes (containing over a million lines of code) from open source systems, SMOTUNED increased AUC and recall by 60% and 20% respectively. These improvements are independent of the classifier used to predict for defects. Same kind of pattern (improvement) was observed when a comparative analysis of SMOTE and SMOTUNED was done against the most recent class imbalance technique. In conclusion, for software analytic tasks like defect prediction, (1) data pre-processing can be more important than classifier choice, (2) ranking studies are incomplete without such pre-processing, and (3) SMOTUNED is a promising candidate for pre-processing.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453183','10.1145/3180155.3180197',71,2,'IEEE','IEEE Conferences',0),(589,'Accurate and Efficient Refactoring Detection in Commit History',1,483,494,'Refactoring detection algorithms have been crucial to a variety of applications: (i) empirical studies about the evolution of code, tests, and faults, (ii) tools for library API migration, (iii) improving the comprehension of changes and code reviews, etc. However, recent research has questioned the accuracy of the state-of-the-art refactoring detection tools, which poses threats to the reliability of their application. Moreover, previous refactoring detection tools are very sensitive to user-provided similarity thresholds, which further reduces their practical accuracy. In addition, their requirement to build the project versions/revisions under analysis makes them inapplicable in many real-world scenarios. To reinvigorate a previously fruitful line of research that has stifled, we designed, implemented, and evaluated RMiner, a technique that overcomes the above limitations. At the heart of RMiner is an AST-based statement matching algorithm that determines refactoring candidates without requiring user-defined thresholds. To empirically evaluate RMiner, we created the most comprehensive oracle to date that uses triangulation to create a dataset with considerably reduced bias, representing 3,188 refactorings from 185 open-source projects. Using this oracle, we found that RMiner has a precision of 98% and recall of 87%, which is a significant improvement over the previous state-of-the-art.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453111','10.1145/3180155.3180206',80,16,'IEEE','IEEE Conferences',0),(590,'The Evolution of C Programming Practices: A Study of the Unix Operating System 1973-2015',5,748,759,'Tracking long-term progress in engineering and applied science allows us to take stock of things we have achieved, appreciate the factors that led to them, and set realistic goals for where we want to go. We formulate seven hypotheses associated with the long term evolution of C programming in the Unix operating system, and examine them by extracting, aggregating, and synthesising metrics from 66 snapshots obtained from a synthetic software configuration management repository covering a period of four decades. We found that over the years developers of the Unix operating system appear to have evolved their coding style in tandem with advancements in hardware technology, promoted modularity to tame rising complexity, adopted valuable new language features, allowed compilers to allocate registers on their behalf, and reached broad agreement regarding code formatting. The progress we have observed appears to be slowing or even reversing prompting the need for new sources of innovation to be discovered and followed.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886953','10.1145/2884781.2884799',63,4,'IEEE','IEEE Conferences',0),(591,'SourcererCC: Scaling Code Clone Detection to Big-Code',5,1157,1168,'Despite a decade of active research, there has been a marked lack in clone detection techniques that scale to large repositories for detecting near-miss clones. In this paper, we present a token-based clone detector, SourcererCC, that can detect both exact and near-miss clones from large inter-project repositories using a standard workstation. It exploits an optimized inverted-index to quickly query the potential clones of a given code block. Filtering heuristics based on token ordering are used to significantly reduce the size of the index, the number of code-block comparisons needed to detect the clones, as well as the number of required token-comparisons needed to judge a potential clone. We evaluate the scalability, execution time, recall and precision of SourcererCC, and compare it to four publicly available and state-of-the-art tools. To measure recall, we use two recent benchmarks: (1) a big benchmark of real clones, BigCloneBench, and (2) a Mutation/Injection-based framework of thousands of fine-grained artificial clones. We find SourcererCC has both high recall and precision, and is able to scale to a large inter-project repository (25K projects, 250MLOC) using a standard workstation.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886988','10.1145/2884781.2884877',42,63,'IEEE','IEEE Conferences',0),(592,'Program Synthesis Using Natural Language',5,345,356,'Interacting with computers is a ubiquitous activity for millions of people. Repetitive or specialized tasks often require creation of small, often one-off, programs. End-users struggle with learning and using the myriad of domain-specific languages (DSLs) to effectively accomplish these tasks. We present a general framework for constructing program synthesizers that take natural language (NL) inputs and produce expressions in a target DSL. The framework takes as input a DSL definition and training data consisting of NL/DSL pairs. From these it constructs a synthesizer by learning optimal weights and classifiers (using NLP features) that rank the outputs of a keyword-programming based translation. We applied our framework to three domains: repetitive text editing, an intelligent tutoring system, and flight information queries. On 1200+ English descriptions, the respective synthesizers rank the desired program as the top-1 and top-3 for 80% and 90% descriptions respectively.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886916','10.1145/2884781.2884786',57,5,'IEEE','IEEE Conferences',0),(593,'Augmenting API Documentation with Insights from Stack Overflow',5,392,403,'Software developers need access to different kinds of information which is often dispersed among different documentation sources, such as API documentation or Stack Overflow. We present an approach to automatically augment API documentation with \'insight sentences\' from Stack Overflow -- sentences that are related to a particular API type and that provide insight not contained in the API documentation of that type. Based on a development set of 1,574 sentences, we compare the performance of two state-of-the-art summarization techniques as well as a pattern-based approach for insight sentence extraction. We then present SISE, a novel machine learning based approach that uses as features the sentences themselves, their formatting, their question, their answer, and their authors as well as part-of-speech tags and the similarity of a sentence to the corresponding API documentation. With SISE, we were able to achieve a precision of 0.64 and a coverage of 0.7 on the development set. In a comparative study with eight software developers, we found that SISE resulted in the highest number of sentences that were considered to add useful information not found in the API documentation. These results indicate that taking into account the meta data available on Stack Overflow as well as part-of-speech tags can significantly improve unsupervised extraction approaches when applied to Stack Overflow data.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886920','10.1145/2884781.2884800',41,36,'IEEE','IEEE Conferences',0),(594,'FAST Approaches to Scalable Similarity-Based Test Case Prioritization',1,222,232,'Many test case prioritization criteria have been proposed for speeding up fault detection. Among them, similarity-based approaches give priority to the test cases that are the most dissimilar from those already selected. However, the proposed criteria do not scale up to handle the many thousands or even some millions test suite sizes of modern industrial systems and simple heuristics are used instead. We introduce the FAST family of test case prioritization techniques that radically changes this landscape by borrowing algorithms commonly exploited in the big data domain to find similar items. FAST techniques provide scalable similarity-based test case prioritization in both white-box and black-box fashion. The results from experimentation on real world C and Java subjects show that the fastest members of the family outperform other black-box approaches in efficiency with no significant impact on effectiveness, and also outperform white-box approaches, including greedy ones, if preparation time is not counted. A simulation study of scalability shows that one FAST technique can prioritize a million test cases in less than 20 minutes.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453081','10.1145/3180155.3180210',34,3,'IEEE','IEEE Conferences',0),(595,'Understanding and Fixing Multiple Language Interoperability Issues: The C/Fortran Case',5,772,783,'We performed an empirical study to understand interoperability issues in C and Fortran programs. C/Fortran interoperability is very common and is representative of general language interoperability issues, such as how interfaces between languages are defined and how data types are shared. Fortran presents an additional challenge, since several ad hoc approaches to C/Fortran interoperability were in use long before a standard mechanism was defined. We explored 20 applications, automatically analyzing over 12 million lines of code. We found that only 3% of interoperability instances follow the ISO standard to describe interfaces; the rest follow a combination of compiler-dependent ad hoc approaches. Several parameters in cross-language functions did not have standards-compliant interoperable types, and about one-fourth of the parameters that were passed by reference could be passed by value. We propose that automated refactoring tools may provide a viable way to migrate programs to use the new interoperability features. We present two refactorings to transform code for this purpose and one refactoring to evolve code thereafter; all of these are instances of multiple language refactorings.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886955','10.1145/2884781.2884858',40,0,'IEEE','IEEE Conferences',0),(596,'Debugging Data Flows in Reactive Programs',1,752,763,'Reactive Programming is a style of programming that provides developers with a set of abstractions that facilitate event handling and stream processing. Traditional debug tools lack support for Reactive Programming, leading developers to fallback to the most rudimentary debug tool available: logging to the console. In this paper, we present the design and implementation of RxFiddle, a visualization and debugging tool targeted to Rx, the most popular form of Reactive Programming. RxFiddle visualizes the dependencies and structure of the data flow, as well as the data inside the flow. We evaluate RxFiddle with an experiment involving 111 developers. The results show that RxFiddle can help developers finish debugging tasks faster than with traditional debugging tools.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453148','10.1145/3180155.3180156',52,2,'IEEE','IEEE Conferences',0),(597,'Identifying Patch Correctness in Test-Based Program Repair',1,789,799,'Test-based automatic program repair has attracted a lot of attention in recent years However, the test suites in practice are often too weak to guarantee correctness and existing approaches often generate a large number of incorrect patches. To reduce the number of incorrect patches generated, we propose a novel approach that heuristically determines the correctness of the generated patches. The core idea is to exploit the behavior similarity of test case executions. The passing tests on original and patched programs are likely to behave similarly while the failing tests on original and patched programs are likely to behave differently. Also, if two tests exhibit similar runtime behavior, the two tests are likely to have the same test results. Based on these observations, we generate new test inputs to enhance the test suites and use their behavior similarity to determine patch correctness. Our approach is evaluated on a dataset consisting of 139 patches generated from existing program repair systems including jGenProg, Nopol, jKali, ACS, and HDRepair. Our approach successfully prevented 56.3% of the incorrect patches to be generated, without blocking any correct patches.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453152','10.1145/3180155.3180182',0,10,'IEEE','IEEE Conferences',0),(598,'Cross-Supervised Synthesis of Web-Crawlers',5,368,379,'A web-crawler is a program that automatically and systematically tracks the links of a website and extracts information from its pages. Due to the different formats of websites, the crawling scheme for different sites can differ dramatically. Manually customizing a crawler for each specific site is time consuming and error-prone. Furthermore, because sites periodically change their format and presentation, crawling schemes have to be manually updated and adjusted. In this paper, we present a technique for automatic synthesis of web-crawlers from examples. The main idea is to use hand-crafted (possibly partial) crawlers for some websites as the basis for crawling other sites that contain the same kind of information. Technically, we use the data on one site to identify data on another site. We then use the identified data to learn the website structure and synthesize an appropriate extraction scheme. We iterate this process, as synthesized extraction schemes result in additional data to be used for re-learning the website structure. We implemented our approach and automatically synthesized 30 crawlers for websites from nine different categories: books, TVs, conferences, universities, cameras, phones, movies, songs, and hotels.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886918','10.1145/2884781.2884842',41,1,'IEEE','IEEE Conferences',0),(599,'Learning API Usages from Bytecode: A Statistical Approach',5,416,427,'Mobile app developers rely heavily on standard API frameworks and libraries. However, learning API usages is often challenging due to the fast-changing nature of API frameworks for mobile systems and the insufficiency of API documentation and source code examples. In this paper, we propose a novel approach to learn API usages from bytecode of Android mobile apps. Our core contributions include HAPI, a statistical model of API usages and three algorithms to extract method call sequences from apps\' bytecode, to train HAPI based on those sequences, and to recommend method calls in code completion using the trained HAPIs. Our empirical evaluation shows that our prototype tool can effectively learn API usages from 200 thousand apps containing 350 million method sequences. It recommends next method calls with top-3 accuracy of 90% and outperforms baseline approaches on average 10-20%.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886922','10.1145/2884781.2884873',45,10,'IEEE','IEEE Conferences',0),(600,'Assessing the Threat of Untracked Changes in Software Evolution',1,1102,1113,'While refactoring is extensively performed by practitioners, many Mining Software Repositories (MSR) approaches do not detect nor keep track of refactorings when performing source code evolution analysis. In the best case, keeping track of refactorings could be unnecessary work; in the worst case, these untracked changes could significantly affect the performance of MSR approaches. Since the extent of the threat is unknown, the goal of this paper is to assess whether it is significant. Based on an extensive empirical study, we answer positively: we found that between 10 and 21% of changes at the method level in 15 large Java systems are untracked. This results in a large proportion (25%) of entities that may have their histories split by these changes, and a measurable effect on at least two MSR approaches. We conclude that handling untracked changes should be systematically considered by MSR studies.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453191','10.1145/3180155.3180212',69,1,'IEEE','IEEE Conferences',0),(601,'Mining Sandboxes',5,37,48,'We present sandbox mining, a technique to confine an application to resources accessed during automatic testing. Sandbox mining first explores software behavior by means of automatic test generation, and extracts the set of resources accessed during these tests. This set is then used as a sandbox, blocking access to resources not used during testing. The mined sandbox thus protects against behavior changes such as the activation of latent malware, infections, targeted attacks, or malicious updates. The use of test generation makes sandbox mining a fully automatic process that can be run by vendors and end users alike. Our BOXMATE prototype requires less than one hour to extract a sandbox from an Android app, with few to no confirmations required for frequently used functionality.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886890','10.1145/2884781.2884782',38,11,'IEEE','IEEE Conferences',0),(602,'Debugging for Reactive Programming',5,796,807,'Reactive programming is a recent programming technique that provides dedicated language abstractions for reactive software. Reactive programming relieves developers from manually updating outputs when the inputs of a computation change, it overcomes a number of well-know issues of the Observer design pattern, and it makes programs more comprehensible. Unfortunately, complementing the new paradigm with proper tools is a vastly unexplored area. Hence, as of now, developers can embrace reactive programming only at the cost of a more challenging development process. In this paper, we investigate a primary issue in the field: debugging programs in the reactive style. We analyze the problem of debugging reactive programs, show that the reactive style requires a paradigm shift in the concepts needed for debugging, and propose RP Debugging, a methodology for effectively debugging reactive programs. These ideas are implemented in Reactive Inspector, a debugger for reactive programs integrated with the Eclipse Scala IDE. Evaluation based on a controlled experiment shows that RP Debugging outperforms traditional debugging techniques.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886957','10.1145/2884781.2884815',49,4,'IEEE','IEEE Conferences',0),(603,'Probing for Requirements Knowledge to Stimulate Architectural Thinking',5,843,854,'Software requirements specifications (SRSs) often lack the detail needed to make informed architectural decisions. Architects therefore either make assumptions, which can lead to incorrect decisions, or conduct additional stakeholder interviews, resulting in potential project delays. We previously observed that software architects ask Probing Questions (PQs) to gather information crucial to architectural decision-making. Our goal is to equip Business Analysts with appropriate PQs so that they can ask these questions themselves. We report a new study with over 40 experienced architects to identify reusable PQs for five areas of functionality and organize them into structured flows. These PQflows can be used by Business Analysts to elicit and specify architecturally relevant information. Additionally, we leverage machine learning techniques to determine when a PQ-flow is appropriate for use in a project, and to annotate individual PQs with relevant information extracted from the existing SRS. We trained and evaluated our approach on over 8,000 individual requirements from 114 requirements specifications and also conducted a pilot study to validate its usefulness.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886961','10.1145/2884781.2884801',52,3,'IEEE','IEEE Conferences',0),(604,'Speedoo: Prioritizing Performance Optimization Opportunities',1,811,821,'Performance problems widely exist in modern software systems. Existing performance optimization techniques, including profiling-based and pattern-based techniques, usually fail to consider the architectural impacts among methods that easily slow down the overall system performance. This paper contributes a new approach, named Speedoo, to identify groups of methods that should be treated together and deserve high priorities for performance optimization. The uniqueness of Speedoo is to measure and rank the performance optimization opportunities of a method based on 1) the architectural impact and 2) the optimization potential. For each highly ranked method, we locate a respective Optimization Space based on 5 performance patterns generalized from empirical observations. The top ranked optimization spaces are suggested to developers as potential optimization opportunities. Our evaluation on three real-life projects has demonstrated that 18.52% to 42.86% of methods in the top ranked optimization spaces indeed undertook performance optimization in the projects. This outperforms one of the state-of-the-art profiling tools YourKit by 2 to 3 times. An important implication of this study is that developers should treat methods in an optimization space together as a group rather than as individuals in performance optimization. The proposed approach can provide guidelines and reduce developers\' manual effort.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453154','10.1145/3180155.3180229',60,2,'IEEE','IEEE Conferences',0),(605,'Code Anomalies Flock Together: Exploring Code Anomaly Agglomerations for Locating Design Problems',5,440,451,'Design problems affect every software system. Diverse software systems have been discontinued or reengineered due to design problems. As design documentation is often informal or nonexistent, design problems need to be located in the source code. The main difficulty to identify a design problem in the implementation stems from the fact that such problem is often scattered through several program elements. Previous work assumed that code anomalies -- popularly known as code smells -- may provide sufficient hints about the location of a design problem. However, each code anomaly alone may represent only a partial embodiment of a design problem. In this paper, we hypothesize that code anomalies tend to ``flock together\'\' to realize a design problem. We analyze to what extent groups of inter-related code anomalies, named agglomerations, suffice to locate design problems. We analyze more than 2200 agglomerations found in seven software systems of different sizes and from different domains. Our analysis indicates that certain forms of agglomerations are consistent indicators of both congenital and evolutionary design problems, with accuracy often higher than 80%.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886924','10.1145/2884781.2884868',45,9,'IEEE','IEEE Conferences',0),(606,'HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts',1,1078,1089,'Advancements in software build tools such as Maven reduce build management effort, but developers still need specialized knowledge and long time to maintain build scripts and resolve build failures. More recent build tools such as Gradle give developers greater extent of customization flexibility, but can be even more difficult to maintain. According to the TravisTorrent dataset of open-source software continuous integration, 22% of code commits include changes in build script files to maintain build scripts or to resolve build failures. Automated program repair techniques have great potential to reduce cost of resolving software failures, but the existing techniques mostly focus on repairing source code so that they cannot directly help resolving software build failures. To address this limitation, we propose HireBuild: History-Driven Repair of Build Scripts, the first approach to automatic patch generation for build scripts, using fix patterns automatically generated from existing build script fixes and recommending fix patterns based on build log similarity. From TravisTorrent dataset, we extracted 175 build failures and their corresponding fixes which revise Gradle build scripts. Among these 175 build failures, we used the 135 earlier build fixes for automatic fix-pattern generation and the more recent 40 build failures (fixes) for evaluation of our approach. Our experiment shows that our approach can fix 11 of 24 reproducible build failures, or 45% of the reproducible build failures, within comparable time of manual fixes.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453189','10.1145/3180155.3180181',51,6,'IEEE','IEEE Conferences',0),(607,'Release Planning of Mobile Apps Based on User Reviews',5,14,24,'Developers have to to constantly improve their apps by fixing critical bugs and implementing the most desired features in order to gain shares in the continuously increasing and competitive market of mobile apps. A precious source of information to plan such activities is represented by reviews left by users on the app store. However, in order to exploit such information developers need to manually analyze such reviews. This is something not doable if, as frequently happens, the app receives hundreds of reviews per day. In this paper we introduce CLAP (Crowd Listener for releAse Planning), a thorough solution to (i) categorize user reviews based on the information they carry out (e.g., bug reporting), (ii) cluster together related reviews (e.g., all reviews reporting the same bug), and (iii) automatically prioritize the clusters of reviews to be implemented when planning the subsequent app release. We evaluated all the steps behind CLAP, showing its high accuracy in categorizing and clustering reviews and the meaningfulness of the recommended prioritizations. Also, given the availability of CLAP as a working tool, we assessed its practical applicability in industrial environments.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886888','10.1145/2884781.2884818',31,41,'IEEE','IEEE Conferences',0),(608,'Goal-Conflict Likelihood Assessment Based on Model Counting',1,1125,1135,'In goal-oriented requirements engineering approaches, conflict analysis has been proposed as an abstraction for risk analysis. Intuitively, given a set of expected goals to be achieved by the system-to-be, a conflict represents a subtle situation that makes goals diverge, i.e., not be satisfiable as a whole. Conflict analysis is typically driven by the identify-assess-control cycle, aimed at identifying, assessing and resolving conflicts that may obstruct the satisfaction of the expected goals. In particular, the assessment step is concerned with evaluating how likely the identified conflicts are, and how likely and severe are their consequences. So far, existing assessment approaches restrict their analysis to obstacles (conflicts that prevent the satisfaction of a single goal), and assume that certain probabilistic information on the domain is provided, that needs to be previously elicited from experienced users, statistical data or simulations. In this paper, we present a novel automated approach to assess how likely a conflict is, that applies to general conflicts (not only obstacles) without requiring probabilistic information on the domain. Intuitively, given the LTL formulation of the domain and of a set of goals to be achieved, we compute goal conflicts, and exploit string model counting techniques to estimate the likelihood of the occurrence of the corresponding conflicting situations and the severity in which these affect the satisfaction of the goals. This information can then be used to prioritize conflicts to be resolved, and suggest which goals to drive attention to for refinements.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453193','10.1145/3180155.3180261',45,0,'IEEE','IEEE Conferences',0),(609,'Adding Sparkle to Social Coding: An Empirical Study of Repository Badges in the npm Ecosystem',1,511,522,'In fast-paced, reuse-heavy, and distributed software development, the transparency provided by social coding platforms like GitHub is essential to decision making. Developers infer the quality of projects using visible cues, known as signals, collected from personal profile and repository pages. We report on a large-scale, mixed-methods empirical study of npm packages that explores the emerging phenomenon of repository badges, with which maintainers signal underlying qualities about their projects to contributors and users. We investigate which qualities maintainers intend to signal and how well badges correlate with those qualities. After surveying developers, mining 294,941 repositories, and applying statistical modeling and time-series analyses, we find that non-trivial badges, which display the build status, test coverage, and up-to-dateness of dependencies, are mostly reliable signals, correlating with more tests, better pull requests, and fresher dependencies. Displaying such badges correlates with best practices, but the effects do not always persist.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453117','10.1145/3180155.3180209',65,2,'IEEE','IEEE Conferences',0),(610,'Performance Issues and Optimizations in JavaScript: An Empirical Study',5,61,72,'As JavaScript is becoming increasingly popular, the performance of JavaScript programs is crucial to ensure the responsiveness and energy-efficiency of thousands of pro- grams. Yet, little is known about performance issues that developers face in practice and they address these issues. This paper presents an empirical study of 98 fixed performance issues from 16 popular client-side and server-side JavaScript projects. We identify eight root causes of issues and show that inefficient usage of APIs is the most prevalent root cause. Furthermore, we find that most is- sues are addressed by optimizations that modify only a few lines of code, without significantly affecting the complexity of the source code. By studying the performance impact of optimizations on several versions of the SpiderMonkey and V8 engines, we find that only 42.68% of all optimizations improve performance consistently across all versions of both engines. Finally, we observe that many optimizations are instances of patterns applicable across projects, as evidenced by 139 previously unknown optimization opportunities that we find based on the patterns identified during the study. The results of the study help application developers to avoid common mistakes, researchers to develop performance-related techniques that address relevant problems, and engine developers to address prevalent bottleneck patterns.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886892','10.1145/2884781.2884829',44,9,'IEEE','IEEE Conferences',0),(611,'Are Mutation Scores Correlated with Real Fault Detection? A Large Scale Empirical Study on the Relationship Between Mutants and Real Faults',1,537,548,'Empirical validation of software testing studies is increasingly relying on mutants. This practice is motivated by the strong correlation between mutant scores and real fault detection that is reported in the literature. In contrast, our study shows that correlations are the results of the confounding effects of the test suite size. In particular, we investigate the relation between two independent variables, mutation score and test suite size, with one dependent variable the detection of (real) faults. We use two data sets, CoreBench and De-fects4J, with large C and Java programs and real faults and provide evidence that all correlations between mutation scores and real fault detection are weak when controlling for test suite size. We also found that both independent variables significantly influence the dependent one, with significantly better fits, but overall with relative low prediction power. By measuring the fault detection capability of the top ranked, according to mutation score, test suites (opposed to randomly selected test suites of the same size), we found that achieving higher mutation scores improves significantly the fault detection. Taken together, our data suggest that mutants provide good guidance for improving the fault detection of test suites, but their correlation with fault detection are weak.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453121','10.1145/3180155.3180183',0,4,'IEEE','IEEE Conferences',0),(612,'RETracer: Triaging Crashes by Reverse Execution from Partial Memory Dumps',5,820,831,'Many software providers operate crash reporting services to automatically collect crashes from millions of customers and file bug reports. Precisely triaging crashes is necessary and important for software providers because the millions of crashes that may be reported every day are critical in identifying high impact bugs. However, the triaging accuracy of existing systems is limited, as they rely only on the syntactic information of the stack trace at the moment of a crash without analyzing program semantics. In this paper, we present RETracer, the first system to triage software crashes based on program semantics reconstructed from memory dumps. RETracer was designed to meet the requirements of large-scale crash reporting services. RETracer performs binary-level backward taint analysis without a recorded execution trace to understand how functions on the stack contribute to the crash. The main challenge is that the machine state at an earlier time cannot be recovered completely from a memory dump, since most instructions are information destroying. We have implemented RETracer for x86 and x86-64 native code, and compared it with the existing crash triaging tool used by Microsoft. We found that RETracer eliminates two thirds of triage errors based on a manual analysis of 140 bugs fixed in Microsoft Windows and Office. RETracer has been deployed as the main crash triaging system on Microsoft\'s crash reporting service.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886959','10.1145/2884781.2884844',52,8,'IEEE','IEEE Conferences',0),(613,'Discovering \'Unknown Known\' Security Requirements',5,866,876,'Security is one of the biggest challenges facing organisations in the modern hyper-connected world. A number of theoretical security models are available that provide best practice security guidelines and are widely utilised as a basis to identify and operationalise security requirements. Such models often capture high-level security concepts (e.g., whitelisting, secure configurations, wireless access control, data recovery, etc.), strategies for operationalising such concepts through specific security controls, and relationships between the various concepts and controls. The threat landscape, however, evolves leading to new tacit knowledge that is embedded in or across a variety of security incidents. These unknown knowns alter, or at least demand reconsideration of the theoretical security models underpinning security requirements. In this paper, we present an approach to discover such unknown knowns through multi-incident analysis. The approach is based on a novel combination of grounded theory and incident fault trees. We demonstrate the effectiveness of the approach through its application to identify revisions to a theoretical security model widely used in industry.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886963','10.1145/2884781.2884785',23,2,'IEEE','IEEE Conferences',0),(614,'RFC-Directed Differential Testing of Certificate Validation in SSL/TLS Implementations',1,859,870,'Certificate validation in Secure Socket Layer or Transport Layer Security protocol (SSL/TLS) is critical to Internet security. Thus, it is significant to check whether certificate validation in SSL/TLS is correctly implemented. With this motivation, we propose a novel differential testing approach which is directed by the standard Request For Comments (RFC). First, rules of certificates are extracted automatically from RFCs. Second, low-level test cases are generated through dynamic symbolic execution. Third, high-level test cases, i.e. certificates, are assembled automatically. Finally, with the assembled certificates being test cases, certificate validations in SSL/TLS implementations are tested to reveal latent vulnerabilities or bugs. Our approach named RFCcert has the following advantages: (1) certificates of RFCcert are discrepancy-targeted since they are assembled according to standards instead of genetics; (2) with the obtained certificates, RFCcert not only reveals the invalidity of traditional differential testing but also is able to conduct testing that traditional differential testing cannot do; and (3) the supporting tool of RFCcert has been implemented and extensive experiments show that the approach is effective in finding bugs of SSL/TLS implementations.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453160','10.1145/3180155.3180226',0,1,'IEEE','IEEE Conferences',0),(615,'CUSTODES: Automatic Spreadsheet Cell Clustering and Smell Detection Using Strong and Weak Features',5,464,475,'Various techniques have been proposed to detect smells in spreadsheets, which are susceptible to errors. These techniques typically detect spreadsheet smells through a mechanism based on a fixed set of patterns or metric thresholds. Unlike conventional programs, tabulation styles vary greatly across spreadsheets. Smell detection based on fixed patterns or metric thresholds, which are insensitive to the varying tabulation styles, can miss many smells in one spreadsheet while reporting many spurious smells in another. In this paper, we propose CUSTODES to effectively cluster spreadsheet cells and detect smells in these clusters. The clustering mechanism can automatically adapt to the tabulation styles of each spreadsheet using strong and weak features. These strong and weak features capture the invariant and variant parts of tabulation styles, respectively. As smelly cells in a spreadsheet normally occur in minority, they can be mechanically detected as clusters\' outliers in feature spaces. We implemented and applied CUSTODES to 70 spreadsheets files randomly sampled from the EUSES corpus. These spreadsheets contain 1,610 formula cell clusters. Experimental results confirmed that CUSTODES is effective. It successfully detected harmful smells that can induce computation anomalies in spreadsheets with an F-measure of 0.72, outperforming state-of-the-art techniques.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886926','10.1145/2884781.2884796',49,8,'IEEE','IEEE Conferences',0),(616,'On The Limits of Mutation Reduction Strategies',5,511,522,'Although mutation analysis is considered the best way to evaluate the effectiveness of a test suite, hefty computational cost often limits its use. To address this problem, various mutation reduction strategies have been proposed, all seeking to reduce the number of mutants while maintaining the representativeness of an exhaustive mutation analysis. While research has focused on the reduction achieved, the effectiveness of these strategies in selecting representative mutants, and the limits in doing so have not been investigated, either theoretically or empirically. We investigate the practical limits to the effectiveness of mutation reduction strategies, and provide a simple theoretical framework for thinking about the absolute limits. Our results show that the limit in improvement of effectiveness over random sampling for real-world open source programs is a mean of only 13.078%. Interestingly, there is no limit to the improvement that can be made by addition of new mutation operators. Given that this is the maximum that can be achieved with perfect advance knowledge of mutation kills, what can be practically achieved may be much worse. We conclude that more effort should be focused on enhancing mutations than removing operators in the name of selective mutation for questionable benefit.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886930','',54,4,'IEEE','IEEE Conferences',0),(617,'A Static Verification Framework for Message Passing in Go Using Behavioural Types',1,1137,1148,'The Go programming language has been heavily adopted in industry as a language that efficiently combines systems programming with concurrency. Go\'s concurrency primitives, inspired by process calculi such as CCS and CSP, feature channel-based communication and lightweight threads, providing a distinct means of structuring concurrent software. Despite its popularity, the Go programming ecosystem offers little to no support for guaranteeing the correctness of message-passing concurrent programs. This work proposes a practical verification framework for message passing concurrency in Go by developing a robust static analysis that infers an abstract model of a program\'s communication behaviour in the form of a behavioural type, a powerful process calculi typing discipline. We make use of our analysis to deploy a model and termination checking based verification of the inferred behavioural type that is suitable for a range of safety and liveness properties of Go programs, providing several improvements over existing approaches. We evaluate our framework and its implementation on publicly available real-world Go code.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453195','10.1145/3180155.3180157',45,1,'IEEE','IEEE Conferences',0),(618,'Optimizing Selection of Competing Services with Probabilistic Hierarchical Refinement',5,85,95,'Recently, many large enterprises (e.g., Netflix, Amazon) have decomposed their monolithic application into services, and composed them to fulfill their business functionalities. Many hosting services on the cloud, with different Quality of Service (QoS) (e.g., availability, cost), can be used to host the services. This is an example of competing services. QoS is crucial for the satisfaction of users. It is important to choose a set of services that maximize the overall QoS, and satisfy all QoS requirements for the service composition. This problem, known as optimal service selection, is NP-hard. Therefore, an effective method for reducing the search space and guiding the search process is highly desirable. To this end, we introduce a novel technique, called Probabilistic Hierarchical Refinement (PROHR). PROHR effectively reduces the search space by removing competing services that cannot be part of the selection. PROHR provides two methods, probabilistic ranking and hierarchical refinement, that enable smart exploration of the reduced search space. Unlike existing approaches that perform poorly when QoS requirements become stricter, PROHR maintains high performance and accuracy, independent of the strictness of the QoS requirements. PROHR has been evaluated on a publicly available dataset, and has shown significant improvement over existing approaches.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886894','10.1145/2884781.2884861',38,6,'IEEE','IEEE Conferences',0),(619,'Augusto: Exploiting Popular Functionalities for the Generation of Semantic GUI Tests with Oracles',1,280,290,'Testing software applications by interacting with their graphical user interface (GUI) is an expensive and complex process. Current automatic test case generation techniques implement explorative approaches that, although producing useful test cases, have a limited capability of covering semantically relevant interactions, thus frequently missing important testing scenarios. These techniques typically interact with the available widgets following the structure of the GUI, without any guess about the functions that are executed. In this paper we propose Augusto, a test case generation technique that exploits a built-in knowledge of the semantics associated with popular and well-known functionalities, such as CRUD operations, to automatically generate effective test cases with automated functional oracles. Empirical results indicate that Augusto can reveal faults that cannot be revealed with state of the art techniques.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453087','10.1145/3180155.3180162',0,2,'IEEE','IEEE Conferences',0),(620,'Spatio-Temporal Context Reduction: A Pointer-Analysis-Based Static Approach for Detecting Use-After-Free Vulnerabilities',1,327,337,'Zero-day Use-After-Free (UAF) vulnerabilities are increasingly popular and highly dangerous, but few mitigations exist. We introduce a new pointer-analysis-based static analysis, CRed, for finding UAF bugs in multi-MLOC C source code efficiently and effectively. Cred achieves this by making three advances: (i) a spatio-temporal context reduction technique for scaling down soundly and precisely the exponential number of contexts that would otherwise be considered at a pair of free and use sites, (ii) a multi-stage analysis for filtering out false alarms efficiently, and (iii) a path-sensitive demand-driven approach for finding the points-to information required. We have implemented CRed in LLVM-3.8.0 and compared it with four different state-of-the-art static tools: CBMC (model checking), Clang (abstract interpretation), Coccinelle (pattern matching), and Supa (pointer analysis) using all the C test cases in Juliet Test Suite (JTS) and 10 open-source C applications. For the ground-truth validated with JTS, CRed detects all the 138 known UAF bugs as CBMC and Supa do while Clang and Coccinelle miss some bugs, with no false alarms from any tool. For practicality validated with the 10 applications (totaling 3+ MLOC), CRed reports 132 warnings including 85 bugs in 7.6 hours while the existing tools are either unscalable by terminating within 3 days only for one application (CBMC) or impractical by finding virtually no bugs (Clang and Coccinelle) or issuing an excessive number of false alarms (Supa).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453091','10.1145/3180155.3180178',0,3,'IEEE','IEEE Conferences',0),(621,'Efficient Large-Scale Trace Checking Using MapReduce',5,888,898,'The problem of checking a logged event trace against a temporal logic specification arises in many practical cases. Unfortunately, known algorithms for an expressive logic like MTL (Metric Temporal Logic) do not scale with respect to two crucial dimensions: the length of the trace and the size of the time interval of the formula to be checked. The former issue can be addressed by distributed and parallel trace checking algorithms that can take advantage of modern cloud computing and programming frameworks like MapReduce. Still, the latter issue remains open with current state-of-the-art approaches. In this paper we address this memory scalability issue by proposing a new semantics for MTL, called lazy semantics. This semantics can evaluate temporal formulae and boolean combinations of temporal-only formulae at any arbitrary time instant. We prove that lazy semantics is more expressive than point-based semantics and that it can be used as a basis for a correct parametric decomposition of any MTL formula into an equivalent one with smaller, bounded time intervals. We use lazy semantics to extend our previous distributed trace checking algorithm for MTL. The evaluation shows that the proposed algorithm can check formulae with large intervals, on large traces, in a memory-efficient way.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886965','10.1145/2884781.2884832',29,1,'IEEE','IEEE Conferences',0),(622,'A Temporal Permission Analysis and Enforcement Framework for Android',1,846,857,'Permission-induced attacks, i.e., security breaches enabled by permission misuse, are among the most critical and frequent issues threatening the security of Android devices. By ignoring the temporal aspects of an attack during the analysis and enforcement, the state-of-the-art approaches aimed at protecting the users against such attacks are prone to have low-coverage in detection and high-disruption in prevention of permission-induced attacks. To address the aforementioned shortcomings, we present TERMINATOR, a temporal permission analysis and enforcement framework for Android. Leveraging temporal logic model checking, TERMINATOR\'s analyzer identifies permission-induced threats with respect to dynamic permission states of the apps. At runtime, TERMINATOR\'s enforcer selectively leases (i.e., temporarily grants) permissions to apps when the system is in a safe state, and revokes the permissions when the system moves to an unsafe state realizing the identified threats. The results of our experiments, conducted over thousands of apps, indicate that TERMINATOR is able to provide an effective, yet non-disruptive defense against permission-induced attacks. We also show that our approach, which does not require modification to the Android framework or apps\' implementation logic, is highly reliable and widely applicable.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453158','10.1145/3180155.3180172',0,1,'IEEE','IEEE Conferences',0),(623,'Identifying and Quantifying Architectural Debt',5,488,498,'Our prior work showed that the majority of error-prone source files in a software system are architecturally connected. Flawed architectural relations propagate defectsamong these files and accumulate high maintenance costs over time, just like debts accumulate interest. We model groups of architecturally connected files that accumulate high maintenance costs as architectural debts. To quantify such debts, we formally define architectural debt, and show how to automatically identify debts, quantify their maintenance costs, and model these costs over time. We describe a novel history coupling probability matrix for this purpose, and identify architecture debts using 4 patterns of architectural flaws shown to correlate with reduced software quality. We evaluate our approach on 7 large-scale open source projects, and show that a significant portion of total project maintenance effort is consumed by paying interest on architectural debts. The top 5 architectural debts, covering a small portion (8% to 25%) of each project\'s error-prone files, capture a significant portion (20% to 61%) of each project\'s maintenance effort. Finally, we show that our approach reveals how architectural issues evolve into debts over time.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886928','10.1145/2884781.2884822',28,17,'IEEE','IEEE Conferences',0),(624,'How Does Regression Test Prioritization Perform in Real-World Software Evolution?',5,535,546,'In recent years, researchers have intensively investigated various topics in test prioritization, which aims to re-order tests to increase the rate of fault detection during regression testing. While the main research focus in test prioritization is on proposing novel prioritization techniques and evaluating on more and larger subject systems, little effort has been put on investigating the threats to validity in existing work on test prioritization. One main threat to validity is that existing work mainly evaluates prioritization techniques based on simple artificial changes on the source code and tests. For example, the changes in the source code usually include only seeded program faults, whereas the test suite is usually not augmented at all. On the contrary, in real-world software development, software systems usually undergo various changes on the source code and test suite augmentation. Therefore, it is not clear whether the conclusions drawn by existing work in test prioritization from the artificial changes are still valid for real-world software evolution. In this paper, we present the first empirical study to investigate this important threat to validity in test prioritization. We reimplemented 24 variant techniques of both the traditional and time-aware test prioritization, and investigated the impacts of software evolution on those techniques based on the version history of 8 real-world Java programs from GitHub. The results show that for both traditional and time-aware test prioritization, test suite augmentation significantly hampers their effectiveness, whereas source code changes alone do not influence their effectiveness much.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886932','10.1145/2884781.2884874',67,9,'IEEE','IEEE Conferences',0),(625,'DroidStar: Callback Typestates for Android Classes',1,1160,1170,'Event-driven programming frameworks, such as Android, are based on components with asynchronous interfaces. The protocols for interacting with these components can often be described by finite-state machines we dub *callback typestates. Callback typestates are akin to classical typestates, with the difference that their outputs (callbacks) are produced asynchronously. While useful, these specifications are not commonly available, because writing them is difficult and error-prone. Our goal is to make the task of producing callback typestates significantly easier. We present a callback typestate assistant tool, DroidStar, that requires only limited user interaction to produce a callback typestate. Our approach is based on an active learning algorithm, L*. We improved the scalability of equivalence queries (a key component of L*), thus making active learning tractable on the Android system. We use DroidStar to learn callback typestates for Android classes both for cases where one is already provided by the documentation, and for cases where the documentation is unclear. The results show that DroidStar learns callback typestates accurately and efficiently. Moreover, in several cases, the synthesized callback typestates uncovered surprising and undocumented behaviors.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453197','10.1145/3180155.3180232',41,0,'IEEE','IEEE Conferences',0),(626,'Belief & Evidence in Empirical Software Engineering',5,108,119,'Empirical software engineering has produced a steady stream of evidence-based results concerning the factors that affect important outcomes such as cost, quality, and interval. However, programmers often also have strongly-held a priori opinions about these issues. These opinions are important, since developers are highlytrained professionals whose beliefs would doubtless affect their practice. As in evidence-based medicine, disseminating empirical findings to developers is a key step in ensuring that the findings impact practice. In this paper, we describe a case study, on the prior beliefs of developers at Microsoft, and the relationship of these beliefs to actual empirical data on the projects in which these developers work. Our findings are that a) programmers do indeed have very strong beliefs on certain topics b) their beliefs are primarily formed based on personal experience, rather than on findings in empirical research and c) beliefs can vary with each project, but do not necessarily correspond with actual evidence in that project. Our findings suggest that more effort should be taken to disseminate empirical findings to developers and that more in-depth study the interplay of belief and evidence in software practice is needed.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886896','10.1145/2884781.2884812',59,20,'IEEE','IEEE Conferences',0),(627,'DeepTest: Automated Testing of Deep-Neural-Network-Driven Autonomous Cars',1,303,314,'Recent advances in Deep Neural Networks (DNNs) have led to the development of DNN-driven autonomous cars that, using sensors like camera, LiDAR, etc., can drive without any human intervention. Most major manufacturers including Tesla, GM, Ford, BMW, and Waymo/Google are working on building and testing different types of autonomous vehicles. The lawmakers of several US states including California, Texas, and New York have passed new legislation to fast-track the process of testing and deployment of autonomous vehicles on their roads. However, despite their spectacular progress, DNNs, just like traditional software, often demonstrate incorrect or unexpected corner-case behaviors that can lead to potentially fatal collisions. Several such real-world accidents involving autonomous cars have already happened including one which resulted in a fatality. Most existing testing techniques for DNN-driven vehicles are heavily dependent on the manual collection of test data under different driving conditions which become prohibitively expensive as the number of test conditions increases. In this paper, we design, implement, and evaluate DeepTest, a systematic testing tool for automatically detecting erroneous behaviors of DNN-driven vehicles that can potentially lead to fatal crashes. First, our tool is designed to automatically generated test cases leveraging real-world changes in driving conditions like rain, fog, lighting conditions, etc. DeepTest systematically explore different parts of the DNN logic by generating test inputs that maximize the numbers of activated neurons. DeepTest found thousands of erroneous behaviors under different realistic driving conditions (e.g., blurring, rain, fog, etc.) many of which lead to potentially fatal crashes in three top performing DNNs in the Udacity self-driving car challenge.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453089','10.1145/3180155.3180220',87,48,'IEEE','IEEE Conferences',0),(628,'Chopped Symbolic Execution',1,350,360,'Symbolic execution is a powerful program analysis technique that systematically explores multiple program paths. However, despite important technical advances, symbolic execution often struggles to reach deep parts of the code due to the well-known path explosion problem and constraint solving limitations. In this paper, we propose chopped symbolic execution, a novel form of symbolic execution that allows users to specify uninter-esting parts of the code to exclude during the analysis, thus only targeting the exploration to paths of importance. However, the excluded parts are not summarily ignored, as this may lead to both false positives and false negatives. Instead, they are executed lazily, when their effect may be observable by code under anal-ysis. Chopped symbolic execution leverages various on-demand static analyses at runtime to automatically exclude code fragments while resolving their side effects, thus avoiding expensive manual annotations and imprecision. Our preliminary results show that the approach can effectively improve the effectiveness of symbolic execution in several different scenarios, including failure reproduction and test suite augmentation.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453093','10.1145/3180155.3180251',45,1,'IEEE','IEEE Conferences',0),(629,'DoubleTake: Fast and Precise Error Detection via Evidence-Based Dynamic Analysis',5,911,922,'Programs written in unsafe languages like C and C++ often suffer from errors like buffer overflows, dangling pointers, and memory leaks. Dynamic analysis tools like Valgrind can detect these errors, but their overhead - primarily due to the cost of instrumenting every memory read and write - makes them too heavyweight for use in deployed applications and makes testing with them painfully slow. The result is that much deployed software remains susceptible to these bugs, which are notoriously difficult to track down.This paper presents evidence-based dynamic analysis, an approach that enables these analyses while imposing minimal overhead (under 5%), making it practical for the first time to perform these analyses in deployed settings. The key insight of evidence-based dynamic analysis is that for a class of errors, it is possible to ensure that evidence that they happened at some point in the past remains for later detection. Evidence-based dynamic analysis allows execution to proceed at nearly full speed until the end of an epoch (e.g., a heavyweight system call). It then examines program state to check for evidence that an error occurred at some time during that epoch. If so, it rolls back execution and re-executes the code with instrumentation activated to pinpoint the error.We present DoubleTake, a prototype evidence-based dynamic analysis framework. DoubleTake is practical and easy to deploy, requiring neither custom hardware, compiler, nor operating system support. We demonstrate DoubleTake\'s generality and efficiency by building dynamic analyses that find buffer overflows, memory use-after-free errors, and memory leaks. Our evaluation shows that DoubleTake is efficient, imposing under 5% overhead on average, making it the fastest such system to date. It is also precise: DoubleTake pinpoints the location of these errors to the exact line and memory addresses where they occur, providing valuable debugging information to programmers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886967','10.1145/2884781.2884784',43,8,'IEEE','IEEE Conferences',0),(630,'Reference Hijacking: Patching, Protecting and Analyzing on Unmodified and Non-rooted Android Devices',5,959,970,'Many efforts have been paid to enhance the security of Android. However, less attention has been given to how to practically adopt the enhancements on off-the-shelf devices. In particular, securing Android devices often requires modifying their write-protected underlying system component files (especially the system libraries) by flashing or rooting devices, which is unacceptable in many realistic cases. In this paper, a novel technique, called reference hijacking, is presented to address the problem. By introducing a specially designed reset procedure, a new execution environment is constructed for the target application, in which the reference to the underlying system libraries will be redirected to the security-enhanced alternatives. The technique can be applicable to both the Dalvik and Android Runtime (ART) environments and to almost all mainstream Android versions (2.x to 5.x). To demonstrate the capability of reference hijacking, we develop three prototype systems, PatchMan, ControlMan, and TaintMan, to enforce specific security enhancements, involving patching vulnerabilities, protecting inter-component communications, and performing dynamic taint analysis for the target application. These three prototypes have been successfully deployed on a number of popular Android devices from different manufacturers, without modifying the underlying system. The evaluation results show that they are effective and do not introduce noticeable overhead. They strongly support that reference hijacking can substantially improve the practicability of many security enhancement efforts for Android.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886971','10.1145/2884781.2884863',55,4,'IEEE','IEEE Conferences',0),(631,'GUILeak: Tracing Privacy Policy Claims on User Input Data for Android Applications',1,37,47,'The Android mobile platform supports billions of devices across more than 190 countries around the world. This popularity coupled with user data collection by Android apps has made privacy protection a well-known challenge in the Android ecosystem. In practice, app producers provide privacy policies disclosing what information is collected and processed by the app. However, it is difficult to trace such claims to the corresponding app code to verify whether the implementation is consistent with the policy. Existing approaches for privacy policy alignment focus on information directly accessed through the Android platform (e.g., location and device ID), but are unable to handle user input, a major source of private information. In this paper, we propose a novel approach that automatically detects privacy leaks of user-entered data for a given Android app and determines whether such leakage may violate the app\'s privacy policy claims. For evaluation, we applied our approach to 120 popular apps from three privacy-relevant app categories: finance, health, and dating. The results show that our approach was able to detect 21 strong violations and 18 weak violations from the studied apps.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453060','10.1145/3180155.3180196',0,2,'IEEE','IEEE Conferences',0),(632,'Reducing Combinatorics in GUI Testing of Android Applications',5,559,570,'The rising popularity of Android and the GUI-driven nature of its apps have motivated the need for applicable automated GUI testing techniques. Although exhaustive testing of all possible combinations is the ideal upper bound in combinatorial testing, it is often infeasible, due to the combinatorial explosion of test cases. This paper presents TrimDroid, a framework for GUI testing of Android apps that uses a novel strategy to generate tests in a combinatorial, yet scalable, fashion. It is backed with automated program analysis and formally rigorous test generation engines. TrimDroid relies on program analysis to extract formal specifications. These specifications express the app\'s behavior (i.e., control flow between the various app screens) as well as the GUI elements and their dependencies. The dependencies among the GUI elements comprising the app are used to reduce the number of combinations with the help of a solver. Our experiments have corroborated TrimDroid\'s ability to achieve a comparable coverage as that possible under exhaustive GUI testing using significantly fewer test cases.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886934','10.1145/2884781.2884853',39,20,'IEEE','IEEE Conferences',0),(633,'On the Techniques We Create, the Tools We Build, and Their Misalignments: A Study of KLEE',5,132,143,'Our community constantly pushes the state-of-the-art by introducing 鈥渘ew鈥� techniques. These techniques often build on top of, and are compared against, existing systems that realize previously published techniques. The underlying assumption is that existing systems correctly represent the techniques they implement. This pa- per examines that assumption through a study of KLEE, a popular and well-cited tool in our community. We briefly describe six improvements we made to KLEE, none of which can be considered 鈥渘ew鈥� techniques, that provide order-of-magnitude performance gains. Given these improvements, we then investigate how the results and conclusions of a sample of papers that cite KLEE are affected. Our findings indicate that the strong emphasis on introducing 鈥渘ew鈥� techniques may lead to wasted effort, missed opportunities for progress, an accretion of artifact complexity, and questionable research conclusions (in our study, 27% of the papers that depend on KLEE can be questioned). We conclude by revisiting initiatives that may help to realign the incentives to better support the foundations on which we build.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886898','10.1145/2884781.2884835',86,2,'IEEE','IEEE Conferences',0),(634,'Collective Program Analysis',1,620,631,'Popularity of data-driven software engineering has led to an increasing demand on the infrastructures to support efficient execution of tasks that require deeper source code analysis. While task optimization and parallelization are the adopted solutions, other research directions are less explored. We present collective program analysis (CPA), a technique for scaling large scale source code analyses, especially those that make use of control and data flow analysis, by leveraging analysis specific similarity. Analysis specific similarity is about, whether two or more programs can be considered similar for a given analysis. The key idea of collective program analysis is to cluster programs based on analysis specific similarity, such that running the analysis on one candidate in each cluster is sufficient to produce the result for others. For determining analysis specific similarity and clustering analysis-equivalent programs, we use a sparse representation and a canonical labeling scheme. Our evaluation shows that for a variety of source code analyses on a large dataset of programs, substantial reduction in the analysis time can be achieved; on average a 69% reduction when compared to a baseline and on average a 36% reduction when compared to a prior technique. We also found that a large amount of analysis-equivalent programs exists in large datasets.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453131','10.1145/3180155.3180252',0,0,'IEEE','IEEE Conferences',0),(635,'\'Jumping Through Hoops\': Why do Java Developers Struggle with Cryptography APIs?',5,935,946,'To protect sensitive data processed by current applications, developers, whether security experts or not, have to rely on cryptography. While cryptography algorithms have become increasingly advanced, many data breaches occur because developers do not correctly use the corresponding APIs. To guide future research into practical solutions to this problem, we perform an empirical investigation into the obstacles developers face while using the Java cryptography APIs, the tasks they use the APIs for, and the kind of (tool) support they desire. We triangulate data from four separate studies that include the analysis of 100 StackOverflow posts, 100 GitHub repositories, and survey input from 48 developers. We find that while developers find it difficult to use certain cryptographic algorithms correctly, they feel surprisingly confident in selecting the right cryptography concepts (e.g., encryption vs. signatures). We also find that the APIs are generally perceived to be too low-level and that developers prefer more task-based solutions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886969','10.1145/2884781.2884790',37,34,'IEEE','IEEE Conferences',0),(636,'The Challenges of Staying Together While Moving Fast: An Exploratory Study',5,982,993,'We report on the results of an empirical study conducted with 35 experienced software developers from 22 high-tech companies, including Google, Facebook, Microsoft, Intel, and others. The goal of the study was to elicit challenges that these developers face, potential solutions that they envision to these challenges, and research initiatives that they think would deliver useful results. Challenges identified by the majority of the study participants relate to the collaborative nature of the work: the availability and discoverability of information, communication, collaborative planning and integration with work of others. Almost all participants also addressed the advantages and disadvantages of the current 鈥渇ast to the market鈥� trend, and the toll it takes on the quality of the software that they are able to deliver and on their professional and personal satisfaction as software engineers. We describe in depth the identified challenges, supporting our findings with explicit quotes from the study participants. We also put these findings in context of work done by the software engineering community and outline a roadmap for possible future research initiatives.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886973','10.1145/2884781.2884871',56,9,'IEEE','IEEE Conferences',0),(637,'Synthesizing Qualitative Research in Software Engineering: A Critical Review',1,1207,1218,'Synthesizing data extracted from primary studies is an integral component of the methodologies in support of Evidence Based Software Engineering (EBSE) such as System Literature Review (SLR). Since a large and increasing number of studies in Software Engineering (SE) incorporate qualitative data, it is important to systematically review and understand different aspects of the Qualitative Research Synthesis (QRS) being used in SE. We have reviewed the use of QRS methods in 328 SLRs published between 2005 and 2015. We also inquired the authors of 274 SLRs to confrm whether or not any QRS methods were used in their respective reviews. 116 of them provided the responses, which were included in our analysis. We found eight QRS methods applied in SE research, two of which, narrative synthesis and thematic synthesis, have been predominantly adopted by SE researchers for synthesizing qualitative data. Our study determines that a signifcant amount of missing knowledge and incomplete understanding of the defned QRS methods in the community. Our effort also identifes an initial set factors that may in?uence the selection and use of appropriate QRS methods in SE.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453202','10.1145/3180155.3180235',67,0,'IEEE','IEEE Conferences',0),(638,'Type-Aware Concolic Testing of JavaScript Programs',5,168,179,'Conventional concolic testing has been used to provide high coverage of paths in statically typed languages. While it has also been applied in the context of JavaScript (JS) programs, we observe that applying concolic testing to dynamically-typed JS programs involves tackling unique problems to ensure scalability. In particular, a naive type-agnostic extension of concolic testing to JS programs causes generation of large number of inputs. Consequently, many executions operate on undefined values and repeatedly explore same paths resulting in redundant tests, thus diminishing the scalability of testing drastically. In this paper, we address this problem by proposing a simple yet effective approach that incorporates type-awareness intelligently in conventional concolic testing to reduce the number of generated inputs for JS programs. We extend our approach inter-procedurally by generating preconditions for each function that provide a summary of the relation between the variable types and paths. Employing the function preconditions when testing reduces the number of inputs generated even further. We implement our ideas and validate it on a number of open-source JS programs (and libraries). For a significant percentage (on average 50%) of the functions, we observe that type-aware concolic testing generates a minuscule percentage (less than 5%) of the inputs as compared to conventional concolic testing approach implemented on top of Jalangi. On average, this approach achieves over 97% of line coverage and over 94% of branch coverage for all the functions across all benchmarks. Moreover, the use of function preconditions reduces the number of inputs generated by 50%. We also demonstrate the use of function preconditions in automatically avoiding real crashes due to incorrectly typed objects.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886901','10.1145/2884781.2884859',40,2,'IEEE','IEEE Conferences',0),(639,'Are Code Examples on an Online Q&A Forum Reliable?: A Study of API Misuse on Stack Overflow',1,886,896,'Programmers often consult an online Q&A forum such as Stack Overflow to learn new APIs. This paper presents an empirical study on the prevalence and severity of API misuse on Stack Overflow. To reduce manual assessment effort, we design ExampleCheck, an API usage mining framework that extracts patterns from over 380K Java repositories on GitHub and subsequently reports potential API usage violations in Stack Overflow posts. We analyze 217,818 Stack Overflow posts using ExampleCheck and find that 31% may have potential API usage violations that could produce unexpected behavior such as program crashes and resource leaks. Such API misuse is caused by three main reasons-missing control constructs, missing or incorrect order of API calls, and incorrect guard conditions. Even the posts that are accepted as correct answers or upvoted by other programmers are not necessarily more reliable than other posts in terms of API misuse. This study result calls for a new approach to augment Stack Overflow with alternative API usage details that are not typically shown in curated examples.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453166','10.1145/3180155.3180260',0,9,'IEEE','IEEE Conferences',0),(640,'VDTest: An Automated Framework to Support Testing for Virtual Devices',5,583,594,'The use of virtual devices in place of physical hardware is increasing in activities such as design, testing and debugging. Yet virtual devices are simply software applications, and like all software they are prone to faults. A full system simulator (FSS), is a class of virtual machine that includes a large set of virtual devices - enough to run the full target software stack. Defects in an FSS virtual device may have cascading effects as the incorrect behavior can be propagated forward to many different platforms as well as to guest programs. In this work we present VDTest, a novel framework for testing virtual devices within an FSS. VDTest begins by generat- ing a test specification obtained through static analysis. It then employs a two-phase testing approach to test virtual components both individually and in combination. It lever- ages a differential oracle strategy, taking advantage of the existence of a physical or golden device to eliminate the need for manually generating test oracles. In an empirical study using both open source and commercial FSSs, we found 64 faults, 83% more than random testing.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886936','10.1145/2884781.2884866',37,0,'IEEE','IEEE Conferences',0),(641,'A Practical Guide to Select Quality Indicators for Assessing Pareto-Based Search Algorithms in Search-Based Software Engineering',5,631,642,'Many software engineering problems are multi-objective in nature, which has been largely recognized by the Search-based Software Engineering (SBSE) community. In this regard, Pareto- based search algorithms, e.g., Non-dominated Sorting Genetic Algorithm II, have already shown good performance for solving multi-objective optimization problems. These algorithms produce Pareto fronts, where each Pareto front consists of a set of non- dominated solutions. Eventually, a user selects one or more of the solutions from a Pareto front for their specific problems. A key challenge of applying Pareto-based search algorithms is to select appropriate quality indicators, e.g., hypervolume, to assess the quality of Pareto fronts. Based on the results of an extended literature review, we found that the current literature and practice in SBSE lacks a practical guide for selecting quality indicators despite a large number of published SBSE works. In this direction, the paper presents a practical guide for the SBSE community to select quality indicators for assessing Pareto-based search algorithms in different software engineering contexts. The practical guide is derived from the following complementary theoretical and empirical methods: 1) key theoretical foundations of quality indicators; 2) evidence from an extended literature review; and 3) evidence collected from an extensive experiment that was conducted to evaluate eight quality indicators from four different categories with six Pareto-based search algorithms using three real industrial problems from two diverse domains.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886940','10.1145/2884781.2884880',65,16,'IEEE','IEEE Conferences',0),(642,'Launch-Mode-Aware Context-Sensitive Activity Transition Analysis',1,598,608,'Existing static analyses model activity transitions in Android apps context-insensitively, making it impossible to distinguish different activity launch modes, reducing the pointer analysis precision for an activity\'s callbacks, and potentially resulting in infeasible activity transition paths. In this paper, we introduce Chime, a launch-mode-aware context-sensitive activity transition analysis that models different instances of an activity class according to its launch mode and the transitions between activities context-sensitively, by working together with an object-sensitive pointer analysis. Our evaluation shows that our context-sensitive activity transition analysis is more precise than its context-insensitive counterpart in capturing activity transitions, facilitating GUI testing, and improving the pointer analysis precision.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453129','10.1145/3180155.3180188',34,2,'IEEE','IEEE Conferences',0),(643,'Exploring Language Support for Immutability',5,736,747,'Programming languages can restrict state change by preventing it entirely (immutability) or by restricting which clients may modify state (read-only restrictions). The benefits of immutability and read-only restrictions in software structures have been long-argued by practicing software engineers, researchers, and programming language designers. However, there are many proposals for language mechanisms for restricting state change, with a remarkable diversity of techniques and goals, and there is little empirical data regarding what practicing software engineers want in their tools and what would benefit them. We systematized the large collection of techniques used by programming languages to help programmers prevent undesired changes in state. We interviewed expert software engineers to discover their expectations and requirements, and found that important requirements, such as expressing immutability constraints, were not reflected in features available in the languages participants used. The interview results informed our design of a new language extension for specifying immutability in Java. Through an iterative, participatory design process, we created a tool that reflects requirements from both our interviews and the research literature.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886832','10.1145/2884781.2884798',45,7,'IEEE','IEEE Conferences',0),(644,'Quantifying and Mitigating Turnover-Induced Knowledge Loss: Case Studies of Chrome and a Project at Avaya',5,1006,1016,'The utility of source code, as of other knowledge artifacts, is predicated on the existence of individuals skilled enough to derive value by using or improving it. Developers leaving a software project deprive the project of the knowledge of the decisions they have made. Previous research shows that the survivors and newcomers maintaining abandoned code have reduced productivity and are more likely to make mistakes. We focus on quantifying the extent of abandoned source files and adapt methods from financial risk analysis to assess the susceptibility of the project to developer turnover. In particular, we measure the historical loss distribution and find (1) that projects are susceptible to losses that are more than three times larger than the expected loss. Using historical simulations we find (2) that projects are susceptible to large losses that are over five times larger than the expected loss. We use Monte Carlo simulations of disaster loss scenarios and find (3) that simplistic estimates of the `truck factor\' exaggerate the potential for loss. To mitigate loss from developer turnover, we modify Cataldo et al\'s coordination requirements matrices. We find (4) that we can recommend the correct successor 34% to 48% of the time. We also find that having successors reduces the expected loss by as much as 15%. Our approach helps large projects assess the risk of turnover thereby making risk more transparent and manageable.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886975','10.1145/2884781.2884851',31,7,'IEEE','IEEE Conferences',0),(645,'Termination-Checking for LLVM Peephole Optimizations',5,191,202,'Mainstream compilers contain a large number of peephole optimizations, which perform algebraic simplification of the input program with local rewriting of the code. These optimizations are a persistent source of bugs. Our recent research on Alive, a domain-specific language for expressing peephole optimizations in LLVM, addresses a part of the problem by automatically verifying the correctness of these optimizations and generating C++ code for use with LLVM. This paper identifies a class of non-termination bugs that arise when a suite of peephole optimizations is executed until a fixed point. An optimization can undo the effect of another optimization in the suite, which results in non-terminating compilation. This paper (1) proposes a methodology to detect non-termination bugs with a suite of peephole optimizations, (2) identifies the necessary condition to ensure termination while composing peephole optimizations, and (3) provides debugging support by generating concrete input programs that cause non-terminating compilation. We have discovered 184 optimization sequences, involving 38 optimizations, that cause non-terminating compilation in LLVM with Alive-generated C++ code.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886903','10.1145/2884781.2884809',40,0,'IEEE','IEEE Conferences',0),(646,'Propagating Configuration Decisions with Modal Implication Graphs',1,898,909,'Highly-configurable systems encompass thousands of interdependent configuration options, which require a non-trivial configuration process. Decision propagation enables a backtracking-free configuration process by computing values implied by user decisions. However, employing decision propagation for large-scale systems is a time-consuming task and, thus, can be a bottleneck in interactive configuration processes and analyses alike. We propose modal implication graphs to improve the performance of decision propagation by precomputing intermediate values used in the process. Our evaluation results show a significant improvement over state-of-the-art algorithms for 120 real-world systems.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453168','10.1145/3180155.3180159',0,2,'IEEE','IEEE Conferences',0),(647,'Deep Code Search',1,933,944,'To implement a program functionality, developers can reuse previously written code snippets by searching through a large-scale codebase. Over the years, many code search tools have been proposed to help developers. The existing approaches often treat source code as textual documents and utilize information retrieval models to retrieve relevant code snippets that match a given query. These approaches mainly rely on the textual similarity between source code and natural language query. They lack a deep understanding of the semantics of queries and source code. In this paper, we propose a novel deep neural network named CODEnn (Code-Description Embedding Neural Network). Instead of matching text similarity, CODEnn jointly embeds code snippets and natural language descriptions into a high-dimensional vector space, in such a way that code snippet and its corresponding description have similar vectors. Using the unified vector representation, code snippets related to a natural language query can be retrieved according to their vectors. Semantically related words can also be recognized and irrelevant/noisy keywords in queries can be handled. As a proof-of-concept application, we implement a code search tool named DeepCS using the proposed CODEnn model. We empirically evaluate DeepCS on a large scale codebase collected from GitHub. The experimental results show that our approach can effectively retrieve relevant code snippets and outperforms previous techniques.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453172','10.1145/3180155.3180167',0,21,'IEEE','IEEE Conferences',0),(648,'Automated Localization for Unreproducible Builds',1,71,81,'Reproducibility is the ability of recreating identical binaries under pre-defined build environments. Due to the need of quality assurance and the benefit of better detecting attacks against build environments, the practice of reproducible builds has gained popularity in many open-source software repositories such as Debian and Bitcoin. However, identifying the unreproducible issues remains a labour intensive and time consuming challenge, because of the lacking of information to guide the search and the diversity of the causes that may lead to the unreproducible binaries. In this paper we propose an automated framework called RepLoc to localize the problematic files for unreproducible builds. RepLoc features a query augmentation component that utilizes the information extracted from the build logs, and a heuristic rule-based filtering component that narrows the search scope. By integrating the two components with a weighted file ranking module, RepLoc is able to automatically produce a ranked list of files that are helpful in locating the problematic files for the unreproducible builds. We have implemented a prototype and conducted extensive experiments over 671 real-world unreproducible Debian packages in four different categories. By considering the topmost ranked file only, RepLoc achieves an accuracy rate of 47.09%. If we expand our examination to the top ten ranked files in the list produced by RepLoc, the accuracy rate becomes 79.28%. Considering that there are hundreds of source code, scripts, Makefiles, etc., in a package, RepLoc significantly reduces the scope of localizing problematic files. Moreover, with the help of RepLoc, we successfully identified and fixed six new unreproducible packages from Debian and Guix.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453064','10.1145/3180155.3180224',0,2,'IEEE','IEEE Conferences',0),(649,'Missing Data Imputation Based on Low-Rank Recovery and Semi-Supervised Regression for Software Effort Estimation',5,607,618,'Software effort estimation (SEE) is a crucial step in software development. Effort data missing usually occurs in real-world data collection. Focusing on the missing data problem, existing SEE methods employ the deletion, ignoring, or imputation strategy to address the problem, where the imputation strategy was found to be more helpful for improving the estimation performance. Current imputation methods in SEE use classical imputation techniques for missing data imputation, yet these imputation techniques have their respective disadvantages and might not be appropriate for effort data. In this paper, we aim to provide an effective solution for the effort data missing problem. Incompletion includes the drive factor missing case and effort label missing case. We introduce the low-rank recovery technique for addressing the drive factor missing case. And we employ the semi-supervised regression technique to perform imputation in the case of effort label missing. We then propose a novel effort data imputation approach, named low-rank recovery and semi-supervised regression imputation (LRSRI). Experiments on 7 widely used software effort datasets indicate that: (1) the proposed approach can obtain better effort data imputation effects than other methods; (2) the imputed data using our approach can apply to multiple estimators well.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886938','10.1145/2884781.2884827',62,3,'IEEE','IEEE Conferences',0),(650,'Featured Model-Based Mutation Analysis',5,655,666,'Model-based mutation analysis is a powerful but expensive testing technique. We tackle its high computation cost by proposing an optimization technique that drastically speeds up the mutant execution process. Central to this approach is the Featured Mutant Model, a modelling framework for mutation analysis inspired by the software product line paradigm. It uses behavioural variability models, viz., Featured Transition Systems, which enable the optimized generation, configuration and execution of mutants. We provide results, based on models with thousands of transitions, suggesting that our technique is fast and scalable. We found that it outperforms previous approaches by several orders of magnitude and that it makes higher-order mutation practically applicable.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886942','10.1145/2884781.2884821',63,9,'IEEE','IEEE Conferences',0),(651,'Code Review Quality: How Developers See It',5,1028,1038,'In a large, long-lived project, an effective code review process is key to ensuring the long-term quality of the code base. In this work, we study code review practices of a large, open source project, and we investigate how the developers themselves perceive code review quality. We present a qualitative study that summarizes the results from a survey of 88 Mozilla core developers. The results provide developer insights into how they define review quality, what factors contribute to how they evaluate submitted code, and what challenges they face when performing review tasks. We found that the review quality is primarily associated with the thoroughness of the feedback, the reviewer\'s familiarity with the code, and the perceived quality of the code itself. Also, we found that while different factors are perceived to contribute to the review quality, reviewers often find it difficult to keep their technical skills up-to-date, manage personal priorities, and mitigate context switching.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886977','10.1145/2884781.2884840',32,10,'IEEE','IEEE Conferences',0),(652,'Floating-Point Precision Tuning Using Blame Analysis',5,1074,1085,'While tremendously useful, automated techniques for tuning the precision of floating-point programs face important scalability challenges. We present Blame Analysis, a novel dynamic approach that speeds up precision tuning. Blame Analysis performs floating-point instructions using different levels of accuracy for their operands. The analysis determines the precision of all operands such that a given precision is achieved in the final result of the program. Our evaluation on ten scientific programs shows that Blame Analysis is successful in lowering operand precision. As it executes the program only once, the analysis is particularly useful when targeting reductions in execution time. In such case, the analysis needs to be combined with search-based tools such as Precimonious. Our experiments show that combining Blame Analysis with Precimonious leads to obtaining better results with significant reduction in analysis time: the optimized programs execute faster (in three cases, we observe as high as 39.9% program speedup) and the combined analysis time is 9脳 faster on average, and up to 38脳 faster than Precimonious alone.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886981','10.1145/2884781.2884850',46,7,'IEEE','IEEE Conferences',0),(653,'iDice: Problem Identification for Emerging Issues',5,214,224,'One challenge for maintaining a large-scale software system, especially an online service system, is to quickly respond to customer issues. The issue reports typically have many categorical attributes that reflect the characteristics of the issues. For a commercial system, most of the time the volume of reported issues is relatively constant. Sometimes, there are emerging issues that lead to significant volume increase. It is important for support engineers to efficiently and effectively identify and resolve such emerging issues, since they have impacted a large number of customers. Currently, problem identification for an emerging issue is a tedious and error-prone process, because it requires support engineers to manually identify a particular attribute combination that characterizes the emerging issue among a large number of attribute combinations. We call such an attribute combination effective combination, which is important for issue isolation and diagnosis. In this paper, we propose iDice, an approach that can identify the effective combination for an emerging issue with high quality and performance. We evaluate the effectiveness and efficiency of iDice through experiments. We have also successfully applied iDice to several Microsoft online service systems in production. The results confirm that iDice can help identify emerging issues and reduce maintenance effort.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886905','10.1145/2884781.2884795',30,4,'IEEE','IEEE Conferences',0),(654,'FaCoY 鈥� A Code-to-Code Search Engine',1,946,957,'Code search is an unavoidable activity in software development. Various approaches and techniques have been explored in the literature to support code search tasks. Most of these approaches focus on serving user queries provided as natural language free-form input. However, there exists a wide range of use-case scenarios where a code-to-code approach would be most beneficial. For example, research directions in code transplantation, code diversity, patch recommendation can leverage a code-to-code search engine to find essential ingredients for their techniques. In this paper, we propose FaCoY, a novel approach for statically finding code fragments which may be semantically similar to user input code. FaCoY implements a query alternation strategy: instead of directly matching code query tokens with code in the search space, FaCoY first attempts to identify other tokens which may also be relevant in implementing the functional behavior of the input code. With various experiments, we show that (1) FaCoY is more effective than online code-to-code search engines; (2) FaCoY can detect more semantic code clones (i.e., Type-4) in BigCloneBench than the state-of-the-art; (3) FaCoY, while static, can detect code fragments which are indeed similar with respect to runtime execution behavior; and (4) FaCoY can be useful in code/patch recommendation.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453174','10.1145/3180155.3180187',0,2,'IEEE','IEEE Conferences',0),(655,'A Large-Scale Empirical Study on the Effects of Code Obfuscations on Android Apps and Anti-Malware Products',1,421,431,'The Android platform has been the dominant mobile platform in recent years resulting in millions of apps and security threats against those apps. Anti-malware products aim to protect smartphone users from these threats, especially from malicious apps. However, malware authors use code obfuscation on their apps to evade detection by anti-malware products. To assess the effects of code obfuscation on Android apps and anti-malware products, we have conducted a large-scale empirical study that evaluates the effectiveness of the top anti-malware products against various obfuscation tools and strategies. To that end, we have obfuscated 3,000 benign apps and 3,000 malicious apps and generated 73,362 obfuscated apps using 29 obfuscation strategies from 7 open-source, academic, and commercial obfuscation tools. The findings of our study indicate that (1) code obfuscation significantly impacts Android anti-malware products; (2) the majority of anti-malware products are severely impacted by even trivial obfuscations; (3) in general, combined obfuscation strategies do not successfully evade anti-malware products more than individual strategies; (4) the detection of anti-malware products depend not only on the applied obfuscation strategy but also on the leveraged obfuscation tool; (5) anti-malware products are slow to adopt signatures of malicious apps; and (6) code obfuscation often results in changes to an app\'s semantic behaviors.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453102','10.1145/3180155.3180228',49,1,'IEEE','IEEE Conferences',0),(656,'How Does the Degree of Variability Affect Bug Finding?',5,679,690,'Software projects embrace variability to increase adaptability and to lower cost; however, others blame variability for increasing complexity and making reasoning about programs more difficult. We carry out a controlled experiment to quantify the impact of variability on debugging of preprocessor- based programs. We measure speed and precision for bug finding tasks defined at three different degrees of variability on several subject programs derived from real systems. The results show that the speed of bug finding decreases linearly with the degree of variability, while effectiveness of finding bugs is relatively independent of the degree of variability. Still, identifying the set of configurations in which the bug manifests itself is difficult already for a low degree of variability. Surprisingly, identifying the exact set of affected configurations appears to be harder than finding the bug in the first place. The difficulty in reasoning about several configurations is a likely reason why the variability bugs are actually introduced in configurable programs. We hope that the detailed findings presented here will inspire the creation of programmer support tools addressing the challenges faced by developers when reasoning about configurations, contributing to more effective debugging and, ultimately, fewer bugs in highly-configurable systems.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886944','10.1145/2884781.2884831',36,5,'IEEE','IEEE Conferences',0),(657,'IntEQ: Recognizing Benign Integer Overflows via Equivalence Checking across Multiple Precisions',5,1051,1062,'Integer overflow (IO) vulnerabilities can be exploited by attackers to compromise computer systems. In the meantime, IOs can be used intentionally by programmers for benign purposes such as hashing and random number generation. Hence, differentiating exploitable and harmful IOs from intentional and benign ones is an important challenge. It allows reducing the number of false positives produced by IO vulnerability detection techniques, helping developers or security analysts to focus on fxing critical IOs without inspecting the numerous false alarms. The difficulty of recognizing benign IOs mainly lies in inferring the intent of programmers from source code. In this paper, we present a novel technique to recognize benign IOs via equivalence checking across multiple precisions. We determine if an IO is benign by comparing the effects of an overflowed integer arithmetic operation in the actual world (with limited precision) and the same operation in the ideal world (with sufficient precision to evade the IO). Specifically, we first extract the data flow path from the overflowed integer arithmetic operation to a security-related program point (i.e., sink) and then create a new version of the path using more precise types with sufficient bits to represent integers so that the IO can be avoided. Using theorem proving we check whether these two versions are equivalent, that is, if they yield the same values at the sink under all possible inputs. If so, the IO is benign. We implement a prototype, named IntEQ, based on the GCC compiler and the Z3 solver, and evaluate it using 26 harmful IO vulnerabilities from 20 real-world programs, and 444 benign IOs from SPECINT 2000, SPECINT 2006, and 7 real-world applications. The experimental results show that IntEQ does not misclassify any harmful IO bugs (no false negatives) and recognizes 355 out of 444 (about 79.95%) benign IOs, whereas the state of the art can only recognize 19 benign IOs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886979','10.1145/2884781.2884820',57,2,'IEEE','IEEE Conferences',0),(658,'Scalable Thread Sharing Analysis',5,1097,1108,'We present two scalable algorithms for identifying program locations that access thread-shared data in concurrent programs. The static algorithm, though simple, and without performing the expensive whole program information flow analysis, is much more efficient, less memory-demanding, and even more precise than the classical escape analysis algorithm. The dynamic algorithm, powered by a location- based approach, achieves significant runtime speedups over a precise dynamic escape analysis. Our evaluation on a set of large real world complex multithreaded systems such as Apache Derby and Eclipse shows that our algorithms achieve unprecedented scalability. Used by client applications, our algorithms reduce the recording overhead of a record-replay system by 9X on average (as much as 16X) and increase the runtime logging speed of a data race detector by 32% on average (as much as 52%).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886983','10.1145/2884781.2884811',42,3,'IEEE','IEEE Conferences',0),(659,'An Empirical Study of Practitioners\' Perspectives on Green Software Engineering',5,237,248,'The energy consumption of software is an increasing concern as the use of mobile applications, embedded systems, and data center-based services expands. While research in green software engineering is correspondingly increasing, little is known about the current practices and perspectives of software engineers in the field. This paper describes the first empirical study of how practitioners think about energy when they write requirements, design, construct, test, and maintain their software. We report findings from a quantitative,targeted survey of 464 practitioners from ABB, Google, IBM, and Microsoft, which was motivated by and supported with qualitative data from 18 in-depth interviews with Microsoft employees. The major findings and implications from the collected data contextualize existing green software engineering research and suggest directions for researchers aiming to develop strategies and tools to help practitioners improve the energy usage of their applications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886907','10.1145/2884781.2884810',60,15,'IEEE','IEEE Conferences',0),(660,'Work Practices and Challenges in Pull-Based Development: The Contributor\'s Perspective',5,285,296,'The pull-based development model is an emerging way of contributing to distributed software projects that is gaining enormous popularity within the open source software (OSS) world. Previous work has examined this model by focusing on projects and their owners-we complement it by examining the work practices of project contributors and the challenges they face.We conducted a survey with 645 top contributors to active OSS projects using the pull-based model on GitHub, the prevalent social coding site. We also analyzed traces extracted from corresponding GitHub repositories. Our research shows that: contributors have a strong interest in maintaining awareness of project status to get inspiration and avoid duplicating work, but they do not actively propagate information; communication within pull requests is reportedly limited to low-level concerns and contributors often use communication channels external to pull requests; challenges are mostly social in nature, with most reporting poor responsiveness from integrators; and the increased transparency of this setting is a confirmed motivation to contribute. Based on these findings, we present recommendations for practitioners to streamline the contribution process and discuss potential future research directions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886911','10.1145/2884781.2884826',54,29,'IEEE','IEEE Conferences',0),(661,'A Graph Solver for the Automated Generation of Consistent Domain-Specific Models',1,969,980,'Many testing and benchmarking scenarios in software and systems engineering depend on the systematic generation of graph models. For instance, tool qualification necessitated by safety standards would require a large set of consistent (well-formed or malformed) instance models specific to a domain. However, automatically generating consistent graph models which comply with a metamodel and satisfy all well-formedness constraints of industrial domains is a significant challenge. Existing solutions which map graph models into first-order logic specification to use back-end logic solvers (like Alloy or Z3) have severe scalability issues. In the paper, we propose a graph solver framework for the automated generation of consistent domain-specific instance models which operates directly over graphs by combining advanced techniques such as refinement of partial models, shape analysis, incremental graph query evaluation, and rule-based design space exploration to provide a more efficient guidance. Our initial performance evaluation carried out in four domains demonstrates that our approach is able to generate models which are 1-2 orders of magnitude larger (with 500 to 6000 objects!) compared to mapping-based approaches natively using Alloy.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453176','10.1145/3180155.3180186',0,4,'IEEE','IEEE Conferences',0),(662,'Testing Vision-Based Control Systems Using Learnable Evolutionary Algorithms',1,1016,1026,'Vision-based control systems are key enablers of many autonomous vehicular systems, including self-driving cars. Testing such systems is complicated by complex and multidimensional input spaces. We propose an automated testing algorithm that builds on learnable evolutionary algorithms. These algorithms rely on machine learning or a combination of machine learning and Darwinian genetic operators to guide the generation of new solutions (test scenarios in our context). Our approach combines multiobjective population-based search algorithms and decision tree classification models to achieve the following goals: First, classification models guide the search-based generation of tests faster towards critical test scenarios (i.e., test scenarios leading to failures). Second, search algorithms refine classification models so that the models can accurately characterize critical regions (i.e., the regions of a test input space that are likely to contain most critical test scenarios). Our evaluation performed on an industrial automotive automotive system shows that: (1) Our algorithm outperforms a baseline evolutionary search algorithm and generates 78% more distinct, critical test scenarios compared to the baseline algorithm. (2) Our algorithm accurately characterizes critical regions of the system under test, thus identifying the conditions that are likely to lead to system failures.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453180','10.1145/3180155.3180160',39,13,'IEEE','IEEE Conferences',0),(663,'An Analysis of the Search Spaces for Generate and Validate Patch Generation Systems',5,702,713,'We present the first systematic analysis of key characteristics of patch search spaces for automatic patch generation systems. We analyze sixteen different configurations of the patch search spaces of SPR and Prophet, two current state-of-the-art patch generation systems. The analysis shows that 1) correct patches are sparse in the search spaces (typically at most one correct patch per search space per defect), 2) incorrect patches that nevertheless pass all of the test cases in the validation test suite are typically orders of magnitude more abundant, and 3) leveraging information other than the test suite is therefore critical for enabling the system to successfully isolate correct patches. We also characterize a key tradeoff in the structure of the search spaces. Larger and richer search spaces that contain correct patches for more defects can actually cause systems to find fewer, not more, correct patches. We identify two reasons for this phenomenon: 1) increased validation times because of the presence of more candidate patches and 2) more incorrect patches that pass the test suite and block the discovery of correct patches. These fundamental properties, which are all characterized for the first time in this paper, help explain why past systems often fail to generate correct patches and help identify challenges, opportunities, and productive future directions for the field.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886946','10.1145/2884781.2884872',41,20,'IEEE','IEEE Conferences',0),(664,'Coverage-Driven Test Code Generation for Concurrent Classes',5,1121,1132,'Previous techniques on concurrency testing have mainly focused on exploring the interleaving space of manually written test code to expose faulty interleavings of shared memory accesses. These techniques assume the availability of failure-inducing tests. In this paper, we present AutoConTest, a coverage-driven approach to generate effective concurrent test code that achieve high interleaving coverage. AutoConTest consists of three components. First, it computes the coverage requirements dynamically and iteratively during sequential test code generation, using a coverage metric that captures the execution context of shared memory accesses. Second, it smartly selects these sequential codes based on the computed result and assembles them for concurrent tests, achieving increased context-sensitive interleaving coverage. Third, it explores the newly covered interleavings. We have implemented AutoConTest as an automated tool and evaluated it using 6 real-world concurrent Java subjects. The results show that AutoConTest is able to generate effective concurrent tests that achieve high interleaving coverage and expose concurrency faults quickly. AutoConTest took less than 65 seconds (including program analysis, test generation and execution) to expose the faults in the program subjects.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886985','10.1145/2884781.2884876',68,4,'IEEE','IEEE Conferences',0),(665,'Too Long; Didn\'t Watch! Extracting Relevant Fragments from Software Development Video Tutorials',5,261,272,'When knowledgeable colleagues are not available, developers resort to offline and online resources, e.g., tutorials, mailing lists, and Q&A websites. These, however, need to be found, read, and understood, which takes its toll in terms of time and mental energy. A more immediate and accessible resource are video tutorials found on the web, which in recent years have seen a steep increase in popularity. Nonetheless, videos are an intrinsically noisy data source, and finding the right piece of information might be even more cumbersome than using the previously mentioned resources. We present CodeTube, an approach which mines video tutorials found on the web, and enables developers to query their contents. The video tutorials are split into coherent fragments, to return only fragments related to the query. These are complemented with information from additional sources, such as Stack Overflow discussions. The results of two studies to assess CodeTube indicate that video tutorials-if appropriately processed-represent a useful, yet still under-utilized source of information for software development.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886909','10.1145/2884781.2884824',44,7,'IEEE','IEEE Conferences',0),(666,'Cross-Project Defect Prediction Using a Connectivity-Based Unsupervised Classifier',5,309,320,'Defect prediction on projects with limited historical data has attracted great interest from both researchers and practitioners. Cross-project defect prediction has been the main area of progress by reusing classifiers from other projects. However, existing approaches require some degree of homogeneity (e.g., a similar distribution of metric values) between the training projects and the target project. Satisfying the homogeneity requirement often requires significant effort (currently a very active area of research). An unsupervised classifier does not require any training data, therefore the heterogeneity challenge is no longer an issue. In this paper, we examine two types of unsupervised classifiers: a) distance-based classifiers (e.g., k-means); and b) connectivity-based classifiers. While distance-based unsupervised classifiers have been previously used in the defect prediction literature with disappointing performance, connectivity-based classifiers have never been explored before in our community. We compare the performance of unsupervised classifiers versus supervised classifiers using data from 26 projects from three publicly available datasets (i.e., AEEEM, NASA, and PROMISE). In the cross-project setting, our proposed connectivity-based classifier (via spectral clustering) ranks as one of the top classifiers among five widely-used supervised classifiers (i.e., random forest, naive Bayes, logistic regression, decision tree, and logistic model tree) and five unsupervised classifiers (i.e., k-means, partition around medoids, fuzzy C-means, neural-gas, and spectral clustering). In the within-project setting (i.e., models are built and applied on the same project), our spectral classifier ranks in the second tier, while only random forest ranks in the first tier. Hence, connectivity-based unsupervised classifiers offer a viable solution for cross and within project defect predictions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886913','10.1145/2884781.2884839',66,27,'IEEE','IEEE Conferences',0),(667,'Nemo: Multi-criteria Test-Suite Minimization with Integer Nonlinear Programming',1,1039,1049,'Multi-criteria test-suite minimization aims to remove redundant test cases from a test suite based on some criteria such as code coverage, while trying to optimally maintain the capability of the reduced suite based on other criteria such as fault-detection effectiveness. Existing techniques addressing this problem with integer linear programming claim to produce optimal solutions. However, the multi-criteria test-suite minimization problem is inherently nonlinear, due to the fact that test cases are often dependent on each other in terms of test-case criteria. In this paper, we propose a framework that formulates the multi-criteria test-suite minimization problem as an integer nonlinear programming problem. To solve this problem optimally, we programmatically transform this nonlinear problem into a linear one and then solve the problem using modern linear solvers. We have implemented our framework as a tool, called Nemo, that supports a number of modern linear and nonlinear solvers. We have evaluated Nemo with a publicly available dataset and minimization problems involving multiple criteria including statement coverage, fault-revealing capability, and test execution time. The experimental results show that Nemo can be used to efficiently find an optimal solution for multi-criteria test-suite minimization problems with modern solvers, and the optimal solutions outperform the suboptimal ones by up to 164.29% in terms of the criteria considered in the problem.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453182','10.1145/3180155.3180174',0,1,'IEEE','IEEE Conferences',0),(668,'Time to Clean Your Test Objectives',1,456,467,'Testing is the primary approach for detecting software defects. A major challenge faced by testers lies in crafting efficient test suites, able to detect a maximum number of bugs with manageable effort. To do so, they rely on coverage criteria, which define some precise test objectives to be covered. However, many common criteria specify a significant number of objectives that occur to be infeasible or redundant in practice, like covering dead code or semantically equal mutants. Such objectives are well-known to be harmful to the design of test suites, impacting both the efficiency and precision of the tester\'s effort. This work introduces a sound and scalable technique to prune out a significant part of the infeasible and redundant objectives produced by a panel of white-box criteria. In a nutshell, we reduce this task to proving the validity of logical assertions in the code under test. The technique is implemented in a tool that relies on weakest-precondition calculus and SMT solving for proving the assertions. The tool is built on top of the Frama-C verification platform, which we carefully tune for our specific scalability needs. The experiments reveal that the pruning capabilities of the tool can reduce the number of targeted test objectives in a program by up to 27% and scale to real programs of 200K lines, making it possible to automate a painstaking part of their current testing process.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453106','10.1145/3180155.3180191',0,0,'IEEE','IEEE Conferences',0),(669,'Improving Refactoring Speed by 10X',5,1145,1156,'Refactoring engines are standard tools in today\'s Integrated Development Environments (IDEs). They allow programmers to perform one refactoring at a time, but programmers need more. Most design patterns in the Gang-of-Four text can be written as a refactoring script - a programmatic sequence of refactorings. In this paper, we present R3, a new Java refactoring engine that supports refactoring scripts. It builds a main-memory, non-persistent database to encode Java entity declarations (e.g., packages, classes, methods), their containment relationships, and language features such as inheritance and modifiers. Unlike classical refactoring engines that modify Abstract Syntax Trees (ASTs), R3 refactorings modify only the database; refactored code is produced only when pretty-printing ASTs that reference database changes. R3 performs comparable precondition checks to those of the Eclipse Java Development Tools (JDT) but R3\'s codebase is about half the size of the JDT refactoring engine and runs an order of magnitude faster. Further, a user study shows that R3 improved the success rate of retrofitting design patterns by 25% up to 50%.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886987','10.1145/2884781.2884802',57,5,'IEEE','IEEE Conferences',0),(670,'AntMiner: Mining More Bugs by Reducing Noise Interference',5,333,344,'Detecting bugs with code mining has proven to be an effective approach. However, the existing methods suffer from reporting serious false positives and false negatives. In this paper, we developed an approach called AntMiner to improve the precision of code mining by carefully preprocessing the source code. Specifically, we employ the program slicing technique to decompose the original source repository into independent sub-repositories, taking critical operations (automatically extracted from source code) as slicing criteria. In this way, the statements irrelevant to a critical operation are excluded from the corresponding sub-repository. Besides, various semantics-equivalent representations are normalized into a canonical form. Eventually, the mining process can be performed on a refined code database, and false positives and false negatives can be significantly pruned. We have implemented AntMiner and applied it to detect bugs in the Linux kernel. It reported 52 violations that have been either confirmed as real bugs by the kernel development community or fixed in new kernel versions. Among them, 41 cannot be detected by a widely used representative analysis tool Coverity. Besides, the result of a comparative analysis shows that our approach can effectively improve the precision of code mining and detect subtle bugs that have previously been missed.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886915','10.1145/2884781.2884870',50,5,'IEEE','IEEE Conferences',0),(671,'Automated Reporting of GUI Design Violations for Mobile Apps',1,165,175,'The inception of a mobile app often takes form of a mock-up of the Graphical User Interface (GUI), represented as a static image delineating the proper layout and style of GUI widgets that satisfy requirements. Following this initial mock-up, the design artifacts are then handed off to developers whose goal is to accurately implement these GUIs and the desired functionality in code. Given the sizable abstraction gap between mock-ups and code, developers often introduce mistakes related to the GUI that can negatively impact an app\'s success in highly competitive marketplaces. Moreover, such mistakes are common in the evolutionary context of rapidly changing apps. This leads to the time-consuming and laborious task of design teams verifying that each screen of an app was implemented according to intended design specifications. This paper introduces a novel, automated approach for verifying whether the GUI of a mobile app was implemented according to its intended design. Our approach resolves GUI-related information from both implemented apps and mock-ups and uses computer vision techniques to identify common errors in the implementations of mobile GUIs. We implemented this approach for Android in a tool called GVT and carried out both a controlled empirical evaluation with open-source apps as well as an industrial evaluation with designers and developers from Huawei. The results show that GVT solves an important, difficult, and highly practical problem with remarkable efficiency and accuracy and is both useful and scalable from the point of view of industrial designers and developers. The tool is currently used by over one-thousand industrial designers and developers at Huawei to improve the quality of their mobile apps.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453076','10.1145/3180155.3180246',0,4,'IEEE','IEEE Conferences',0),(672,'Fine-Grained Test Minimization',1,210,221,'As a software system evolves, its test suite can accumulate redundancies over time. Test minimization aims at removing redundant test cases. However, current techniques remove whole test cases from the test suite using test adequacy criteria, such as code coverage. This has two limitations, namely (1) by removing a whole test case the corresponding test assertions are also lost, which can inhibit test suite effectiveness, (2) the issue of partly redundant test cases, i.e., tests with redundant test statements, is ignored. We propose a novel approach for fine-grained test case minimization. Our analysis is based on the inference of a test suite model that enables automated test reorganization within test cases. It enables removing redundancies at the test statement level, while preserving the coverage and test assertions of the test suite. We evaluated our approach, implemented in a tool called Testler, on the test suites of 15 open source projects. Our analysis shows that over 4,639 (24%) of the tests in these test suites are partly redundant, with over 11,819 redundant test statements in total. Our results show that Testler removes 43% of the redundant test statements, reducing the number of partly redundant tests by 52%. As a result, test suite execution time is reduced by up to 37% (20% on average), while maintaining the original statement coverage, branch coverage, test assertions, and fault detection capability.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453080','10.1145/3180155.3180203',0,0,'IEEE','IEEE Conferences',0),(673,'An Empirical Study on the Impact of C++ Lambdas and Programmer Experience',5,760,771,'Lambdas have seen increasing use in mainstream programming languages, notably in Java 8 and C++ 11. While the technical aspects of lambdas are known, we conducted the first randomized controlled trial on the human factors impact of C++ 11 lambdas compared to iterators. Because there has been recent debate on having students or professionals in experiments, we recruited undergraduates across the academic pipeline and professional programmers to evaluate these findings in a broader context. Results afford some doubt that lambdas benefit developers and show evidence that students are negatively impacted in regard to how quickly they can write correct programs to a test specification and whether they can complete a task. Analysis from log data shows that participants spent more time with compiler errors, and have more errors, when using lambdas as compared to iterators, suggesting difficulty with the syntax chosen for C++. Finally, experienced users were more likely to complete tasks, with or without lambdas, and could do so more quickly, with experience as a factor explaining 45.7% of the variance in our sample in regard to completion time.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886954','10.1145/2884781.2884849',59,9,'IEEE','IEEE Conferences',0),(674,'ConflictJS: Finding and Understanding Conflicts Between JavaScript Libraries',1,741,751,'It is a common practice for client-side web applications to build on various third-party JavaScript libraries. Due to the lack of namespaces in JavaScript, these libraries all share the same global namespace. As a result, one library may inadvertently modify or even delete the APIs of another library, causing unexpected behavior of library clients. Given the quickly increasing number of libraries, manually keeping track of such conflicts is practically impossible both for library developers and users. This paper presents ConflictJS, an automated and scalable approach to analyze libraries for conflicts. The key idea is to tackle the huge search space of possible conflicts in two phases. At first, a dynamic analysis of individual libraries identifies pairs of potentially conflicting libraries. Then, targeted test synthesis validates potential conflicts by creating a client application that suffers from a conflict. The overall approach is free of false positives, in the sense that it reports a problem only when such a client exists. We use ConflictJS to analyze and study conflicts among 951 real-world libraries. The results show that one out of four libraries is potentially conflicting and that 166 libraries are involved in at least one certain conflict. The detected conflicts cause crashes and other kinds of unexpected behavior. Our work helps library developers to prevent conflicts, library users to avoid combining conflicting libraries, and provides evidence that designing a language without explicit namespaces has undesirable effects.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453147','10.1145/3180155.3180184',0,2,'IEEE','IEEE Conferences',0),(675,'Understanding Asynchronous Interactions in Full-Stack JavaScript',5,1169,1180,'JavaScript has become one of the most popular languages in practice. Developers now use JavaScript not only for the client-side but also for server-side programming, leading to \'full-stack\' applications written entirely in JavaScript. Understanding such applications is challenging for developers, due to the temporal and implicit relations of asynchronous and event-driven entities spread over the client and server side. We propose a technique for capturing a behavioural model of full-stack JavaScript applications\' execution. The model is temporal and context-sensitive to accommodate asynchronous events, as well as the scheduling and execution of lifelines of callbacks. We present a visualization of the model to facilitate program understanding for developers. We implement our approach in a tool, called Sahand, and evaluate it through a controlled experiment. The results show that Sahand improves developers\' performance in completing program comprehension tasks by increasing their accuracy by a factor of three.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886989','10.1145/2884781.2884864',48,8,'IEEE','IEEE Conferences',0),(676,'SWIM: Synthesizing What I Mean - Code Search and Idiomatic Snippet Synthesis',5,357,367,'Modern programming frameworks come with large libraries, with diverse applications such as for matching regular expressions, parsing XML files and sending email. Programmers often use search engines such as Google and Bing to learn about existing APIs. In this paper, we describe SWIM, a tool which suggests code snippets given API-related natural language queries such as 鈥済enerate md5 hash code鈥�. The query does not need to contain framework-specific trivia such as the type names or methods of interest. We translate user queries into the APIs of interest using clickthrough data from the Bing search engine. Then, based on patterns learned from open-source code repositories, we synthesize idiomatic code describing the use of these APIs. We introduce structured call sequences to capture API-usage patterns. Structured call sequences are a generalized form of method call sequences, with if-branches and while-loops to represent conditional and repeated API usage patterns, and are simple to extract and amenable to synthesis. We evaluated SWIM with 30 common C# API-related queries received by Bing. For 70% of the queries, the first suggested snippet was a relevant solution, and a relevant solution was present in the top 10 results for all benchmarked queries. The online portion of the workflow is also very responsive, at an average of 1.5 seconds per snippet.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886917','10.1145/2884781.2884808',28,18,'IEEE','IEEE Conferences',0),(677,'From Word Embeddings to Document Similarities for Improved Information Retrieval in Software Engineering',5,404,415,'The application of information retrieval techniques to search tasks in software engineering is made difficult by the lexical gap between search queries, usually expressed in natural language (e.g. English), and retrieved documents, usually expressed in code (e.g. programming languages). This is often the case in bug and feature location, community question answering, or more generally the communication between technical personnel and non-technical stake holders in a software project. In this paper, we propose bridging the lexical gap by projecting natural language statements and code snippets as meaning vectors in a shared representation space. In the proposed architecture, word embeddings are rst trained on API documents, tutorials, and reference documents, and then aggregated in order to estimate semantic similarities between documents. Empirical evaluations show that the learned vector space embeddings lead to improvements in a previously explored bug localization task and a newly de ned task of linking API documents to computer programming questions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886921','10.1145/2884781.2884862',47,40,'IEEE','IEEE Conferences',0),(678,'The Road to Live Programming: Insights from the Practice',1,1090,1101,'Live Programming environments allow programmers to get feedback instantly while changing software. Liveness is gaining attention among industrial and open-source communities; several IDEs offer high degrees of liveness. While several studies looked at how programmers work during software evolution tasks, none of them consider live environments. We conduct such a study based on an analysis of 17 programming sessions of practitioners using Pharo, a mature Live Programming environment. The study is complemented by a survey and subsequent analysis of 16 programming sessions in additional languages, e.g., JavaScript. We document the approaches taken by developers during their work. We find that some liveness features are extensively used, and have an impact on the way developers navigate source code and objects in their work.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453190','10.1145/3180155.3180200',0,2,'IEEE','IEEE Conferences',0),(679,'Repairing Crashes in Android Apps',1,187,198,'Android apps are omnipresent, and frequently suffer from crashes - leading to poor user experience and economic loss. Past work focused on automated test generation to detect crashes in Android apps. However, automated repair of crashes has not been studied. In this paper, we propose the first approach to automatically repair Android apps, specifically we propose a technique for fixing crashes in Android apps. Unlike most test-based repair approaches, we do not need a test-suite; instead a single failing test is meticulously analyzed for crash locations and reasons behind these crashes. Our approach hinges on a careful empirical study which seeks to establish common root-causes for crashes in Android apps, and then distills the remedy of these root-causes in the form of eight generic transformation operators. These operators are applied using a search-based repair framework embodied in our repair tool Droix. We also prepare a benchmark DroixBench capturing reproducible crashes in Android apps. Our evaluation of Droix on DroixBench reveals that the automatically produced patches are often syntactically identical to the human patch, and on some rare occasion even better than the human patch (in terms of avoiding regressions). These results confirm our intuition that our proposed transformations form a sufficient set of operators to patch crashes in Android.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453078','10.1145/3180155.3180243',0,6,'IEEE','IEEE Conferences',0),(680,'Towards Refactoring-Aware Regression Test Selection',1,233,244,'Regression testing checks that recent project changes do not break previously working functionality. Although important, regression testing is costly when changes are frequent. Regression test selection (RTS) optimizes regression testing by running only tests whose results might be affected by a change. Traditionally, RTS collects dependencies (e.g., on files) for each test and skips the tests, at a new project revision, whose dependencies did not change. Existing RTS techniques do not differentiate behavior-preserving transformations (i.e., refactorings) from other code changes. As a result, tests are run more frequently than necessary. We present the first step towards a refactoring-aware RTS technique, dubbed Reks, which skips tests affected only by behavior-preserving changes. Reks defines rules to update the test dependencies without running the tests. To ensure that Reks does not hide any bug introduced by the refactoring engines, we integrate Reks only in the pre-submit testing phase, which happens on the developers\' machines. We evaluate Reks by measuring the savings in the testing effort. Specifically, we reproduce 100 refactoring tasks performed by developers of 37 projects on GitHub. Our results show that Reks would not run, on average, 33% of available tests (that would be run by a refactoring-unaware RTS technique). Additionally, we systematically run 27 refactoring types on ten projects. The results, based on 74,160 refactoring tasks, show that Reks would not run, on average, 16% of tests (max: 97% and SD: 24%). Finally, our results show that the Reks update rules are efficient.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453082','10.1145/3180155.3180254',80,5,'IEEE','IEEE Conferences',0),(681,'BigDebug: Debugging Primitives for Interactive Big Data Processing in Spark',5,784,795,'Developers use cloud computing platforms to process a large quantity of data in parallel when developing big data analytics. Debugging the massive parallel computations that run in today\'s data-centers is time consuming and error-prone. To address this challenge, we design a set of interactive, real-time debugging primitives for big data processing in Apache Spark, the next generation data-intensive scalable cloud computing platform. This requires re-thinking the notion of step-through debugging in a traditional debugger such as gdb, because pausing the entire computation across distributed worker nodes causes significant delay and naively inspecting millions of records using a watchpoint is too time consuming for an end user.First, BigDebug\'s simulated breakpoints and on-demand watchpoints allow users to selectively examine distributed, intermediate data on the cloud with little overhead. Second, a user can also pinpoint a crash-inducing record and selectively resume relevant sub-computations after a quick fix. Third, a user can determine the root causes of errors (or delays) at the level of individual records through a fine-grained data provenance capability. Our evaluation shows that BigDebug scales to terabytes and its record-level tracing incurs less than 25% overhead on average. It determines crash culprits orders of magnitude more accurately and provides up to 100% time saving compared to the baseline replay debugger. The results show that BigDebug supports debugging at interactive speeds with minimal performance impact.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886956','10.1145/2884781.2884813',40,4,'IEEE','IEEE Conferences',0),(682,'Are \'Non-functional\' Requirements really Non-functional? An Investigation of Non-functional Requirements in Practice',5,832,842,'Non-functional requirements (NFRs) are commonly distinguished from functional requirements by differentiating how the system shall do something in contrast to what the system shall do. This distinction is not only prevalent in research, but also influences how requirements are handled in practice. NFRs are usually documented separately from functional requirements, without quantitative measures, and with relatively vague descriptions.As a result, they remain difficult to analyze and test.Several authors argue, however, that many so-called NFRs actually describe behavioral properties and may be treated the same way as functional requirements. In this paper, we empirically investigate this point of view and aim to increase our understanding on the nature of NFRs addressing system properties. We report on the classification of 530 NFRs extracted from 11 industrial requirements specifications and analyze to which extent these NFRs describe system behavior.Our results suggest that most \'non-functional\' requirements are not non-functional as they describe behavior of a system. Consequently, we argue that many so-called NFRs can be handled similarly to functional requirements.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886960','10.1145/2884781.2884788',31,8,'IEEE','IEEE Conferences',0),(683,'Automatic Model Generation from Documentation for Java API Functions',5,380,391,'Modern software systems are becoming increasingly complex, relying on a lot of third-party library support. Library behaviors are hence an integral part of software behaviors. Analyzing them is as important as analyzing the software itself. However, analyzing libraries is highly challenging due to the lack of source code, implementation in different languages, and complex optimizations. We observe that many Java library functions provide excellent documentation, which concisely describes the functionalities of the functions. We develop a novel technique that can construct models for Java API functions by analyzing the documentation. These models are simpler implementations in Java compared to the original ones and hence easier to analyze. More importantly, they provide the same functionalities as the original functions. Our technique successfully models 326 functions from 14 widely used Java classes. We also use these models in static taint analysis on Android apps and dynamic slicing for Java programs, demonstrating the effectiveness and efficiency of our models.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886919','10.1145/2884781.2884881',37,9,'IEEE','IEEE Conferences',0),(684,'On the \'Naturalness\' of Buggy Code',5,428,439,'Real software, the kind working programmers produce by the kLOC to solve real-world problems, tends to be 鈥渘atural鈥�, like speech or natural language; it tends to be highly repetitive and predictable. Researchers have captured this naturalness of software through statistical models and used them to good effect in suggestion engines, porting tools, coding standards checkers, and idiom miners. This suggests that code that appears improbable, or surprising, to a good statistical language model is 鈥渦nnatural鈥� in some sense, and thus possibly suspicious. In this paper, we investigate this hypothesis. We consider a large corpus of bug fix commits (ca. 7,139), from 10 different Java projects, and focus on its language statistics, evaluating the naturalness of buggy code and the corresponding fixes. We find that code with bugs tends to be more entropic (i.e. unnatural), becoming less so as bugs are fixed. Ordering files for inspection by their average entropy yields cost-effectiveness scores comparable to popular defect prediction methods. At a finer granularity, focusing on highly entropic lines is similar in cost-effectiveness to some well-known static bug finders (PMD, FindBugs) and or- dering warnings from these bug finders using an entropy measure improves the cost-effectiveness of inspecting code implicated in warnings. This suggests that entropy may be a valid, simple way to complement the effectiveness of PMD or FindBugs, and that search-based bug-fixing methods may benefit from using entropy both for fault-localization and searching for fixes.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886923','10.1145/2884781.2884848',57,29,'IEEE','IEEE Conferences',0),(685,'CCAligner: A Token Based Large-Gap Clone Detector',1,1066,1077,'Copying code and then pasting with large number of edits is a common activity in software development, and the pasted code is a kind of complicated Type-3 clone. Due to large number of edits, we consider the clone as a large-gap clone. Large-gap clone can reflect the extension of code, such as change and improvement. The existing state-of-the-art clone detectors suffer from several limitations in detecting large-gap clones. In this paper, we propose a tool, CCAligner, using code window that considers e edit distance for matching to detect large-gap clones. In our approach, a novel e-mismatch index is designed and the asymmetric similarity coefficient is used for similarity measure. We thoroughly evaluate CCAligner both for large-gap clone detection, and for general Type-1, Type-2 and Type-3 clone detection. The results show that CCAligner performs better than other competing tools in large-gap clone detection, and has the best execution time for 10MLOC input with good precision and recall in general Type-1 to Type-3 clone detection. Compared with existing state-of-the-art tools, CCAligner is the best performing large-gap clone detection tool, and remains competitive with the best clone detectors in general Type-1, Type-2 and Type-3 clone detection.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453188','10.1145/3180155.3180179',57,7,'IEEE','IEEE Conferences',0),(686,'PRADA: Prioritizing Android Devices for Apps by Mining Large-Scale Usage Data',5,3,13,'Selecting and prioritizing major device models are critical for mobile app developers to select testbeds and optimize resources such as marketing and quality-assurance resources. The heavily fragmented distribution of Android devices makes it challenging to select a few major device models out of thousands of models available on the market. Currently app developers usually rely on some reported or estimated general market share of device models. However, these estimates can be quite inaccurate, and more problematically, can be irrelevant to the particular app under consideration. To address this issue, we propose PRADA, the first approach to prioritizing Android device models for individual apps, based on mining large-scale usage data. PRADA adapts the concept of operational profiling (popularly used in software reliability engineering) for mobile apps - the usage of an app on a specific device model reflects the importance of that device model for the app. PRADA includes a collaborative filtering technique to predict the usage of an app on different device models, even if the app is entirely new (without its actual usage in the market yet), based on the usage data of a large collection of apps. We empirically demonstrate the effectiveness of PRADA over two popular app categories, i.e., Game and Media, covering over 3.86 million users and 14,000 device models collected through a leading Android management app in China.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886887','10.1145/2884781.2884828',41,10,'IEEE','IEEE Conferences',0),(687,'Programming Not Only by Example',1,1114,1124,'Recent years have seen great progress in automated synthesis techniques that can automatically generate code based on some intent expressed by the programmer, but communicating this intent remains a major challenge. When the expressed intent is coarse-grained (for example, restriction on the expected type of an expression), the synthesizer often produces a long list of results for the programmer to choose from, shifting the heavy-lifting to the user. An alternative approach, successfully used in end-user synthesis, is programming by example (PBE), where the user leverages examples to interactively and iteratively refine the intent. However, using only examples is not expressive enough for programmers, who can observe the generated program and refine the intent by directly relating to parts of the generated program. We present a novel approach to interacting with a synthesizer using a granular interaction model. Our approach employs a rich interaction model where (i) the synthesizer decorates a candidate program with debug information that assists in understanding the program and identifying good or bad parts, and (ii) the user is allowed to provide feedback not only on the expected output of a program but also on the program itself. After identifying a program as (partially) correct or incorrect, the user can also explicitly indicate the good or bad parts, to allow the synthesizer to accept or discard parts of the program instead of discarding the program as a whole. We show the value of our approach in a controlled user study. Our study shows that participants have a strong preference for granular feedback instead of examples and can provide granular feedback much faster.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453192','10.1145/3180155.3180189',41,0,'IEEE','IEEE Conferences',0),(688,'How Modern News Aggregators Help Development Communities Shape and Share Knowledge',1,499,510,'Many developers rely on modern news aggregator sites such as reddit and hn to stay up to date with the latest technological developments and trends. In order to understand what motivates developers to contribute, what kind of content is shared, and how knowledge is shaped by the community, we interviewed and surveyed developers that participate on the reddit programming subreddit and we analyzed a sample of posts on both reddit and hn. We learned what kind of content is shared in these websites and developer motivations for posting, sharing, discussing, evaluating, and aggregating knowledge on these aggregators, while revealing challenges developers face in terms of how content and participant behavior is moderated. Our insights aim to improve the practices developers follow when using news aggregators, as well as guide tool makers on how to improve their tools. Our findings are also relevant to researchers that study developer communities of practice.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453116','10.1145/3180155.3180180',0,3,'IEEE','IEEE Conferences',0),(689,'Generating Performance Distributions via Probabilistic Symbolic Execution',5,49,60,'Analyzing performance and understanding the potential best-case, worst-case and distribution of program execution times are very important software engineering tasks. There have been model-based and program analysis-based approaches for performance analysis. Model-based approaches rely on analytical or design models derived from mathematical theories or software architecture abstraction, which are typically coarse-grained and could be imprecise. Program analysis-based approaches collect program profiles to identify performance bottlenecks, which often fail to capture the overall program performance. In this paper, we propose a performance analysis framework PerfPlotter. It takes the program source code and usage profile as inputs and generates a performance distribution that captures the input probability distribution over execution times for the program. It heuristically explores high-probability and low-probability paths through probabilistic symbolic execution. Once a path is explored, it generates and runs a set of test inputs to model the performance of the path. Finally, it constructs the performance distribution for the program. We have implemented PerfPlotter based on the Symbolic PathFinder infrastructure, and experimentally demonstrated that PerfPlotter could accurately capture the best-case, worst-case and distribution of program execution times. We also show that performance distributions can be applied to various important tasks such as performance understanding, bug validation, and algorithm selection.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886891','10.1145/2884781.2884794',61,7,'IEEE','IEEE Conferences',0),(690,'Almost There: A Study on Quasi-Contributors in Open-Source Software Projects',1,256,266,'Recent studies suggest that well-known OSS projects struggle to find the needed workforce to continue evolving-in part because external developers fail to overcome their first contribution barriers. In this paper, we investigate how and why quasi-contributors (external developers who did not succeed in getting their contributions accepted to an OSS project) fail. To achieve our goal, we collected data from 21 popular, non-trivial GitHub projects, identified quasi-contributors, and analyzed their pull-requests. In addition, we conducted surveys with quasi-contributors, and projects\' integrators, to understand their perceptions about nonacceptance.We found 10,099 quasi-contributors - about 70% of the total actual contributors - that submitted 12,367 non-accepted pull-requests. In five projects, we found more quasi-contributors than actual contributors. About one-third of the developers who took our survey disagreed with the nonacceptance, and around 30% declared the nonacceptance demotivated or prevented them from placing another pull-request. The main reasons for pull-request nonacceptance from the quasi-contributors\' perspective were \'superseded/duplicated pull-request\' and \'mismatch between developer\'s and team\'s vision/opinion.\' A manual analysis of a representative sample of 263 pull-requests corroborated with this finding. We also found reasons related to the relationship with the community and lack of experience or commitment from the quasi-contributors. This empirical study is particularly relevant to those interested in fostering developers\' participation and retention in OSS communities.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453084','10.1145/3180155.3180208',0,8,'IEEE','IEEE Conferences',0),(691,'Revisit of Automatic Debugging via Human Focus-Tracking Analysis',5,808,819,'In many fields of software engineering, studies on human behavior have attracted a lot of attention; however, few such studies exist in automated debugging. Parnin and Orso conducted a pioneering study comparing the performance of programmers in debugging with and without a ranking-based fault localization technique, namely Spectrum-Based Fault Localization (SBFL). In this paper, we revisit the actual helpfulness of SBFL, by addressing some major problems that were not resolved in Parnin and Orso\'s study. Our investigation involved 207 participants and 17 debugging tasks. A user-friendly SBFL tool was adopted. It was found that SBFL tended not to be helpful in improving the efficiency of debugging. By tracking and analyzing programmers\' focus of attention, we characterized their source code navigation patterns and provided in-depth explanations to the observations. Results indicated that (1) a short 鈥渇irst scan鈥� on the source code tended to result in inefficient debugging; and (2) inspections on the pinpointed statements during the 鈥渇ollow-up browsing鈥� were normally just quick skimming. Moreover, we found that the SBFL assistbrowsing鈥� were normally just quick skimming. Moreover, we found that the SBFL assistanceance may even slightly weaken programmers\' abilities in fault detection. Our observations imply interference between the mechanism of automated fault localization and the actual assistance needed by programmers in debugging. To resolve this interference, we provide several insights and suggestions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886958','10.1145/2884781.2884834',40,12,'IEEE','IEEE Conferences',0),(692,'Risk-Driven Revision of Requirements Models',5,855,865,'Requirements incompleteness is often the result of unanticipated adverse conditions which prevent the software and its environment from behaving as expected. These conditions represent risks that can cause severe software failures. The identification and resolution of such risks is therefore a crucial step towards requirements completeness. Obstacle analysis is a goal-driven form of risk analysis that aims at detecting missing conditions that can obstruct goals from being satisfied in a given domain, and resolving them. This paper proposes an approach for automatically revising goals that may be under-specified or (partially) wrong to resolve obstructions in a given domain. The approach deploys a learning-based revision methodology in which obstructed goals in a goal model are iteratively revised from traces exemplifying obstruction and non-obstruction occurrences. Our revision methodology computes domain-consistent, obstruction-free revisions that are automatically propagated to other goals in the model in order to preserve the correctness of goal models whilst guaranteeing minimal change to the original model. We present the formal foundations of our learning-based approach, and show that it preserves the properties of our formal framework. We validate it against the benchmarking case study of the London Ambulance Service.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886962','10.1145/2884781.2884838',37,2,'IEEE','IEEE Conferences',0),(693,'Using (Bio)Metrics to Predict Code Quality Online',5,452,463,'Finding and fixing code quality concerns, such as defects or poor understandability of code, decreases software development and evolution costs. A common industrial practice to identify code quality concerns early on are code reviews. While code reviews help to identify problems early on, they also impose costs on development and only take place after a code change is already completed. The goal of our research is to automatically identify code quality concerns while a developer is making a change to the code. By using biometrics, such as heart rate variability, we aim to determine the difficulty a developer experiences working on a part of the code as well as identify and help to fix code quality concerns before they are even committed to the repository. In a field study with ten professional developers over a two-week period we investigated the use of biometrics to determine code quality concerns. Our results show that biometrics are indeed able to predict quality concerns of parts of the code while a developer is working on, improving upon a naive classifier by more than 26% and outperforming classifiers based on more traditional metrics. In a second study with five professional developers from a different country and company, we found evidence that some of our findings from our initial study can be replicated. Overall, the results from the presented studies suggest that biometrics have the potential to predict code quality concerns online and thus lower development and evolution costs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886925','10.1145/2884781.2884803',77,10,'IEEE','IEEE Conferences',0),(694,'Toward a Framework for Detecting Privacy Policy Violations in Android Application Code',5,25,36,'Mobile applications frequently access sensitive personal information to meet user or business requirements. Because such information is sensitive in general, regulators increasingly require mobile-app developers to publish privacy policies that describe what information is collected. Furthermore, regulators have fined companies when these policies are inconsistent with the actual data practices of mobile apps. To help mobile-app developers check their privacy policies against their apps\' code for consistency, we propose a semi-automated framework that consists of a policy terminology- API method map that links policy phrases to API methods that produce sensitive information, and information flow analysis to detect misalignments. We present an implementation of our framework based on a privacy-policy-phrase ontology and a collection of map- pings from API methods to policy phrases. Our empirical evaluation on 477 top Android apps discovered 341 potential privacy policy violations.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886889','10.1145/2884781.2884855',42,13,'IEEE','IEEE Conferences',0),(695,'\'Was My Contribution Fairly Reviewed?\' A Framework to Study the Perception of Fairness in Modern Code Reviews',1,523,534,'Modern code reviews improve the quality of software products. Although modern code reviews rely heavily on human interactions, little is known regarding whether they are performed fairly. Fairness plays a role in any process where decisions that affect others are made. When a system is perceived to be unfair, it affects negatively the productivity and motivation of its participants. In this paper, using fairness theory we create a framework that describes how fairness affects modern code reviews. To demonstrate its applicability, and the importance of fairness in code reviews, we conducted an em-pirical study that asked developers of a large industrial open source ecosystem (OpenStack) what their perceptions are regarding fairness in their code reviewing process. Our study shows that, in general, the code review process in OpenStack is perceived as fair; however, a significant portion of respondents perceive it as unfair. We also show that the variability in the way they prioritize code reviews signals a lack of consistency and the existence of bias (potentially increasing the perception of unfairness). The contributions of this paper are: (1) we propose a framework-based on fairness theory-for studying and managing social behaviour in modern code reviews, (2) we provide support for the framework through the results of a case study on a large industrial-backed open source project, (3) we present evidence that fairness is an issue in the code review process of a large open source ecosystem, and, (4) we present a set of guidelines for practitioners to address unfairness in modern code reviews.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453118','10.1145/3180155.3180217',79,3,'IEEE','IEEE Conferences',0),(696,'Reliability of Run-Time Quality-of-Service Evaluation Using Parametric Model Checking',5,73,84,'Run-time Quality-of-Service (QoS) assurance is crucial for business-critical systems. Complex behavioral performance metrics (PMs) are useful but often difficult to monitor or measure. Probabilistic model checking, especially parametric model checking, can support the computation of aggre- gate functions for a broad range of those PMs. In practice, those PMs may be defined with parameters determined by run-time data. In this paper, we address the reliability of QoS evaluation using parametric model checking. Due to the imprecision with the instantiation of parameters, an evaluation outcome may mislead the judgment about requirement violations. Based on a general assumption of run-time data distribution, we present a novel framework that contains light-weight statistical inference methods to analyze the re- liability of a parametric model checking output with respect to an intuitive criterion. We also present case studies in which we test the stability and accuracy of our inference methods and describe an application of our framework to a cloud server management problem.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886893','10.1145/2884781.2884814',31,5,'IEEE','IEEE Conferences',0),(697,'To Distribute or Not to Distribute? Why Licensing Bugs Matter',1,268,279,'Software licenses dictate how source code or binaries can be modified, reused, and redistributed. In the case of open source projects, software licenses generally fit into two main categories, permissive and restrictive, depending on the degree to which they allow redistribution or modification under licenses different from the original one(s). Developers and organizations can also modify existing licenses, creating custom licenses with specific permissive/restrictive terms. Having such a variety of software licenses can create confusion among software developers, and can easily result in the introduction of licensing bugs, not necessarily limited to well-known license incompatibilities. In this work, we report a study aimed at characterizing licensing bugs by (i) building a catalog categorizing the types of licensing bugs developers and other stakeholders face, and (ii) understanding the implications licensing bugs have on the software projects they affect. The presented study is the result of the manual analysis of 1,200 discussions related to licensing bugs carried out in issue trackers and in five legal mailing lists of open source communities. Our findings uncover new types of licensing bugs not addressed in prior literature, and a detailed assessment of their implications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453086','10.1145/3180155.3180221',0,1,'IEEE','IEEE Conferences',0),(698,'Behavioral Log Analysis with Statistical Guarantees',5,877,887,'Scalability is a major challenge for existing behavioral log analysis algorithms, which extract finite-state automaton models or temporal properties from logs generated by running systems. In this paper we present statistical log analysis, which addresses scalability using statistical tools. The key to our approach is to consider behavioral log analysis as a statistical experiment.Rather than analyzing the entire log, we suggest to analyze only a sample of traces from the log and, most importantly, provide means to compute statistical guarantees for the correctness of the analysis result.We present the theoretical foundations of our approach and describe two example applications, to the classic k-Tails algorithm and to the recently presented BEAR algorithm.Finally, based on experiments with logs generated from real-world models and with real-world logs provided to us by our industrial partners, we present extensive evidence for the need for scalable log analysis and for the effectiveness of statistical log analysis.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886964','10.1145/2884781.2884805',36,6,'IEEE','IEEE Conferences',0),(699,'Traceability in the Wild: Automatically Augmenting Incomplete Trace Links',1,834,845,'Software and systems traceability is widely accepted as an essential element for supporting many software development tasks. Today\'s version control systems provide inbuilt features that allow developers to tag each commit with one or more issue ID, thereby providing the building blocks from which project-wide traceability can be established between feature requests, bug fixes, commits, source code, and specific developers. However, our analysis of six open source projects showed that on average only 60% of the commits were linked to specific issues. Without these fundamental links the entire set of project-wide links will be incomplete, and therefore not trustworthy. In this paper we address the fundamental problem of missing links between commits and issues. Our approach leverages a combination of process and text-related features characterizing issues and code changes to train a classifier to identify missing issue tags in commit messages, thereby generating the missing links. We conducted a series of experiments to evaluate our approach against six open source projects and showed that it was able to effectively recommend links for tagging issues at an average of 96% recall and 33% precision. In a related task for augmenting a set of existing trace links, the classifier returned precision at levels greater than 89% in all projects and recall of 50%.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453157','10.1145/3180155.3180207',63,5,'IEEE','IEEE Conferences',0),(700,'Symbolic Verification of Regular Properties',1,871,881,'Verifying the regular properties of programs has been a significant challenge. This paper tackles this challenge by presenting symbolic regular verification (SRV) that offers significant speedups over the state-of-the-art. SRV is based on dynamic symbolic execution (DSE) and enabled by novel techniques for mitigating path explosion: (1) a regular property-oriented path slicing algorithm, and (2) a synergistic combination of property-oriented path slicing and guiding. Slicing prunes redundant paths, while guiding boosts the search for counterexamples. We have implemented SRV for Java and evaluated it on 15 real-world open-source Java programs (totaling 259K lines of code). Our evaluation results demonstrate the effectiveness and efficiency of SRV. Compared with the state-of-the-art - pure DSE, pure guiding, and pure path slicing - SRV achieves average speedups of more than 8.4X, 8.6X, and 7X, respectively, making symbolic regular property verification significantly more practical.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453161','10.1145/3180155.3180227',49,0,'IEEE','IEEE Conferences',0),(701,'Disseminating Architectural Knowledge on Open-Source Projects: A Case Study of the Book \'Architecture of Open-Source Applications\'',5,476,487,'This paper reports on an interview-based study of 18 authors of different chapters of the two-volume book \'Architecture of Open-Source Applications\'. The main contributions are a synthesis of the process of authoring essay-style documents (ESDs) on software architecture, a series of observations on important factors that influence the content and presentation of architectural knowledge in this documentation form, and a set of recommendations for readers and writers of ESDs on software architecture. We analyzed the influence of three factors in particular: the evolution of a system, the community involvement in the project, and the personal characteristics of the author. This study provides the first systematic investigation of the creation of ESDs on software architecture. The observations we collected have implications for both readers and writers of ESDs, and for architecture documentation in general.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886927','10.1145/2884781.2884792',58,1,'IEEE','IEEE Conferences',0),(702,'Comparing White-Box and Black-Box Test Prioritization',5,523,534,'Although white-box regression test prioritization has been well-studied, the more recently introduced black-box prioritization approaches have neither been compared against each other nor against more well-established white-box techniques. We present a comprehensive experimental comparison of several test prioritization techniques, including well-established white-box strategies and more recently introduced black-box approaches. We found that Combinatorial Interaction Testing and diversity-based techniques (Input Model Diversity and Input Test Set Diameter) perform best among the black-box approaches. Perhaps surprisingly, we found little difference between black-box and white-box performance (at most 4% fault detection rate difference). We also found the overlap between black- and white-box faults to be high: the first 10% of the prioritized test suites already agree on at least 60% of the faults found. These are positive findings for practicing regression testers who may not have source code available, thereby making white-box techniques inapplicable. We also found evidence that both black-box and white-box prioritization remain robust over multiple system releases.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886931','10.1145/2884781.2884791',69,25,'IEEE','IEEE Conferences',0),(703,'Inferring and Asserting Distributed System Invariants',1,1149,1159,'Distributed systems are difficult to debug and understand. A key reason for this is distributed state, which is not easily accessible and must be pieced together from the states of the individual nodes in the system. We propose Dinv, an automatic approach to help developers of distributed systems uncover the runtime distributed state properties of their systems. Dinv uses static and dynamic program analyses to infer relations between variables at different nodes. For example, in a leader election algorithm, Dinv can relate the variable leader at different nodes to derive the invariant forall 鈭� nodes i, j, leader_i = leader_j. This can increase the developer\'s confidence in the correctness of their system. The developer can also use Dinv to convert an inferred invariant into a distributed runtime assertion on distributed state. We applied Dinv to several popular distributed systems, such as etcd Raft, Hashicorp Serf, and Taipei-Torrent, which have between 1.7K and 144K LOC and are widely used. Dinv derived useful invariants for these systems, including invariants that capture the correctness of distributed routing strategies, leadership, and key hash distribution. We also used Dinv to assert correctness of the inferred etcd Raft invariants at runtime, using these asserts to detect injected silent bugs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453196','10.1145/3180155.3180199',59,1,'IEEE','IEEE Conferences',0),(704,'The Emerging Role of Data Scientists on Software Development Teams',5,96,107,'Creating and running software produces large amounts of raw data about the development process and the customer usage, which can be turned into actionable insight with the help of skilled data scientists. Unfortunately, data scientists with the analytical and software engineering skills to analyze these large data sets have been hard to come by; only recently have software companies started to develop competencies in software-oriented data analytics. To understand this emerging role, we interviewed data scientists across several product groups at Microsoft. In this paper, we describe their education and training background, their missions in software engineering contexts, and the type of problems on which they work. We identify five distinct working styles of data scientists: (1) Insight Providers, who work with engineers to collect the data needed to inform decisions that managers make; (2) Modeling Specialists, who use their machine learning expertise to build predictive models; (3) Platform Builders, who create data platforms, balancing both engineering and data analysis concerns; (4) Polymaths, who do all data science activities themselves; and (5) Team Leaders, who run teams of data scientists and spread best practices. We further describe a set of strategies that they employ to increase the impact and actionability of their work.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886895','10.1145/2884781.2884783',49,14,'IEEE','IEEE Conferences',0),(705,'Understanding Developers\' Needs on Deprecation as a Language Feature',1,561,571,'Deprecation is a language feature that allows API producers to mark a feature as obsolete. We aim to gain a deep understanding of the needs of API producers and consumers alike regarding deprecation. To that end, we investigate why API producers deprecate features, whether they remove deprecated features, how they expect consumers to react, and what prompts an API consumer to react to deprecation. To achieve this goal we conduct semi-structured interviews with 17 third-party Java API producers and survey 170 Java developers. We observe that the current deprecation mechanism in Java and the proposal to enhance it does not address all the needs of a developer. This leads us to propose and evaluate three further enhancements to the deprecation mechanism.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453124','10.1145/3180155.3180170',0,2,'IEEE','IEEE Conferences',0),(706,'Towards Optimal Concolic Testing',1,291,302,'Concolic testing integrates concrete execution (e.g., random testing) and symbolic execution for test case generation. It is shown to be more cost-effective than random testing or symbolic execution sometimes. A concolic testing strategy is a function which decides when to apply random testing or symbolic execution, and if it is the latter case, which program path to symbolically execute. Many heuristics-based strategies have been proposed. It is still an open problem what is the optimal concolic testing strategy. In this work, we make two contributions towards solving this problem. First, we show the optimal strategy can be defined based on the probability of program paths and the cost of constraint solving. The problem of identifying the optimal strategy is then reduced to a model checking problem of Markov Decision Processes with Costs. Secondly, in view of the complexity in identifying the optimal strategy, we design a greedy algorithm for approximating the optimal strategy. We conduct two sets of experiments. One is based on randomly generated models and the other is based on a set of C programs. The results show that existing heuristics have much room to improve and our greedy algorithm often outperforms existing heuristics.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453088','10.1145/3180155.3180177',0,1,'IEEE','IEEE Conferences',0),(707,'Program Splicing',1,338,349,'We introduce program splicing, a programming methodology that aims to automate the work ow of copying, pasting, and modifying code available online. Here, the programmer starts by writing a \'draft\' that mixes un nished code, natural language comments, and correctness requirements. A program synthesizer that interacts with a large, searchable database of program snippets is used to automatically complete the draft into a program that meets the re-quirements. The synthesis process happens in two stages. First, the synthesizer identi es a small number of programs in the database that are relevant to the synthesis task. Next it uses an enumerative search to systematically ll the draft with expressions and statements from these relevant programs. The resulting program is returned to the programmer, who can modify it and possibly invoke additional rounds of synthesis. We present an implementation of program splicing, called Splicer, for the Java programming language. Splicer uses a corpus of over 3.5 million procedures from an open-source software repository. Our evaluation uses the system in a suite of everyday programming tasks, and includes a comparison with a state-of-the-art competing approach as well as a user study. The results point to the broad scope and scalability of program splicing and indicate that the approach can signi cantly boost programmer productivity.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453092','10.1145/3180155.3180190',0,0,'IEEE','IEEE Conferences',0),(708,'Feedback-Directed Instrumentation for Deployed JavaScript Applications',5,899,910,'Many bugs in JavaScript applications manifest themselves as objects that have incorrect property values when a failure occurs. For this type of error, stack traces and log files are often insufficient for diagnosing problems. In such cases, it is helpful for developers to know the control flow path from the creation of an object to a crashing statement. Such crash paths are useful for understanding where the object originated and whether any properties of the object were corrupted since its creation.We present a feedback-directed instrumentation technique for computing crash paths that allows the instrumentation overhead to be distributed over a crowd of users and to reduce it for users who do not encounter the crash. We implemented our technique in a tool, Crowdie, and evaluated it on 10 real-world issues for which error messages and stack traces are insufficient to isolate the problem. Our results show that feedback-directed instrumentation requires 5% to 25% of the program to be instrumented, that the same crash must be observed 3 to 10 times to discover the crash path, and that feedback-directed instrumentation typically slows down execution by a factor 2x-9x compared to 8x-90x for an approach where applications are fully instrumented.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886966','10.1145/2884781.2884846',32,3,'IEEE','IEEE Conferences',0),(709,'Finding Security Bugs in Web Applications Using a Catalog of Access Control Patterns',5,947,958,'We propose a specification-free technique for finding missing security checks in web applications using a catalog of access control patterns in which each pattern models a common access control use case. Our implementation, SPACE, checks that every data exposure allowed by an application\'s code matches an allowed exposure from a security pattern in our catalog. The only user-provided input is a mapping from application types to the types of the catalog; the rest of the process is entirely automatic. In an evaluation on the 50 most watched Ruby on Rails applications on Github, SPACE reported 33 possible bugs---23 previously unknown security bugs, and 10 false positives.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886970','10.1145/2884781.2884836',37,3,'IEEE','IEEE Conferences',0),(710,'Context-Aware Patch Generation for Better Automated Program Repair',1,1,11,'The effectiveness of search-based automated program repair is limited in the number of correct patches that can be successfully generated. There are two causes of such limitation. First, the search space does not contain the correct patch. Second, the search space is huge and therefore the correct patch cannot be generated (ie correct patches are either generated after incorrect plausible ones or not generated within the time budget). To increase the likelihood of including the correct patches in the search space, we propose to work at a fine granularity in terms of AST nodes. This, however, will further enlarge the search space, increasing the challenge to find the correct patches. We address the challenge by devising a strategy to prioritize the candidate patches based on their likelihood of being correct. Specifically, we study the use of AST nodes\' context information to estimate the likelihood. In this paper, we propose CapGen, a context-aware patch generation technique. The novelty which allows CapGen to produce more correct patches lies in three aspects: (1) The fine-granularity design enables it to find more correct fixing ingredients; (2) The context-aware prioritization of mutation operators enables it to constrain the search space; (3) Three context-aware models enable it to rank correct patches at high positions before incorrect plausible ones. We evaluate CapGen on Defects4J and compare it with the state-of-the-art program repair techniques. Our evaluation shows that CapGen outperforms and complements existing techniques. CapGen achieves a high precision of 84.00% and can prioritize the correct patches before 98.78% of the incorrect plausible ones.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453055','10.1145/3180155.3180233',58,18,'IEEE','IEEE Conferences',0),(711,'Decoupling Level: A New Metric for Architectural Maintenance Complexity',5,499,510,'Despite decades of research on software metrics, we still cannot reliably measure if one design is more maintainable than another. Software managers and architects need to understand whether their software architecture is \'good enough\', whether it is decaying over time and, if so, by how much. In this paper, we contribute a new architecture maintainability metric---Decoupling Level (DL)---derived from Baldwin andClark\'s option theory. Instead of measuring how coupled an architecture is, we measure how well the software can be decoupled into small and independently replaceable modules. We measured the DL for 108 open source projects and 21 industrial projects, each of which has multiple releases. Our main result shows that the larger the DL, the better thearchitecture. By \'better\' we mean: the more likely bugs and changes can be localized and separated, and the more likely that developers can make changes independently. The DL metric also opens the possibility of quantifying canonical principles of single responsibility and separation of concerns, aiding cross-project comparison and architecture decay monitoring.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886929','10.1145/2884781.2884825',39,14,'IEEE','IEEE Conferences',0),(712,'The Impact of Test Case Summaries on Bug Fixing Performance: An Empirical Investigation',5,547,558,'Automated test generation tools have been widely investigated with the goal of reducing the cost of testing activities. However, generated tests have been shownnot to help developers in detecting and finding more bugs even though they reach higher structural coverage compared to manual testing. The main reason is that generated tests are difficult to understand and maintain. Our paper proposes an approach, coined TestDescriber, which automatically generates test case summaries of the portion of code exercised by each individual test, thereby improving understandability. We argue that this approach can complement the current techniques around automated unit test generation or search-based techniques designed to generate a possibly minimal set of test cases. In evaluating our approach we found that (1) developers find twice as many bugs, and (2) test case summaries significantly improve the comprehensibility of test cases, which is considered particularly useful by developers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886933','10.1145/2884781.2884847',57,16,'IEEE','IEEE Conferences',0),(713,'Grounded Theory in Software Engineering Research: A Critical Review and Guidelines',5,120,131,'Grounded Theory (GT) has proved an extremely useful research approach in several fields including medical sociology, nursing, education and management theory. However, GT is a complex method based on an inductive paradigm that is fundamentally different from the traditional hypothetico-deductive research model. As there are at least three variants of GT, some ostensibly GT research suffers from method slurring, where researchers adopt an arbitrary subset of GT practices that are not recognizable as GT. In this paper, we describe the variants of GT and identify the core set of GT practices. We then analyze the use of grounded theory in software engineering. We carefully and systematically selected 98 articles that mention GT, of which 52 explicitly claim to use GT, with the other 46 using GT techniques only. Only 16 articles provide detailed accounts of their research procedures. We offer guidelines to improve the quality of both conducting and reporting GT studies. The latter is an important extension since current GT guidelines in software engineering do not cover the reporting process, despite good reporting being necessary for evaluating a study and informing subsequent research.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886897','10.1145/2884781.2884833',78,33,'IEEE','IEEE Conferences',0),(714,'UFO: Predictive Concurrency Use-After-Free Detection',1,609,619,'Use-After-Free (UAF) vulnerabilities are caused by the program operating on a dangling pointer and can be exploited to compromise critical software systems. While there have been many tools to mitigate UAF vulnerabilities, UAF remains one of the most common attack vectors. UAF is particularly di cult to detect in concurrent programs, in which a UAF may only occur with rare thread schedules. In this paper, we present a novel technique, UFO, that can precisely predict UAFs based on a single observed execution trace with a provably higher detection capability than existing techniques with no false positives. The key technical advancement of UFO is an extended maximal thread causality model that captures the largest possible set of feasible traces that can be inferred from a given multithreaded execution trace. By formulating UAF detection as a constraint solving problem atop this model, we can explore a much larger thread scheduling space than classical happens-before based techniques. We have evaluated UFO on several real-world large complex C/C++ programs including Chromium and FireFox. UFO scales to real-world systems with hundreds of millions of events in their execution and has detected a large number of real concurrency UAFs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453130','10.1145/3180155.3180225',0,2,'IEEE','IEEE Conferences',0),(715,'Perses: Syntax-Guided Program Reduction',1,361,371,'Given a program P that exhibits a certain property 蠄 (e.g., a C program that crashes GCC when it is being compiled), the goal of program reduction is to minimize P to a smaller variant P? that still exhibits the same property, i.e., 蠄(P\'). Program reduction is important and widely demanded for testing and debugging. For example, all compiler/interpreter development projects need effective program reduction to minimize failure-inducing test programs to ease debugging. However, state-of-the-art program reduction techniques - notably Delta Debugging (DD), Hierarchical Delta Debugging (HDD), and C-Reduce - do not perform well in terms of speed (reduction time) and quality (size of reduced programs), or are highly customized for certain languages and thus lack generality. This paper presents Perses, a novel framework for effective, efficient, and general program reduction. The key insight is to exploit, in a general manner, the formal syntax of the programs under reduction and ensure that each reduction step considers only smaller, syntactically valid variants to avoid futile efforts on syntactically invalid variants. Our framework supports not only deletion (as for DD and HDD), but also general, effective program transformations. We have designed and implemented Perses, and evaluated it for two language settings: C and Java. Our evaluation results on 20 C programs triggering bugs in GCC and Clang demonstrate Perses\'s strong practicality compared to the state-of-the-art: (1) smaller size - Perses\'s results are respectively 2% and 45% in size of those from DD and HDD; and (2) shorter reduction time - Perses takes 23% and 47% time taken by DD and HDD respectively. Even when compared to the highly customized and optimized C-Reduce for C/C++, Perses takes only 38-60% reduction time.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453094','10.1145/3180155.3180236',0,2,'IEEE','IEEE Conferences',0),(716,'Automated Partitioning of Android Applications for Trusted Execution Environments',5,923,934,'The co-existence of critical and non-critical applications on computing devices, such as mobile phones, is becoming commonplace. The sensitive segments of a critical application should be executed in isolation on Trusted Execution Environments (TEE) so that the associated code and data can be protected from malicious applications. TEE is supported by different technologies and platforms, such as ARM Trustzone, that allow logical separation of \'secure\' and \'normal\' worlds. We develop an approach for automated partitioning of critical Android applications into \'client\' code to be run in the \'normal\' world and \'TEE commands\' encapsulating the handling of confidential data to be run in the \'secure\' world. We also reduce the overhead due to transitions between the two worlds by choosing appropriate granularity for the TEE commands. The advantage of our proposed solution is evidenced by efficient partitioning of real-world applications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886968','10.1145/2884781.2884817',42,1,'IEEE','IEEE Conferences',0),(717,'Building a Theory of Job Rotation in Software Engineering from an Instrumental Case Study',5,971,981,'Job Rotation is an organizational practice in which individuals are frequently moved from a job (or project) to another in the same organization. Studies in other areas have found that this practice has both negative and positive effects on individuals\' work. However, there are only few studies addressing this issue in software engineering so far. The goal of our study is to investigate the effects of job rotation on work related factors in software engineering by performing a qualitative case study on a large software organization that uses job rotation as an organizational practice. We interviewed senior managers, project managers, and software engineers that had experienced this practice. Altogether, 48 participants were involved in all phases of this research. Collected data was analyzed using qualitative coding techniques and the results were checked and validated with participants through member checking. Our findings suggest that it is necessary to find balance between the positive effects on work variety and learning opportunities, and negative effects on cognitive workload and performance. Further, the lack of feedback resulting from constant movement among projects and teams may have a negative impact on performance feedback. We conclude that job rotation is an important organizational practice with important positive results. However, managers must be aware of potential negative effects and deploy tactics to balance them. We discuss such tactics in this article.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886972','10.1145/2884781.2884837',39,2,'IEEE','IEEE Conferences',0),(718,'Synthesizing Framework Models for Symbolic Execution',5,156,167,'Symbolic execution is a powerful program analysis technique, but it is difficult to apply to programs built using frameworks such as Swing and Android, because the framework code itself is hard to symbolically execute. The standard solution is to manually create a framework model that can be symbolically executed, but developing and maintaining a model is difficult and error-prone. In this paper, we present Pasket, a new system that takes a first step toward automatically generating Java framework models to support symbolic execution. Pasket\'s focus is on creating models by instantiating design patterns. Pasket takes as input class, method, and type information from the framework API, together with tutorial programs that exercise the framework. From these artifacts and Pasket\'s internal knowledge of design patterns, Pasket synthesizes a framework model whose behavior on the tutorial programs matches that of the original framework. We evaluated Pasket by synthesizing models for subsets of Swing and Android. Our results show that the models derived by Pasket are sufficient to allow us to use off-the-shelf symbolic execution tools to analyze Java programs that rely on frameworks.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886900','10.1145/2884781.2884856',40,3,'IEEE','IEEE Conferences',0),(719,'MobiPlay: A Remote Execution Based Record-and-Replay Tool for Mobile Applications',5,571,582,'The record-and-replay approach for software testing is important and valuable for developers in designing mobile applications. However, the existing solutions for recording and replaying Android applications are far from perfect. When considering the richness of mobile phones\' input capabilities including touch screen, sensors, GPS, etc., existing approaches either fall short of covering all these different input types, or require elevated privileges that are not easily attained and can be dangerous. In this paper, we present a novel system, called MobiPlay, which aims to improve record-and-replay testing. By collaborating between a mobile phone and a server, we are the first to capture all possible inputs by doing so at the application layer, instead of at the Android framework layer or the Linux kernel layer, which would be infeasible without a server. MobiPlay runs the to-be-tested application on the server under exactly the same environment as the mobile phone, and displays the GUI of the application in real time on a thin client application installed on the mobile phone. From the perspective of the mobile phone user, the application appears to be local. We have implemented our system and evaluated it with tens of popular mobile applications showing that MobiPlay is efficient, flexible, and comprehensive. It can record all input data, including all sensor data, all touchscreen gestures, and GPS. It is able to record and replay on both the mobile phone and the server. Furthermore, it is suitable for both white-box and black-box testing.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886935','10.1145/2884781.2884854',36,14,'IEEE','IEEE Conferences',0),(720,'Guiding Dynamic Symbolic Execution toward Unverified Program Executions',5,144,155,'Most techniques to detect program errors, such as testing, code reviews, and static program analysis, do not fully verify all possible executions of a program. They leave executions unverified when they do not check certain properties, fail to verify properties, or check properties under certain unsound assumptions such as the absence of arithmetic overflow. In this paper, we present a technique to complement partial verification results by automatic test case generation. In contrast to existing work, our technique supports the common case that the verification results are based on unsound assumptions. We annotate programs to reflect which executions have been verified, and under which assumptions. These annotations are then used to guide dynamic symbolic execution toward unverified program executions. Our main technical contribution is a code instrumentation that causes dynamic symbolic execution to abort tests that lead to verified executions, to prune parts of the search space, and to prioritize tests that cover more properties that are not fully verified. We have implemented our technique for the .NET static analyzer Clousot and the dynamic symbolic execution tool Pex. It produces smaller test suites (by up to 19.2%), covers more unverified executions (by up to 7.1%), and reduces testing time (by up to 52.4%) compared to combining Clousot and Pex without our technique.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886899','10.1145/2884781.2884843',41,5,'IEEE','IEEE Conferences',0),(721,'Dataflow Tunneling: Mining Inter-Request Data Dependencies for Request-Based Applications',1,586,597,'Request-based applications, e.g., most server-side applications, expose services to users in a request-based paradigm, in which requests are served by request-handler methods. An important task for request-based applications is inter-request analysis, which analyzes request-handler methods that are related by inter-request data dependencies together. However, in the request-based paradigm, data dependencies between related request-handler methods are implicitly established by the underlying frameworks that execute these methods. As a result, existing analysis tools are usually limited to the scope of each single method without the knowledge of dependencies between different methods. In this paper, we design an approach called dataflow tunneling to capture inter-request data dependencies from concrete application executions and produce data-dependency specifications. Our approach answers two key questions: (1) what request-handler methods have data dependencies and (2) what these data dependencies are. Our evaluation using applications developed with two representative and popular frameworks shows that our approach is general and accurate. We also present a characteristic study and a use case of cache tuning based on the mined specifications. We envision that our approach can provide key information to enable future inter-request analysis techniques.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453128','10.1145/3180155.3180171',59,0,'IEEE','IEEE Conferences',0),(722,'Statistical Learning of API Fully Qualified Names in Code Snippets of Online Forums',1,632,642,'Software developers often make use of the online forums such as StackOverflow to learn how to use software libraries and their APIs. However, the code snippets in such a forum often contain undeclared, ambiguous, or largely unqualified external references. Such declaration ambiguity and external reference ambiguity present challenges for developers in learning to correctly use the APIs. In this paper, we propose StatType, a statistical approach to resolve the fully qualified names (FQNs) for the API elements in such code snippets. Unlike existing approaches that are based on heuristics, StatType has two well-integrated factors. We first learn from a large training code corpus the FQNs that often co-occur. Then, to derive the FQN for an API name in a code snippet, we use that knowledge and leverage the context consisting of neighboring API names. To realize those factors, we treat the problem as statistical machine translation from source code with partially qualified names to source code with FQNs of the APIs. Our empirical evaluation on real-world code and StackOverflow posts shows that StatType achieves very high accuracy with 97.6% precision and 96.7% recall, which is 16.5% relatively higher than the state-of-the-art approach.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453132','10.1145/3180155.3180230',0,3,'IEEE','IEEE Conferences',0),(723,'StubDroid: Automatic Inference of Precise Data-Flow Summaries for the Android Framework',5,725,735,'Smartphone users suffer from insucient information on how commercial as well as malicious apps handle sensitive data stored on their phones. Automated taint analyses address this problem by allowing users to detect and investigate how applications access and handle this data. A current problem with virtually all those analysis approaches is, though, that they rely on explicit models of the Android runtime library. In most cases, the existence of those models is taken for granted, despite the fact that the models are hard to come by: Given the size and evolution speed of a modern smartphone operating system it is prohibitively expensive to derive models manually from code or documentation. In this work, we therefore present StubDroid, the first fully automated approach for inferring precise and efficient library models for taint-analysis problems. StubDroid automatically constructs these summaries from a binary distribution of the library. In our experiments, we use StubDroid-inferred models to prevent the static taint analysis FlowDroid from having to re-analyze the Android runtime library over and over again for each analyzed app. As the results show, the models make it possible to analyze apps in seconds whereas most complete re-analyses would time out after 30 minutes. Yet, StubDroid yields comparable precision. In comparison to manually crafted summaries, StubDroid\'s cause the analysis to be more precise and to use less time and memory.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886831','10.1145/2884781.2884816',22,6,'IEEE','IEEE Conferences',0),(724,'EnMobile: Entity-Based Characterization and Analysis of Mobile Malware',1,384,394,'Modern mobile malware tend to conduct their malicious exploits through sophisticated patterns of interactions that involve multiple entities, e.g., the mobile platform, human users, and network locations. Such malware often evade the detection by existing approaches due to their limited expressiveness and accuracy in characterizing and detecting these malware. To address these issues, in this paper, we recognize entities in the environment of an app, the app\'s interactions with such entities, and the provenance of these interactions, i.e., the intent and ownership of each interaction, as the key to comprehensively characterizing modern mobile apps, and mobile malware in particular. With this insight, we propose a novel approach named EnMobile including a new entity-based characterization of mobile-app behaviors, and corresponding static analyses, to accurately characterize an app\'s interactions with entities. We implement EnMobile and provide a practical application of EnMobile in a signature-based scheme for detecting mobile malware. We evaluate EnMobile on a set of 6614 apps consisting of malware from Genome and Drebin along with benign apps from Google Play. Our results show that EnMobile detects malware with substantially higher precision and recall than four state-of-the-art approaches, namely Apposcopy, Drebin, MUDFLOW, and AppContext.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453096','10.1145/3180155.3180223',0,5,'IEEE','IEEE Conferences',0),(725,'The Sky Is Not the Limit: Multitasking Across GitHub Projects',5,994,1005,'Software development has always inherently required multitasking: developers switch between coding, reviewing, testing, designing, and meeting with colleagues. The advent of software ecosystems like GitHub has enabled something new: the ability to easily switch between projects. Developers also have social incentives to contribute to many projects; prolific contributors gain social recognition and (eventually) economic rewards. Multitasking, however, comes at a cognitive cost: frequent context-switches can lead to distraction, sub-standard work, and even greater stress. In this paper, we gather ecosystem-level data on a group of programmers working on a large collection of projects. We develop models and methods for measuring the rate and breadth of a developers\' context-switching behavior, and we study how context-switching affects their productivity. We also survey developers to understand the reasons for and perceptions of multitasking. We find that the most common reason for multitasking is interrelationships and dependencies between projects. Notably, we find that the rate of switching and breadth (number of projects) of a developer\'s work matter. Developers who work on many projects have higher productivity if they focus on few projects per day. Developers that switch projects too much during the course of a day have lower productivity as they work on more projects overall. Despite these findings, developers perceptions of the benefits of multitasking are varied.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886974','10.1145/2884781.2884875',60,15,'IEEE','IEEE Conferences',0),(726,'An Empirical Comparison of Compiler Testing Techniques',5,180,190,'Compilers, as one of the most important infrastructure of today\'s digital world, are expected to be trustworthy. Different testing techniques are developed for testing compilers automatically. However, it is unknown so far how these testing techniques compared to each other in terms of testing effectiveness: how many bugs a testing technique can find within a time limit. In this paper, we conduct a systematic and comprehensive empirical comparison of three compiler testing techniques, namely, Randomized Differential Testing (RDT), a variant of RDT-Different Optimization Levels (DOL), and Equivalence Modulo Inputs (EMI). Our results show that DOL is more effective at detecting bugs related to optimization, whereas RDT is more effective at detecting other types of bugs, and the three techniques can complement each other to a certain degree. Furthermore, in order to understand why their effectiveness differs, we investigate three factors that influence the effectiveness of compiler testing, namely, efficiency, strength of test oracles, and effectiveness of generated test programs. The results indicate that all the three factors are statistically significant, and efficiency has the most significant impact.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886902','10.1145/2884781.2884878',32,9,'IEEE','IEEE Conferences',0),(727,'Software Protection on the Go: A Large-Scale Empirical Study on Mobile App Obfuscation',1,26,36,'The prosperity of smartphone markets has raised new concerns about software security on mobile platforms, leading to a growing demand for effective software obfuscation techniques. Due to various differences between the mobile and desktop ecosystems, obfuscation faces both technical and non-technical challenges when applied to mobile software. Although there have been quite a few software security solution providers launching their mobile app obfuscation services, it is yet unclear how real-world mobile developers perform obfuscation as part of their software engineering practices. Our research takes a first step to systematically studying the deployment of software obfuscation techniques in mobile software development. With the help of an automated but coarse-grained method, we computed the likelihood of an app being obfuscated for over a million app samples crawled from Apple App Store. We then inspected the top 6600 instances and managed to identify 601 obfuscated versions of 539 iOS apps. By analyzing this sample set with extensive manual effort, we made various observations that reveal the status quo of mobile obfuscation in the real world, providing insights into understanding and improving the situation of software protection on mobile platforms.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453059','10.1145/3180155.3180169',0,0,'IEEE','IEEE Conferences',0),(728,'Neuro-Symbolic Program Corrector for Introductory Programming Assignments',1,60,70,'Automatic correction of programs is a challenging problem with numerous real world applications in security, verification, and education. One application that is becoming increasingly important is the correction of student submissions in online courses for providing feedback. Most existing program repair techniques analyze Abstract Syntax Trees (ASTs) of programs, which are unfortunately unavailable for programs with syntax errors. In this paper, we propose a novel Neuro-symbolic approach that combines neural networks with constraint-based reasoning. Specifically, our method first uses a Recurrent Neural Network (RNN) to perform syntax repairs for the buggy programs; subsequently, the resulting syntactically-fixed programs are repaired using constraint-based techniques to ensure functional correctness. The RNNs are trained using a corpus of syntactically correct submissions for a given programming assignment, and are then queried to fix syntax errors in an incorrect programming submission by replacing or inserting the predicted tokens at the error location. We evaluate our technique on a dataset comprising of over 14,500 student submissions with syntax errors. Our method is able to repair syntax errors in 60% (8689) of submissions, and finds functionally correct repairs for 23.8% (3455) submissions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453063','10.1145/3180155.3180219',0,0,'IEEE','IEEE Conferences',0),(729,'Automated Test Suite Generation for Time-Continuous Simulink Models',5,595,606,'All engineering disciplines are founded and rely on models, although they may differ on purposes and usages of modeling. Interdisciplinary domains such as Cyber Physical Systems (CPSs) seek approaches that incorporate different modeling needs and usages. Specifically, the Simulink modeling platform greatly appeals to CPS engineers due to its seamless support for simulation and code generation. In this paper, we propose a test generation approach that is applicable to Simulink models built for both purposes of simulation and code generation. We define test inputs and outputs as signals that capture evolution of values over time. Our test generation approach is implemented as a meta-heuristic search algorithm and is guided to produce test outputs with diverse shapes according to our proposed notion of diversity. Our evaluation, performed on industrial and public domain models, demonstrates that: (1) In contrast to the existing tools for testing Simulink models that are only applicable to a subset of code generation models, our approach is applicable to both code generation and simulation Simulink models. (2) Our new notion of diversity for output signals outperforms random baseline testing and an existing notion of signal diversity in revealing faults in Simulink models. (3) The fault revealing ability of our test generation approach outperforms that of the Simulink Design Verifier, the only testing toolbox for Simulink.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886937','10.1145/2884781.2884797',61,10,'IEEE','IEEE Conferences',0),(730,'A Comparison of 10 Sampling Algorithms for Configurable Systems',5,643,654,'Almost every software system provides configuration options to tailor the system to the target platform and application scenario. Often, this configurability renders the analysis of every individual system configuration infeasible. To address this problem, researchers have proposed a diverse set of sampling algorithms. We present a comparative study of 10 state-of-the-art sampling algorithms regarding their fault-detection capability and size of sample sets. The former is important to improve software quality and the latter to reduce the time of analysis. In a nutshell, we found that sampling algorithms with larger sample sets are able to detect higher numbers of faults, but simple algorithms with small sample sets, such as most-enabled-disabled, are the most efficient in most contexts. Furthermore, we observed that the limiting assumptions made in previous work influence the number of detected faults, the size of sample sets, and the ranking of algorithms. Finally, we have identified a number of technical challenges when trying to avoid the limiting assumptions, which questions the practicality of certain sampling algorithms.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886941','10.1145/2884781.2884793',58,13,'IEEE','IEEE Conferences',0),(731,'Deuce: A Lightweight User Interface for Structured Editing',1,654,664,'We present a structure-aware code editor, called Deuce, that is equipped with direct manipulation capabilities for invoking automated program transformations. Compared to traditional refactoring environments, Deuce employs a direct manipulation interface that is tightly integrated within a text-based editing workflow. In particular, Deuce draws (i) clickable widgets atop the source code that allow the user to structurally select the unstructured text for subexpressions and other relevant features, and (ii) a lightweight, interactive menu of potential transformations based on the current selections. We implement and evaluate our design with mostly standard transformations in the context of a small functional programming language. A controlled user study with 21 participants demonstrates that structural selection is preferred to a more traditional text-selection interface and may be faster overall once users gain experience with the tool. These results accord with Deuce\'s aim to provide human-friendly structural interactions on top of familiar text-based editing.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453134','10.1145/3180155.3180165',0,0,'IEEE','IEEE Conferences',0),(732,'Quality Experience: A Grounded Theory of Successful Agile Projects without Dedicated Testers',5,1017,1027,'Context: While successful conventional software development regularly employs separate testing staff, there are successful agile teams with as well as without separate testers. Question: How does successful agile development work without separate testers? What are advantages and disadvantages? Method: A case study, based on Grounded Theory evaluation of interviews and direct observation of three agile teams; one having separate testers, two without. All teams perform long-term development of parts of e-business web portals. Results: Teams without testers use a quality experience work mode centered around a tight field-use feedback loop, driven by a feeling of responsibility, supported by test automation, resulting in frequent deployments. Conclusion: In the given domain, hand-overs to separate testers appear to hamper the feedback loop more than they contribute to quality, so working without testers is preferred. However, Quality Experience is achievable only with modular architectures and in suitable domains.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886976','10.1145/2884781.2884789',27,1,'IEEE','IEEE Conferences',0),(733,'Big problems in industry (panel)',6,3,3,'Software Engineering in practice deals with scale in a variety of dimensions. We build large scale systems operating on vast amount of data. We have millions of customers with billions of queries and transactions. We have distributed teams making thousands of changes, running millions of tests and releasing multiple times per day. These dimensions of scale interact to provide challenges for software development tools and processes. The panelists will describe the challenging aspects of scale in their specific problem domains and discuss which software engineering methods work and which leave room for improvement.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693060','10.1109/ASE.2013.6693060',0,1,'IEEE','IEEE Conferences',0),(734,'Toward Practical Automatic Program Repair',7,1262,1264,'Automated program repair (APR) reduces the burden of debugging by directly suggesting likely fixes for the bugs. We believe scalability, applicability, and accurate patch validation are among the main challenges for building practical APR techniques that the researchers in this area are dealing with. In this paper, we describe the steps that we are taking toward addressing these challenges.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952355','10.1109/ASE.2019.00156',54,0,'IEEE','IEEE Conferences',0),(735,'TsmartGP: A Tool for Finding Memory Defects with Pointer Analysis',7,1170,1173,'Precise pointer analysis is desired since it is a core technique to find memory defects. There are several dimensions of pointer analysis precision, flow sensitivity, context sensitivity, field sensitivity and path sensitivity. For static analysis tools utilizing pointer analysis, considering all dimensions is difficult because the trade-off between precision and efficiency should be balanced. This paper presents TsmartGP, a static analysis tool for finding memory defects in C programs with a precise and efficient pointer analysis. The pointer analysis algorithm is flow, context, field, and quasi path sensitive. Control flow automatons are the key structures for our analysis to be flow sensitive. Function summaries are applied to get context information and elements of aggregate structures are handled to improve precision. Path conditions are used to filter unreachable paths. For efficiency, a multi-entry mechanism is proposed. Utilizing the pointer analysis algorithm, we implement a checker in TsmartGP to find uninitialized pointer errors in 13 real-world applications. Cppcheck and Clang Static Analyzer are chosen for comparison. The experimental results show that TsmartGP can find more errors while its accuracy is also higher than Cppcheck and Clang Static Analyzer.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952426','10.1109/ASE.2019.00129',12,0,'IEEE','IEEE Conferences',0),(736,'Retrieve and Refine: Exemplar-Based Neural Comment Generation',7,1250,1252,'Code comment generation is a crucial task in the field of automatic software development. Most previous neural comment generation systems used an encoder-decoder neural network and encoded only information from source code as input. Software reuse is common in software development. However, this feature has not been introduced to existing systems. Inspired by the traditional IR-based approaches, we propose to use the existing comments of similar source code as exemplars to guide the comment generation process. Based on an open source search engine, we first retrieve a similar code and treat its comment as an exemplar. Then we applied a seq2seq neural network to conduct an exemplar-based comment generation. We evaluate our approach on a large-scale Java corpus, and experimental results demonstrate that our model significantly outperforms the state-of-the-art methods.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952536','10.1109/ASE.2019.00152',21,0,'IEEE','IEEE Conferences',0),(737,'Humanoid: A Deep Learning-Based Approach to Automated Black-box Android App Testing',7,1070,1073,'Automated input generators must constantly choose which UI element to interact with and how to interact with it, in order to achieve high coverage with a limited time budget. Currently, most black-box input generators adopt pseudo-random or brute-force searching strategies, which may take very long to find the correct combination of inputs that can drive the app into new and important states. We propose Humanoid, an automated black-box Android app testing tool based on deep learning. The key technique behind Humanoid is a deep neural network model that can learn how human users choose actions based on an app\'s GUI from human interaction traces. The learned model can then be used to guide test input generation to achieve higher coverage. Experiments on both open-source apps and market apps demonstrate that Humanoid is able to reach higher coverage, and faster as well, than the state-of-the-art test input generators. Humanoid is open-sourced at https://github.com/yzygitzh/Humanoid and a demo video can be found at https://youtu.be/PDRxDrkyORs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952324','10.1109/ASE.2019.00104',14,0,'IEEE','IEEE Conferences',0),(738,'A Machine Learning Based Approach to Identify SQL Injection Vulnerabilities',7,1286,1288,'This paper presents a machine learning classifier designed to identify SQL injection vulnerabilities in PHP code. Both classical and deep learning based machine learning algorithms were used to train and evaluate classifier models using input validation and sanitization features extracted from source code files. On ten-fold cross validations a model trained using Convolutional Neural Network(CNN) achieved the highest precision (95.4%), while a model based on Multilayer Perceptron(MLP) achieved the highest recall (63.7%) and the highest f-measure (0.746).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952467','10.1109/ASE.2019.00164',18,0,'IEEE','IEEE Conferences',0),(739,'Test Automation and Its Limitations: A Case Study',7,1208,1209,'Modern embedded systems are increasingly complex and contain multiple software layers from BSP (Board Support Packages) to OS to middleware to AI (Artificial Intelligence) algorithms like perception and voice recognition. Integrations of inter-layer and intra-layer in embedded systems provide dedicated services such as taking a picture or movie-streaming. Accordingly, it gets more complicated to find out the root cause of a system failure. This industrial proposal describes a difficulty of testing embedded systems, and presents a case study in terms of integration testing.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952292','10.1109/ASE.2019.00139',19,0,'IEEE','IEEE Conferences',0),(740,'PHANTA: Diversified Test Code Quality Measurement for Modern Software Development',7,1206,1207,'Test code is becoming more essential to the modern software development process. However, practitioners often pay inadequate attention to key aspects of test code quality, such as bug detectability, maintainability and speed. Existing tools also typically report a single test code quality measure, such as code coverage, rather than a diversified set of metrics. To measure and visualize quality of test code in a comprehensive fashion, we developed an integrated test code analysis tool called Phanta. In this show case, we posit that the enhancement of test code quality is key to modernizing software development, and show how Phanta\'s techniques measure the quality using mutation analysis, test code clone detection, and so on. Further, we present an industrial case study where Phanta was applied to analyze test code in a real Fujitsu project, and share lessons learned from the case study.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952538','10.1109/ASE.2019.00138',6,0,'IEEE','IEEE Conferences',0),(741,'Enabling Continuous Improvement of a Continuous Integration Process',7,1246,1249,'Continuous Integration (CI) is a widely-adopted software engineering practice. Despite its undisputed benefits, like higher software quality and improved developer productivity, mastering CI is not easy. Among the several barriers when transitioning to CI, developers need to face a new type of software failures (i.e., build failures) that requires them to understand complex build logs. Even when a team has successfully introduced a CI culture, living up to its principles and improving the CI practice are also challenging. In my research, I want to provide developers with the right support for establishing CI and the proper recommendations for continuously improving their CI process.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952505','10.1109/ASE.2019.00151',26,0,'IEEE','IEEE Conferences',0),(742,'Better Development of Safety Critical Systems: Chinese High Speed Railway System Development Experience Report',7,1216,1217,'Ensure the correctness of safety critical systems play a key role in the worldwide software engineering. Over the past years we have been helping CASCO Signal Ltd which is the Chinese biggest high speed railway company to develop high speed railway safety critical software. We have also contributed specific methods for developing better safety critical software, including a search-based model-driven software development approach which uses SysML diagram refinement method to construct SysML model and SAT solver to check the model. This talk aims at sharing the challenge of developing high speed railway safety critical system, what we learn from develop a safety critical software with a Chinese high speed railway company, and we use ZC subsystem as a case study to show the systematic model-driven safety critical software development method.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952294','10.1109/ASE.2019.00143',7,0,'IEEE','IEEE Conferences',0),(743,'User Preference Aware Multimedia Pricing Model using Game Theory and Prospect Theory for Wireless Communications',7,1265,1267,'Providing user satisfaction is a major concern for on-demand multimedia service providers and Internet carriers in Wireless Communications. Traditionally, user satisfaction was measured objectively in terms of throughput and latency. Nowadays the user satisfaction is measured using subjective metrices such as Quality of Experience (QoE). Recently, Smart Media Pricing (SMP) was conceptualized to price the QoE rather than the binary data traffic in multimedia services. In this research, we have leveraged the SMP concept to chalk up a QoE-sensitive multimedia pricing framework to allot price, based on the user preference and multimedia quality achieved by the customer. We begin by defining the utility equations for the provider-carrier and the customer. Then we translate the profit maximizing interplay between the parties into a two-stage Stackelberg game. We model the user personal preference using Prelec weighting function which follows the postulates Prospect Theory (PT). An algorithm has been developed to implement the proposed pricing scheme and determine the Nash Equilibrium. Finally, the proposed smart pricing scheme was tested against the traditional pricing method and simulation results indicate a significant boost in the utility achieved by the mobile customers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952218','10.1109/ASE.2019.00157',11,0,'IEEE','IEEE Conferences',0),(744,'Ares: Inferring Error Specifications through Static Analysis',7,1174,1177,'Misuse of APIs happens frequently due to misunderstanding of API semantics and lack of documentation. An important category of API-related defects is the error handling defects, which may result in security and reliability flaws. These defects can be detected with the help of static program analysis, provided that error specifications are known. The error specification of an API function indicates how the function can fail. Writing error specifications manually is time-consuming and tedious. Therefore, automatic inferring the error specification from API usage code is preferred. In this paper, we present Ares, a tool for automatic inferring error specifications for C code through static analysis. We employ multiple heuristics to identify error handling blocks and infer error specifications by analyzing the corresponding condition logic. Ares is evaluated on 19 real world projects, and the results reveal that Ares outperforms the state-of-the-art tool APEx by 37% in precision. Ares can also identify more error specifications than APEx. Moreover, the specifications inferred from Ares help find dozens of API-related bugs in well-known projects such as OpenSSL, among them 10 bugs are confirmed by developers. Video: https://youtu.be/nf1QnFAmu8Q. Repository: https://github.com/lc3412/Ares.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952222','10.1109/ASE.2019.00130',12,0,'IEEE','IEEE Conferences',0);
INSERT INTO `article_info` VALUES (745,'Empirical Study of Python Call Graph',7,1274,1276,'In recent years, the extensive application of the Python language has made its analysis work more and more valuable. Many static analysis algorithms need to rely on the construction of call graphs. In this paper, we did a comparative empirical analysis of several widely used Python static call graph tools both quantitatively and qualitatively. Experiments show that the existing Python static call graph tools have a large difference in the construction effectiveness, and there is still room for improvement.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952190','10.1109/ASE.2019.00160',13,0,'IEEE','IEEE Conferences',0),(746,'Verifying Determinism in Sequential Programs',7,1271,1273,'A nondeterministic program is difficult to test and debug. Nondeterminism occurs even in sequential programs: for example, iterating over the elements of a hash table can result in diverging test results. We have created a type system that can express whether a computation is deterministic, nondeterministic, or ordernondeterministic (like a set). While state-of-the-art nondeterminism detection tools unsoundly rely on observing run-time output, our approach soundly verifies determinism at compile time. Our implementation found previously-unknown nondeterminism errors in a 24,000 line program that had been heavily vetted by its developers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952328','10.1109/ASE.2019.00159',9,0,'IEEE','IEEE Conferences',0),(747,'Grading-Based Test Suite Augmentation',7,226,229,'Enrollment in introductory programming (CS1) courses continues to surge and hundreds of CS1 students can produce thousands of submissions for a single problem, all requiring timely and accurate grading. One way that instructors can efficiently grade is to construct a custom instructor test suite that compares a student submission to a reference solution over randomly generated or hand-crafted inputs. However, such test suite is often insufficient, causing incorrect submissions to be marked as correct. To address this issue, we propose the Grasa (GRAding-based test Suite Augmentation) approach consisting of two techniques. Grasa first detects and clusters incorrect submissions by approximating their behavioral equivalence to each other. To augment the existing instructor test suite, Grasa generates a minimal set of additional tests that help detect the incorrect submissions. We evaluate our Grasa approach on a dataset of CS1 student submissions for three programming problems. Our preliminary results show that Grasa can effectively identify incorrect student submissions and minimally augment the instructor test suite.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952332','10.1109/ASE.2019.00030',14,0,'IEEE','IEEE Conferences',0),(748,'Crowdsourced Report Generation via Bug Screenshot Understanding',7,1277,1279,'Quality control is a challenge of crowdsourcing, especially in software testing. As some unprofessional workers involved, low-quality yieldings may hinder crowdsourced testing from satisfying requesters\' requirements. Therefore, it is in demand to assist crowdworkers to raise bug report quality. In this paper, we propose a novel auxiliary method, namely CroReG, to generate crowdsourcing bug reports by analyzing bug screenshots uploaded by crowdworkers with image understanding techniques. The preliminary experiment results show that CroReG can effectively generate bug reports containing accurate screenshot captions and providing positive guidance for crowdworkers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952296','10.1109/ASE.2019.00161',11,0,'IEEE','IEEE Conferences',0),(749,'How Do API Selections Affect the Runtime Performance of Data Analytics Tasks?',7,665,668,'As data volume and complexity grow at an unprecedented rate, the performance of data analytics programs is becoming a major concern for developers. We observed that developers sometimes use alternative data analytics APIs to improve program runtime performance while preserving functional equivalence. However, little is known on the characteristics and performance attributes of alternative data analytics APIs. In this paper, we propose a novel approach to extracting alternative implementations that invoke different data analytics APIs to solve the same tasks. A key appeal of our approach is that it exploits the comparative structures in Stack Overflow discussions to discover programming alternatives. We show that our approach is promising, as 86% of the extracted code pairs were validated as true alternative implementations. In over 20% of these pairs, the faster implementation was reported to achieve a 10x or more speedup over its slower alternative. We hope that our study offers a new perspective of API recommendation and motivates future research on optimizing data analytics programs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952224','10.1109/ASE.2019.00067',11,0,'IEEE','IEEE Conferences',0),(750,'mCUTE: A Model-Level Concolic Unit Testing Engine for UML State Machines',7,1182,1185,'Model Driven Engineering (MDE) techniques raise the level of abstraction at which developers construct software. However, modern cyber-physical systems are becoming more prevalent and complex and hence software models that represent the structure and behavior of such systems still tend to be large and complex. These models may have numerous if not infinite possible behaviors, with complex communications between their components. Appropriate software testing techniques to generate test cases with high coverage rate to put these systems to test at the model-level (without the need to understand the underlying code generator or refer to the generated code) are therefore important. Concolic testing, a hybrid testing technique that benefits from both concrete and symbolic execution, gains a high execution coverage and is used extensively in the industry for program testing but not for software models. In this paper, we present a novel technique and its tool mCUTE1, an open source 2 model-level concolic testing engine. We describe the implementation of our tool in the context of Papyrus-RT, an open source Model Driven Engineering (MDE) tool based on UML-RT, and report the results of validating our tool using a set of benchmark models.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952438','10.1109/ASE.2019.00132',22,0,'IEEE','IEEE Conferences',0),(751,'LIRAT: Layout and Image Recognition Driving Automated Mobile Testing of Cross-Platform',7,1066,1069,'The fragmentation issue spreads over multiple mobile platforms such as Android, iOS, mobile web, and WeChat, which hinders test scripts from running across platforms. To reduce the cost of adapting scripts for various platforms, some existing tools apply conventional computer vision techniques to replay the same script on multiple platforms. However, because these solutions can hardly identify dynamic or similar widgets. It becomes difficult for engineers to apply them in practice. In this paper, we present an image-driven tool, namely LIRAT, to record and replay test scripts cross platforms, solving the problem of test script cross-platform replay for the first time. LIRAT records screenshots and layouts of the widgets, and leverages image understanding techniques to locate them in the replay process. Based on accurate widget localization, LIRAT supports replaying test scripts across devices and platforms. We employed LIRAT to replay 25 scripts from 5 application across 8 Android devices and 2 iOS devices. The results show that LIRAT can replay 88% scripts on Android platforms and 60% on iOS platforms. The demo can be found at: https: //github.com/YSC9848/LIRAT','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952513','10.1109/ASE.2019.00103',11,0,'IEEE','IEEE Conferences',0),(752,'Automatic Generation of Graphical User Interface Prototypes from Unrestricted Natural Language Requirements',7,1234,1237,'High-fidelity GUI prototyping provides a meaningful manner for illustrating the developers\' understanding of the requirements formulated by the customer and can be used for productive discussions and clarification of requirements and expectations. However, high-fidelity prototypes are time-consuming and expensive to develop. Furthermore, the interpretation of requirements expressed in informal natural language is often error-prone due to ambiguities and misunderstandings. In this dissertation project, we will develop a methodology based on Natural Language Processing (NLP) for supporting GUI prototyping by automatically translating Natural Language Requirements (NLR) into a formal Domain-Specific Language (DSL) describing the GUI and its navigational schema. The generated DSL can be further translated into corresponding target platform prototypes and directly provided to the user for inspection. Most related systems stop after generating artifacts, however, we introduce an intelligent and automatic interaction mechanism that allows users to provide natural language feedback on generated prototypes in an iterative fashion, which accordingly will be translated into respective prototype changes.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952477','10.1109/ASE.2019.00148',29,0,'IEEE','IEEE Conferences',0),(753,'SPrinter: A Static Checker for Finding Smart Pointer Errors in C++ Programs',7,1122,1125,'Smart pointers are widely used to prevent memory errors in modern C++ code. However, improper usage of smart pointers may also lead to common memory errors, which makes the code not as safe as expected. To avoid smart pointer errors as early as possible, we present a coding style checker to detect possible bad smart pointer usages during compile time, and notify programmers about bug-prone behaviors. The evaluation indicates that the currently available state-of-the-art static code checkers can only detect 25 out of 116 manually inserted errors, while our tool can detect all these errors. And we also found 521 bugs among 8 open source projects with only 4 false positives.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952230','10.1109/ASE.2019.00117',12,0,'IEEE','IEEE Conferences',0),(754,'PMExec: An Execution Engine of Partial UML-RT Models',7,1178,1181,'This paper presents PMExec, a tool that supports the execution of partial UML-RT models. To this end, the tool implements the following steps: static analysis, automatic refinement, and input-driven execution. The static analysis that respects the execution semantics of UML-RT models is used to detect problematic model elements, i.e., elements that cause problems during execution due to the partiality. Then, the models are refined automatically using model transformation techniques, which mostly add decision points where missing information can be supplied. Third, the refined models are executed, and when the execution reaches the decision points, input required to continue the execution is obtained either interactively or from a script that captures how to deal with partial elements. We have evaluated PMExec using several use-cases that show that the static analysis, refinement, and application of user input can be carried out with reasonable performance, and that the overhead of approach is manageable. https://youtu.be/BRKsselcMnc Note: Interested readers can refer to [1] for a thorough discussion and evaluation of this work.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952369','10.1109/ASE.2019.00131',12,0,'IEEE','IEEE Conferences',0),(755,'TestCov: Robust Test-Suite Execution and Coverage Measurement',7,1074,1077,'We present TestCov, a tool for robust test-suite execution and test-coverage measurement on C programs. TestCov executes program tests in isolated containers to ensure system integrity and reliable resource control. The tool provides coverage statistics per test and for the whole test suite. TestCov uses the simple, XML -based exchange format for test-suite specifications that was established as standard by Test-Comp. TestCov has been successfully used in Test-Comp \'19 to execute almost 9 million tests on 1720 different programs. The source code of TestCov is released under the open-source license Apache 2.0 and available at https://gitlab.com/sosy-lab/software/test-suite-validator. A full artifact, including a demonstration video, is available at https://doi.org/10.5281/zenodo.3418726.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952265','10.1109/ASE.2019.00105',13,0,'IEEE','IEEE Conferences',0),(756,'Improving Patch Quality by Enhancing Key Components of Automatic Program Repair',7,1230,1233,'The error repair process in software systems is, historically, a resource-consuming task that relies heavily in developer manual effort. Automatic program repair approaches enable the repair of software with minimum human interaction, therefore, mitigating the burden from developers. However, a problem automatically generated patches commonly suffer is generating low-quality patches (which overfit to one program specification, thus not generalizing to an independent oracle evaluation). This work proposes a set of mechanisms to increase the quality of plausible patches including an analysis of test suite behavior and their key characteristics for automatic program repair, analyzing developer behavior to inform the mutation operator selection distribution, and a study of patch diversity as a means to create consolidated higher quality fixes.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952342','10.1109/ASE.2019.00147',19,0,'IEEE','IEEE Conferences',0),(757,'PTracer: A Linux Kernel Patch Trace Bot',7,1210,1211,'We present PTracer, a Linux kernel patch trace bot based on an improved PatchNet. PTracer continuously monitors new patches in the git repository of the mainline Linux kernel, filters out unconcerned ones, classifies the rest as bug-fixing or non bug-fixing patches, and reports bug-fixing patches to the kernel experts of commercial operating systems. We use the patches in February 2019 of the mainline Linux kernel to perform the test. As a result, PTracer recommended 151 patches to CGEL kernel experts out of 5,142, and 102 of which were accepted. PTracer has been successfully applied to a commercial operating system and has the advantages of improving software quality and saving labor cost.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952485','10.1109/ASE.2019.00140',7,0,'IEEE','IEEE Conferences',0),(758,'AutoFocus: Interpreting Attention-Based Neural Networks by Code Perturbation',7,38,41,'Despite being adopted in software engineering tasks, deep neural networks are treated mostly as a black box due to the difficulty in interpreting how the networks infer the outputs from the inputs. To address this problem, we propose AutoFocus, an automated approach for rating and visualizing the importance of input elements based on their effects on the outputs of the networks. The approach is built on our hypotheses that (1) attention mechanisms incorporated into neural networks can generate discriminative scores for various input elements and (2) the discriminative scores reflect the effects of input elements on the outputs of the networks. This paper verifies the hypotheses by applying AutoFocus on the task of algorithm classification (i.e., given a program source code as input, determine the algorithm implemented by the program). AutoFocus identifies and perturbs code elements in a program systematically, and quantifies the effects of the perturbed elements on the network\'s classification results. Based on evaluation on more than 1000 programs for 10 different sorting algorithms, we observe that the attention scores are highly correlated to the effects of the perturbed code elements. Such a correlation provides a strong basis for the uses of attention scores to interpret the relations between code elements and the algorithm classification results of a neural network, and we believe that visualizing code elements in an input program ranked according to their attention scores can facilitate faster program comprehension with reduced code.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952269','10.1109/ASE.2019.00014',17,0,'IEEE','IEEE Conferences',0),(759,'VeriAbs : Verification by Abstraction and Test Generation',7,1138,1141,'Verification of programs continues to be a challenge and no single known technique succeeds on all programs. In this paper we present VeriAbs, a reachability verifier for C programs that incorporates a portfolio of techniques implemented as four strategies, where each strategy is a set of techniques applied in a specific sequence. It selects a strategy based on the kind of loops in the program. We analysed the effectiveness of the implemented strategies on the 3831 verification tasks from the ReachSafety category of the 8th International Competition on Software Verification (SV-COMP) 2019 and found that although classic techniques - explicit state model checking and bounded model checking, succeed on a majority of the programs, a wide range of further techniques are required to analyse the rest. A screencast of the tool is available at https://youtu.be/Hzh3PPiODwk.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952452','10.1109/ASE.2019.00121',27,0,'IEEE','IEEE Conferences',0),(760,'Trusted Software Supply Chain',7,1212,1213,'Modern software delivery happens in a geographically distributed environment and resembles like a supply chain 鈥� consists of various participants, involves various phases, needs adherence to multiple regulations and needs to maintain artifacts\' integrity throughout the delivery phases. This shift in software development brings along with it several challenges ranging from communication of information/knowledge, coordination and control of teams, activities adhering to goals and policies and artifacts adhering to quality, visibility, and management. %Software development processes to be transparent, verifiable, compliant, and accountable thereby increasing software\'s trustworthiness. With the dispersion of centralized control over software delivery to autonomous delivery organizations, the variety of processes and tools used turns transparency into opacity as autonomous teams use different software processes, tools, and metrics, leading to issues like ineffective compliance monitoring, friction prone coordination, and lack of provenance, and thereby trust. In this paper, we present a delivery governance framework based on distributed ledger technology that uses a notion of \'software telemetry\' to record data from disparate delivery partners and enables compliance monitoring and adherence, provenance and traceability, transparency, and thereby trust.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952169','10.1109/ASE.2019.00141',4,0,'IEEE','IEEE Conferences',0),(761,'BuRRiTo: A Framework to Extract, Specify, Verify and Analyze Business Rules',7,1190,1193,'An enterprise system operates business by providing various services that are guided by set of certain business rules (BR) and constraints. These BR are usually written using plain Natural Language in operating procedures, terms and conditions, and other documents or in source code of legacy enterprise systems. For implementing the BR in a software system, expressing them as UML use-case specifications, or preparing for Merger & Acquisition (M&A) activity, analysts manually interpret the documents or try to identify constraints from the source code, leading to potential discrepancies and ambiguities. These issues in the software system can be resolved only after testing, which is a very tedious and expensive activity. To minimize such errors and efforts, we propose BuRRiTo framework consisting of automatic extraction of BR by mining documents and source code, ability to clean them of various anomalies like inconsistency, redundancies, conflicts, etc. and able to analyze the functional gaps present and performing semantic querying and searching.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952315','10.1109/ASE.2019.00134',20,0,'IEEE','IEEE Conferences',0),(762,'Prema: A Tool for Precise Requirements Editing, Modeling and Analysis',7,1166,1169,'We present Prema, a tool for Precise Requirement Editing, Modeling and Analysis. It can be used in various fields for describing precise requirements using formal notations and performing rigorous analysis. By parsing the requirements written in formal modeling language, Prema is able to get a model which aptly depicts the requirements. It also provides different rigorous verification and validation techniques to check whether the requirements meet users\' expectation and find potential errors. We show that our tool can provide a unified environment for writing and verifying requirements without using tools that are not well inter-related. For experimental demonstration, we use the requirements of the automatic train protection (ATP) system of CASCO signal co. LTD., the largest railway signal control system manufacturer of China. The code of the tool cannot be released here because the project is commercially confidential. However, a demonstration video of the tool is available at https://youtu.be/BX0yv8pRMWs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952250','10.1109/ASE.2019.00128',18,0,'IEEE','IEEE Conferences',0),(763,'Demystifying Application Performance Management Libraries for Android',7,682,685,'Since the performance issues of apps can influence users\' experience, developers leverage application performance management (APM) tools to locate the potential performance bottleneck of their apps. Unfortunately, most developers do not understand how APMs monitor their apps during the runtime and whether these APMs have any limitations. In this paper, we demystify APMs by inspecting 25 widely-used APMs that target on Android apps. We first report how these APMs implement 8 key functions as well as their limitations. Then, we conduct a large-scale empirical study on 500,000 Android apps from Google Play to explore the usage of APMs. This study has some interesting observations about existing APMs for Android, including 1) some APMs still use deprecated permissions and approaches so that they may not always work properly; 2) some app developers use APMs to collect users\' privacy information.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952393','10.1109/ASE.2019.00069',19,0,'IEEE','IEEE Conferences',0),(764,'Generating Tests to Analyse Dynamically-Typed Programs',7,1226,1229,'The increasing popularity of dynamically-typed programming languages, such as JavaScript or Python, requires specific support methods for developers to avoid pitfalls arising from the dynamic nature of these languages. Static analyses are frequently used but the dynamic type systems limit their applicability. Dynamic analyses, in contrast, depend on the execution of the code under analysis, and thus depend on the quality of existing tests. This quality of the test suite can be improved by the use of automated test generation but automated test generation for dynamically-typed programming languages itself is hard due to the lack of type information in the programs. The limitations of each of these approaches will be overcome by iteratively combining test generation with static and dynamic analysis techniques for dynamically-typed programs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952500','10.1109/ASE.2019.00146',32,0,'IEEE','IEEE Conferences',0),(765,'DeepMutation++: A Mutation Testing Framework for Deep Learning Systems',7,1158,1161,'Deep neural networks (DNNs) are increasingly expanding their real-world applications across domains, e.g., image processing, speech recognition and natural language processing. However, there is still limited tool support for DNN testing in terms of test data quality and model robustness. In this paper, we introduce a mutation testing-based tool for DNNs, DeepMutation++, which facilitates the DNN quality evaluation, supporting both feed-forward neural networks (FNNs) and stateful recurrent neural networks (RNNs). It not only enables to statically analyze the robustness of a DNN model against the input as a whole, but also allows to identify the vulnerable segments of a sequential input (e.g. audio input) by runtime analysis. It is worth noting that DeepMutation++ specially features the support of RNNs mutation testing. The tool demo video can be found on the project website https://sites.google.com/view/deepmutationpp.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952248','10.1109/ASE.2019.00126',11,0,'IEEE','IEEE Conferences',0),(766,'NeuralVis: Visualizing and Interpreting Deep Learning Models',7,1106,1109,'Deep Neural Network(DNN) techniques have been prevalent in software engineering. They are employed to facilitate various software engineering tasks and embedded into many software applications. However, because DNNs are built upon a rich data-driven programming paradigm that employs plenty of labeled data to train a set of neurons to construct the internal system logic, analyzing and understanding their behaviors becomes a difficult task for software engineers. In this paper, we present an instance-based visualization tool for DNN, namely NeuralVis, to support software engineers in visualizing and interpreting deep learning models. NeuralVis is designed for: 1). visualizing the structure of DNN models, i.e., neurons, layers, as well as connections; 2). visualizing the data transformation process; 3). integrating existing adversarial attack algorithms for test input generation; 4). comparing intermediate layers\' outputs of different inputs. To demonstrate the effectiveness of NeuralVis, we design a task-based user study involving ten participants on two classic DNN models, i.e., LeNet and VGG-12. The result shows NeuralVis can assist engineers in identifying critical features that determine the prediction results. Video: https://youtu.be/solkJri4Z44','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952427','10.1109/ASE.2019.00113',14,0,'IEEE','IEEE Conferences',0),(767,'Improving Collaboration Efficiency in Fork-Based Development',7,1218,1221,'Fork-based development is a lightweight mechanism that allows developers to collaborate with or without explicit coordination. Although it is easy to use and popular, when developers each create their own fork and develop independently, their contributions are usually not easily visible to others. When the number of forks grows, it becomes very difficult to maintain an overview of what happens in individual forks, which would lead to additional problems and inefficient practices: lost contributions, redundant development, fragmented communities, and so on. Facing the problems mentioned above, we developed two complementary strategies: (1) Identifying existing best practices and suggesting evidence-based interventions for projects that are inefficient; (2) designing new interventions that could improve the awareness of a community using fork-based development, and help developers to detect redundant development to reduce unnecessary effort.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952395','10.1109/ASE.2019.00144',14,0,'IEEE','IEEE Conferences',0),(768,'An Approach for Investigating Emotion Dynamics in Software Development',7,1268,1270,'Emotion awareness is critical to interpersonal communication, including that in software development. The SE community has studied emotion in software development using isolated emotion states but it has not considered the dynamic nature of emotion. To investigate the emotion dynamics, SE community needs an effective approach. In this paper, we propose such an approach which can automatically collect project teams\' communication records, identify the emotions and their intensities in them, model the emotion dynamics into time series, and provide efficient data management. We demonstrate that this approach can provide end-to-end support for various emotion awareness research and practices through automated data collection, modeling, storage, analysis, and presentation using the IPython\'s project data on GitHub.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952358','10.1109/ASE.2019.00158',13,0,'IEEE','IEEE Conferences',0),(769,'Inference of Properties from Requirements and Automation of Their Formal Verification',7,1222,1225,'Over the past decades, various techniques for the application of formal program analysis of software for embedded systems have been proposed. However, the application of formal methods for software verification is still limited in practise. It is acknowledged that the task of formally stating requirements by specifying the formal properties is a major hindrance. The verification step itself has its shortcoming in its scalability and its limitation to predefined proof tactics in case of automated theorem proving (ATP). These constraints are reduced today by the interaction of the user with the theorem prover (TP) during the execution of the proof. However, this is difficult for non-experts. The objectives of the presented PhD project are the automated inference of declarative property specifications from example data specified by the engineer for a function under development and their automated verification on abstract model level and on code level. We propose the meta-model for Scenario Modeling Language (SML) that allows to specify example data. For the automated property generation we are motivated by Inductive Logic Programming (ILP) techniques for first-order logic in pure mathematics. We propose modifications to its algorithm that allow to process the information that is incorporated in the meta-model of SML. However, this technique is expected to produce too many uninteresting properties. To turn this weakness into strength, our approach proposes to tailor the algorithm towards selection of the right properties that facilitate the automation of the proof. Automated property generation and less user interaction with the prover will leverage formal verification as it will relieve the engineer in the specification as well as in proofing tasks.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952397','10.1109/ASE.2019.00145',36,0,'IEEE','IEEE Conferences',0),(770,'Compile-Time Detection of Machine Image Sniping',7,1256,1258,'Machine image sniping is a difficult-to-detect security vulnerability in cloud computing code. When programmatically initializing a machine, a developer specifies a machine image (operating system and file system). The developer should restrict the search to only those machine images which their organization controls: otherwise, an attacker can insert a similarly-named malicious image into the public database, where it might be selected instead of the image the developer intended. We present a lightweight type and effect system that detects requests to a cloud provider that are vulnerable to an image sniping attack, or proves that no vulnerable request exists in a codebase. We prototyped our type system for Java programs that initialize Amazon Web Services machines, and evaluated it on more than 500 codebases, detecting 14 vulnerable requests with only 3 false positives.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952221','10.1109/ASE.2019.00154',8,0,'IEEE','IEEE Conferences',0),(771,'Boosting Neural Commit Message Generation with Code Semantic Analysis',7,1280,1282,'It has been long suggested that commit messages can greatly facilitate code comprehension. However, developers may not write good commit messages in practice. Neural machine translation (NMT) has been suggested to automatically generate commit messages. Despite the efforts in improving NMT algorithms, the quality of the generated commit messages is not yet satisfactory. This paper, instead of improving NMT algorithms, suggests that proper preprocessing of code changes into concise inputs is quite critical to train NMT. We approach it with semantic analysis of code changes. We collect a real-world dataset with 50k+ commits of popular Java projects, and verify our idea with comprehensive experiments. The results show that preprocessing inputs with code semantic analysis can improve NMT significantly. This work sheds light to how to apply existing DNNs designed by the machine learning community, e.g., NMT models, to complete software engineering tasks.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952539','10.1109/ASE.2019.00162',38,0,'IEEE','IEEE Conferences',0),(772,'FPChecker: Detecting Floating-Point Exceptions in GPU Applications',7,1126,1129,'Floating-point arithmetic is widely used in applications from several fields including scientific computing, machine learning, graphics, and finance. Many of these applications are rapidly adopting the use of GPUs to speedup computations. GPUs, however, have limited support to detect floating-point exceptions, which hinders the development of reliable applications in GPU-based systems. We present FPCHECKER, the first tool to automatically detect floating-point exceptions in GPU applications. FPCHECKER uses the clang/LLVM compiler to instrument GPU kernels and to detect exceptions at runtime. Once an exception is detected, it reports to the programmer the code location of the exception as well as other useful information. The programmer can then use this report to avoid the exception, e.g., by modifying the application algorithm or changing the input. We present the design of FPCHECKER, an evaluation of the overhead of the tool, and a real-world case scenario on which the tool is used to identify a hidden exception. The slowdown of FPCHECKER is moderate and the code is publicly available as open source.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952258','10.1109/ASE.2019.00118',6,0,'IEEE','IEEE Conferences',0),(773,'A Journey Towards Providing Intelligence and Actionable Insights to Development Teams in Software Delivery',7,1214,1215,'For delivering high-quality artifacts within the budget and on schedule, software delivery teams ideally should have a holistic and in-process view of the current health and future trajectory of the project. However, such insights need to be at the right level of granularity and need to be derived typically from a heterogeneous project environment, in a way that helps development team members with their tasks at hand. Due to client mandates, software delivery project environments employ many disparate tools and teams tend to be distributed, thus making the relevant information retrieval, insight generation, and developer intelligence augmentation process fairly complex. In this paper, we discuss our journey in this area spanning across facets like software project modelling and new development metrics, studying developer priorities, adoption of new metrics, and different approaches of developer intelligence augmentation. Finally, we present our exploration of new immersive technologies for human-centered software engineering.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952441','10.1109/ASE.2019.00142',10,0,'IEEE','IEEE Conferences',0),(774,'Pangolin: An SFL-Based Toolset for Feature Localization',7,1130,1133,'Pinpointing the location where a given unit of functionality-or feature-was implemented is a demanding and time-consuming task, yet prevalent in most software maintenance or evolution efforts. To that extent, we present PANGOLIN, an Eclipse plugin that helps developers identifying features among the source code. It borrows Spectrum-based Fault Localization techniques from the software diagnosis research field by framing feature localization as a diagnostic problem. PANGOLIN prompts users to label system executions based on feature involvement, and subsequently presents its spectrum-based feature localization analysis to users with the aid of a color-coded, hierarchic, and navigable visualization which was shown to be effective at conveying diagnostic information to users. Our evaluation shows that PANGOLIN accurately pinpoints feature implementations and is resilient to misclassifications by users. The tool can be downloaded at https://tqrg.github.io/pangolin/.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952297','10.1109/ASE.2019.00119',10,0,'IEEE','IEEE Conferences',0),(775,'SWAN_ASSIST: Semi-Automated Detection of Code-Specific, Security-Relevant Methods',7,1094,1097,'To detect specific types of bugs and vulnerabilities, static analysis tools must be correctly configured with security-relevant methods (SRM), e.g., sources, sinks, sanitizers and authentication methods鈥搖sually a very labour-intensive and error-prone process. This work presents the semi-automated tool SWAN_ASSIST, which aids the configuration with an IntelliJ plugin based on active machine learning. It integrates our novel automated machine-learning approach SWAN, which identifies and classifies Java SRM. SWAN_ASSIST further integrates user feedback through iterative learning. SWAN_ASSIST aids developers by asking them to classify at each point in time exactly those methods whose classification best impact the classification result. Our experiments show that SWAN_ASSIST classifies SRM with a high precision, and requires a relatively low effort from the user. A video demo of SWAN_ASSIST can be found at https://youtu.be/fSyD3V6EQOY. The source code is available at https://github.com/secure-software-engineering/swan.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952264','10.1109/ASE.2019.00110',9,0,'IEEE','IEEE Conferences',0),(776,'Kotless: A Serverless Framework for Kotlin',7,1110,1113,'Recent trends in Web development demonstrate an increased interest in serverless applications, i.e. applications that utilize computational resources provided by cloud services on demand instead of requiring traditional server management. This approach enables better resource management while being scalable, reliable, and cost-effective. However, it comes with a number of organizational and technical difficulties which stem from the interaction between the application and the cloud infrastructure, for example, having to set up a recurring task of reuploading updated files. In this paper, we present Kotless 鈥� a Kotlin Serverless Framework. Kotless is a cloud-agnostic toolkit that solves these problems by interweaving the deployed application into the cloud infrastructure and automatically generating the necessary deployment code. This relieves developers from having to spend their time integrating and managing their applications instead of developing them. Kotless has proven its capabilities and has been used to develop several serverless applications already in production. Its source code is available at https://github.com/JetBrains/kotless, a tool demo can be found at https://www.youtube.com/watch?v=IMSakPNl3TY.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952482','10.1109/ASE.2019.00114',8,0,'IEEE','IEEE Conferences',0),(777,'Towards Comprehensible Representation of Controllers using Machine Learning',7,1283,1285,'From the point of view of a software engineer, having safe and optimal controllers for real life systems like cyber physical systems is a crucial requirement before deployment. Given the mathematical model of these systems along with their specifications, model checkers can be used to synthesize controllers for them. The given work proposes novel approaches for making controller analysis easier by using machine learning to represent the controllers synthesized by model checkers in a succinct manner, while also incorporating the domain knowledge of the system. It also proposes the implementation of a visualization tool which will be integrated into existing model checkers. A lucid controller representation along with a tool to visualize it will help the software engineer debug and monitor the system much more efficiently.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952374','10.1109/ASE.2019.00163',17,0,'IEEE','IEEE Conferences',0),(778,'FogWorkflowSim: An Automated Simulation Toolkit for Workflow Performance Evaluation in Fog Computing',7,1114,1117,'Workflow underlies most process automation software, such as those for product lines, business processes, and scientific computing. However, current Cloud Computing based workflow systems cannot support real-time applications due to network latency, which limits their application in many IoT systems such as smart healthcare and smart traffic. Fog Computing extends the Cloud by providing virtualized computing resources close to the End Devices so that the response time of accessing computing resources can be reduced significantly. However, how to most effectively manage heterogeneous resources and different computing tasks in the Fog is a big challenge. In this paper, we introduce \'FogWorkflowSim\' an efficient and extensible toolkit for automatically evaluating resource and task management strategies in Fog Computing with simulated user-defined workflow applications. Specifically, FogWorkflowSim is able to: 1) automatically set up a simulated Fog Computing environment for workflow applications; 2) automatically execute user submitted workflow applications; 3) automatically evaluate and compare the performance of different computation offloading and task scheduling strategies with three basic performance metrics, including time, energy and cost. FogWorkflowSim can serve as an effective experimental platform for researchers in Fog based workflow systems as well as practitioners interested in adopting Fog Computing and workflow systems for their new software projects. (Demo video: https://youtu.be/AsMovcuSkx8)','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952516','10.1109/ASE.2019.00115',12,0,'IEEE','IEEE Conferences',0),(779,'An Image-Inspired and CNN-Based Android Malware Detection Approach',7,1259,1261,'Abstract-Until 2017, Android smartphones occupied approximately 87% of the smartphone market. The vast market also promotes the development of Android malware. Nowadays, the number of malware targeting Android devices found daily is more than 38,000. With the rapid progress of mobile application programming and anti-reverse-engineering techniques, it is harder to detect all kinds of malware. To address challenges in existing detection techniques, such as data obfuscation and limited code coverage, we propose a detection approach that directly learns features of malware from Dalvik bytecode based on deep learning technique (CNN). The average detection time of our model is0.22 seconds, which is much lower than other existing detection approaches. In the meantime, the overall accuracy of our model achieves over 93%.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952484','10.1109/ASE.2019.00155',18,0,'IEEE','IEEE Conferences',0),(780,'CONVUL: An Effective Tool for Detecting Concurrency Vulnerabilities',7,1154,1157,'Concurrency vulnerabilities are extremely harmful and can be frequently exploited to launch severe attacks. Due to the non-determinism of multithreaded executions, it is very difficult to detect them. Recently, data race detectors and techniques based on maximal casual model have been applied to detect concurrency vulnerabilities. However, the former are ineffective and the latter report many false negatives. In this paper, we present CONVUL, an effective tool for concurrency vulnerability detection. CONVUL is based on exchangeable events, and adopts novel algorithms to detect three major kinds of concurrency vulnerabilities. In our experiments, CONVUL detected 9 of 10 known vulnerabilities, while other tools only detected at most 2 out of these 10 vulnerabilities. The 10 vulnerabilities are available at https://github.com/mryancai/ConVul.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952233','10.1109/ASE.2019.00125',15,0,'IEEE','IEEE Conferences',0),(781,'Automatically Repairing Binary Programs Using Adapter Synthesis',7,1238,1241,'Bugs in commercial software and third-party components are an undesirable and expensive phenomenon. Such software is usually released to users only in binary form. The lack of source code renders users of such software dependent on their software vendors for repairs of bugs. Such dependence is even more harmful if the bugs introduce new vulnerabilities in the software. Automatically repairing security and functionality bugs in binary code increases software robustness without any developer effort. In this research, we propose development of a binary program repair tool that uses existing bug-free fragments of code to repair buggy code.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952199','10.1109/ASE.2019.00149',24,0,'IEEE','IEEE Conferences',0),(782,'Visual Analytics for Concurrent Java Executions',7,1102,1105,'Analyzing executions of concurrent software is very difficult. Even if a trace is available, such traces are very hard to read and interpret. A textual trace contains a lot of data, most of which is not relevant to the issue at hand. Past visualization attempts either do not show concurrent behavior, or result in a view that is overwhelming for the user. We provide a visual analytics tool, VA4JVM, for error traces produced by either the Java Virtual Machine, or by Java Pathfinder. Its key features are a layout that spatially associates events with threads, a zoom function, and the ability to filter event data in various ways. We show in examples how filtering and zooming in can highlight a problem without having to read lengthy textual data.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952488','10.1109/ASE.2019.00112',32,0,'IEEE','IEEE Conferences',0),(783,'Tackling Build Failures in Continuous Integration',7,1242,1245,'In popular continuous integration(CI) practice, coding is followed by building, integration and system testing, pre-release inspection, and deploying artifacts. This can reduce integration risk and speed up the development process. But large number of CI build failures may interrupt the normal software development process. So, the failures need to be analyzed and fixed quickly. Although various automated program repair techniques have great potential to resolve software failures, the existing techniques mostly focus on repairing source code. So, those techniques cannot directly help resolve software build failures. Apart from that, a special challenge to fix build failures in CI environment is that the failures are often involved with both source code and build scripts. This paper outlines promising preliminary work towards automatic build repair in CI environment that involves both source code and build script. As the first step, we conducted an empirical study on software build failures and build fix patterns. Based on the findings of the empirical study, we developed an approach that can automatically fix build errors involving build scripts. We plan to extend this repair approach considering both source code and build script. Moreover, we plan to quantify our automatic fixes by user study and comparison between fixes generated by our approach and actual fixes.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952416','10.1109/ASE.2019.00150',21,0,'IEEE','IEEE Conferences',0),(784,'API Design Implications of Boilerplate Client Code',7,1253,1255,'Designing usable APIs is critical to developers\' productivity and software quality but is quite difficult. In this paper, I focus on \'boilerplate\' code, sections of code that have to be included in many places with little or no alteration, which many experts in API design have said can be an indicator of API usability problems. I investigate what properties make code count as boilerplate, and present a novel approach to automatically mine boilerplate code from a large set of client code. The technique combines an existing API usage mining algorithm, with novel filters using AST comparison and graph partitioning. With boilerplate candidates identified by the technique, I discuss how this technique could help API designers in reviewing their design decisions and identifying usability issues.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952241','10.1109/ASE.2019.00153',20,0,'IEEE','IEEE Conferences',0),(785,'Manticore: A User-Friendly Symbolic Execution Framework for Binaries and Smart Contracts',7,1186,1189,'An effective way to maximize code coverage in software tests is through dynamic symbolic execution鈥攁 technique that uses constraint solving to systematically explore a program\'s state space. We introduce an open-source dynamic symbolic execution framework called Manticore for analyzing binaries and Ethereum smart contracts. Manticore\'s flexible architecture allows it to support both traditional and exotic execution environments, and its API allows users to customize their analysis. Here, we discuss Manticore\'s architecture and demonstrate the capabilities we have used to find bugs and verify the correctness of code for our commercial clients.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952204','10.1109/ASE.2019.00133',19,0,'IEEE','IEEE Conferences',0),(786,'Lancer: Your Code Tell Me What You Need',7,1202,1205,'Programming is typically a difficult and repetitive task. Programmers encounter endless problems during programming, and they often need to write similar code over and over again. To prevent programmers from reinventing wheels thus increase their productivity, we propose a context-aware code-to-code recommendation tool named Lancer. With the support of a Library-Sensitive Language Model (LSLM) and the BERT model, Lancer is able to automatically analyze the intention of the incomplete code and recommend relevant and reusable code samples in real-time. A video demonstration of Lancer can be found at https://youtu.be/tO9nhqZY35g. Lancer is open source and the code is available at https://github.com/sfzhou5678/Lancer.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952168','10.1109/ASE.2019.00137',18,0,'IEEE','IEEE Conferences',0),(787,'MutAPK: Source-Codeless Mutant Generation for Android Apps',7,1090,1093,'The amount of Android application is having a tremendous increasing trend, exerting pressure over practitioners and researchers around application quality, frequent releases, and quick fixing of bugs. This pressure leads practitioners to make usage of automated approaches based on using source-code as input. Nevertheless, third-party services are not able to use these approaches due to privacy factors. In this paper we present MutAPK, an open source mutation testing tool that enables the usage of APK as input for this task. MutAPK generates mutants without the need of having access to source code, because the mutations are done in an intermediate representation of the code (i.e., SMALI) that does not require compilation. MutAPK is publicly available at GitHub: https://bit.ly/2KYvgP9 VIDEO: https://bit.ly/2WOjiyy','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952526','10.1109/ASE.2019.00109',15,0,'IEEE','IEEE Conferences',0),(788,'Developer Reputation Estimator (DRE)',7,1082,1085,'Evidence shows that developer reputation is extremely important when accepting pull requests or resolving reported issues. It is particularly salient in Free/Libre Open Source Software since the developers are distributed around the world, do not work for the same organization and, in most cases, never meet face to face. The existing solutions to expose developer reputation tend to be forge specific (GitHub), focus on activity instead of impact, do not leverage social or technical networks, and do not correct often misspelled developer identities. We aim to remedy this by amalgamating data from all public Git repositories, measuring the impact of developer work, expose developer\'s collaborators, and correct notoriously problematic developer identity data. We leverage World of Code (WoC), a collection of an almost complete (and continuously updated) set of Git repositories by first allowing developers to select which of the 34 million(M) Git commit author IDs belong to them and then generating their profiles by treating the selected collection of IDs as that single developer. As a side-effect, these selections serve as a training set for a supervised learning algorithm that merges multiple identity strings belonging to a single individual. As we evaluate the tool and the proposed impact measure, we expect to build on these findings to develop reputation badges that could be associated with pull requests and commits so developers could easier trust and prioritize them.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952390','10.1109/ASE.2019.00107',7,0,'IEEE','IEEE Conferences',0),(789,'CocoQa: Question Answering for Coding Conventions Over Knowledge Graphs',7,1086,1089,'Coding convention plays an important role in guaranteeing software quality. However, coding conventions are usually informally presented and inconvenient for programmers to use. In this paper, we present CocoQa, a system that answers programmer\'s questions about coding conventions. CocoQa answers questions by querying a knowledge graph for coding conventions. It employs 1) a subgraph matching algorithm that parses the question into a SPARQL query, and 2) a machine comprehension algorithm that uses an end-to-end neural network to detect answers from searched paragraphs. We have implemented CocoQa, and evaluated it on a coding convention QA dataset. The results show that CocoQa can answer questions about coding conventions precisely. In particular, CocoQa can achieve a precision of 82.92% and a recall of 91.10%. Repository: https://github.com/14dtj/CocoQa/ Video: https://youtu.be/VQaXi1WydAU','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952314','10.1109/ASE.2019.00108',15,0,'IEEE','IEEE Conferences',0),(790,'MuSC: A Tool for Mutation Testing of Ethereum Smart Contract',7,1198,1201,'The smart contract cannot be modified when it has been deployed on a blockchain. Therefore, it must be given thorough test before its being deployed. Mutation testing is considered as a practical test methodology to evaluate the adequacy of software testing. In this paper, we introduce MuSC, a mutation testing tool for Ethereum Smart Contract (ESC). It can generate numerous mutants at a fast speed and supports the automatic operations such as creating test nets, deploying and executing tests. Specially, MuSC implements a set of novel mutation operators w.r.t ESC programming language, Solidity. Therefore, it can expose the defects of smart contracts to a certain degree. The demonstration video of MuSC is available at https: //youtu.be/3KBKXJPVjbQ, and the source code can be downloaded at https://github.com/belikout/MuSC-Tool-Demo-repo.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952206','10.1109/ASE.2019.00136',20,0,'IEEE','IEEE Conferences',0),(791,'SiMPOSE - Configurable N-Way Program Merging Strategies for Superimposition-Based Analysis of Variant-Rich Software',7,1134,1137,'Modern software often exists in many different, yet similar versions and/or variants, usually derived from a common code base (e.g., via clone-and-own). In the context of product-line engineering, family-based analysis has shown very promising potential for improving efficiency in applying quality-assurance techniques to variant-rich software, as compared to a variant-by-variant approach. Unfortunately, these strategies rely on a product-line representation superimposing all program variants in a syntactically well-formed, semantically sound and variant-preserving manner, which is manually hard to obtain in practice. We demonstrate the SiMPOSE methodology for automatically generating superimpositions of N given program versions and/or variants facilitating family-based analysis of variant-rich software. SiMPOSE is based on a novel N-way model-merging technique operating at the level of control-flow automata (CFA) representations of C programs. CFAs constitute a unified program abstraction utilized by many recent software-analysis tools. We illustrate different merging strategies supported by SiMPOSE, namely variant-by-variant, N-way merging, incremental 2-way merging, and partition-based N/2-way merging, and demonstrate how SiMPOSE can be used to systematically compare their impact on efficiency and effectiveness of family-based unit-test generation. The SiMPOSE tool, the demonstration of its usage as well as related artifacts and documentation can be found at http://pi.informatik.uni-siegen.de/projects/variance/simpose.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952245','10.1109/ASE.2019.00120',12,0,'IEEE','IEEE Conferences',0),(792,'Towards search-based modelling and analysis of requirements and architecture decisions',8,1026,1029,'Many requirements engineering and software architecture decisions are complicated by uncertainty and multiple conflicting stakeholders objectives. Using quantitative decision models helps clarify these decisions and allows the use of multi-objective simulation optimisation techniques in analysing the impact of decisions on objectives. Existing requirements and architecture decision support methods that use quantitative decision models are limited by the difficulty in elaborating problem-specific decision models and/or lack integrated tool support for automated decision analysis under uncertainty. To address these problems and facilitate requirements and architecture decision analysis, this research proposes a novel modelling language and automated decision analysis technique, implemented in a tool called RADAR. The modelling language is a simplified version of quantitative AND/OR goal models used in requirements engineering and similar to feature models used in software product lines. This research involves developing the RADAR tool and evaluating the tool\'s applicability, usefulness and scalability on a set of real-world examples.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115725','10.1109/ASE.2017.8115725',26,1,'IEEE','IEEE Conferences',0),(793,'Tool Support for Analyzing Mobile App Reviews',9,789,794,'Mobile app reviews often contain useful user opinions for app developers. However, manual analysis of those reviews is challenging due to their large volume and noisynature. This paper introduces MARK, a supporting tool for review analysis of mobile apps. With MARK, an analyst can describe her interests of one or more apps via a set of keywords. MARK then lists the reviews most relevant to those keywords for further analyses. It can also draw the trends over time of the selected keywords, which might help the analyst to detect sudden changes in the related user reviews. To help the analyst describe her interests more effectively, MARK can automatically extract and rank the keywords by their associations with negative reviews, divide a large set of keywords into more cohesive subgroups, or expand a small set into a broader one.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372068','10.1109/ASE.2015.101',11,3,'IEEE','IEEE Conferences',0),(794,'The challenges of verification and validation of automated planning systems (keynote)',6,2,2,'Mission planning is central to space mission operations, and has benefited from advances in model-based planning software. A model is a description of the objects, actions, constraints and preferences that the planner reasons over to generate plans. Developing, verifying and validating a planning model is, however, a difficult task. Mission planning constraints and preferences arise from many sources, including simulators and engineering specification documents. As mission constraints evolve, planning domain modelers must add and update model constraints efficiently using the available source data, catching errors quickly, and correcting the model. The consequences of erroneous models are very high, especially in the space operations environment. We first describe the space operations environment, particularly the role of the mission planning system. We then describe model-based planning, and briefly review the current state of the practice in designing model-based mission planning tools and the challenges facing model developers. We then describe an Interactive Model Development Environment (IMDE) approach to developing mission planning systems. This approach integrates modeling and simulation environments to reduce model editing time, generate simulations automatically to evaluate plans, and identify modeling errors automatically by evaluating simulation output. The IMDE approach was tested on a small subset of the Lunar Atmosphere and Dust Environment Explorer (LADEE) flight software to demonstrate how to develop the LADEE mission planning system.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693059','10.1109/ASE.2013.6693059',0,0,'IEEE','IEEE Conferences',0),(795,'LED: Tool for Synthesizing Web Element Locators',9,848,851,'Web applications are growing fast in popularity and complexity. One of the major problems faced by web developers is writing JavaScript code that can retrieve Document Object Model (DOM) tree elements, and is consistent among multiple DOM states. We attempt to solve this problem by automatically synthesizing JavaScript code that interacts with the DOM. We present an automated tool called LED, to analyze the DOM elements, and synthesize code to select the DOM elements based on the DOM hierarchy as well as the nature of task that the user wants to perform. LED provides an interactive drag and drop support inside the browser for selecting positive and negative examples of DOM elements. We find that LED supports at least 86% of the locators used in the JavaScript code of deployed web applications, and that the locators synthesized by LED have a recall of 98% and a precision of 63%. LED is fast, taking only 0.23 seconds on average to synthesize a locator.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372078','10.1109/ASE.2015.110',14,0,'IEEE','IEEE Conferences',0),(796,'The bounded model checker LLBMC',6,706,709,'This paper presents LLBMC, a tool for finding bugs and runtime errors in sequential C/C++ programs. LLBMC employs bounded model checking using an SMT-solver for the theory of bitvectors and arrays and thus achieves precision down to the level of single bits. The two main features of LLBMC that distinguish it from other bounded model checking tools for C/C++ are (i) its bit-precise memory model, which makes it possible to support arbitrary type conversions via stores and loads; and (ii) that it operates on a compiler intermediate representation and not directly on the source code.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693138','10.1109/ASE.2013.6693138',21,14,'IEEE','IEEE Conferences',0),(797,'Cobra 鈥� An interactive static code analyzer',8,1,1,'Sadly we know that virtually all software of any significance has residual errors. Some of those errors can be traced back to requirements flaws or faulty design assumptions; others are just plain coding mistakes. Static analyzers have become quite good at spotting these types of errors, but they don\'t scale very well. If, for instance, you need to check a code base of a few million lines you better be prepared to wait for the result; sometimes hours. Eyeballing a large code base to find flaws is clearly not an option, so what is missing is a static analysis capability that can be used to answer common types of queries interactively, even for large code bases. I will describe the design and use of such a tool in this talk.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115610','10.1109/ASE.2017.8115610',0,0,'IEEE','IEEE Conferences',0),(798,'Measuring Object-Oriented Design Principles',9,882,885,'The idea of automatizing the assessment of object-oriented design is not new. Different approaches define and apply their own quality models, which are composed of single metrics or combinations thereof, to operationalize software design. However, single metrics are too fine-grained to identify core design flaws and they cannot provide hints for making design improvements. In order to deal with these weaknesses of metric-based models, rules-based approaches have proven successful in the realm of source-code quality. Moreover, for developing a well-designed software system, design principles play a key role, as they define fundamental guidelines and help to avoid pitfalls. Therefore, this thesis will enhance and complete a rule-based quality reference model for operationalizing design principles and will provide a measuring tool that implements these rules. The validation of the design quality model and the measurement tool will be based on various industrial projects. Additionally, quantitative and qualitative surveys will be conducted in order to get validated results on the value of object-oriented design principles for software development.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372084','10.1109/ASE.2015.17',14,1,'IEEE','IEEE Conferences',0),(799,'Characterizing and taming non-deterministic bugs in Javascript applications',8,1006,1009,'JavaScript has become one of the most popular programming languages for both client-side and server-side applications. In JavaScript applications, events may be generated, triggered and consumed non-deterministically. Thus, JavaScript applications may suffer from non-deterministic bugs, when events are triggered and consumed in an unexpected order. In this proposal, we aim to characterize and combat non-deterministic bugs in JavaScript applications. Specifically, we first perform a comprehensive study about real-world non-deterministic bugs in server-side JavaScript applications. In order to facilitate bug diagnosis, we further propose approaches to isolate the necessary events that are responsible for the occurrence of a failure. We also plan to design new techniques in detecting non-deterministic bugs in JavaScript applications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115720','10.1109/ASE.2017.8115720',25,0,'IEEE','IEEE Conferences',0),(800,'Software engineering without borders',8,3,3,'DevOps approaches software engineering by advocating the removal of borders between development and operations. DevOps emphasizes operational resilience, continuous feedback from operations back to development, and rapid deployment of features developed. In this talk we will look at selected (automation) aspects related to DevOps, based on our collaborations with various industrial partners. For example, we will explore (automated) methods for analyzing log data to support deployments and monitor REST API integrations, (search-based) test input generation for reproducing crashes and testing complex database queries, and zero downtime database schema evolution and deployment. We will close by looking at borders beyond those between development and operations, in order to see whether there are other borders we need to remove in order to strengthen the impact of software engineering research.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115612','10.1109/ASE.2017.8115612',0,0,'IEEE','IEEE Conferences',0),(801,'MetaMod: A Modeling Formalism with Modularity at Its Core',9,890,893,'Because modern engineering products require more and more functionality, the models used in the design of these products get larger and more complex. A way to handle this complexity would be a suitable mechanism to modularize models. However, current approaches in the Model Driven Engineering field have limited support for modularity. This is the gap that our research addresses. We want to tackle the gap by designing and creating a modeling formalism with modularity at its core - MetaMod. We are including the modeling formalism into a prototype such that we can experiment with it. Our evaluation plan includes bootstrapping MetaMod (defining MetaMod in MetaMod) and creating an industrial DSL in MetaMod.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372086','10.1109/ASE.2015.29',16,1,'IEEE','IEEE Conferences',0),(802,'TRAM: A tool for transforming textual requirements into analysis models',6,738,741,'Tool support for automatically constructing analysis models from the natural language specification of requirements (NLR) is critical to model driven development (MDD), as it can bring forward the use of precise formal languages from the coding to the specification phase in the MDD lifecycle. TRAM provides such a support through a novel approach. By using a set of conceptual patterns to facilitate the transformation of an NLR to its target software model, TRAM has shown its potential as an automated tool to support the earliest phase of MDD. This paper describes TRAM and evaluates the tool against three benchmark approaches.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693146','10.1109/ASE.2013.6693146',15,4,'IEEE','IEEE Conferences',0),(803,'Understanding, Refactoring, and Fixing Concurrency in C#',9,898,901,'Industry leaders provide concurrent libraries because asynchronous & parallel programming are increasingly in demand: responsiveness, scalability, and high-throughput are key elements of all modern applications. However, we know little about how developers use these concurrent libraries in practice and the developer\'s toolbox for concurrency is very limited. We present the first study that analyzes the usage of concurrent libraries in large codebases, such as 2258 open-source C# apps comprising 54M SLOC and 1378 open-source Windows Phone apps comprising 12M SLOC. Using this data, we find important problems about use and misuse of concurrency. Inspired by our findings, we designed, evaluated, and implemented several static analyses and refactoring tools.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372088','10.1109/ASE.2015.82',25,0,'IEEE','IEEE Conferences',0),(804,'Privacy-aware data-intensive applications',8,1030,1033,'The rise of Big Data is leading to an increasing demand for data-intensive applications (DIAs), which, in many cases, are expected to process massive amounts of sensitive data. In this context, ensuring data privacy becomes paramount. While the way we design and develop DIAs has radically changed over the last few years in order to deal with Big Data, there has been relatively little effort to make such design privacy-aware. As a result, enforcing privacy policies in large-scale data processing is currently an open research problem. This thesis proposal makes one step towards this investigation: after identifying the dataflow model as the reference computational model for large-scale DIAs, (1) we propose a novel language for specifying privacy policies on dataflow applications along with (2) a dataflow rewriting mechanism to enforce such policies during DIA execution. Although a systematic evaluation still needs to be carried out, preliminary results are promising. We plan to implement our approach within a model-driven solution to ultimately simplify the design and development of privacy-aware DIAs, i.e. DIAs that ensure privacy policies at runtime.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115726','10.1109/ASE.2017.8115726',11,0,'IEEE','IEEE Conferences',0),(805,'Clone Merge -- An Eclipse Plugin to Abstract Near-Clone C++ Methods',9,819,823,'Software clones are prevalent. In the work of Lagu毛 et al. [2], they observe that 6.4% and 7.5% of the source code in different versions of a large, mature code base are clones. The work of Baxter et al. [1] reports even higher numbers, sometimes exceeding 25%. We consider the prevalence of such near miss clones to be strong indicators that copy-paste-modify is a wide-spread development methodology. Even though clones are prevalent, they are a significant development headache. Specially, if bugs arise in one of the clones, they need to be fixed in all of the clones. This problem is acknowledged in the work of Juergens et al. [4] who say in their work that \'cloning can be a substantial problem during development and maintenance\', since \'inconsistent clones constitute a major source of faults\'. A similar concern is raised in practitioner literature [3] suggesting that clones should be removed in some form or the other. We present a tool that can be installed as a plugin to Eclipse CDT, the development environment for C/C++. The research prototype comes with a refactoring option called \'Copy Paste merge\' refactoring, which is available as a menu option in the modified version of the Eclipse CDT.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372073','10.1109/ASE.2015.103',7,0,'IEEE','IEEE Conferences',0),(806,'BOOM: Experiences in language and tool design for distributed systems (keynote)',6,1,1,'With the rapid expansion of cloud infrastructure and mobile devices, distributed systems have quickly emerged as a dominant computing platform. Distributed systems bring significant complexity to programming, due to platform issues including asynchrony, concurrency, and partial failure. Meanwhile, scalable distributed infrastructure鈥攏otably 鈥淣oSQL鈥� systems鈥攈ave put additional burdens on programmers by sacrificing traditional infrastructure contracts like linearizable or transactional I/O in favor of high availability. A growing segment of the developer community needs to deal with these issues today, and for the most part developers are still using languages and tools designed for sequential computation on tightly coupled architectures. This has led to software that is increasingly hard to test and hard to trust. Over the past 5 years, the BOOM project at Berkeley has focused on making it easier to write correct and maintainable code for distributed systems. Our work has taken a number of forms, including the development of the Bloom programming language for distributed systems, tools for testing and checking distributed programs, and the CALM Theorem, which connects programmer level concerns of determinism to system-level concerns about the need for distributed coordination. This talk will reflect on this work, and highlight opportunities for improved collaboration between the software engineering and distributed systems research communities.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693058','10.1109/ASE.2013.6693058',0,0,'IEEE','IEEE Conferences',0),(807,'Tool support for automatic model transformation specification using concrete visualisations',6,718,721,'Complex model transformation is crucial in several domains, including Model-Driven Engineering (MDE), information visualisation and data mapping. Most current approaches use meta-model-driven transformation specification via coding in textual scripting languages. This paper demonstrates a novel approach and tool support that instead provides for specification of correspondences between models using concrete visualisations of source and target models, and generates transformation scripts from these by-example model correspondence specifications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693141','10.1109/ASE.2013.6693141',9,1,'IEEE','IEEE Conferences',0),(808,'Mining structures from massive text data: Will it help software engineering?',8,2,2,'The real-world big data are largely unstructured, interconnected text data. One of the grand challenges is to turn such massive unstructured text data into structured, actionable knowledge. We propose a text mining approach that requires only distant or minimal supervision but relies on massive text data. We show quality phrases can be mined from such massive text data, types can be extracted from massive text data with distant supervision, and entities/attributes/values can be discovered by meta-path directed pattern discovery. We show text-rich and structure-rich networks can be constructed from massive unstructured data. Finally, we speculate whether such a paradigm could be useful for turning massive software repositories into multi-dimensional structures to help searching and mining software repositories.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115611','10.1109/ASE.2017.8115611',0,0,'IEEE','IEEE Conferences',0),(809,'Crushinator: A framework towards game-independent testing',6,726,729,'Testing game applications relies heavily on beta testing methods. The effectiveness of beta testing depends on how well beta testers represent the common game-application users and if users are willing to participate in the beta test. An automated testing tool framework could reduce the dependence upon beta testing by most companies to analyze their game applications. This paper presents the Crushinator as one such framework. This framework provides a game-independent testing tool that implements multiple testing methods that can assist and possibly replace the use of beta testing.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693143','10.1109/ASE.2013.6693143',14,5,'IEEE','IEEE Conferences',0),(810,'Towards API-specific automatic program repair',8,1010,1013,'The domain of Automatic Program Repair (APR) had many research contributions in recent years. So far, most approaches target fixing generic bugs in programs (e.g., off-by-one errors). Nevertheless, recent studies reveal that about 50% of real bugs require API-specific fixes (e.g., adding missing API method calls or correcting method ordering), for which existing APR approaches are not designed. In this paper, we address this problem and introduce the notion of an API-specific program repair mechanism. This mechanism detects erroneous code in a similar way to existing APR approaches. However, to fix such bugs, it uses API-specific information from the erroneous code to search for API usage patterns in other software, with which we could fix the bug. We provide first insights on the applicability of this mechanism and discuss upcoming research challenges.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115721','10.1109/ASE.2017.8115721',38,0,'IEEE','IEEE Conferences',0),(811,'Developing self-verifying service-based systems',6,734,737,'We present a tool-supported framework for the engineering of service-based systems (SBSs) capable of self-verifying their compliance with developer-specified reliability requirements. These self-verifying systems select their services dynamically by using a combination of continual quantitative verification and online updating of the verified models. Our framework enables the practical exploitation of recent theoretical advances in the development of self-adaptive SBSs through (a) automating the generation of the software components responsible for model updating, continual verification and service selection; and (b) employing standard SBS development processes.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693145','10.1109/ASE.2013.6693145',16,13,'IEEE','IEEE Conferences',0),(812,'A Generic Framework for Concept-Based Exploration of Semi-Structured Software Engineering Data',9,894,897,'Software engineering meta-data (SE data), such as revision control data, Github project data or test reports, is typically semi-structured, it comprises a mixture of formatted and free-text fields and is often self-describing. Semi-structured SE data cannot be queried in a SQL-like manner because of its lack of structure. Consequently, there are a variety of customized tools built to analyze specific datasets but these do not generalize. We propose to develop a generic framework for exploration and querying of semi-structured SE data. Our approach investigates the use of a formal concept lattice as a universal data structure and a tag cloud as an intuitive interface to support data exploration.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372087','10.1109/ASE.2015.34',21,5,'IEEE','IEEE Conferences',0),(813,'Automatic Self-Validation for Code Coverage Profilers',7,79,90,'Code coverage as the primitive dynamic program behavior information, is widely adopted to facilitate a rich spectrum of software engineering tasks, such as testing, fuzzing, debugging, fault detection, reverse engineering, and program understanding. Thanks to the widespread applications, it is crucial to ensure the reliability of the code coverage profilers. Unfortunately, due to the lack of research attention and the existence of testing oracle problem, coverage profilers are far away from being tested sufficiently. Bugs are still regularly seen in the widely deployed profilers, like gcov and llvm-cov, along with gcc and llvm, respectively. This paper proposes Cod, an automated self-validator for effectively uncovering bugs in the coverage profilers. Starting from a test program (either from a compiler\'s test suite or generated randomly), Cod detects profiler bugs with zero false positive using a metamorphic relation in which the coverage statistics of that program and a mutated variant are bridged. We evaluated Cod over two of the most well-known code coverage profilers, namely gcov and llvm-cov. Within a four-month testing period, a total of 196 potential bugs (123 for gcov, 73 for llvm-cov) are found, among which 23 are confirmed by the developers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952463','10.1109/ASE.2019.00018',51,0,'IEEE','IEEE Conferences',0),(814,'Machine Learning Based Recommendation of Method Names: How Far are We',7,602,614,'High quality method names are critical for the readability and maintainability of programs. However, constructing concise and consistent method names is often challenging, especially for inexperienced developers. To this end, advanced machine learning techniques have been recently leveraged to recommend method names automatically for given method bodies/implementation. Recent large-scale evaluations also suggest that such approaches are accurate. However, little is known about where and why such approaches work or don\'t work. To figure out the state of the art as well as the rationale for the success/failure, in this paper we conduct an empirical study on the state-of-the-art approach code2vec. We assess code2vec on a new dataset with more realistic settings. Our evaluation results suggest that although switching to new dataset does not significantly influence the performance, more realistic settings do significantly reduce the performance of code2vec. Further analysis on the successfully recommended method names also reveals the following findings: 1) around half (48.3%) of the accepted recommendations are made on getter/setter methods; 2) a large portion (19.2%) of the successfully recommended method names could be copied from the given bodies. To further validate its usefulness, we ask developers to manually score the difficulty in naming methods they developed. Code2vec is then applied to such manually scored methods to evaluate how often it works in need. Our evaluation results suggest that code2vec rarely works when it is really needed. Finally, to intuitively reveal the state of the art and to investigate the possibility of designing simple and straightforward alternative approaches, we propose a heuristics based approach to recommending method names. Evaluation results on large-scale dataset suggest that this simple heuristics-based approach significantly outperforms the state-of-the-art machine learning based approach, improving precision and recall by 65.25% and 22.45%, respectively. The comparison suggests that machine learning based recommendation of method names may still have a long way to go.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952208','10.1109/ASE.2019.00062',46,0,'IEEE','IEEE Conferences',0),(815,'Learning from Examples to Find Fully Qualified Names of API Elements in Code Snippets',7,243,254,'Developers often reuse code snippets from online forums, such as Stack Overflow, to learn API usages of software frameworks or libraries. These code snippets often contain ambiguous undeclared external references. Such external references make it difficult to learn and use those APIs correctly. In particular, reusing code snippets containing such ambiguous undeclared external references requires significant manual efforts and expertise to resolve them. Manually resolving fully qualified names (FQN) of API elements is a non-trivial task. In this paper, we propose a novel context-sensitive technique, called COSTER, to resolve FQNs of API elements in such code snippets. The proposed technique collects locally specific source code elements as well as globally related tokens as the context of FQNs, calculates likelihood scores, and builds an occurrence likelihood dictionary (OLD). Given an API element as a query, COSTER captures the context of the query API element, matches that with the FQNs of API elements stored in the OLD, and rank those matched FQNs leveraging three different scores: likelihood, context similarity, and name similarity scores. Evaluation with more than 600K code examples collected from GitHub and two different Stack Overflow datasets shows that our proposed technique improves precision by 4-6% and recall by 3-22% compared to state-of-the-art techniques. The proposed technique significantly reduces the training time compared to the StatType, a state-of-the-art technique, without sacrificing accuracy. Extensive analyses on results demonstrate the robustness of the proposed technique.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952501','10.1109/ASE.2019.00032',41,0,'IEEE','IEEE Conferences',0),(816,'Accurate Modeling of Performance Histories for Evolving Software Systems',7,640,652,'Learning from the history of a software system\'s performance behavior does not only help discovering and locating performance bugs, but also identifying evolutionary performance patterns and general trends, such as when technical debt accumulates. Exhaustive regression testing is usually impractical, because rigorous performance benchmarking requires executing a realistic workload per revision, which results in large execution times. In this paper, we propose a novel active revision sampling approach, which aims at tracking and understanding a system\'s performance history by approximating the performance behavior of a software system across all of its revisions. In a nutshell, we iteratively sample and measure the performance of specific revisions that help us building an exact performance-evolution model, and we use Gaussian Process models to assess in which revision ranges our model is most uncertain with the goal to sample further revisions for measurement. We have conducted an empirical analysis of the evolutionary performance behavior modeled as a time series of the histories of six real-world software systems. Our evaluation demonstrates that Gaussian Process models are able to accurately estimate the performance-evolution history of real-world software systems with only few measurements and to reveal interesting behaviors and trends.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952290','10.1109/ASE.2019.00065',39,0,'IEEE','IEEE Conferences',0),(817,'Model Checking Embedded Control Software using OS-in-the-Loop CEGAR',7,565,576,'Verification of multitasking embedded software requires taking into account its underlying operating system w.r.t. its scheduling policy and handling of task priorities in order to achieve a higher degree of accuracy. However, such comprehensive verification of multitasking embedded software together with its underlying operating system is very costly and impractical. To reduce the verification cost while achieving the desired accuracy, we propose a variant of CEGAR, named OiL-CEGAR (OS-in-the-Loop Counterexample-Guided Abstraction Refinement), where a composition of a formal OS model and an abstracted application program is used for comprehensive verification and is successively refined using the counterexamples generated from the composition model. The refinement process utilizes the scheduling information in the counterexample, which acts as a mini-OS to check the executability of the counterexample trace on the concrete program. Our experiments using a prototype implementation of OiL-CEGAR show that OiL-CEGAR greatly improves the accuracy and efficiency of property checking in this domain. It automatically removed all false alarms and accomplished property checking within an average of 476 seconds over a set of multitasking programs, whereas model checking using existing approaches over the same set of programs either showed an accuracy of under 11.1% or was unable to finish the verification due to timeout.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952214','10.1109/ASE.2019.00059',47,0,'IEEE','IEEE Conferences',0),(818,'Improving the Decision-Making Process of Self-Adaptive Systems by Accounting for Tactic Volatility',7,949,961,'When self-adaptive systems encounter changes withintheir surrounding environments, they enacttacticsto performnecessary adaptations. For example, a self-adaptive cloud-basedsystem may have a tactic that initiates additional computingresources when response time thresholds are surpassed, or theremay be a tactic to activate a specific security measure when anintrusion is detected. In real-world environments, these tacticsfrequently experiencetactic volatilitywhich is variable behaviorduring the execution of the tactic.Unfortunately, current self-adaptive approaches do not accountfor tactic volatility in their decision-making processes, and merelyassume that tactics do not experience volatility. This limitationcreates uncertainty in the decision-making process and mayadversely impact the system\'s ability to effectively and efficientlyadapt. Additionally, many processes do not properly account forvolatility that may effect the system\'s Service Level Agreement(SLA). This can limit the system\'s ability to act proactively, especially when utilizing tactics that contain latency.To address the challenge of sufficiently accounting for tacticvolatility, we propose aTactic Volatility Aware(TVA) solution.Using Multiple Regression Analysis (MRA), TVA enables self-adaptive systems to accurately estimate the cost and timerequired to execute tactics. TVA also utilizesAutoregressiveIntegrated Moving Average(ARIMA) for time series forecasting, allowing the system to proactively maintain specifications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952178','10.1109/ASE.2019.00092',45,0,'IEEE','IEEE Conferences',0),(819,'Characterizing Android App Signing Issues',7,280,292,'In the app releasing process, Android requires all apps to be digitally signed with a certificate before distribution. Android uses this certificate to identify the author and ensure the integrity of an app. However, a number of signature issues have been reported recently, threatening the security and privacy of Android apps. In this paper, we present the first large-scale systematic measurement study on issues related to Android app signatures. We first create a taxonomy covering four types of app signing issues (21 anti-patterns in total), including vulnerabilities, potential attacks, release bugs and compatibility issues. Then we developed an automated tool to characterize signature-related issues in over 5 million app items (3 million distinct apks) crawled from Google Play and 24 alternative Android app markets. Our empirical findings suggest that although Google has introduced apk-level signing schemes (V2 and V3) to overcome some of the known security issues, more than 93% of the apps still use only the JAR signing scheme (V1), which poses great security threats. Besides, we also revealed that 7% to 45% of the apps in the 25 studied markets have been found containing at least one signing issue, while a large number of apps have been exposed to security vulnerabilities, attacks and compatibility issues. Among them a considerable number of apps we identified are popular apps with millions of downloads. Finally, our evolution analysis suggested that most of the issues were not mitigated after a considerable amount of time across markets. The results shed light on the emergency for detecting and repairing the app signing issues.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952357','10.1109/ASE.2019.00035',64,0,'IEEE','IEEE Conferences',0),(820,'SCMiner: Localizing System-Level Concurrency Faults from Large System Call Traces',7,515,526,'Localizing concurrency faults that occur in production is hard because, (1) detailed field data, such as user input, file content and interleaving schedule, may not be available to developers to reproduce the failure; (2) it is often impractical to assume the availability of multiple failing executions to localize the faults using existing techniques; (3) it is challenging to search for buggy locations in an application given limited runtime data; and, (4) concurrency failures at the system level often involve multiple processes or event handlers (e.g., software signals), which can not be handled by existing tools for diagnosing intra-process(thread-level) failures. To address these problems, we present SCMiner, a practical online bug diagnosis tool to help developers understand how a system-level concurrency fault happens based on the logs collected by the default system audit tools. SCMiner achieves online bug diagnosis to obviate the need for offline bug reproduction. SCMiner does not require code instrumentation on the production system or rely on the assumption of the availability of multiple failing executions. Specifically, after the system call traces are collected, SCMiner uses data mining and statistical anomaly detection techniques to identify the failure-inducing system call sequences. It then maps each abnormal sequence to specific application functions. We have conducted an empirical study on 19 real-world benchmarks. The results show that SCMiner is both effective and efficient at localizing system-level concurrency faults.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952396','10.1109/ASE.2019.00055',56,0,'IEEE','IEEE Conferences',0),(821,'Discovering, Explaining and Summarizing Controversial Discussions in Community Q&A Sites',7,151,162,'Developers often look for solutions to programming problems in community Q&A sites like Stack Overflow. Due to the crowdsourcing nature of these Q&A sites, many user-provided answers are wrong, less optimal or out-of-date. Relying on community-curated quality indicators (e.g., accepted answer, answer vote) cannot reliably identify these answer problems. Such problematic answers are often criticized by other users. However, these critiques are not readily discoverable when reading the posts. In this paper, we consider the answers being criticized and their critique posts as controversial discussions in community Q&A sites. To help developers notice such controversial discussions and make more informed choices of appropriate solutions, we design an automatic open information extraction approach for systematically discovering and summarizing the controversies in Stack Overflow and exploiting official API documentation to assist the understanding of the discovered controversies. We apply our approach to millions of java/android-tagged Stack overflow questions and answers and discover a large scale of controversial discussions in Stack Overflow. Our manual evaluation confirms that the extracted controversy information is of high accuracy. A user study with 18 developers demonstrates the usefulness of our generated controversy summaries in helping developers avoid the controversial answers and choose more appropriate solutions to programming questions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952216','10.1109/ASE.2019.00024',47,0,'IEEE','IEEE Conferences',0),(822,'Cautious Adaptation of Defiant Components',7,974,985,'Systems-of-systems are formed by the composition of independently created software components. These components are designed to satisfy their individual requirements, rather than the global requirements of the systems-of-systems. We refer to components that cannot be adapted to meet both individual and global requirements as \'defiant\' components. In this paper, we propose a \'cautious\' adaptation approach which supports changing the behaviour of such defiant components under exceptional conditions to satisfy global requirements, while continuing to guarantee the satisfaction of the components\' individual requirements. The approach represents both normal and exceptional conditions as scenarios; models the behaviour of exceptional conditions as wrappers implemented using an aspect-oriented technique; and deals with both single and multiple instances of defiant components with different precedence order at runtime. We evaluated an implementation of the approach using drones and boats for an organ delivery application conceived by our industrial partners, in which we assess how the proposed approach help achieve the system-of-systems\' global requirements while accommodating increased complexity of hybrid aspects such as multiplicity, precedence ordering, openness, and heterogeneity.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952359','10.1109/ASE.2019.00094',47,0,'IEEE','IEEE Conferences',0),(823,'Goal-Driven Exploration for Android Applications',7,115,127,'This paper proposes a solution for automated goal-driven exploration of Android applications - a scenario in which a user, e.g., a security auditor, needs to dynamically trigger the functionality of interest in an application, e.g., to check whether user-sensitive info is only sent to recognized third-party servers. As the auditor might need to check hundreds or even thousands of apps, manually exploring each app to trigger the desired behavior is too time-consuming to be feasible. Existing automated application exploration and testing techniques are of limited help in this scenario as well, as their goal is mostly to identify faults by systematically exploring different app paths, rather than swiftly navigating to the target functionality. The goal-driven application exploration approach proposed in this paper, called GoalExplorer, automatically generates an executable test script that directly triggers the functionality of interest. The core idea behind GoalExplorer is to first statically model the application\'s UI screens and transitions between these screens, producing a Screen Transition Graph (STG). Then, GoalExplorer uses the STG to guide the dynamic exploration of the application to the particular target of interest: an Android activity, API call, or a program statement. The results of our empirical evaluation on 93 benchmark applications and the 95 most popular GooglePlay applications show that the STG is substantially more accurate than other Android UI models and that GoalExplorer is able to trigger a target functionality much faster than existing application exploration techniques.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952363','10.1109/ASE.2019.00021',60,0,'IEEE','IEEE Conferences',0),(824,'InFix: Automatically Repairing Novice Program Inputs',7,399,410,'This paper presents InFix, a technique for automatically fixing erroneous program inputs for novice programmers. Unlike comparable existing approaches for automatic debugging and maintenance tasks, InFix repairs input data rather than source code, does not require test cases, and does not require special annotations. Instead, we take advantage of patterns commonly used by novice programmers to automatically create helpful, high quality input repairs. InFix iteratively applies error-message based templates and random mutations based on insights about the debugging behavior of novices. This paper presents an implementation of InFix for Python. We evaluate on 29,995 unique scenarios with input-related errors collected from four years of data from Python Tutor, a free online programming tutoring environment. Our results generalize and scale; compared to previous work, we consider an order of magnitude more unique programs. Overall, InFix is able to repair 94.5% of deterministic input errors. We also present the results of a human study with 97 participants. Surprisingly, this simple approach produces high quality repairs; humans judged the output of InFix to be equally helpful and within 4% of the quality of human-generated repairs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952434','10.1109/ASE.2019.00045',51,0,'IEEE','IEEE Conferences',0),(825,'Automatic Generation of Pull Request Descriptions',7,176,188,'Enabled by the pull-based development model, developers can easily contribute to a project through pull requests (PRs). When creating a PR, developers can add a free-form description to describe what changes are made in this PR and/or why. Such a description is helpful for reviewers and other developers to gain a quick understanding of the PR without touching the details and may reduce the possibility of the PR being ignored or rejected. However, developers sometimes neglect to write descriptions for PRs. For example, in our collected dataset with over 333K PRs, more than 34% of the PR descriptions are empty. To alleviate this problem, we propose an approach to automatically generate PR descriptions based on the commit messages and the added source code comments in the PRs. We regard this problem as a text summarization problem and solve it using a novel sequence-to-sequence model. To cope with out-of-vocabulary words in software artifacts and bridge the gap between the training loss function of the sequence-to-sequence model and the evaluation metric ROUGE, which has been shown to correspond to human evaluation, we integrate the pointer generator and directly optimize for ROUGE using reinforcement learning and a special loss function. We build a dataset with over 41K PRs and evaluate our approach on this dataset through ROUGE and a human evaluation. Our evaluation results show that our approach outperforms two baselines by significant margins.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952330','10.1109/ASE.2019.00026',63,0,'IEEE','IEEE Conferences',0),(826,'An Empirical Study Towards Characterizing Deep Learning Development and Deployment Across Different Frameworks and Platforms',7,810,822,'Deep Learning (DL) has recently achieved tremendous success. A variety of DL frameworks and platforms play a key role to catalyze such progress. However, the differences in architecture designs and implementations of existing frameworks and platforms bring new challenges for DL software development and deployment. Till now, there is no study on how various mainstream frameworks and platforms influence both DL software development and deployment in practice. To fill this gap, we take the first step towards understanding how the most widely-used DL frameworks and platforms support the DL software development and deployment. We conduct a systematic study on these frameworks and platforms by using two types of DNN architectures and three popular datasets. (1) For development process, we investigate the prediction accuracy under the same runtime training configuration or same model weights/biases. We also study the adversarial robustness of trained models by leveraging the existing adversarial attack techniques. The experimental results show that the computing differences across frameworks could result in an obvious prediction accuracy decline, which should draw the attention of DL developers. (2) For deployment process, we investigate the prediction accuracy and performance (refers to time cost and memory consumption) when the trained models are migrated/quantized from PC to real mobile devices and web browsers. The DL platform study unveils that the migration and quantization still suffer from compatibility and reliability issues. Meanwhile, we find several DL software bugs by using the results as a benchmark. We further validate the results through bug confirmation from stakeholders and industrial positive feedback to highlight the implications of our study. Through our study, we summarize practical guidelines, identify challenges and pinpoint new research directions, such as understanding the characteristics of DL frameworks and platforms, avoiding compatibility and reliability issues, detecting DL software bugs, and reducing time cost and memory consumption towards developing and deploying high quality DL systems effectively.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952401','10.1109/ASE.2019.00080',70,1,'IEEE','IEEE Conferences',0),(827,'RENN: Efficient Reverse Execution with Neural-Network-Assisted Alias Analysis',7,924,935,'Reverse execution and coredump analysis have long been used to diagnose the root cause of software crashes. Each of these techniques, however, face inherent challenges, such as insufficient capability when handling memory aliases. Recent works have used hypothesis testing to address this drawback, albeit with high computational complexity, making them impractical for real world applications. To address this issue, we propose a new deep neural architecture, which could significantly improve memory alias resolution. At the high level, our approach employs a recurrent neural network (RNN) to learn the binary code pattern pertaining to memory accesses. It then infers the memory region accessed by memory references. Since memory references to different regions naturally indicate a non-alias relationship, our neural architecture can greatly reduce the burden of doing hypothesis testing to track down non-alias relation in binary code. Different from previous researches that have utilized deep learning for other binary analysis tasks, the neural network proposed in this work is fundamentally novel. Instead of simply using off-the-shelf neural networks, we designed a new recurrent neural architecture that could capture the data dependency between machine code segments. To demonstrate the utility of our deep neural architecture, we implement it as RENN, a neural network-assisted reverse execution system. We utilize this tool to analyze software crashes corresponding to 40 memory corruption vulnerabilities from the real world. Our experiments show that RENN can significantly improve the efficiency of locating the root cause for the crashes. Compared to a state-of-the-art technique, RENN has 36.25% faster execution time on average, detects an average of 21.35% more non-alias pairs, and successfully identified the root cause of 12.5% more cases.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952186','10.1109/ASE.2019.00090',50,0,'IEEE','IEEE Conferences',0),(828,'Experience Paper: Search-Based Testing in Automated Driving Control Applications',7,26,37,'Automated test generation and evaluation in simulation environments is a key technology for verification of automated driving (AD) applications. Search-based testing (SBT) is an approach for automated test generation that leverages optimization to efficiently generate interesting concrete tests from abstract test descriptions. In this experience paper, we report on our observations after successfully applying SBT to AD control applications in several use cases with different characteristics. Based on our experiences, we derive a number of lessons learned that we consider important for the adoption of SBT methods and tools in industrial settings. The key lesson is that SBT finds relevant errors and provides valuable feedback to the developers, but requires tool support for writing specifications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952365','10.1109/ASE.2019.00013',43,0,'IEEE','IEEE Conferences',0),(829,'Assessing the Generalizability of Code2vec Token Embeddings',7,1,12,'Many Natural Language Processing (NLP) tasks, such as sentiment analysis or syntactic parsing, have benefited from the development of word embedding models. In particular, regardless of the training algorithms, the learned embeddings have often been shown to be generalizable to different NLP tasks. In contrast, despite recent momentum on word embeddings for source code, the literature lacks evidence of their generalizability beyond the example task they have been trained for. In this experience paper, we identify 3 potential downstream tasks, namely code comments generation, code authorship identification, and code clones detection, that source code token embedding models can be applied to. We empirically assess a recently proposed code token embedding model, namely code2vec\'s token embeddings. Code2vec was trained on the task of predicting method names, and while there is potential for using the vectors it learns on other tasks, it has not been explored in literature. Therefore, we fill this gap by focusing on its generalizability for the tasks we have identified. Eventually, we show that source code token embeddings cannot be readily leveraged for the downstream tasks. Our experiments even show that our attempts to use them do not result in any improvements over less sophisticated methods. We call for more research into effective and general use of code embeddings.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952475','10.1109/ASE.2019.00011',65,0,'IEEE','IEEE Conferences',0),(830,'MAP-Coverage: A Novel Coverage Criterion for Testing Thread-Safe Classes',7,722,734,'Concurrent programs must be thoroughly tested, as concurrency bugs are notoriously hard to detect. Code coverage criteria can be used to quantify the richness of a test suite (e.g., whether a program has been tested sufficiently) or provide practical guidelines on test case generation (e.g., as objective functions used in program fuzzing engines). Traditional code coverage criteria are, however, designed for sequential programs and thus ineffective for concurrent programs. In this work, we introduce a novel code coverage criterion for testing thread-safe classes called MAP-coverage (short for memory-access patterns). The motivation is that concurrency bugs are often correlated with certain memory-access patterns, and thus it is desirable to comprehensively cover all memory-access patterns. Furthermore, we propose a testing method for maximizing MAP-coverage. Our method has been implemented as a self-contained toolkit, and the experimental results on 20 benchmark programs show that our toolkit outperforms existing testing methods. Lastly, we show empirically that there exists positive correlation between MAP-coverage and the effectiveness of a set of test executions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952403','10.1109/ASE.2019.00073',48,0,'IEEE','IEEE Conferences',0),(831,'CodeKernel: A Graph Kernel Based Approach to the Selection of API Usage Examples',7,590,601,'Developers often want to find out how to use a certain API (e.g., FileReader.read in JDK library). API usage examples are very helpful in this regard. Over the years, many automated methods have been proposed to generate code examples by clustering and summarizing relevant code snippets extracted from a code corpus. These approaches simplify source code as method invocation sequences or feature vectors. Such simplifications only model partial aspects of the code and tend to yield inaccurate examples. We propose CodeKernel, a graph kernel based approach to the selection of API usage examples. Instead of approximating source code as method invocation sequences or feature vectors, CodeKernel represents source code as object usage graphs. Then, it clusters graphs by embedding them into a continuous space using a graph kernel. Finally, it outputs code examples by selecting a representative graph from each cluster using designed ranking metrics. Our empirical evaluation shows that CodeKernel selects more accurate code examples than the related work (MUSE and eXoaDocs). A user study involving 25 developers in a multinational company also confirms the usefulness of CodeKernel in selecting API usage examples.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952546','10.1109/ASE.2019.00061',53,0,'IEEE','IEEE Conferences',0),(832,'Empirical Evaluation of the Impact of Class Overlap on Software Defect Prediction',7,698,709,'Software defect prediction (SDP) utilizes the learning models to detect the defective modules in project, and their performance depends on the quality of training data. The previous researches mainly focus on the quality problems of class imbalance and feature redundancy. However, training data often contains some instances that belong to different class but have similar values on features, and this leads to class overlap to affect the quality of training data. Our goal is to investigate the impact of class overlap on software defect prediction. At the same time, we propose an improved K-Means clustering cleaning approach (IKMCCA) to solve both the class overlap and class imbalance problems. Specifically, we check whether K-Means clustering cleaning approach (KMCCA) or neighborhood cleaning learning (NCL) or IKMCCA is feasible to improve defect detection performance for two cases (i) within-project defect prediction (WPDP) (ii) cross-project defect prediction (CPDP). To have an objective estimate of class overlap, we carry out our investigations on 28 open source projects, and compare the performance of state-of-the-art learning models for the above-mentioned cases by using IKMCCA or KMCCA or NCL VS. without cleaning data. The experimental results make clear that learning models obtain significantly better performance in terms of balance, Recall and AUC for both WPDP and CPDP when the overlapping instances are removed. Moreover, it is better to consider both class overlap and class imbalance.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952192','10.1109/ASE.2019.00071',41,0,'IEEE','IEEE Conferences',0),(833,'SEGATE: Unveiling Semantic Inconsistencies between Code and Specification of String Inputs',7,200,212,'Automated testing techniques are often assessed on coverage based metrics. However, despite giving good coverage, the test cases may miss the gap between functional specification and the code implementation. This gap may be subtle in nature, arising due to the absence of logical checks, either in the implementation or in the specification, resulting in inconsistencies in the input definition. The inconsistencies may be prevalent especially for structured inputs, commonly specified using string-based data types. Our study on defects reported over popular libraries reveals that such gaps may not be limited to input validation checks. We propose a test generation technique for structured string inputs where we infer inconsistencies in input definition to expose semantic gaps in the method under test and the method specification. We assess this technique using our tool SEGATE, Semantic Gap Tester. SEGATE uses static analysis and automaton modeling to infer the gap and generate test cases. On our benchmark dataset, comprising of defects reported in 15 popular open-source libraries, written in Java, SEGATE was able to generate tests to expose 80% of the defects.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952371','10.1109/ASE.2019.00028',47,0,'IEEE','IEEE Conferences',0),(834,'DaPanda: Detecting Aggressive Push Notifications in Android Apps',7,66,78,'Mobile push notifications have been widely used in mobile platforms to deliver all sorts of information to app users. Although it offers great convenience for both app developers and mobile users, this feature was frequently reported to serve malicious and aggressive purposes, such as delivering annoying push notification advertisement. However, to the best of our knowledge, this problem has not been studied by our research community so far. To fill the void, this paper presents the first study to detect aggressive push notifications and further characterize them in the global mobile app ecosystem on a large scale. To this end, we first provide a taxonomy of mobile push notifications and identify the aggressive ones using a crowdsourcing-based method. Then we propose sc DaPanda, a novel hybrid approach, aiming at automatically detecting aggressive push notifications in Android apps. sc DaPanda leverages a guided testing approach to systematically trigger and record push notifications. By instrumenting the Android framework, sc DaPanda further collects all notification-relevant runtime information to flag the aggressive ones. Our experimental results show that sc DaPanda is capable of detecting different types of aggressive push notifications effectively in an automated way. By applying sc DaPanda to 20,000 Android apps from different app markets, it yields over 1,000 aggressive notifications, which have been further confirmed as true positives. Our in-depth analysis further reveals that aggressive notifications are prevalent across different markets and could be manifested in all the phases in the lifecycle of push notifications. It is hence urgent for our community to take actions to detect and mitigate apps involving aggressive push notifications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952509','10.1109/ASE.2019.00017',75,0,'IEEE','IEEE Conferences',0),(835,'Efficient Test Generation Guided by Field Coverage Criteria',7,91,101,'Field-exhaustive testing is a testing criterion suitable for object-oriented code over complex, heap-allocated, data structures. It requires test suites to contain enough test inputs to cover all feasible values for the object\'s fields within a certain scope (input-size bound). While previous work shows that field-exhaustive suites can be automatically generated, the generation technique required a formal specification of the inputs that can be subject to SAT-based analysis. Moreover, the restriction of producing all feasible values for inputs\' fields makes test generation costly. In this paper, we deal with field coverage as testing criteria that measure the quality of a test suite in terms of coverage and mutation score, by examining to what extent the values of inputs\' fields are covered. In particular, we consider field coverage in combination with test generation based on symbolic execution to produce underapproximations of field-exhaustive suites, using the Symbolic Pathfinder tool. To underapproximate these suites we use tranScoping, a technique that estimates characteristics of yet to be run analyses for large scopes, based on data obtained from analyses performed in small scopes. This provides us with a suitable condition to prematurely stop the symbolic execution. As we show, tranScoping different metrics regarding field coverage allows us to produce significantly smaller suites using a fraction of the generation time. All this while retaining the effectiveness of field exhaustive suites in terms of test suite quality.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952481','10.1109/ASE.2019.00019',32,0,'IEEE','IEEE Conferences',0),(836,'Fine-Grain Memory Object Representation in Symbolic Execution',7,912,923,'Dynamic Symbolic Execution (DSE) has seen rising popularity as it allows to check applications for behaviours such as error patterns automatically. One of its biggest challenges is the state space explosion problem: DSE tries to evaluate all possible execution paths of an application. For every path, it needs to represent the allocated memory and its accesses. Even though different approaches have been proposed to mitigate the state space explosion problem, DSE still needs to represent a multitude of states in parallel to analyse them. If too many states are present, they cannot fit into memory, and DSE needs to terminate them prematurely or store them on disc intermediately. With a more efficient representation of allocated memory, DSE can handle more states simultaneously, improving its performance. In this work, we introduce an enhanced, fine-grain and efficient representation of memory that mimics the allocations of tested applications. We tested Coreutils using three different search strategies with our implementation on top of the symbolic execution engine KLEE. We achieve a significant reduction of the memory consumption of states by up to 99.06% (mean DFS: 2%, BFS: 51%, Cov.: 49%), allowing to represent more states in memory more efficiently. The total execution time is reduced by up to 97.81% (mean DFS: 9%, BFS: 7%, Cov.:4%)鈥攁 speedup of 49x in comparison to baseline KLEE.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952548','10.1109/ASE.2019.00089',18,0,'IEEE','IEEE Conferences',0),(837,'PeASS: A Tool for Identifying Performance Changes at Code Level',7,1146,1149,'We present PeASS (Performance Analysis of Software System versions), a tool for detecting performance changes at source code level that occur between different code versions. By using PeASS, it is possible to identify performance regressions that happened in the past to fix them. PeASS measures the performance of unit tests in different source code versions. To achieve statistic rigor, measurements are repeated and analyzed using an agnostic t-test. To execute a minimal amount of tests, PeASS uses a regression test selection. We evaluate PeASS on a selection of Apache Commons projects and show that 81% of all unit test covered performance changes can be found by PeASS. A video presentation is available at https://www.youtube.com/watch?v=RORFEGSCh6Y and PeASS can be downloaded from https://github.com/DaGeRe/peass.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952552','10.1109/ASE.2019.00123',22,0,'IEEE','IEEE Conferences',0),(838,'The Impact of Structure on Software Merging: Semistructured Versus Structured Merge',7,1002,1013,'Merge conflicts often occur when developers concurrently change the same code artifacts. While state of practice unstructured merge tools (e.g Git merge) try to automatically resolve merge conflicts based on textual similarity, semistructured and structured merge tools try to go further by exploiting the syntactic structure and semantics of the artifacts involved. Although there is evidence that semistructured merge has significant advantages over unstructured merge, and that structured merge reports significantly fewer conflicts than unstructured merge, it is unknown how semistructured merge compares with structured merge. To help developers decide which kind of tool to use, we compare semistructured and structured merge in an empirical study by reproducing more than 40,000 merge scenarios from more than 500 projects. In particular, we assess how often the two merge strategies report different results, we identify conflicts incorrectly reported by one but not by the other (false positives), and conflicts correctly reported by one but missed by the other (false negatives). Our results show that semistructured and structured merge differ in 24% of the scenarios with conflicts. Semistructured merge reports more false positives, whereas structured merge has more false negatives. Finally, we found that adapting a semistructured merge tool to resolve a particular kind of conflict makes semistructured and structured merge even closer.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952301','10.1109/ASE.2019.00097',41,0,'IEEE','IEEE Conferences',0),(839,'ReduKtor: How We Stopped Worrying About Bugs in Kotlin Compiler',7,317,326,'Bug localization is well-known to be a difficult problem in software engineering, and specifically in compiler development, where it is beneficial to reduce the input program to a minimal reproducing example; this technique is more commonly known as delta debugging. What additionally contributes to the problem is that every new programming language has its own unique quirks and foibles, making it near impossible to reuse existing tools and approaches with full efficiency. In this experience paper we tackle the delta debugging problem w.r.t. Kotlin, a relatively new programming language from JetBrains. Our approach is based on a novel combination of program slicing, hierarchical delta debugging and Kotlin-specific transformations, which are synergistic to each other. We implemented it in a prototype called ReduKtor and did extensive evaluation on both synthetic and real Kotlin programs; we also compared its performance with classic delta debugging techniques. The evaluation results support the practical usability of our approach to Kotlin delta debugging and also shows the importance of using both language-agnostic and language-specific techniques to achieve best reduction efficiency and performance.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952444','10.1109/ASE.2019.00038',27,0,'IEEE','IEEE Conferences',0),(840,'Continuous Incident Triage for Large-Scale Online Service Systems',7,364,375,'In recent years, online service systems have become increasingly popular. Incidents of these systems could cause significant economic loss and customer dissatisfaction. Incident triage, which is the process of assigning a new incident to the responsible team, is vitally important for quick recovery of the affected service. Our industry experience shows that in practice, incident triage is not conducted only once in the beginning, but is a continuous process, in which engineers from different teams have to discuss intensively among themselves about an incident, and continuously refine the incident-triage result until the correct assignment is reached. In particular, our empirical study on 8 real online service systems shows that the percentage of incidents that were reassigned ranges from 5.43% to 68.26% and the number of discussion items before achieving the correct assignment is up to 11.32 on average. To improve the existing incident triage process, in this paper, we propose DeepCT, a Deep learning based approach to automated Continuous incident Triage. DeepCT incorporates a novel GRU-based (Gated Recurrent Unit) model with an attention-based mask strategy and a revised loss function, which can incrementally learn knowledge from discussions and update incident-triage results. Using DeepCT, the correct incident assignment can be achieved with fewer discussions. We conducted an extensive evaluation of DeepCT on 14 large-scale online service systems in Microsoft. The results show that DeepCT is able to achieve more accurate and efficient incident triage, e.g., the average accuracy identifying the responsible team precisely is 0.641~0.729 with the number of discussion items increasing from 1 to 5. Also, DeepCT statistically significantly outperforms the state-of-the-art bug triage approach.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952483','10.1109/ASE.2019.00042',50,1,'IEEE','IEEE Conferences',0),(841,'Test Transfer Across Mobile Apps Through Semantic Mapping',7,42,53,'GUI-based testing has been primarily used to examine the functionality and usability of mobile apps. Despite the numerous GUI-based test input generation techniques proposed in the literature, these techniques are still limited by (1) lack of context-aware text inputs; (2) failing to generate expressive tests; and (3) absence of test oracles. To address these limitations, we propose CraftDroid, a framework that leverages information retrieval, along with static and dynamic analysis techniques, to extract the human knowledge from an existing test suite for one app and transfer the test cases and oracles to be used for testing other apps with the similar functionalities. Evaluation of CraftDroid on real-world commercial Android apps corroborates its effectiveness by achieving 73% precision and 90% recall on average for transferring both the GUI events and oracles. In addition, 75% of the attempted transfers successfully generated valid and feature-based tests for popular features among apps in the same category.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952228','10.1109/ASE.2019.00015',43,1,'IEEE','IEEE Conferences',0),(842,'Root Cause Localization for Unreproducible Builds via Causality Analysis Over System Call Tracing',7,527,538,'Localization of the root causes for unreproducible builds during software maintenance is an important yet challenging task, primarily due to limited runtime traces from build processes and high diversity of build environments. To address these challenges, in this paper, we propose RepTrace, a framework that leverages the uniform interfaces of system call tracing for monitoring executed build commands in diverse build environments and identifies the root causes for unreproducible builds by analyzing the system call traces of the executed build commands. Specifically, from the collected system call traces, RepTrace performs causality analysis to build a dependency graph starting from an inconsistent build artifact (across two builds) via two types of dependencies: read/write dependencies among processes and parent/child process dependencies, and searches the graph to find the processes that result in the inconsistencies. To address the challenges of massive noisy dependencies and uncertain parent/child dependencies, RepTrace includes two novel techniques: (1) using differential analysis on multiple builds to reduce the search space of read/write dependencies, and (2) computing similarity of the runtime values to filter out noisy parent/child process dependencies. The evaluation results of RepTrace over a set of real-world software packages show that RepTrace effectively finds not only the root cause commands responsible for the unreproducible builds, but also the files to patch for addressing the unreproducible issues. Among its Top-10 identified commands and files, RepTrace achieves high accuracy rate of 90.00% and 90.56% in identifying the root causes, respectively.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952375','10.1109/ASE.2019.00056',30,0,'IEEE','IEEE Conferences',0),(843,'Targeted Example Generation for Compilation Errors',7,327,338,'We present TEGCER, an automated feedback tool for novice programmers. TEGCER uses supervised classification to match compilation errors in new code submissions with relevant pre-existing errors, submitted by other students before. The dense neural network used to perform this classification task is trained on 15000+ error-repair code examples. The proposed model yields a test set classification Pred@3 accuracy of 97.7% across 212 error category labels. Using this model as its base, TEGCER presents students with the closest relevant examples of solutions for their specific error on demand. A large scale (N>230) usability study shows that students who use TEGCER are able to resolve errors more than 25% faster on average than students being assisted by human tutors.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952446','10.1109/ASE.2019.00039',39,0,'IEEE','IEEE Conferences',0),(844,'Semistructured Merge in JavaScript Systems',7,1014,1025,'Industry widely uses unstructured merge tools that rely on textual analysis to detect and resolve conflicts between code contributions. Semistructured merge tools go further by partially exploring the syntactic structure of code artifacts, and, as a consequence, obtaining significant merge accuracy gains for Java-like languages. To understand whether semistructured merge and the observed gains generalize to other kinds of languages, we implement two semistructured merge tools for JavaScript, and compare them to an unstructured tool. We find that current semistructured merge algorithms and frameworks are not directly applicable for scripting languages like JavaScript. By adapting the algorithms, and studying 10,345 merge scenarios from 50 JavaScript projects on GitHub, we find evidence that our JavaScript tools report fewer spurious conflicts than unstructured merge, without compromising the correctness of the merging process. The gains, however, are much smaller than the ones observed for Java-like languages, suggesting that semistructured merge advantages might be limited for languages that allow both commutative and non-commutative declarations at the same syntactic level.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952450','10.1109/ASE.2019.00098',37,0,'IEEE','IEEE Conferences',0),(845,'Detecting Error-Handling Bugs without Error Specification Input',7,213,225,'Most software systems frequently encounter errors when interacting with their environments. When errors occur, error-handling code must execute flawlessly to facilitate system recovery. Implementing correct error handling is repetitive but non-trivial, and developers often inadvertently introduce bugs into error-handling code. Existing tools require correct error specifications to detect error-handling bugs. Manually generating error specifications is error-prone and tedious, while automatically mining error specifications is hard to achieve a satisfying accuracy. In this paper, we propose EH-Miner, a novel and practical tool that can automatically detect error-handling bugs without the need for error specifications. Given a function, EH-Miner mines its error-handling rules when the function is frequently checked by an equivalent condition, and handled by the same action. We applied EH-Miner to 117 applications across 15 software domains. EH-Miner mined error-handling rules with the precision of 91.1% and the recall of 46.9%. We reported 142 bugs to developers, and 106 bugs had been confirmed and fixed at the time of writing. We further applied EH-Miner to Linux kernel, and reported 68 bugs for kernel-4.17, of which 42 had been confirmed or fixed.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952517','10.1109/ASE.2019.00029',47,0,'IEEE','IEEE Conferences',0),(846,'CoRA: Decomposing and Describing Tangled Code Changes for Reviewer',7,1050,1061,'Code review is an important mechanism for code quality assurance both in open source software and industrial software. Reviewers usually suffer from numerous, tangled and loosely related code changes that are bundled in a single commit, which makes code review very difficult. In this paper, we propose CoRA (Code Review Assistant), an automatic approach to decompose a commit into different parts and generate concise descriptions for reviewers. More specifically, CoRA can decompose a commit into independent parts (e.g., bug fixing, new feature adding, or refactoring) by code dependency analysis and tree-based similar-code detection, then identify the most important code changes in each part based on the PageRank algorithm and heuristic rules. As a result, CoRA can generate a concise description for each part of the commit. We evaluate our approach in seven open source software projects and 50 code commits. The results indicate that CoRA can improve the accuracy of decomposing code changes by 6.3% over the state-ofart practice. At the same time, CoRA can identify the important part from the fine-grained code changes with a mean average precision (MAP) of 87.7%. We also conduct a human study with eight participants to evaluate the performance and usefulness of CoRA, the user feedback indicates that CoRA can effectively help reviewers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952413','10.1109/ASE.2019.00101',53,0,'IEEE','IEEE Conferences',0),(847,'B2SFinder: Detecting Open-Source Software Reuse in COTS Software',7,1038,1049,'COTS software products are developed extensively on top of OSS projects, resulting in OSS reuse vulnerabilities. To detect such vulnerabilities, finding OSS reuses in COTS software has become imperative. While scalable to tens of thousands of OSS projects, existing binary-to-source matching approaches are severely imprecise in analyzing COTS software products, since they support only a limited number of code features, compute matching scores only approximately in measuring OSS reuses, and neglect the code structures in OSS projects. We introduce a novel binary-to-source matching approach, called B2SFINDER, to address these limitations. First of all, B2SFINDER can reason about seven kinds of code featuresthat are traceable in both binary and source code. In order to compute matching scores precisely, B2SFINDER employs a weighted feature matching algorithm that combines three matching methods (for dealing with different code features) with two importance-weighting methods (for computing the weight of an instance of a code feature in a given COTS software application based on its specificity and occurrence frequency). Finally, B2SFINDER identifies different types of code reusesbased on matching scores and code structures of OSS projects. We have implemented B2SFINDER using an optimized datastructure. We have evaluated B2SFINDERusing 21991 binaries from 1000 popular COTS software products and 2189 candidateOSS projects. Our experimental results show that B2SFINDER is not only precise but also scalable. Compared with the state ofthe art, B2SFINDER has successfully found up to 2.15x as many reuse cases in 53.85 seconds per binary file on average. We also discuss how B2SFINDER can be leveraged in detecting OSS reusevulnerabilities in practice.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952556','10.1109/ASE.2019.00100',43,0,'IEEE','IEEE Conferences',0),(848,'Property Inference for Deep Neural Networks',7,797,809,'We present techniques for automatically inferring formal properties of feed-forward neural networks. We observe that a significant part (if not all) of the logic of feed forward networks is captured in the activation status (on or off) of its neurons. We propose to extract patterns based on neuron decisions as preconditions that imply certain desirable output property e.g., the prediction being a certain class. We present techniques to extract input properties, encoding convex predicates on the input space that imply given output properties and layer properties, representing network properties captured in the hidden layers that imply the desired output behavior. We apply our techniques on networks for the MNIST and ACASXU applications. Our experiments highlight the use of the inferred properties in a variety of tasks, such as explaining predictions, providing robustness guarantees, simplifying proofs, and network distillation.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952519','10.1109/ASE.2019.00079',36,1,'IEEE','IEEE Conferences',0),(849,'Combining Spectrum-Based Fault Localization and Statistical Debugging: An Empirical Study',7,502,514,'Program debugging is a time-consuming task, and researchers have proposed different kinds of automatic fault localization techniques to mitigate the burden of manual debugging. Among these techniques, two popular families are spectrum-based fault localization (SBFL) and statistical debugging (SD), both localizing faults by collecting statistical information at runtime. Though the ideas are similar, the two families have been developed independently and their combinations have not been systematically explored. In this paper we perform a systematical empirical study on the combination of SBFL and SD. We first build a unified model of the two techniques, and systematically explore four types of variations, different predicates, different risk evaluation formulas, different granularities of data collection, and different methods of combining suspicious scores. Our study leads to several findings. First, most of the effectiveness of the combined approach contributed by a simple type of predicates: branch conditions. Second, the risk evaluation formulas of SBFL significantly outperform that of SD. Third, fine-grained data collection significantly outperforms coarse-grained data collection with a little extra execution overhead. Fourth, a linear combination of SBFL and SD predicates outperforms both individual approaches. According to our empirical study, we propose a new fault localization approach, PREDFL (Predicate-based Fault Localization), with the best configuration for each dimension under the unified model. Then, we explore its complementarity to existing techniques by integrating PREDFL with a state-of-the-art fault localization framework. The experimental results show that PREDFL can further improve the effectiveness of state-of-the-art fault localization techniques. More concretely, integrating PREDFL results in an up to 20.8% improvement w.r.t the faults successfully located at Top-1, which reveals that PREDFL complements existing techniques.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952344','10.1109/ASE.2019.00054',79,0,'IEEE','IEEE Conferences',0),(850,'SGUARD: A Feature-Based Clustering Tool for Effective Spreadsheet Defect Detection',7,1142,1145,'Spreadsheets are widely used but subject to various defects. In this paper, we present SGUARD to effectively detect spreadsheet defects. SGUARD learns spreadsheet features to cluster cells with similar computational semantics, and then refines these clusters to recognize anomalous cells as defects. SGUARD well balances the trade-off between the precision (87.8%) and recall rate (71.9%) in the defect detection, and achieves an F-measure of 0.79, exceeding existing spreadsheet defect detection techniques. We introduce the SGUARD implementation and its usage by a video presentation (https://youtu.be/gNPmMvQVf5Q), and provide its public download repository (https://github.com/sheetguard/sguard).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952240','10.1109/ASE.2019.00122',23,0,'IEEE','IEEE Conferences',0),(851,'RANDR: Record and Replay for Android Applications via Targeted Runtime Instrumentation',7,128,138,'The ability to repeat the execution of a program is a fundamental requirement in many areas of computing from computer system evaluation to software engineering. Reproducing executions of mobile apps, in particular, has proven difficult under real-life scenarios due to multiple sources of external inputs and interactive nature of the apps. Previous works that provide record/replay functionality for mobile apps are restricted to particular input sources (e.g., touchscreen events) and present deployment challenges due to intrusive modifications to the underlying software stack. Moreover, due to their reliance on record and replay of device specific events, the recorded executions cannot be reliably reproduced across different platforms. In this paper, we present a new practical approach, RandR, for record and replay of Android applications. RandR captures and replays multiple sources of input (i.e., UI and network) without requiring source code (OS or app), administrative device privileges, or any special platform support. RandR achieves these qualities by instrumenting a select set of methods at runtime within an application\'s own sandbox. In addition, to enable portability of recorded executions across different platforms for replay, RandR contextualizes UI events as interactions with particular UI components (e.g., a button) as opposed to relying on platform specific features (e.g., screen coordinates). We demonstrate RandR\'s accurate cross-platform record and replay capabilities using over 30 real-world Android apps across a variety of platforms including emulators as well as commercial off-the-shelf mobile devices deployed in real life.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952379','10.1109/ASE.2019.00022',40,0,'IEEE','IEEE Conferences',0),(852,'Performance-Boosting Sparsification of the IFDS Algorithm with Applications to Taint Analysis',7,267,279,'The IFDS algorithm can be compute-and memoryintensive for some large programs, often running for a long time (more than expected) or terminating prematurely after some time and/or memory budgets have been exhausted. In the latter case, the corresponding IFDS data-flow analyses may suffer from false negatives and/or false positives. To improve this, we introduce a sparse alternative to the traditional IFDS algorithm. Instead of propagating the data-flow facts across all the program points along the program鈥檚 (interprocedural) control flow graph, we propagate every data-flow fact directly to its next possible use points along its own sparse control flow graph constructed on the fly, thus reducing significantly both the time and memory requirements incurred by the traditional IFDS algorithm. In our evaluation, we compare FLOWDROID, a taint analysis performed by using the traditional IFDS algorithm, with our sparse incarnation, SPARSEDROID, on a set of 40 Android apps selected. For the time budget (5 hours) and memory budget (220GB) allocated per app, SPARSEDROID can run every app to completion but FLOWDROID terminates prematurely for 9 apps, resulting in an average speedup of 22.0x. This implies that when used as a market-level vetting tool, SPARSEDROID can finish analyzing these 40 apps in 2.13 hours (by issuing 228 leak warnings) while FLOWDROID manages to analyze only 30 apps in the same time period (by issuing only 147 leak warnings).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952383','10.1109/ASE.2019.00034',51,0,'IEEE','IEEE Conferences',0),(853,'Empirical Study of Programming to an Interface',7,847,850,'A popular recommendation to programmers in object-oriented software is to \'program to an interface, not an implementation\' (PTI). Expected benefits include increased simplicity from abstraction, decreased dependency on implementations, and higher flexibility. Yet, interfaces must be immutable, excessive class hierarchies can be a form of complexity, and \'speculative generality\' is a known code smell. To advance the empirical knowledge of PTI, we conducted an empirical investigation that involves 126 Java projects on GitHub, aiming to measuring the decreased dependency benefits (in terms of cochange).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952238','10.1109/ASE.2019.00083',18,0,'IEEE','IEEE Conferences',0),(854,'Mutation Analysis for Coq',7,539,551,'Mutation analysis, which introduces artificial defects into software systems, is the basis of mutation testing, a technique widely applied to evaluate and enhance the quality of test suites. However, despite the deep analogy between tests and formal proofs, mutation analysis has seldom been considered in the context of deductive verification. We propose mutation proving, a technique for analyzing verification projects that use proof assistants. We implemented our technique for the Coq proof assistant in a tool dubbed mCoq. mCoq applies a set of mutation operators to Coq definitions of functions and datatypes, inspired by operators previously proposed for functional programming languages. mCoq then checks proofs of lemmas affected by operator application. To make our technique feasible in practice, we implemented several optimizations in mCoq such as parallel proof checking. We applied mCoq to several medium and large scale Coq projects, and recorded whether proofs passed or failed when applying different mutation operators. We then qualitatively analyzed the mutants, finding many instances of incomplete specifications. For our evaluation, we made several improvements to serialization of Coq files and even discovered a notable bug in Coq itself, all acknowledged by developers. We believe mCoq can be useful both to proof engineers for improving the quality of their verification projects and to researchers for evaluating proof engineering techniques.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952421','10.1109/ASE.2019.00057',61,0,'IEEE','IEEE Conferences',0),(855,'ACTGAN: Automatic Configuration Tuning for Software Systems with Generative Adversarial Networks',7,465,476,'Complex software systems often provide a large number of parameters so that users can configure them for their specific application scenarios. However, configuration tuning requires a deep understanding of the software system, far beyond the abilities of typical system users. To address this issue, many existing approaches focus on exploring and learning good performance estimation models. The accuracy of such models often suffers when the number of available samples is small, a thorny challenge under a given tuning-time constraint. By contrast, we hypothesize that good configurations often share certain hidden structures. Therefore, instead of trying to improve the performance estimation of a given configuration, we focus on capturing the hidden structures of good configurations and utilizing such learned structure to generate potentially better configurations. We propose ACTGAN to achieve this goal. We have implemented and evaluated ACTGAN using 17 workloads with eight different software systems. Experimental results show that ACTGAN outperforms default configurations by 76.22% on average, and six state-of-the-art configuration tuning algorithms by 6.58%-64.56%. Furthermore, the ACTGAN-generated configurations are often better than those used in training and show certain features consisting with domain knowledge, both of which supports our hypothesis.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952456','10.1109/ASE.2019.00051',57,0,'IEEE','IEEE Conferences',0),(856,'Statistical Log Differencing',7,851,862,'Recent works have considered the problem of log differencing: given two or more system\'s execution logs, output a model of their differences. Log differencing has potential applications in software evolution, testing, and security. In this paper we present statistical log differencing, which accounts for frequencies of behaviors found in the logs. We present two algorithms, s2KDiff for differencing two logs, and snKDiff, for differencing of many logs at once, both presenting their results over a single inferred model. A unique aspect of our algorithms is their use of statistical hypothesis testing: we let the engineer control the sensitivity of the analysis by setting the target distance between probabilities and the statistical significance value, and report only (and all) the statistically significant differences. Our evaluation shows the effectiveness of our work in terms of soundness, completeness, and performance. It also demonstrates its effectiveness compared to previous work via a user-study and its potential applications via a case study using real-world logs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952205','10.1109/ASE.2019.00084',39,0,'IEEE','IEEE Conferences',0),(857,'VeriSmart 2.0: Swarm-Based Bug-Finding for Multi-threaded Programs with Lazy-CSeq',7,1150,1153,'Swarm-based verification methods split a verification problem into a large number of independent simpler tasks and so exploit the availability of large numbers of cores to speed up verification. Lazy-CSeq is a BMC-based bug-finding tool for C programs using POSIX threads that is based on sequentialization. Here we present the tool VeriSmart 2.0, which extends Lazy-CSeq with a swarm-based bug-finding method. The key idea of this approach is to constrain the interleaving such that context switches can only happen within selected tiles (more specifically, contiguous code segments within the individual threads). This under-approximates the program\'s behaviours, with the number and size of tiles as additional parameters, which allows us to vary the complexity of the tasks. Overall, this significantly improves peak memory consumption and (wall-clock) analysis time.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952527','10.1109/ASE.2019.00124',19,0,'IEEE','IEEE Conferences',0),(858,'Automated Trainability Evaluation for Smart Software Functions',7,998,1001,'More and more software-intensive systems employ machine learning and runtime optimization to improve their functionality by providing advanced features (e. g. personal driving assistants or recommendation engines). Such systems incorporate a number of smart software functions (SSFs) which gradually learn and adapt to the users\' preferences. A key property of SSFs is their ability to learn based on data resulting from the interaction with the user (implicit and explicit feedback)-which we call trainability. Newly developed and enhanced features in a SSF must be evaluated based on their effect on the trainability of the system. Despite recent approaches for continuous deployment of machine learning systems, trainability evaluation is not yet part of continuous integration and deployment (CID) pipelines. In this paper, we describe the different facets of trainability for the development of SSFs. We also present our approach for automated trainability evaluation within an automotive CID framework which proposes to use automated quality gates for the continuous evaluation of machine learning models. The results from our indicative evaluation based on real data from eight BMW cars highlight the importance of continuous and rigorous trainability evaluation in the development of SSFs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952173','10.1109/ASE.2019.00096',10,0,'IEEE','IEEE Conferences',0),(859,'VisFuzz: Understanding and Intervening Fuzzing with Interactive Visualization',7,1078,1081,'Fuzzing is widely used for vulnerability detection. One of the challenges for an efficient fuzzing is covering code guarded by constraints such as the magic number and nested conditions. Recently, academia has partially addressed the challenge via whitebox methods. However, high-level constraints such as array sorts, virtual function invocations, and tree set queries are yet to be handled. To meet this end, we present VisFuzz, an interactive tool for better understanding and intervening fuzzing process via real-time visualization. It extracts call graph and control flow graph from source code, maps each function and basic block to the line of source code and tracks real-time execution statistics with detail constraint contexts. With VisFuzz, test engineers first locate blocking constraints and then learn its semantic context, which helps to craft targeted inputs or update test drivers. Preliminary evaluations are conducted on four real-world programs in Google fuzzer-test-suite. Given additional 15 minutes to understand and intervene the state of fuzzing, the intervened fuzzing outperform the original pure AFL fuzzing, and the path coverage improvements range from 10.84% to 150.58%, equally fuzzed by for 12 hours.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952352','10.1109/ASE.2019.00106',14,0,'IEEE','IEEE Conferences',0),(860,'Systematically Covering Input Structure',7,189,199,'Grammar-based testing uses a given grammar to produce syntactically valid inputs. To cover program features, it is necessary to also cover input features鈥攕ay, all URL variants for a URL parser. Our k-path algorithm for grammar production systematically covers syntactic elements as well as their combinations. In our evaluation, we show that this results in a significantly higher code coverage than state of the art.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952419','10.1109/ASE.2019.00027',52,0,'IEEE','IEEE Conferences',0),(861,'Test Migration Between Mobile Apps with Similar Functionality',7,54,65,'The use of mobile apps is increasingly widespread, and much effort is put into testing these apps to make sure they behave as intended. To reduce this effort, and thus the overall cost of mobile app testing, we propose APPTESTMIGRATOR, a technique for migrating test cases between apps in the same category (e.g., banking apps). The intuition behind APPTESTMIGRATOR is that many apps share similarities in their functionality, and these similarities often result in conceptually similar user interfaces (through which that functionality is accessed). APPTESTMIGRATOR leverages these commonalities between user interfaces to migrate existing tests written for an app to another similar app. Specifically, given (1) a test case for an app (source app) and (2) a second app (target app), APPTESTMIGRATOR attempts to automatically transform the sequence of events and oracles in the test for the source app to events and oracles for the target app. We implemented APPTESTMIGRATOR for Android mobile apps and evaluated it on a set of randomly selected apps from the Google Play Store in four different categories. Our initial results are promising, support our intuition that test migration is possible, and motivate further research in this direction.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952387','10.1109/ASE.2019.00016',34,1,'IEEE','IEEE Conferences',0),(862,'Coverage-Guided Fuzzing for Feedforward Neural Networks',7,1162,1165,'Deep neural network (DNN) has been widely applied to safety-critical scenarios such as autonomous vehicle, security surveillance, and cyber-physical control systems. Yet, the incorrect behaviors of DNNs can lead to severe accidents and tremendous losses due to hidden defects. In this paper, we present DeepHunter, a general-purpose fuzzing framework for detecting defects of DNNs. DeepHunter is inspired by traditional grey-box fuzzing and aims to increase the overall test coverage by applying adaptive heuristics according to runtime feedback. Specifically, DeepHunter provides a series of seed selection strategies, metamorphic mutation strategies, and testing criteria customized to DNN testing; all these components support multiple built-in configurations which are easy to extend. We evaluated DeepHunter on two popular datasets and the results demonstrate the effectiveness of DeepHunter in achieving coverage increase and detecting real defects. A video demonstration which showcases the main features of DeepHunter can be found at https://youtu.be/s5DfLErcgrc.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952279','10.1109/ASE.2019.00127',15,0,'IEEE','IEEE Conferences',0),(863,'A Study of Oracle Approximations in Testing Deep Learning Libraries',7,785,796,'Due to the increasing popularity of deep learning (DL) applications, testing DL libraries is becoming more and more important. Different from testing general software, for which output is often asserted definitely (e.g., an output is compared with an oracle for equality), testing deep learning libraries often requires to perform oracle approximations, i.e., the output is allowed to be within a restricted range of the oracle. However, oracle approximation practices have not been studied in prior empirical work that focuses on traditional testing practices. The prevalence, common practices, maintenance and evolution challenges of oracle approximations remain unknown in literature. In this work, we study oracle approximation assertions implemented to test four popular DL libraries. Our study shows that there exists a non-negligible portion of assertions that leverage oracle approximation in the test cases of DL libraries. Also, we identify the common sources of oracles on which oracle approximations are being performed through a comprehensive manual study. Moreover, we find that developers frequently modify code related to oracle approximations, i.e., using a different approximation API, modifying the oracle or the output from the code under test, and using a different approximation threshold. Last, we performed an in-depth study to understand the reasons behind the evolution of oracle approximation assertions. Our findings reveal important maintenance challenges that developers may face when maintaining oracle approximation practices as code evolves in DL libraries.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952211','10.1109/ASE.2019.00078',28,0,'IEEE','IEEE Conferences',0),(864,'Automating CUDA Synchronization via Program Transformation',7,748,759,'While CUDA has been the most popular parallel computing platform and programming model for general purpose GPU computing, CUDA synchronization undergoes significant challenges for GPU programmers due to its intricate parallel computing mechanism and coding practices. In this paper, we propose AuCS, the first general framework to automate synchronization for CUDA kernel functions. AuCS transforms the original LLVM-level CUDA program control flow graph in a semantic-preserving manner for exploring the possible barrier function locations. Accordingly, AuCS develops mechanisms to correctly place barrier functions for automating synchronization in multiple erroneous (challenging-to-be-detected) synchronization scenarios, including data race, barrier divergence, and redundant barrier functions. To evaluate the effectiveness and efficiency of AuCS, we conduct an extensive set of experiments and the results demonstrate that AuCS can automate 20 out of 24 erroneous synchronization scenarios.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952529','10.1109/ASE.2019.00075',60,0,'IEEE','IEEE Conferences',0),(865,'History-Guided Configuration Diversification for Compiler Test-Program Generation',7,305,316,'Compilers, like other software systems, contain bugs, and compiler testing is the most widely-used way to assure compiler quality. A critical task of compiler testing is to generate test programs that could effectively and efficiently discover bugs. Though we can configure test generators such as Csmith to control the features of the generated programs, it is not clear what test configuration is effective. In particular, an effective test configuration needs to generate test programs that are bug-revealing, i.e., likely to trigger bugs, and diverse, i.e., able to discover different types of bugs. It is not easy to satisfy both properties. In this paper, we propose a novel test-program generation approach, called HiCOND, which utilizes historical data for configuration diversification to solve this challenge. HiCOND first infers the range for each option in a test configuration where bug-revealing test programs are more likely to be generated based on historical data. Then, it identifies a set of test configurations that can lead to diverse test programs through a search method (particle swarm optimization). Finally, based on the set of test configurations for compiler testing, HiCOND generates test programs, which are likely to be bug-revealing and diverse. We have conducted experiments on two popular compilers GCC and LLVM, and the results confirm the effectiveness of our approach. For example, HiCOND detects 75.00%, 133.33%, and 145.00% more bugs than the three existing approaches, respectively. Moreover, HiCOND has been successfully applied to actual compiler testing in a global IT company and detected 11 bugs during the practical evaluation.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952321','10.1109/ASE.2019.00037',58,1,'IEEE','IEEE Conferences',0),(866,'An Industrial Experience Report on Performance-Aware Refactoring on a Database-Centric Web Application',7,653,664,'Modern web applications rely heavily on databases to query and update information. To ease the development efforts, Object Relational Mapping (ORM) frameworks provide an abstraction for developers to manage databases by writing in the same Object-Oriented programming languages. Prior studies have shown that there are various types of performance issues caused by inefficient accesses to databases via different ORM frameworks (e.g., Hibernate and ActiveRecord). However, it is not clear whether the reported performance anti-patterns (common performance issues) can be generalizable across various frameworks. In particular, there is no study focusing on detecting performance issues for applications written in PHP, which is the choice of programming languages for the majority (79%) of web applications. In this experience paper, we detail our process on conducting performance-aware refactoring of an industrial web application written in Laravel, the most popular web framework in PHP. We have derived a complete catalog of 17 performance anti-patterns based on prior research and our experimentation. We have found that some of the reported anti-patterns and refactoring techniques are framework or programming language specific, whereas others are general. The performance impact of the anti-pattern instances are highly dependent on the actual usage context (workload and database settings). When communicating the performance differences before and after refactoring, the results of the complex statistical analysis may be sometimes confusing. Instead, developers usually prefer more intuitive measures like percentage improvement. Experiments show that our refactoring techniques can reduce the response time up to 93.0% and 93.4% for the industrial and the open source application under various scenarios.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952177','10.1109/ASE.2019.00066',27,0,'IEEE','IEEE Conferences',0),(867,'Efficient Transaction-Based Deterministic Replay for Multi-threaded Programs',7,760,771,'Existing deterministic replay techniques propose strategies which attempt to reduce record log sizes and achieve successful replay. However, these techniques still generate large logs and achieve replay only under certain conditions. We propose a solution based on the division of the sequence of events of each thread into sequential blocks called transactions. Our insight is that there are usually few to no atomicity violations among transactions reported during a program execution. We present TPLAY, a novel deterministic replay technique which records thread access interleavings on shared memory locations at the transactional level. TPLAY also generates an artificial pair of interleavings when an atomicity violation is reported on a transaction. We present an experiment using the Splash2x extension of the PARSEC benchmark suite. Experimental results indicate that TPLAY experiences a 13-fold improvement in record log sizes and achieves a higher replay probability in comparison to existing work.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952181','10.1109/ASE.2019.00076',31,0,'IEEE','IEEE Conferences',0),(868,'Debreach: Mitigating Compression Side Channels via Static Analysis and Transformation',7,899,911,'Compression is an emerging source of exploitable side-channel leakage that threatens data security, particularly in web applications where compression is indispensable for performance reasons. Current approaches to mitigating compression side channels have drawbacks in that they either degrade compression ratio drastically or require too much effort from developers to be widely adopted. To bridge the gap, we develop Debreach, a static analysis and program transformation based approach to mitigating compression side channels. Debreach consists of two steps. First, it uses taint analysis to soundly identify flows of sensitive data in the program and uses code instrumentation to annotate data before feeding them to the compressor. Second, it enhances the compressor to exploit the freedom to not compress of standard compression protocols, thus removing the dependency between sensitive data and the size of the compressor\'s output. Since Debreach automatically instruments applications and does not change the compression protocols, it has the advantage of being non-disruptive and compatible with existing systems. We have evaluated Debreach on a set of web server applications written in PHP. Our experiments show that, while ensuring leakage-freedom, Debreach can achieve significantly higher compression performance than state-of-the-art approaches.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952360','10.1109/ASE.2019.00088',69,0,'IEEE','IEEE Conferences',0),(869,'Regexes are Hard: Decision-Making, Difficulties, and Risks in Programming Regular Expressions',7,415,426,'Regular expressions (regexes) are a powerful mechanism for solving string-matching problems. They are supported by all modern programming languages, and have been estimated to appear in more than a third of Python and JavaScript projects. Yet existing studies have focused mostly on one aspect of regex programming: readability. We know little about how developers perceive and program regexes, nor the difficulties that they face. In this paper, we provide the first study of the regex development cycle, with a focus on (1) how developers make decisions throughout the process, (2) what difficulties they face, and (3) how aware they are about serious risks involved in programming regexes. We took a mixed-methods approach, surveying 279 professional developers from a diversity of backgrounds (including top tech firms) for a high-level perspective, and interviewing 17 developers to learn the details about the difficulties that they face and the solutions that they prefer. In brief, regexes are hard. Not only are they hard to read, our participants said that they are hard to search for, hard to validate, and hard to document. They are also hard to master: the majority of our studied developers were unaware of critical security risks that can occur when using regexes, and those who knew of the risks did not deal with them in effective manners. Our findings provide multiple implications for future work, including semantic regex search engines for regex reuse and improved input generators for regex validation.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952499','10.1109/ASE.2019.00047',60,1,'IEEE','IEEE Conferences',0),(870,'A Qualitative Analysis of Android Taint-Analysis Results',7,102,114,'In the past, researchers have developed a number of popular taint-analysis approaches, particularly in the context of Android applications. Numerous studies have shown that automated code analyses are adopted by developers only if they yield a good \'signal to noise ratio\', i.e., high precision. Many previous studies have reported analysis precision quantitatively, but this gives little insight into what can and should be done to increase precision further. To guide future research on increasing precision, we present a comprehensive study that evaluates static Android taint-analysis results on a qualitative level. To unravel the exact nature of taint flows, we have designed COVA, an analysis tool to compute partial path constraints that inform about the circumstances under which taint flows may actually occur in practice. We have conducted a qualitative study on the taint flows reported by FlowDroid in 1,022 real-world Android applications. Our results reveal several key findings: Many taint flows occur only under specific conditions, e.g., environment settings, user interaction, I/O. Taint analyses should consider the application context to discern such situations. COVA shows that few taint flows are guarded by multiple different kinds of conditions simultaneously, so tools that seek to confirm true positives dynamically can concentrate on one kind at a time, e.g., only simulating user interactions. Lastly, many false positives arise due to a too liberal source/sink configuration. Taint analyses must be more carefully configured, and their configuration could benefit from better tool assistance.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952502','10.1109/ASE.2019.00020',59,0,'IEEE','IEEE Conferences',0),(871,'RefBot: Intelligent Software Refactoring Bot',7,823,834,'The adoption of refactoring techniques for continuous integration received much less attention from the research community comparing to root-canal refactoring to fix the quality issues in the whole system. Several recent empirical studies show that developers, in practice, are applying refactoring incrementally when they are fixing bugs or adding new features. There is an urgent need for refactoring tools that can support continuous integration and some recent development processes such as DevOps that are based on rapid releases. Furthermore, several studies show that manual refactoring is expensive and existing automated refactoring tools are challenging to configure and integrate into the development pipelines with significant disruption cost. In this paper, we propose, for the first time, an intelligent software refactoring bot, called RefBot. Integrated into the version control system (e.g. GitHub), our bot continuously monitors the software repository, and it is triggered by any \'open\' or \'merge\' action on pull requests. The bot analyzes the files changed during that pull request to identify refactoring opportunities using a set of quality attributes then it will find the best sequence of refactorings to fix the quality issues if any. The bot recommends all these refactorings through an automatically generated pull-request. The developer can review the recommendations and their impacts in a detailed report and select the code changes that he wants to keep or ignore. After this review, the developer can close and approve the merge of the bot\'s pull request. We quantitatively and qualitatively evaluated the performance and effectiveness of RefBot by a survey conducted with experienced developers who used the bot on both open source and industry projects','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952287','10.1109/ASE.2019.00081',49,0,'IEEE','IEEE Conferences',0),(872,'Understanding Exception-Related Bugs in Large-Scale Cloud Systems',7,339,351,'Exception mechanism is widely used in cloud systems. This is mainly because it separates the error handling code from main business logic. However, the huge space of potential error conditions and the sophisticated logic of cloud systems present a big hurdle to the correct use of exception mechanism. As a result, mistakes in the exception use may lead to severe consequences, such as system downtime and data loss. To address this issue, the communities direly need a better understanding of the exception-related bugs, i.e., eBugs, which are caused by the incorrect use of exception mechanism, in cloud systems. In this paper, we present a comprehensive study on 210 eBugs from six widely-deployed cloud systems, including Cassandra, HBase, HDFS, Hadoop MapReduce, YARN, and ZooKeeper. For all the studied eBugs, we analyze their triggering conditions, root causes, bug impacts, and their relations. To the best of our knowledge, this is the first study on eBugs in cloud systems, and the first one that focuses on triggering conditions. We find that eBugs are severe in cloud systems: 74% of our studied eBugs affect system availability or integrity. Luckily, exposing eBugs through testing is possible: 54% of the eBugs are triggered by non-semantic conditions, such as network errors; 40% of the eBugs can be triggered by simulating the triggering conditions at simple system states. Furthermore, we find that the triggering conditions are useful for detecting eBugs. Based on such relevant findings, we build a static analysis tool, called DIET, and apply it to the latest versions of the studied systems. Our results show that DIET reports 31 bugs and bad practices, and 23 of them are confirmed by the developers as \'previously-unknown\' ones.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952179','10.1109/ASE.2019.00040',55,0,'IEEE','IEEE Conferences',0),(873,'Accurate String Constraints Solution Counting with Weighted Automata',7,440,452,'As an important extension of symbolic execution (SE), probabilistic symbolic execution (PSE) computes execution probabilities of program paths. Using this information, PSE can prioritize path exploration strategies. To calculate the probability of a path PSE relies on solution counting approaches for the path constraint. The correctness of a solution counting approach depends on the methodology used to count solutions and whether a path constraint maintains a one-to-one relation with program input values. This work focuses on the latter aspect of the solution counting correctness for string constraints. In general, maintaining a one-to-one relation is not always possible, especially in the presence of non-linear constraints. To deal with this issue, researchers that work on PSE for numerical domains either analyze programs with linear constraints, or develop novel techniques to handle solution counting of non-linear constraints. For the string domain, however, previous work on PSE mainly focuses on efficient and accurate solution counting for automata-based string models and has not investigated whether a one-to-one relationship between the strings encoded by automata and input string values is preserved. In this work we demonstrate that traditional automata-based string models fail to maintain one-to-one relations and propose to use the weighted automata model, which preserves the one-to-one relation between the path constraint it encodes and the input string values. We use this model to implement a string constraint solver and show its correctness on a set of non-trivial synthetic benchmarks. We also present an empirical evaluation of traditional and proposed automata solvers on real-world string constraints. The evaluations show that while being less efficient than traditional automata models, the weighted automata model maintains correct solution counts.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952608','10.1109/ASE.2019.00049',43,0,'IEEE','IEEE Conferences',0),(874,'Wuji: Automatic Online Combat Game Testing Using Evolutionary Deep Reinforcement Learning',7,772,784,'Game testing has been long recognized as a notoriously challenging task, which mainly relies on manual playing and scripting based testing in game industry. Even until recently, automated game testing still remains to be largely untouched niche. A key challenge is that game testing often requires to play the game as a sequential decision process. A bug may only be triggered until completing certain difficult intermediate tasks, which requires a certain level of intelligence. The recent success of deep reinforcement learning (DRL) sheds light on advancing automated game testing, without human competitive intelligent support. However, the existing DRLs mostly focus on winning the game rather than game testing. To bridge the gap, in this paper, we first perform an in-depth analysis of 1349 real bugs from four real-world commercial game products. Based on this, we propose four oracles to support automated game testing, and further propose Wuji, an on-the-fly game testing framework, which leverages evolutionary algorithms, DRL and multi-objective optimization to perform automatic game testing. Wuji balances between winning the game and exploring the space of the game. Winning the game allows the agent to make progress in the game, while space exploration increases the possibility of discovering bugs. We conduct a large-scale evaluation on a simple game and two popular commercial games. The results demonstrate the effectiveness of Wuji in exploring space and detecting bugs. Moreover, Wuji found 3 previously unknown bugs, which have been confirmed by the developers, in the commercial games.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952543','10.1109/ASE.2019.00077',47,0,'IEEE','IEEE Conferences',0),(875,'Verifying Arithmetic in Cryptographic C Programs',7,552,564,'Cryptographic primitives are ubiquitous for modern security. The correctness of their implementations is crucial to resist malicious attacks. Typical arithmetic computation of these C programs contains large numbers of non-linear operations, hence is challenging existing automatic C verification tools. We present an automated approach to verify cryptographic C programs. Our approach successfully verifies C implementations of various arithmetic operations used in NIST P-224, P-256, P-521 and Curve25519 in OpenSSL. During verification, we expose a bug and a few anomalies that have been existing for a long time. They have been reported to and confirmed by the OpenSSL community. Our results establish the functional correctness of these C implementations for the first time.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952256','10.1109/ASE.2019.00058',40,0,'IEEE','IEEE Conferences',0),(876,'Understanding Automatically-Generated Patches Through Symbolic Invariant Differences',7,411,414,'Developer trust is a major barrier to the deployment of automatically-generated patches. Understanding the effect of a patch is a key element of that trust. We find that differences in sets of formal invariants characterize patch differences and that implication-based distances in invariant space characterize patch similarities. When one patch is similar to another it often contains the same changes as well as additional behavior; this pattern is well-captured by logical implication. We can measure differences using a theorem prover to verify implications between invariants implied by separate programs. Although effective, theorem provers are computationally intensive; we find that string distance is an efficient heuristic for implication-based distance measurements. We propose to use distances between patches to construct a hierarchy highlighting patch similarities. We evaluated this approach on over 300 patches and found that it correctly categorizes programs into semantically similar clusters. Clustering programs reduces human effort by reducing the number of semantically distinct patches that must be considered by over 50%, thus reducing the time required to establish trust in automatically generated repairs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952219','10.1109/ASE.2019.00046',20,0,'IEEE','IEEE Conferences',0),(877,'Get Rid of Inline Assembly through Verification-Oriented Lifting',7,577,589,'Formal methods for software development have made great strides in the last two decades, to the point that their application in safety-critical embedded software is an undeniable success. Their extension to non-critical software is one of the notable forthcoming challenges. For example, C programmers regularly use inline assembly for low-level optimizations and system primitives. This usually results in rendering state-of-the-art formal analyzers developed for C ineffective. We thus propose TINA, the first automated, generic, verification-friendly and trustworthy lifting technique turning inline assembly into semantically equivalent C code amenable to verification, in order to take advantage of existing C analyzers. Extensive experiments on real-world code (including GMP and ffmpeg) show the feasibility and benefits of TINA.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952223','10.1109/ASE.2019.00060',59,0,'IEEE','IEEE Conferences',0),(878,'Emotions Extracted from Text vs. True Emotions鈥揂n Empirical Evaluation in SE Context',7,230,242,'Emotion awareness research in SE context has been growing in recent years. Currently, researchers often rely on textual communication records to extract emotion states using natural language processing techniques. However, how well these extracted emotion states reflect people\'s real emotions has not been thoroughly investigated. In this paper, we report a multi-level, longitudinal empirical study with 82 individual members in 27 project teams. We collected their self-reported retrospective emotion states on a weekly basis during their year-long projects and also extracted corresponding emotions from the textual communication records. We then model and compare the dynamics of these two types of emotions using multiple statistical and time series analysis methods. Our analyses yield a rich set of findings. The most important one is that the dynamics of emotions extracted using text-based algorithms often do not well reflect the dynamics of self-reported retrospective emotions. Besides, the extracted emotions match self-reported retrospective emotions better at the team-level. Our results also suggest that individual personalities and the team\'s emotion display norms significantly impact the match/mismatch. Our results should warn the research community about the limitations and challenges of applying text-based emotion recognition tools in SE research.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952437','10.1109/ASE.2019.00031',89,0,'IEEE','IEEE Conferences',0),(879,'V2: Fast Detection of Configuration Drift in Python',7,477,488,'Code snippets are prevalent, but are hard to reuse because they often lack an accompanying environment configuration. Most are not actively maintained, allowing for drift between the most recent possible configuration and the code snippet as the snippet becomes out-of-date over time. Recent work has identified the problem of validating and detecting out-of-date code snippets as the most important consideration for code reuse. However, determining if a snippet is correct, but simply out-of-date, is a non-trivial task. In the best case, breaking changes are well documented, allowing developers to manually determine when a code snippet contains an out-of-date API usage. In the worst case, determining if and when a breaking change was made requires an exhaustive search through previous dependency versions. We present V2, a strategy for determining if a code snippet is out-of-date by detecting discrete instances of configuration drift, where the snippet uses an API which has since undergone a breaking change. Each instance of configuration drift is classified by a failure encountered during validation and a configuration patch, consisting of dependency version changes, which fixes the underlying fault. V2 uses feedback-directed search to explore the possible configuration space for a code snippet, reducing the number of potential environment configurations that need to be validated. When run on a corpus of public Python snippets from prior research, V2 identifies 248 instances of configuration drift.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952262','10.1109/ASE.2019.00052',33,0,'IEEE','IEEE Conferences',0),(880,'Automated Refactoring to Reactive Programming',7,835,846,'Reactive programming languages and libraries, such as ReactiveX, have been shown to significantly improve software design and have seen important industrial adoption over the last years. Asynchronous applications - which are notoriously error-prone to implement and to maintain - greatly benefit from reactive programming because they can be defined in a declarative style, which improves code clarity and extensibility. In this paper, we tackle the problem of refactoring existing software that has been designed with traditional abstractions for asynchronous programming. We propose 2Rx, a refactoring approach to automatically convert asynchronous code to reactive programming. Our evaluation on top-starred GitHub projects shows that 2Rx is effective with the most common asynchronous constructs, covering 12.7% of projects with asynchronous computations, and it can provide a refactoring for 91.7% of their occurrences.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952329','10.1109/ASE.2019.00082',59,0,'IEEE','IEEE Conferences',0),(881,'Active Hotspot: An Issue-Oriented Model to Monitor Software Evolution and Degradation',7,986,997,'Architecture degradation has a strong negative impact on software quality and can result in significant losses. Severe software degradation does not happen overnight. Software evolves continuously, through numerous issues, fixing bugs and adding new features, and architecture flaws emerge quietly and largely unnoticed until they grow in scope and significance when the system becomes difficult to maintain. Developers are largely unaware of these flaws or the accumulating debt as they are focused on their immediate tasks of address individual issues. As a consequence, the cumulative impacts of their activities, as they affect the architecture, go unnoticed. To detect these problems early and prevent them from accumulating into severe ones we propose to monitor software evolution by tracking the interactions among files revised to address issues. In particular, we propose and show how we can automatically detect active hotspots, to reveal architecture problems. We have studied hundreds of hotspots along the evolution timelines of 21 open source projects and showed that there exist just a few dominating active hotspots per project at any given time. Moreover, these dominating active hotspots persist over long time periods, and thus deserve special attention. Compared with state-of-the-art design and code smell detection tools we report that, using active hotspots, it is possible to detect signs of software degradation both earlier and more precisely.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952512','10.1109/ASE.2019.00095',55,0,'IEEE','IEEE Conferences',0),(882,'Automating App Review Response Generation',7,163,175,'Previous studies showed that replying to a user review usually has a positive effect on the rating that is given by the user to the app. For example, Hassan et al. found that responding to a review increases the chances of a user updating their given rating by up to six times compared to not responding. To alleviate the labor burden in replying to the bulk of user reviews, developers usually adopt a template-based strategy where the templates can express appreciation for using the app or mention the company email address for users to follow up. However, reading a large number of user reviews every day is not an easy task for developers. Thus, there is a need for more automation to help developers respond to user reviews. Addressing the aforementioned need, in this work we propose a novel approach RRGen that automatically generates review responses by learning knowledge relations between reviews and their responses. RRGen explicitly incorporates review attributes, such as user rating and review length, and learns the relations between reviews and corresponding responses in a supervised way from the available training data. Experiments on 58 apps and 309,246 review-response pairs highlight that RRGen outperforms the baselines by at least 67.4% in terms of BLEU-4 (an accuracy measure that is widely used to evaluate dialogue response generation systems). Qualitative analysis also confirms the effectiveness of RRGen in generating relevant and accurate responses.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952476','10.1109/ASE.2019.00025',76,0,'IEEE','IEEE Conferences',0),(883,'DIRE: A Neural Approach to Decompiled Identifier Naming',7,628,639,'The decompiler is one of the most common tools for examining binaries without corresponding source code. It transforms binaries into high-level code, reversing the compilation process. Decompilers can reconstruct much of the information that is lost during the compilation process (e.g., structure and type information). Unfortunately, they do not reconstruct semantically meaningful variable names, which are known to increase code understandability. We propose the Decompiled Identifier Renaming Engine (DIRE), a novel probabilistic technique for variable name recovery that uses both lexical and structural information recovered by the decompiler. We also present a technique for generating corpora suitable for training and evaluating models of decompiled code renaming, which we use to create a corpus of 164,632 unique x86-64 binaries generated from C projects mined from GitHub. Our results show that on this corpus DIRE can predict variable names identical to the names in the original source code up to 74.3% of the time.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952404','10.1109/ASE.2019.00064',43,0,'IEEE','IEEE Conferences',0),(884,'CLCDSA: Cross Language Code Clone Detection using Syntactical Features and API Documentation',7,1026,1037,'Software clones are detrimental to software maintenance and evolution and as a result many clone detectors have been proposed. These tools target clone detection in software applications written in a single programming language. However, a software application may be written in different languages for different platforms to improve the application\'s platform compatibility and adoption by users of different platforms. Cross language clones (CLCs) introduce additional challenges when maintaining multi-platform applications and would likely go undetected using existing tools. In this paper, we propose CLCDSA, a cross language clone detector which can detect CLCs without extensive processing of the source code and without the need to generate an intermediate representation. The proposed CLCDSA model analyzes different syntactic features of source code across different programming languages to detect CLCs. To support large scale clone detection, the CLCDSA model uses an action filter based on cross language API call similarity to discard non-potential clones. The design methodology of CLCDSA is two-fold: (a) it detects CLCs on the fly by comparing the similarity of features, and (b) it uses a deep neural network based feature vector learning model to learn the features and detect CLCs. Early evaluation of the model observed an average precision, recall and F-measure score of 0.55, 0.86, and 0.64 respectively for the first phase and 0.61, 0.93, and 0.71 respectively for the second phase which indicates that CLCDSA outperforms all available models in detecting cross language clones.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952189','10.1109/ASE.2019.00099',63,0,'IEEE','IEEE Conferences',0),(885,'Learning-Guided Network Fuzzing for Testing Cyber-Physical System Defences',7,962,973,'The threat of attack faced by cyber-physical systems (CPSs), especially when they play a critical role in automating public infrastructure, has motivated research into a wide variety of attack defence mechanisms. Assessing their effectiveness is challenging, however, as realistic sets of attacks to test them against are not always available. In this paper, we propose smart fuzzing, an automated, machine learning guided technique for systematically finding \'test suites\' of CPS network attacks, without requiring any knowledge of the system\'s control programs or physical processes. Our approach uses predictive machine learning models and metaheuristic search algorithms to guide the fuzzing of actuators so as to drive the CPS into different unsafe physical states. We demonstrate the efficacy of smart fuzzing by implementing it for two real-world CPS testbeds鈥攁 water purification plant and a water distribution system鈥攆inding attacks that drive them into 27 different unsafe states involving water flow, pressure, and tank levels, including six that were not covered by an established attack benchmark. Finally, we use our approach to test the effectiveness of an invariant-based defence system for the water treatment plant, finding two attacks that were not detected by its physical invariant checks, highlighting a potential weakness that could be exploited in certain conditions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952193','10.1109/ASE.2019.00093',67,0,'IEEE','IEEE Conferences',0),(886,'Subformula Caching for Model Counting and Quantitative Program Analysis',7,453,464,'Quantitative program analysis is an emerging area with applications to software reliability, quantitative information flow, side-channel detection and attack synthesis. Most quantitative program analysis techniques rely on model counting constraint solvers, which are typically the bottleneck for scalability. Although the effectiveness of formula caching in expediting expensive model-counting queries has been demonstrated in prior work, our key insight is that many subformulas are shared across non-identical constraints generated during program analyses. This has not been utilized by prior formula caching approaches. In this paper we present a subformula caching framework and integrate it into a model counting constraint solver. We experimentally evaluate its effectiveness under three quantitative program analysis scenarios: 1) model counting constraints generated by symbolic execution, 2) reliability analysis using probabilistic symbolic execution, 3) adaptive attack synthesis for side-channels. Our experimental results demonstrate that our subformula caching approach significantly improves the performance of quantitative program analysis.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952551','10.1109/ASE.2019.00050',36,0,'IEEE','IEEE Conferences',0),(887,'Testing Regex Generalizability And Its Implications: A Large-Scale Many-Language Measurement Study',7,427,439,'The regular expression (regex) practices of software engineers affect the maintainability, correctness, and security of their software applications. Empirical research has described characteristics like the distribution of regex feature usage, the structural complexity of regexes, and worst-case regex match behaviors. But researchers have not critically examined the methodology they follow to extract regexes, and findings to date are typically generalized from regexes written in only 1-2 programming languages. This is an incomplete foundation. Generalizing existing research depends on validating two hypotheses: (1) Various regex extraction methodologies yield similar results, and (2) Regex characteristics are similar across programming languages. To test these hypotheses, we defined eight regex metrics to capture the dimensions of regex representation, string language diversity, and worst-case match complexity. We report that the two competing regex extraction methodologies yield comparable corpuses, suggesting that simpler regex extraction techniques will still yield sound corpuses. But in comparing regexes across programming languages, we found significant differences in some characteristics by programming language. Our findings have bearing on future empirical methodology, as the programming language should be considered, and generalizability will not be assured. Our measurements on a corpus of 537,806 regexes can guide data-driven designs of a new generation of regex tools and regex engines.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952443','10.1109/ASE.2019.00048',75,1,'IEEE','IEEE Conferences',0),(888,'Size and Accuracy in Model Inference',7,887,898,'Many works infer finite-state models from execution logs. Large models are more accurate but also more difficult to present and understand. Small models are easier to present and understand but are less accurate. In this work we investigate the tradeoff between model size and accuracy in the context of the classic k-Tails model inference algorithm. First, we define mk-Tails, a generalization of k-Tails from one to many parameters, which enables fine-grained control over the tradeoff. Second, we extend mk-Tails with a reduction based on past-equivalence, which effectively reduces the size of the model without decreasing its accuracy. We implemented our work and evaluated its performance and effectiveness on real-world logs as well as on models and generated logs from the literature.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952335','10.1109/ASE.2019.00087',31,0,'IEEE','IEEE Conferences',0),(889,'Logzip: Extracting Hidden Structures via Iterative Clustering for Log Compression',7,863,873,'System logs record detailed runtime information of software systems and are used as the main data source for many tasks around software engineering. As modern software systems are evolving into large scale and complex structures, logs have become one type of fast-growing big data in industry. In particular, such logs often need to be stored for a long time in practice (e.g., a year), in order to analyze recurrent problems or track security issues. However, archiving logs consumes a large amount of storage space and computing resources, which in turn incurs high operational cost. Data compression is essential to reduce the cost of log storage. Traditional compression tools (e.g., gzip) work well for general texts, but are not tailed for system logs. In this paper, we propose a novel and effective log compression method, namely logzip. Logzip is capable of extracting hidden structures from raw logs via fast iterative clustering and further generating coherent intermediate representations that allow for more effective compression. We evaluate logzip on five large log datasets of different system types, with a total of 63.6 GB in size. The results show that logzip can save about half of the storage space on average over traditional compression tools. Meanwhile, the design of logzip is highly parallel and only incurs negligible overhead. In addition, we share our industrial experience of applying logzip to Huawei\'s real products.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952406','10.1109/ASE.2019.00085',49,0,'IEEE','IEEE Conferences',0),(890,'An Experience Report of Generating Load Tests Using Log-Recovered Workloads at Varying Granularities of User Behaviour',7,669,681,'Designing field-representative load tests is an essential step for the quality assurance of large-scale systems. Practitioners may capture user behaviour at different levels of granularity. A coarse-grained load test may miss detailed user behaviour, leading to a non-representative load test; while an extremely fine-grained load test would simply replay user actions step by step, leading to load tests that are costly to develop, execute and maintain. Workload recovery is at core of these load tests. Prior research often captures the workload as the frequency of user actions. However, there exists much valuable information in the context and sequences of user actions. Such richer information would ensure that the load tests that leverage such workloads are more field-representative. In this experience paper, we study the use of different granularities of user behaviour, i.e., basic user actions, basic user actions with contextual information and user action sequences with contextual information, when recovering workloads for use in the load testing of large-scale systems. We propose three approaches that are based on the three granularities of user behaviour and evaluate our approaches on four subject systems, namely Apache James, OpenMRS, Google Borg, and an ultra-large-scale industrial system (SA) from Alibaba. Our results show that our approach that is based on user action sequences with contextual information outperforms the other two approaches and can generate more representative load tests with similar throughput and CPU usage to the original field workload (i.e., mostly statistically insignificant or with small/trivial effect sizes). Such representative load tests are generated only based on a small number of clusters of users, leading to a low cost of conducting/maintaining such tests. Finally, we demonstrate that our approaches can detect injected users in the original field workloads with high precision and recall. Our paper demonstrates the importance of user action sequences with contextual information in the workload recovery of large-scale systems.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952553','10.1109/ASE.2019.00068',60,0,'IEEE','IEEE Conferences',0),(891,'Automating Non-Blocking Synchronization In Concurrent Data Abstractions',7,735,747,'This paper investigates using compiler technology to automatically convert sequential C++ data abstractions, e.g., queues, stacks, maps, and trees, to concurrent lock-free implementations. By automatically tailoring a number of state-of-the-practice synchronization methods to the underlying sequential implementations of different data structures, our automatically synchronized code can attain performance competitive to that of manually-written concurrent data structures by experts and much better performance than heavier-weight support by software transactional memory (STM).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952270','10.1109/ASE.2019.00074',63,0,'IEEE','IEEE Conferences',0),(892,'Multi-modal Attention Network Learning for Semantic Source Code Retrieval',7,13,25,'Code retrieval techniques and tools have been playing a key role in facilitating software developers to retrieve existing code fragments from available open-source repositories given a user query (e.g., a short natural language text describing the functionality for retrieving a particular code snippet). Despite the existing efforts in improving the effectiveness of code retrieval, there are still two main issues hindering them from being used to accurately retrieve satisfiable code fragments from large-scale repositories when answering complicated queries. First, the existing approaches only consider shallow features of source code such as method names and code tokens, but ignoring structured features such as abstract syntax trees (ASTs) and control-flow graphs (CFGs) of source code, which contains rich and well-defined semantics of source code. Second, although the deep learning-based approach performs well on the representation of source code, it lacks the explainability, making it hard to interpret the retrieval results and almost impossible to understand which features of source code contribute more to the final results. To tackle the two aforementioned issues, this paper proposes MMAN, a novel Multi-Modal Attention Network for semantic source code retrieval. A comprehensive multi-modal representation is developed for representing unstructured and structured features of source code, with one LSTM for the sequential tokens of code, a Tree-LSTM for the AST of code and a GGNN (Gated Graph Neural Network) for the CFG of code. Furthermore, a multi-modal attention fusion layer is applied to assign weights to different parts of each modality of source code and then integrate them into a single hybrid representation. Comprehensive experiments and analysis on a large-scale real-world dataset show that our proposed model can accurately retrieve code snippets and outperforms the state-of-the-art methods.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952337','10.1109/ASE.2019.00012',57,0,'IEEE','IEEE Conferences',0),(893,'iFeedback: Exploiting User Feedback for Real-Time Issue Detection in Large-Scale Online Service Systems',7,352,363,'Large-scale online systems are complex, fast-evolving, and hardly bug-free despite the testing efforts. Backend system monitoring cannot detect many types of issues, such as UI related bugs, bugs with small impact on backend system indicators, or errors from third-party co-operating systems, etc. However, users are good informers of such issues: They will provide their feedback for any types of issues. This experience paper discusses our design of iFeedback, a tool to perform real-time issue detection based on user feedback texts. Unlike traditional approaches that analyze user feedback with computation-intensive natural language processing algorithms, iFeedback is focusing on fast issue detection, which can serve as a system life-condition monitor. In particular, iFeedback extracts word combination-based indicators from feedback texts. This allows iFeedback to perform fast system anomaly detection with sophisticated machine learning algorithms. iFeedback then further summarizes the texts with an aim to effectively present the anomaly to the developers for root cause analysis. We present our representative experiences in successfully applying iFeedback in tens of large-scale production online service systems in ten months.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952229','10.1109/ASE.2019.00041',42,0,'IEEE','IEEE Conferences',0),(894,'Apricot: A Weight-Adaptation Approach to Fixing Deep Learning Models',7,376,387,'A deep learning (DL) model is inherently imprecise. To address this problem, existing techniques retrain a DL model over a larger training dataset or with the help of fault injected models or using the insight of failing test cases in a DL model. In this paper, we present Apricot, a novel weight-adaptation approach to fixing DL models iteratively. Our key observation is that if the deep learning architecture of a DL model is trained over many different subsets of the original training dataset, the weights in the resultant reduced DL model (rDLM) can provide insights on the adjustment direction and magnitude of the weights in the original DL model to handle the test cases that the original DL model misclassifies. Apricot generates a set of such reduced DL models from the original DL model. In each iteration, for each failing test case experienced by the input DL model (iDLM), Apricot adjusts each weight of this iDLM toward the average weight of these rDLMs correctly classifying the test case and/or away from that of these rDLMs misclassifying the same test case, followed by training the weight-adjusted iDLM over the original training dataset to generate a new iDLM for the next iteration. The experiment using five state-of-the-art DL models shows that Apricot can increase the test accuracy of these models by 0.87%-1.55% with an average of 1.08%. The experiment also reveals the complementary nature of these rDLMs in Apricot.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952197','10.1109/ASE.2019.00043',60,0,'IEEE','IEEE Conferences',0),(895,'OAUTHLINT: An Empirical Study on OAuth Bugs in Android Applications',7,293,304,'Mobile developers use OAuth APIs to implement Single-Sign-On services. However, the OAuth protocol was originally designed for the authorization for third-party websites not to authenticate users in third-party mobile apps. As a result, it is challenging for developers to correctly implement mobile OAuth securely. These vulnerabilities due to the misunderstanding of OAuth and inexperience of developers could lead to data leakage and account breach. In this paper, we perform an empirical study on the usage of OAuth APIs in Android applications and their security implications. In particular, we develop OAUTHLINT, that incorporates a query-driven static analysis to automatically check programs on the Google Play marketplace. OAUTHLINT takes as input an anti-protocol that encodes a vulnerable pattern extracted from the OAuth specifications and a program P. Our tool then generates a counter-example if the anti-protocol can match a trace of Ps possible executions. To evaluate the effectiveness of our approach, we perform a systematic study on 600+ popular apps which have more than 10 millions of downloads. The evaluation shows that 101 (32%) out of 316 applications that use OAuth APIs make at least one security mistake.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952200','10.1109/ASE.2019.00036',40,0,'IEEE','IEEE Conferences',0),(896,'Predicting Licenses for Changed Source Code',7,686,697,'Open source software licenses regulate the circumstances under which software can be redistributed, reused and modified. Ensuring license compatibility and preventing license restriction conflicts among source code during software changes are the key to protect their commercial use. However, selecting the appropriate licenses for software changes requires lots of experience and manual effort that involve examining, assimilating and comparing various licenses as well as understanding their relationships with software changes. Worse still, there is no state-of-the-art methodology to provide this capability. Motivated by this observation, we propose in this paper Automatic License Prediction (ALP), a novel learning-based method and tool for predicting licenses as software changes. An extensive evaluation of ALP on predicting licenses in 700 open source projects demonstrate its effectiveness: ALP can achieve not only a high overall prediction accuracy (92.5% in micro F1 score) but also high accuracies across all license types.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952518','10.1109/ASE.2019.00070',28,0,'IEEE','IEEE Conferences',0),(897,'Re-Factoring Based Program Repair Applied to Programming Assignments',7,388,398,'Automated program repair has been used to provide feedback for incorrect student programming assignments, since program repair captures the code modification needed to make a given buggy program pass a given test-suite. Existing student feedback generation techniques are limited because they either require manual effort in the form of providing an error model, or require a large number of correct student submissions to learn from, or suffer from lack of scalability and accuracy. In this work, we propose a fully automated approach for generating student program repairs in real-time. This is achieved by first re-factoring all available correct solutions to semantically equivalent solutions. Given an incorrect program, we match the program with the closest matching refactored program based on its control flow structure. Subsequently, we infer the input-output specifications of the incorrect program\'s basic blocks from the executions of the correct program\'s aligned basic blocks. Finally, these specifications are used to modify the blocks of the incorrect program via search-based synthesis. Our dataset consists of almost 1,800 real-life incorrect Python program submissions from 361 students for an introductory programming course at a large public university. Our experimental results suggest that our method is more effective and efficient than recently proposed feedback generation approaches. About 30% of the patches produced by our tool Refactory are smaller than those produced by the state-of-art tool Clara, and can be produced given fewer correct solutions (often a single correct solution) and in a shorter time. We opine that our method is applicable not only to programming assignments, and could be seen as a general-purpose program repair method that can achieve good results with just a single correct reference solution.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952522','10.1109/ASE.2019.00044',20,0,'IEEE','IEEE Conferences',0),(898,'PraPR: Practical Program Repair via Bytecode Mutation',7,1118,1121,'Automated program repair (APR) is one of the recent advances in automated software engineering aiming for reducing the burden of debugging by suggesting high-quality patches that either directly fix the bugs, or help the programmers in the course of manual debugging. We believe scalability, applicability, and accurate patch validation are the main design objectives for a practical APR technique. In this paper, we present PraPR, our implementation of a practical APR technique that operates at the level of JVM bytecode. We discuss design decisions made in the development of PraPR, and argue that the technique is a viable baseline toward attaining aforementioned objectives. Our experimental results show that: (1) PraPR can fix more bugs than state-of-the-art APR techniques and can be over 10X faster, (2) state-of-the-art APR techniques suffer from dataset overfitting, while the simplistic template-based PraPR performs more consistently on different datasets, and (3) PraPR can fix bugs for other JVM languages, such as Kotlin. PraPR is publicly available at https://github.com/prapr/prapr.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952486','10.1109/ASE.2019.00116',44,0,'IEEE','IEEE Conferences',0),(899,'Combining Program Analysis and Statistical Language Model for Code Statement Completion',7,710,721,'Automatic code completion helps improve developers\' productivity in their programming tasks. A program contains instructions expressed via code statements, which are considered as the basic units of program execution. In this paper, we introduce AutoSC, which combines program analysis and the principle of software naturalness to fill in a partially completed statement. AutoSC benefits from the strengths of both directions, in which the completed code statement is both frequent and valid. AutoSC is first trained on a large code corpus to derive the templates of candidate statements. Then, it uses program analysis to validate and concretize the templates into syntactically and type-valid candidate statements. Finally, these candidates are ranked by using a language model trained on the lexical form of the source code in the code corpus. Our empirical evaluation on the large datasets of real-world projects shows that AutoSC achieves 38.9-41.3% top-1 accuracy and 48.2-50.1% top-5 accuracy in statement completion. It also outperforms a state-of-the-art approach from 9X-69X in top-1 accuracy.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952235','10.1109/ASE.2019.00072',29,0,'IEEE','IEEE Conferences',0),(900,'MalScan: Fast Market-Wide Mobile Malware Scanning by Social-Network Centrality Analysis',7,139,150,'Malware scanning of an app market is expected to be scalable and effective. However, existing approaches use either syntax-based features which can be evaded by transformation attacks or semantic-based features which are usually extracted by performing expensive program analysis. Therefor, in this paper, we propose a lightweight graph-based approach to perform Android malware detection. Instead of traditional heavyweight static analysis, we treat function call graphs of apps as social networks and perform social-network-based centrality analysis to represent the semantic features of the graphs. Our key insight is that centrality provides a succinct and fault-tolerant representation of graph semantics, especially for graphs with certain amount of inaccurate information (e.g., inaccurate call graphs). We implement a prototype system, MalScan, and evaluate it on datasets of 15,285 benign samples and 15,430 malicious samples. Experimental results show that MalScan is capable of detecting Android malware with up to 98% accuracy under one second which is more than 100 times faster than two state-of-the-art approaches, namely MaMaDroid and Drebin. We also demonstrate the feasibility of MalScan on market-wide malware scanning by performing a statistical study on over 3 million apps. Finally, in a corpus of dataset collected from Google-Play app market, MalScan is able to identify 18 zero-day malware including malware samples that can evade detection of existing tools.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952382','10.1109/ASE.2019.00023',43,0,'IEEE','IEEE Conferences',0),(901,'Sip4J: Statically Inferring Access Permission Contracts for Parallelising Sequential Java Programs',7,1098,1101,'This paper presents Sip4J, a fully automated, scalable and effective tool to automatically generate access permission contracts for a sequential Java program. The access permission contracts, which represent the dependency of code blocks, have been frequently used to enable concurrent execution of sequential programs. Those permission contracts, unfortunately, need to be manually created by programmers, which is known to be time-consuming, laborious and error-prone. To mitigate those manual efforts, Sip4J performs inter-procedural static analysis of Java source code to automatically extract the implicit dependencies in the program and subsequently leverages them to automatically generate access permission contracts, following the Design by Contract principle. The inferred specifications are then used to identify the concurrent (immutable) methods in the program. Experimental results further show that Sip4J is useful and effective towards generating access permission contracts for sequential Java programs. The implementation of Sip4J has been published as an open-sourced project at https://github.com/Sip4J/Sip4J and a demo video of Sip4J can be found at https://youtu.be/RjMTIxlhHTg.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952453','10.1109/ASE.2019.00111',17,0,'IEEE','IEEE Conferences',0),(902,'XRaSE: Towards Virtually Tangible Software using Augmented Reality',7,1194,1197,'Software engineering has seen much progress in recent past including introduction of new methodologies, new paradigms for software teams, and from smaller monolithic applications to complex, intricate, and distributed software applications. However, the way we represent, discuss, and collaborate on software applications throughout the software development life cycle is still primarily using the source code, textual representations, or charts on 2D computer screens - the confines of which have long limited how we visualize and comprehend software systems. In this paper, we present XRaSE, a novel prototype implementation that leverages augmented reality to visualize a software application as a virtually tangible entity. This immersive approach is aimed at making activities like application comprehension, architecture analysis, knowledge communication, and analysis of a software\'s dynamic aspects, more intuitive, richer and collaborative.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952170','10.1109/ASE.2019.00135',16,0,'IEEE','IEEE Conferences',0),(903,'Code-First Model-Driven Engineering: On the Agile Adoption of MDE Tooling',7,874,886,'Domain models are the most important asset in widely accepted software development approaches, like Domain-Driven Design (DDD), yet those models are still implicitly represented in programs. Model-Driven Engineering (MDE) regards those models as representable entities that are amenable to automated analysis and processing, facilitating quality assurance while increasing productivity in software development processes. Although this connection is not new, very few approaches facilitate adoption of MDE tooling without compromising existing value, their data. Moreover, switching to MDE tooling usually involves re-engineering core parts of an application, hindering backward compatibility and, thereby, continuous integration, while requiring an up-front investment in training in specialized modeling frameworks. In those approaches that overcome the previous problem, there is no clear indication - from a quantitative point of view - of the extent to which adopting state-of-the-art MDE practices and tooling is feasible or advantageous. In this work, we advocate a code-first approach to modeling through an approach for applying MDE techniques and tools to existing object-oriented software applications that fully preserves the semantics of the original application, which need not be modified. Our approach consists both of a semi-automated method for specifying explicit view models out of existing object-oriented applications and of a conservative extension mechanism that enables the use of such view models at run time, where view model queries are resolved on demand and view model updates are propagated incrementally to the original application. This mechanism enables an iterative, flexible application of MDE tooling to software applications, where metamodels and models do not exist explicitly. An evaluation of this extension mechanism, implemented for Java applications and for view models atop the Eclipse Modeling Framework (EMF), has been conducted with an industry-targeted benchmark for decision support systems, analyzing performance and scalability of the synchronization mechanism. Backward propagation of large updates over very large views is instant.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952237','10.1109/ASE.2019.00086',41,0,'IEEE','IEEE Conferences',0),(904,'MARBLE: Mining for Boilerplate Code to Identify API Usability Problems',7,615,627,'Designing usable APIs is critical to developers\' productivity and software quality, but is quite difficult. One of the challenges is that anticipating API usability barriers and real-world usage is difficult, due to a lack of automated approaches to mine usability data at scale. In this paper, we focus on one particular grievance that developers repeatedly express in online discussions about APIs: \'boilerplate code.\' We investigate what properties make code count as boilerplate, the reasons for boilerplate, and how programmers can reduce the need for it. We then present MARBLE, a novel approach to automatically mine boilerplate code candidates from API client code repositories. MARBLE adapts existing techniques, including an API usage mining algorithm, an AST comparison algorithm, and a graph partitioning algorithm. We evaluate MARBLE with 13 Java APIs, and show that our approach successfully identifies both already-known and new API-related boilerplate code instances.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952239','10.1109/ASE.2019.00063',65,1,'IEEE','IEEE Conferences',0),(905,'Feature-Interaction Aware Configuration Prioritization for Configurable Code',7,489,501,'Unexpected interactions among features induce most bugs in a configurable software system. Exhaustively analyzing all the exponential number of possible configurations is prohibitively costly. Thus, various sampling techniques have been proposed to systematically narrow down the exponential number of legal configurations to be analyzed. Since analyzing all selected configurations can require a huge amount of effort, fault-based configuration prioritization, that helps detect faults earlier, can yield practical benefits in quality assurance. In this paper, we propose CoPro, a novel formulation of feature-interaction bugs via common program entities enabled/disabled by the features. Leveraging from that, we develop an efficient feature-interaction-aware configuration prioritization technique for a configurable system by ranking the configurations according to their total number of potential bugs. We conducted several experiments to evaluate CoPro on the ability to detect configuration-related bugs in a public benchmark. We found that CoPro outperforms the state-of-the-art configuration prioritization techniques when we add them on advanced sampling algorithms. In 78% of the cases, CoPro ranks the buggy configurations at the top 3 positions in the resulting list. Interestingly, CoPro is able to detect 17 not-yet-discovered feature-interaction bugs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952386','10.1109/ASE.2019.00053',59,0,'IEEE','IEEE Conferences',0),(906,'A Quantitative Analysis Framework for Recurrent Neural Network',7,1062,1065,'Recurrent neural network (RNN) has achieved great success in processing sequential inputs for applications such as automatic speech recognition, natural language processing and machine translation. However, quality and reliability issues of RNNs make them vulnerable to adversarial attacks and hinder their deployment in real-world applications. In this paper, we propose a quantitative analysis framework - DeepStellar - to pave the way for effective quality and security analysis of software systems powered by RNNs. DeepStellar is generic to handle various RNN architectures, including LSTM and GRU, scalable to work on industrial-grade RNN models, and extensible to develop customized analyzers and tools. We demonstrated that, with DeepStellar, users are able to design efficient test generation tools, and develop effective adversarial sample detectors. We tested the developed applications on three real RNN models, including speech recognition and image classification. DeepStellar outperforms existing approaches three hundred times in generating defect-triggering tests and achieves 97% accuracy in detecting adversarial attacks. A video demonstration which shows the main features of DeepStellar is available at: https://sites.google.com/view/deepstellar/tool-demo.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952565','10.1109/ASE.2019.00102',18,0,'IEEE','IEEE Conferences',0),(907,'Batch Alias Analysis',7,936,948,'Many program-analysis based tools require precise points-to/alias information only for some program variables. To meet this requirement efficiently, there have been many works on demand-driven analyses that perform only the work necessary to compute the points-to or alias information on the requested variables (queries). However, these demand-driven analyses can be very expensive when applied on large systems where the number of queries can be significant. Such a blow-up in analysis time is unacceptable in cases where scalability with real-time constraints is crucial; for example, when program analysis tools are plugged into an IDE (Integrated Development Environment). In this paper, we propose schemes to improve the scalability of demand-driven analyses without compromising on precision. Our work is based on novel ideas for eliminating irrelevant and redundant data-flow paths for the given queries. We introduce the idea of batch analysis, which can answer multiple given queries in batch mode. Batch analysis suits the environments with strict time constraints, where the queries come in batch. We present a batch alias analysis framework that can be used to speed up given demand-driven alias analysis. To show the effectiveness of this framework, we use two demand-driven alias analyses (1) the existing best performing demand-driven alias analysis tool for race-detection clients and (2) an optimized version thereof that avoids irrelevant computation. Our evaluations on a simulated data-race client, and on a recent program-understanding tool, show that batch analysis leads to significant performance gains, along with minor gains in precision.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952457','10.1109/ASE.2019.00091',36,0,'IEEE','IEEE Conferences',0),(908,'Inferring Program Transformations From Singular Examples via Big Code',7,255,266,'Inferring program transformations from concrete program changes has many potential uses, such as applying systematic program edits, refactoring, and automated program repair. Existing work for inferring program transformations usually rely on statistical information over a potentially large set of program-change examples. However, in many practical scenarios we do not have such a large set of program-change examples. In this paper, we address the challenge of inferring a program transformation from one single example. Our core insight is that \'big code\' can provide effective guide for the generalization of a concrete change into a program transformation, i.e., code elements appearing in many files are general and should not be abstracted away. We first propose a framework for transformation inference, where programs are represented as hypergraphs to enable fine-grained generalization of transformations. We then design a transformation inference approach, GENPAT, that infers a program transformation based on code context and statistics from a big code corpus. We have evaluated GENPAT under two distinct application scenarios, systematic editing and program repair. The evaluation on systematic editing shows that GENPAT significantly outperforms a state-of-the-art approach, SYDIT, with up to 5.5x correctly transformed cases. The evaluation on program repair suggests that GENPAT has the potential to be integrated in advanced program repair tools-GENPAT successfully repaired 19 real-world bugs in the Defects4J benchmark by simply applying transformations inferred from existing patches, where 4 bugs have never been repaired by any existing technique. Overall, the evaluation results suggest that GENPAT is effective for transformation inference and can potentially be adopted for many different applications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952210','10.1109/ASE.2019.00033',63,1,'IEEE','IEEE Conferences',0),(909,'SpyREST: Automated RESTful API Documentation Using an HTTP Proxy Server (N)',9,271,276,'RESTful API documentation is expensive to produce and maintain due to the lack of reusable tools and automated solutions. Most RESTful APIs are documented manually and the API developers are responsible for keeping the documentation up to date as the API evolves making the process both costly and error-prone. In this paper we introduce a novel technique using an HTTP proxy server that can be used to automatically generate RESTful API documentation and demonstrate SpyREST, an example implementation of the proposed technique. SpyREST uses a proxy to intercept example API calls and intelligently produces API documentation for RESTful Web APIs by processing the request and response data. Using the proposed HTTP proxy server based technique, RESTful API developers can significantly reduce the cost of producing and maintaining API documentation by replacing a large manual process with an automated process.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372015','10.1109/ASE.2015.52',19,10,'IEEE','IEEE Conferences',0),(910,'Testing intermediate representations for binary analysis',8,353,364,'Binary lifting, which is to translate a binary executable to a high-level intermediate representation, is a primary step in binary analysis. Despite its importance, there are only few existing approaches to testing the correctness of binary lifters. Furthermore, the existing approaches suffer from low test coverage, because they largely depend on random test case generation. In this paper, we present the design and implementation of the first systematic approach to testing binary lifters. We have evaluated the proposed system on 3 state-of-the-art binary lifters, and found 24 previously unknown semantic bugs. Our result demonstrates that writing a precise binary lifter is extremely difficult even for those heavily tested projects.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115648','10.1109/ASE.2017.8115648',60,3,'IEEE','IEEE Conferences',0),(911,'Have We Seen Enough Traces? (T)',9,93,103,'Dynamic specification mining extracts candidate specifications from logs of execution traces. Existing algorithms differ in the kinds of traces they take as input and in the kinds of candidate specification they present as output. One challenge common to all approaches relates to the faithfulness of the mining results: how can we be confident that the extracted specifications faithfully characterize the program we investigate? Since producing and analyzing traces is costly, how would we know we have seen enough traces? And, how would we know we have not wasted resources and seen too many of them?In this paper we address these important questions by presenting a novel, black box, probabilistic framework based on a notion of log completeness, and by applying it to three different well-known specification mining algorithms from the literature: k-Tails, Synoptic, and mining of scenario-based triggers and effects. Extensive evaluation over 24 models taken from 9 different sources shows the soundness, generalizability, and usefulness of the framework and its contribution to the state-of-the-art in dynamic specification mining.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7371999','10.1109/ASE.2015.62',42,7,'IEEE','IEEE Conferences',0),(912,'Mining implicit design templates for actionable code reuse',8,394,404,'In this paper, we propose an approach to detecting project-specific recurring designs in code base and abstracting them into design templates as reuse opportunities. The mined templates allow programmers to make further customization for generating new code. The generated code involves the code skeleton of recurring design as well as the semi-implemented code bodies annotated with comments to remind programmers of necessary modification. We implemented our approach as an Eclipse plugin called MICoDe. We evaluated our approach with a reuse simulation experiment and a user study involving 16 participants. The results of our simulation experiment on 10 open source Java projects show that, to create a new similar feature with a design template, (1) on average 69% of the elements in the template can be reused and (2) on average 60% code of the new feature can be adopted from the template. Our user study further shows that, compared to the participants adopting the copy-paste-modify strategy, the ones using MICoDe are more effective to understand a big design picture and more efficient to accomplish the code reuse task.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115652','10.1109/ASE.2017.8115652',41,3,'IEEE','IEEE Conferences',0),(913,'The potential of polyhedral optimization: An empirical study',6,508,518,'Present-day automatic optimization relies on powerful static (i.e., compile-time) analysis and transformation methods. One popular platform for automatic optimization is the polyhedron model. Yet, after several decades of development, there remains a lack of empirical evidence of the model\'s benefits for real-world software systems. We report on an empirical study in which we analyzed a set of popular software systems, distributed across various application domains. We found that polyhedral analysis at compile time often lacks the information necessary to exploit the potential for optimization of a program\'s execution. However, when conducted also at run time, polyhedral analysis shows greater relevance for real-world applications. On average, the share of the execution time amenable to polyhedral optimization is increased by a factor of nearly 3. Based on our experimental results, we discuss the merits and potential of polyhedral optimization at compile time and run time.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693108','10.1109/ASE.2013.6693108',37,2,'IEEE','IEEE Conferences',0),(914,'Automated verification of interactive rule-based configuration systems',6,551,561,'Rule-based specifications of systems have again become common in the context of product line variability modeling and configuration systems. In this paper, we define a logical foundation for rule-based specifications that has enough expressivity and operational behavior to be practically useful and at the same time enables decidability of important overall properties such as consistency or cycle-freeness. Our logic supports rule-based interactive user transitions as well as the definition of a domain theory via rule transitions. As a running example, we model DOPLER, a rule-based configuration system currently in use at Siemens.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693112','10.1109/ASE.2013.6693112',19,1,'IEEE','IEEE Conferences',0),(915,'Static Analysis of Implicit Control Flow: Resolving Java Reflection and Android Intents (T)',9,669,679,'Implicit or indirect control flow is a transfer of control between procedures using some mechanism other than an explicit procedure call. Implicit control flow is a staple design pattern that adds flexibility to system design. However, it is challenging for a static analysis to compute or verify properties about a system that uses implicit control flow. This paper presents static analyses for two types of implicit control flow that frequently appear in Android apps: Java reflection and Android intents. Our analyses help to resolve where control flows and what data is passed. This information improves the precision of downstream analyses, which no longer need to make conservative assumptions about implicit control flow. We have implemented our techniques for Java. We enhanced an existing security analysis with a more precise treatment of reflection and intents. In a case study involving ten real-world Android apps that use both intents and reflection, the precision of the security analysis was increased on average by two orders of magnitude. The precision of two other downstream analyses was also improved.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372054','10.1109/ASE.2015.69',35,26,'IEEE','IEEE Conferences',0),(916,'Learning effective changes for software projects',8,1002,1005,'The primary motivation of much of software analytics is decision making. How to make these decisions? Should one make decisions based on lessons that arise from within a particular project? Or should one generate these decisions from across multiple projects? This work is an attempt to answer these questions. Our work was motivated by a realization that much of the current generation software analytics tools focus primarily on prediction. Indeed prediction is a useful task, but it is usually followed by \'planning\' about what actions need to be taken. This research seeks to address the planning task by seeking methods that support actionable analytics by offering clear guidance on what to do. Specifically, we propose XTREE and BELLTREE algorithms for generating a set of actionable plans within and across projects. Each of these plans, if followed will improve the quality of the software project.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115719','10.1109/ASE.2017.8115719',29,0,'IEEE','IEEE Conferences',0),(917,'Towards the automatic classification of traceability links',8,1018,1021,'A wide range of text-based artifacts contribute to software projects (e.g., source code, test cases, use cases, project requirements, interaction diagrams, etc.). Traceability Link Recovery (TLR) is the software task in which relevant documents in these various sets are linked to one another, uncovering information about the project that is not available when considering only the documents themselves. This information is helpful for enabling other tasks such as improving test coverage, impact analysis, and ensuring that system or regulatory requirements are met. However, while traceability links are useful, performing TLR manually is time consuming and fraught with error. Previous work has applied Information Retrieval (IR) and other techniques to reduce the human effort involved; however, that effort remains significant. In this research we seek to take the next step in reducing it by using machine learning (ML) classification models to predict whether a candidate link is valid or invalid without human oversight. Preliminary results show that this approach has promise for accurately recommending valid links; however, there are several challenges that still must be addressed in order to achieve a technique with high enough performance to consider it a viable, completely automated solution.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115723','10.1109/ASE.2017.8115723',33,0,'IEEE','IEEE Conferences',0),(918,'Automated verification of pattern-based interaction invariants in Ajax applications',6,158,168,'When developing asynchronous JavaScript and XML (Ajax) applications, developers implement Ajax design patterns for increasing the usability of the applications. However, unpredictable contexts of running applications might conceal faults that will break the design patterns, which decreases usability. We propose a support tool called JSVerifier that auto-matically verifies interaction invariants; the applications handle their interactions in invariant occurrence and order. We also present a selective set of interaction invariants derived from Ajax design patterns, as input. If the application behavior breaks the design patterns, JSVerifier automatically outputs faulty execution paths for debugging. The results of our case studies show that JSVerifier can verify the interaction invariants in a feasible amount of time, and we conclude that it can help developers increase the usability of Ajax applications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693076','10.1109/ASE.2013.6693076',26,1,'IEEE','IEEE Conferences',0),(919,'JFlow: Practical refactorings for flow-based parallelism',6,202,212,'Emerging applications in the domains of recognition, mining and synthesis (RMS); image and video processing; data warehousing; and automatic financial trading admit a particular style of parallelism termed flow-based parallelism. To help developers exploit flow-based parallelism, popular parallel libraries such as Groovy\'s GPars, Intel\'s TBB Flow Graph and Microsoft\'s TPL Dataflow have begun introducing many new and useful constructs. However, to reap the benefits of such constructs, developers must first use them. This involves refactoring their existing sequential code to incorporate these constructs - a manual process that overwhelms even experts. To alleviate this burden, we introduce a set of novel analyses and transformations targeting flow-based parallelism. We implemented these ideas in JFlow, an interactive refactoring tool integrated into the Eclipse IDE. We used JFlow to parallelize seven applications: four from a previously known benchmark and three from a suite of large open source projects. JFlow, with minimal interaction from the developer, can successfully parallelize applications from the aforementioned domains with good performance (offering up to 3.45x speedup on a 4-core machine) and is fast enough to be used interactively as part of a developer\'s workflow.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693080','10.1109/ASE.2013.6693080',56,2,'IEEE','IEEE Conferences',0),(920,'Understanding and overcoming parallelism bottlenecks in ForkJoin applications',8,765,775,'ForkJoin framework is a widely used parallel programming framework upon which both core concurrency libraries and real-world applications are built. Beneath its simple and user-friendly APIs, ForkJoin is a sophisticated managed parallel runtime unfamiliar to many application programmers: the framework core is a work-stealing scheduler, handles fine-grained tasks, and sustains the pressure from automatic memory management. ForkJoin poses a unique gap in the compute stack between high-level software engineering and low-level system optimization. Understanding and bridging this gap is crucial for the future of parallelism support in JVM-supported applications. This paper describes a comprehensive study on parallelism bottlenecks in ForkJoin applications, with a unique focus on how they interact with underlying system-level features, such as work stealing and memory management. We identify 6 bottlenecks, and found that refactoring them can significantly improve performance and energy efficiency. Our field study includes an in-depth analysis of Akka - a real-world actor framework - and 30 additional open-source ForkJoin projects. We sent our patches to the developers of 15 projects, and 7 out of the 9 projects that replied to our patches have accepted them.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115687','10.1109/ASE.2017.8115687',39,2,'IEEE','IEEE Conferences',0),(921,'Symlnfer: Inferring program invariants using symbolic states',8,804,814,'We introduce a new technique for inferring program invariants that uses symbolic states generated by symbolic execution. Symbolic states, which consist of path conditions and constraints on local variables, are a compact description of sets of concrete program states and they can be used for both invariant inference and invariant verification. Our technique uses a counterexample-based algorithm that creates concrete states from symbolic states, infers candidate invariants from concrete states, and then verifies or refutes candidate invariants using symbolic states. The refutation case produces concrete counterexamples that prevent spurious results and allow the technique to obtain more precise invariants. This process stops when the algorithm reaches a stable set of invariants. We present Symlnfer, a tool that implements these ideas to automatically generate invariants at arbitrary locations in a Java program. The tool obtains symbolic states from Symbolic PathFinder and uses existing algorithms to infer complex (potentially nonlinear) numerical invariants. Our preliminary results show that Symlnfer is effective in using symbolic states to generate precise and useful invariants for proving program safety and analyzing program runtime complexity. We also show that Symlnfer outperforms existing invariant generation systems.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115691','10.1109/ASE.2017.8115691',37,1,'IEEE','IEEE Conferences',0),(922,'EHBDroid: Beyond GUI testing for Android applications',8,27,37,'With the prevalence of Android-based mobile devices, automated testing for Android apps has received increasing attention. However, owing to the large variety of events that Android supports, test input generation is a challenging task. In this paper, we present a novel approach and an open source tool called EHBDroid for testing Android apps. In contrast to conventional GUI testing approaches, a key novelty of EHBDroid is that it does not generate events from the GUI, but directly invokes callbacks of event handlers. By doing so, EHBDroid can efficiently simulate a large number of events that are difficult to generate by traditional UI-based approaches. We have evaluated EHBDroid on a collection of 35 real-world large-scale Android apps and compared its performance with two state-of-the-art UI-based approaches, Monkey and Dynodroid. Our experimental results show that EHBDroid is significantly more effective and efficient than Monkey and Dynodroid: in a much shorter time, EHBDroid achieves as much as 22.3% higher statement coverage (11.1% on average) than the other two approaches, and found 12 bugs in these benchmarks, including 5 new bugs that the other two failed to find.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115615','10.1109/ASE.2017.8115615',39,5,'IEEE','IEEE Conferences',0),(923,'iProbe: A lightweight user-level dynamic instrumentation tool',6,742,745,'We introduce a new hybrid instrumentation tool for dynamic application instrumentation called iProbe, which is flexible and has low overhead. iProbe takes a novel 2-stage design, and offloads much of the dynamic instrumentation complexity to an offline compilation stage. It leverages standard compiler flags to introduce 鈥減lace-holders鈥� for hooks in the program executable. Then it utilizes an efficient user-space 鈥淗otPatching鈥� mechanism which modifies the functions to be traced and enables execution of instrumented code in a safe and secure manner. In its evaluation on a micro-benchmark and SPEC CPU2006 benchmark applications, the iProbe prototype achieved the instrumentation overhead an order of magnitude lower than existing state-of-the-art dynamic instrumentation tools like SystemTap and DynInst.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693147','10.1109/ASE.2013.6693147',19,1,'IEEE','IEEE Conferences',0),(924,'Context-aware task allocation for distributed agile team',6,758,761,'The philosophy of Agile software development advocates the spirit of open discussion and coordination among team members to adapt to incremental changes encountered during the process. Based on our observations from 20 agile student development teams over an 8-week study in Beihang University, China, we found that the task allocation strategy as a result of following the Agile process heavily depends on the experience of the users, and cannot be guaranteed to result in efficient utilization of team resources. In this research, we propose a context-aware task allocation decision support system that balances the considerations for quality and timeliness to improve the overall utility derived from an agile software development project.We formulate the agile process as a distributed constraint optimization problem, and propose a technology framework that assesses individual developers\' situations based on data collected from a Scrum-based agile process, and helps individual developers make situation-aware decisions on which tasks from the backlog to select in real-time. Preliminary analysis and simulation results show that it can achieve close to optimally efficient utilization of the developers\' collective capacity. We plan to build the framework into a computer-supported collaborative development platform and refine the method through more realistic projects.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693151','10.1109/ASE.2013.6693151',11,4,'IEEE','IEEE Conferences',0),(925,'A Message-Passing Architecture without Public Ids Using Send-to-Behavior',9,902,905,'We explore a novel model of computation based on nodes that have no public addresses (ids). We define nodes as concurrent, message-passing computational entities in an abstract communication medium, similar to the Actor model, but with all public node ids elided. Instead, drawing inspiration from biological systems, we postulate a send-to-behavior language construct to enable anonymous one-way communication. A behavior, defined as a function of input to actions, is also an intensional definition of the subset of nodes that express it. Sending to a behavior is defined to deliver the message to one or more nodes that implement that behavior.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372089','10.1109/ASE.2015.79',8,0,'IEEE','IEEE Conferences',0),(926,'An Automated Framework for Recommending Program Elements to Novices (N)',9,283,288,'Novice programmers often learn programming by implementing well-known algorithms. There are several challenges in the process. Recommendation systems in software currently focus on programmer productivity and ease of development. Teaching aides for such novice programmers based on recommendation systems still remain an under-explored area. In this paper, we present a general framework for recognizing the desired target for partially-written code and recommending a reliable series of edits to transform the input program into the target solution. Our code analysis is based on graph matching and tree edit algorithms. Our experimental results show that efficient graph comparison techniques can accurately match two portions of source code and produce an accurate set of source code edits. We provide details on implementation of our framework, which is developed as a plugin for Java in Eclipse IDE.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372017','10.1109/ASE.2015.54',30,2,'IEEE','IEEE Conferences',0),(927,'Search-Based Synthesis of Probabilistic Models for Quality-of-Service Software Engineering (T)',9,319,330,'The formal verification of finite-state probabilistic models supports the engineering of software with strict quality-of-service (QoS) requirements. However, its use in software design is currently a tedious process of manual multiobjective optimisation. Software designers must build and verify probabilistic models for numerous alternative architectures and instantiations of the system parameters. When successful, they end up with feasible but often suboptimal models. The EvoChecker search-based software engineering approach and tool introduced in our paper employ multiobjective optimisation genetic algorithms to automate this process and considerably improve its outcome. We evaluate EvoChecker for six variants of two software systems from the domains of dynamic power management and foreign exchange trading. These systems are characterised by different types of design parameters and QoS requirements, and their design spaces comprise between 2E+14 and 7.22E+86 relevant alternative designs. Our results provide strong evidence that EvoChecker significantly outperforms the current practice and yields actionable insights for software designers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372021','10.1109/ASE.2015.22',68,15,'IEEE','IEEE Conferences',0),(928,'Automatically assessing code understandability: How far are we?',8,417,427,'Program understanding plays a pivotal role in software maintenance and evolution: a deep understanding of code is the stepping stone for most software-related activities, such as bug fixing or testing. Being able to measure the understandability of a piece of code might help in estimating the effort required for a maintenance activity, in comparing the quality of alternative implementations, or even in predicting bugs. Unfortunately, there are no existing metrics specifically designed to assess the understandability of a given code snippet. In this paper, we perform a first step in this direction, by studying the extent to which several types of metrics computed on code, documentation, and developers correlate with code understandability. To perform such an investigation we ran a study with 46 participants who were asked to understand eight code snippets each. We collected a total of 324 evaluations aiming at assessing the perceived understandability, the actual level of understanding, and the time needed to understand a code snippet. Our results demonstrate that none of the (existing and new) metrics we considered is able to capture code understandability, not even the ones assumed to assess quality attributes strongly related with it, such as code readability and complexity.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115654','10.1109/ASE.2017.8115654',37,7,'IEEE','IEEE Conferences',0),(929,'Detecting system use cases and validations from documents',6,568,573,'Identifying system use cases and corresponding validations involves analyzing large requirement documents to understand the descriptions of business processes, rules and policies. This consumes a significant amount of effort and time. We discuss an approach to automate the detection of system use cases and corresponding validations from documents. We have devised a representation that allows for capturing the essence of rule statements as a composition of atomic `Rule intents\' and key phrases associated with the intents. Rule intents that co-occur frequently constitute `Rule acts\' analogous to the Speech acts in Linguistics. Our approach is based on NLP techniques designed around this Rule Model. We employ syntactic and semantic NL analyses around the model to identify and classify rules and annotate them with Rule acts. We map the Rule acts to business process steps and highlight the combinations as potential system use cases and validations for human supervision.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693114','10.1109/ASE.2013.6693114',26,5,'IEEE','IEEE Conferences',0),(930,'Semantic Slicing of Software Version Histories (T)',9,686,696,'Software developers often need to transfer func-tionality, e.g., a set of commits implementing a new feature or a bug fix, from one branch of a configuration management system to another. That can be a challenging task as the existing configuration management tools lack support for matching high-level semantic functionality with low-level version histories. The developer thus has to either manually identify the exact set of semantically-related commits implementing the functionality of interest or sequentially port a specific subset of the change history, \'inheriting\' additional, unwanted functionality. In this paper, we tackle this problem by providing automated support for identifying the set of semantically-related commits implementing a particular functionality, which is defined by a set of tests. We refer to our approach, CSLICER, as semantic slicing of version histories. We formally define the semantic slicing problem, provide an algorithm for identifying a set of commits that constitute a slice, and instantiate it in a specific implementation for Java projects managed in Git. We evaluate the correctness and effectiveness of our approach on a set of open-source software repositories. We show that it allows to identify subsets of change histories that maintain the functionality of interest but are substantially smaller than the original ones.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372056','10.1109/ASE.2015.47',38,9,'IEEE','IEEE Conferences',0),(931,'Developing a DSL-Based Approach for Event-Based Monitoring of Systems of Systems: Experiences and Lessons Learned (E)',9,715,725,'Complex software-intensive systems are often described as systems of systems (SoS) comprising heterogeneous architectural elements. As SoS behavior fully emerges during operation only, runtime monitoring is needed to detect deviations from requirements. Today, diverse approaches exist to define and check runtime behavior and performance characteristics. However, existing approaches often focus on specific types of systems and address certain kinds of checks, thus impeding their use in industrial SoS. Furthermore, as many SoS need to run continuously for long periods, the dynamic definition and deployment of constraints needs to be supported. In this paper we describe experiences of developing and applying a DSL-based approach for monitoring an SoS in the domain of industrial automation software. We evaluate both the expressiveness of our DSL as well as the scalability of the constraint checker. We also describe lessons learned.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372060','10.1109/ASE.2015.25',45,10,'IEEE','IEEE Conferences',0),(932,'A study of repetitiveness of code changes in software evolution',6,180,190,'In this paper, we present a large-scale study of repetitiveness of code changes in software evolution. We collected a large data set of 2,841 Java projects, with 1.7 billion source lines of code (SLOC) at the latest revisions, 1.8 million code change revisions (0.4 million fixes), 6.2 million changed files, and 2.5 billion changed SLOCs. A change is considered repeated within or cross-project if it matches another change having occurred in the history of the project or another project, respectively. We report the following important findings. First, repetitiveness of changes could be as high as 70-100% at small sizes and decreases exponentially as size increases. Second, repetitiveness is higher and more stable in the cross-project setting than in the within-project one. Third, fixing changes repeat similarly to general changes. Importantly, learning code changes and recommending them in software evolution is beneficial with accuracy for top-1 recommendation of over 30% and top-3 of nearly 35%. Repeated fixing changes could also be useful for automatic program repair.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693078','10.1109/ASE.2013.6693078',39,34,'IEEE','IEEE Conferences',0),(933,'Automatically synthesizing SQL queries from input-output examples',6,224,234,'Many computer end-users, such as research scientists and business analysts, need to frequently query a database, yet lack enough programming knowledge to write a correct SQL query. To alleviate this problem, we present a programming by example technique (and its tool implementation, called SQLSynthesizer) to help end-users automate such query tasks. SQLSynthesizer takes from users an example input and output of how the database should be queried, and then synthesizes a SQL query that reproduces the example output from the example input. If the synthesized SQL query is applied to another, potentially larger, database with a similar schema, the synthesized SQL query produces a corresponding result that is similar to the example output. We evaluated SQLSynthesizer on 23 exercises from a classic database textbook and 5 forum questions about writing SQL queries. SQLSynthesizer synthesized correct answers for 15 textbook exercises and all 5 forum questions, and it did so from relatively small examples.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693082','10.1109/ASE.2013.6693082',35,12,'IEEE','IEEE Conferences',0),(934,'Automatic loop-invariant generation anc refinement through selective sampling',8,782,792,'Automatic loop-invariant generation is important in program analysis and verification. In this paper, we propose to generate loop-invariants automatically through learning and verification. Given a Hoare triple of a program containing a loop, we start with randomly testing the program, collect program states at run-time and categorize them based on whether they satisfy the invariant to be discovered. Next, classification techniques are employed to generate a candidate loop-invariant automatically. Afterwards, we refine the candidate through selective sampling so as to overcome the lack of sufficient test cases. Only after a candidate invariant cannot be improved further through selective sampling, we verify whether it can be used to prove the Hoare triple. If it cannot, the generated counterexamples are added as new tests and we repeat the above process. Furthermore, we show that by introducing a path-sensitive learning, i.e., partitioning the program states according to program locations they visit and classifying each partition separately, we are able to learn disjunctive loop-invariants. In order to evaluate our idea, a prototype tool has been developed and the experiment results show that our approach complements existing approaches.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115689','10.1109/ASE.2017.8115689',50,0,'IEEE','IEEE Conferences',0),(935,'Mining constraints for event-based monitoring in systems of systems',8,826,831,'The full behavior of software-intensive systems of systems (SoS) emerges during operation only. Runtime monitoring approaches have thus been proposed to detect deviations from the expected behavior. They commonly rely on temporal logic or domain-specific languages to formally define requirements, which are then checked by analyzing the stream of monitored events and event data. Some approaches also allow developers to generate constraints from declarative specifications of the expected behavior. However, independent of the approach, deep domain knowledge is required to specify the desired behavior. This knowledge is often not accessible in SoS environments with multiple development teams independently working on different, heterogeneous systems. In this New Ideas Paper we thus describe an approach that automatically mines constraints for runtime monitoring from event logs recorded in SoS. Our approach builds on ideas from specification mining, process mining, and machine learning to mine different types of constraints on event occurrence, event timing, and event data. The approach further presents the mined constraints to users in an existing constraint language and it ranks the constraints using different criteria. We demonstrate the feasibility of our approach by applying it to event logs from a real-world industrial SoS.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115693','10.1109/ASE.2017.8115693',29,0,'IEEE','IEEE Conferences',0),(936,'Saying 鈥楬i!鈥� is not enough: Mining inputs for effective test generation',8,44,49,'Automatically generating unit tests is a powerful approach to exercise complex software. Unfortunately, current techniques often fail to provide relevant input values, such as strings that bypass domain-specific sanity checks. As a result, state-of-the-art techniques are effective for generic classes, such as collections, but less successful for domain-specific software. This paper presents TestMiner, the first technique for mining a corpus of existing tests for input values to be used by test generators for effectively testing software not in the corpus. The main idea is to extract literals from thousands of tests and to adapt information retrieval techniques to find values suitable for a particular domain. Evaluating the approach with 40 Java classes from 18 different projects shows that TestMiner improves test coverage by 21% over an existing test generator. The approach can be integrated into various test generators in a straightforward way, increasing their effectiveness on previously difficult-to-test classes.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115617','10.1109/ASE.2017.8115617',57,0,'IEEE','IEEE Conferences',0),(937,'Synthesizing fault-tolerant programs from deontic logic specifications',6,750,753,'We study the problem of synthesizing fault-tolerant components from specifications, i.e., the problem of automatically constructing a fault-tolerant component implementation from a logical specification of the component, and the system\'s required level of fault-tolerance. In our approach, the logical specification of the component is given in dCTL, a branching time temporal logic with deontic operators, especially designed for fault-tolerant component specification. The synthesis algorithm takes the component specification, and a user-defined level of fault-tolerance (masking, nonmasking, failsafe), and automatically determines whether a component with the required fault-tolerance is realizable. Moreover, if the answer is positive, then the algorithm produces such a fault-tolerant implementation. Our technique for synthesis is based on the use of (bi)simulation algorithms for capturing different fault-tolerance classes, and the extension of a synthesis algorithm for CTL to cope with dCTL specifications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693149','10.1109/ASE.2013.6693149',16,0,'IEEE','IEEE Conferences',0),(938,'Can automated pull requests encourage software developers to upgrade out-of-date dependencies?',8,84,94,'Developers neglect to update legacy software dependencies, resulting in buggy and insecure software. One explanation for this neglect is the difficulty of constantly checking for the availability of new software updates, verifying their safety, and addressing any migration efforts needed when upgrading a dependency. Emerging tools attempt to address this problem by introducing automated pull requests and project badges to inform the developer of stale dependencies. To understand whether these tools actually help developers, we analyzed 7,470 GitHub projects that used these notification mechanisms to identify any change in upgrade behavior. Our results find that, on average, projects that use pull request notifications upgraded 1.6脳 as often as projects that did not use any tools. Badge notifications were slightly less effective: users upgraded 1.4脳 more frequently. Unfortunately, although pull request notifications are useful, developers are often overwhelmed by notifications: only a third of pull requests were actually merged. Through a survey, 62 developers indicated that their most significant concerns are breaking changes, understanding the implications of changes, and migration effort. The implications of our work suggests ways in which notifications can be improved to better align with developers\' expectations and the need for new mechanisms to reduce notification fatigue and improve confidence in automated pull requests.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115621','10.1109/ASE.2017.8115621',33,8,'IEEE','IEEE Conferences',0),(939,'Repairing Programs with Semantic Code Search (T)',9,295,306,'Automated program repair can potentially reduce debugging costs and improve software quality but recent studies have drawn attention to shortcomings in the quality of automatically generated repairs. We propose a new kind of repair that uses the large body of existing open-source code to find potential fixes. The key challenges lie in efficiently finding code semantically similar (but not identical) to defective code and then appropriately integrating that code into a buggy program. We present SearchRepair, a repair technique that addresses these challenges by(1) encoding a large database of human-written code fragments as SMT constraints on input-output behavior, (2) localizing a given defect to likely buggy program fragments and deriving the desired input-output behavior for code to replace those fragments, (3) using state-of-the-art constraint solvers to search the database for fragments that satisfy that desired behavior and replacing the likely buggy code with these potential patches, and (4) validating that the patches repair the bug against program testsuites. We find that SearchRepair repairs 150 (19%) of 778 benchmark C defects written by novice students, 20 of which are not repaired by GenProg, TrpAutoRepair, and AE. We compare the quality of the patches generated by the four techniques by measuring how many independent, not-used-during-repairtests they pass, and find that SearchRepair-repaired programs pass 97.3% ofthe tests, on average, whereas GenProg-, TrpAutoRepair-, and AE-repaired programs pass 68.7%, 72.1%, and 64.2% of the tests, respectively. We concludethat SearchRepair produces higher-quality repairs than GenProg, TrpAutoRepair, and AE, and repairs some defects those tools cannot.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372019','10.1109/ASE.2015.60',77,52,'IEEE','IEEE Conferences',0),(940,'Cost-Efficient Sampling for Performance Prediction of Configurable Systems (T)',9,342,352,'A key challenge of the development and maintenanceof configurable systems is to predict the performance ofindividual system variants based on the features selected. It isusually infeasible to measure the performance of all possible variants, due to feature combinatorics. Previous approaches predictperformance based on small samples of measured variants, butit is still open how to dynamically determine an ideal samplethat balances prediction accuracy and measurement effort. Inthis paper, we adapt two widely-used sampling strategies forperformance prediction to the domain of configurable systemsand evaluate them in terms of sampling cost, which considersprediction accuracy and measurement effort simultaneously. Togenerate an initial sample, we introduce a new heuristic based onfeature frequencies and compare it to a traditional method basedon t-way feature coverage. We conduct experiments on six realworldsystems and provide guidelines for stakeholders to predictperformance by sampling.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372023','10.1109/ASE.2015.45',21,35,'IEEE','IEEE Conferences',0),(941,'Understanding feature requests by leveraging fuzzy method and linguistic analysis',8,440,450,'In open software development environment, a large number of feature requests with mixed quality are often posted by stakeholders and usually managed in issue tracking systems. Thoroughly understanding and analyzing the real intents that feature requests imply is a labor-intensive and challenging task. In this paper, we introduce an approach to understand feature requests automatically. We generate a set of fuzzy rules based on natural language processing techniques that classify each sentence in feature requests into a set of categories: Intent, Explanation, Benefit, Drawback, Example and Trivia. Consequently, the feature requests can be automatically structured based on the classification results. We conduct experiments on 2,112 sentences taken from 602 feature requests of nine popular open source projects. The results show that our method can reach a high performance on classifying sentences from feature requests. Moreover, when applying fuzzy rules on machine learning methods, the performance can be improved significantly.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115656','10.1109/ASE.2017.8115656',45,2,'IEEE','IEEE Conferences',0),(942,'Software performance self-adaptation through efficient model predictive control',8,485,496,'A key challenge in software systems that are exposed to runtime variabilities, such as workload fluctuations and service degradation, is to continuously meet performance requirements. In this paper we present an approach that allows performance self-adaptation using a system model based on queuing networks (QNs), a well-assessed formalism for software performance engineering. Software engineers can select the adaptation knobs of a QN (routing probabilities, service rates, and concurrency level) and we automatically derive a Model Predictive Control (MPC) formulation suitable to continuously configure the selected knobs and track the desired performance requirements. Previous MPC approaches have two main limitations: i) high computational cost of the optimization, due to nonlinearity of the models; ii) focus on long-run performance metrics only, due to the lack of tractable representations of the QN\'s time-course evolution. As a consequence, these limitations allow adaptations with coarse time granularities, neglecting the system\'s transient behavior. Our MPC adaptation strategy is efficient since it is based on mixed integer programming, which uses a compact representation of a QN with ordinary differential equations. An extensive evaluation on an implementation of a load balancer demonstrates the effectiveness of the adaptation and compares it with traditional methods based on probabilistic model checking.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115660','10.1109/ASE.2017.8115660',66,1,'IEEE','IEEE Conferences',0),(943,'From comparison matrix to Variability Model: The Wikipedia case study',6,580,585,'Product comparison matrices (PCMs) provide a convenient way to document the discriminant features of a family of related products and now abound on the internet. Despite their apparent simplicity, the information present in existing PCMs can be very heterogeneous, partial, ambiguous, hard to exploit by users who desire to choose an appropriate product. Variability Models (VMs) can be employed to formulate in a more precise way the semantics of PCMs and enable automated reasoning such as assisted configuration. Yet, the gap between PCMs and VMs should be precisely understood and automated techniques should support the transition between the two. In this paper, we propose variability patterns that describe PCMs content and conduct an empirical analysis of 300+ PCMs mined from Wikipedia. Our findings are a first step toward better engineering techniques for maintaining and configuring PCMs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693116','10.1109/ASE.2013.6693116',21,6,'IEEE','IEEE Conferences',0),(944,'SBFR: A search based approach for reproducing failures of programs with grammar based input',6,604,609,'Reproducing field failures in-house, a step developers must perform when assigned a bug report, is an arduous task. In most cases, developers must be able to reproduce a reported failure using only a stack trace and/or some informal description of the failure. The problem becomes even harder for the large class of programs whose input is highly structured and strictly specified by a grammar. To address this problem, we present SBFR, a search-based failure-reproduction technique for programs with structured input. SBFR formulates failure reproduction as a search problem. Starting from a reported failure and a limited amount of dynamic information about the failure, SBFR exploits the potential of genetic programming to iteratively find legal inputs that can trigger the failure.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693120','10.1109/ASE.2013.6693120',32,4,'IEEE','IEEE Conferences',0),(945,'Quantification of Software Changes through Probabilistic Symbolic Execution (N)',9,703,708,'Characterizing software changes is fundamental for software maintenance. However existing techniques are imprecise leading to unnecessary maintenance efforts. We introduce a novel approach that computes a precise numeric characterization of program changes, which quantifies the likelihood of reaching target program events (e.g., assert violations or successful termination) and how that evolves with each program update, together with the percentage of inputs impacted by the change. This precise characterization leads to a natural ranking of different program changes based on their probability of execution and their impact on target events. The approach is based on model counting over the constraints collected with a symbolic execution of the program, and exploits the similarity between program versions to reduce cost and improve the quality of analysis results. We implemented our approach in the Symbolic PathFinder tool and illustrate it on several Java case studies, including the evaluation of different program repairs, mutants used in testing, or incremental analysis after a change.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372058','10.1109/ASE.2015.78',23,6,'IEEE','IEEE Conferences',0),(946,'How Verified is My Code? Falsification-Driven Verification (T)',9,737,748,'Formal verification has advanced to the point that developers can verify the correctness of small, critical modules. Unfortunately, despite considerable efforts, determining if a \'verification\' verifies what the author intends is still difficult. Previous approaches are difficult to understand and often limited in applicability. Developers need verification coverage in terms of the software they are verifying, not model checking diagnostics. We propose a methodology to allow developers to determine (and correct) what it is that they have verified, and tools to support that methodology. Our basic approach is based on a novel variation of mutation analysis and the idea of verification driven by falsification. We use the CBMC model checker to show that this approach is applicable not only to simple data structures and sorting routines, and verification of a routine in Mozilla\'s JavaScript engine, but to understanding an ongoing effort to verify the Linux kernel Read-Copy-Update (RCU) mechanism.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372062','10.1109/ASE.2015.40',56,7,'IEEE','IEEE Conferences',0),(947,'Characteristic studies of loop problems for structural test generation via symbolic execution',6,246,256,'Dynamic Symbolic Execution (DSE) is a state-of-the-art test-generation approach that systematically explores program paths to generate high-covering tests. In DSE, the presence of loops (especially unbound loops) can cause an enormous or even infinite number of paths to be explored. There exist techniques (such as bounded iteration, heuristics, and summarization) that assist DSE in addressing loop problems. However, there exists no literature-survey or empirical work that shows the pervasiveness of loop problems or identifies challenges faced by these techniques on real-world open-source applications. To fill this gap, we provide characteristic studies to guide future research on addressing loop problems for DSE. Our proposed study methodology starts with conducting a literature-survey study to investigate how technical problems such as loop problems compromise automated software-engineering tasks such as test generation, and which existing techniques are proposed to deal with such technical problems. Then the study methodology continues with conducting an empirical study of applying the existing techniques on real-world software applications sampled based on the literature-survey results and major open-source project hostings. This empirical study investigates the pervasiveness of the technical problems and how well existing techniques can address such problems among real-world software applications. Based on such study methodology, our two-phase characteristic studies identify that bounded iteration and heuristics are effective in addressing loop problems when used properly. Our studies further identify challenges faced by these techniques and provide guidelines for effectively addressing these challenges.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693084','10.1109/ASE.2013.6693084',54,21,'IEEE','IEEE Conferences',0),(948,'Test suite parallelization in open-source projects: A study on its usage and impact',8,838,848,'Dealing with high testing costs remains an important problem in Software Engineering. Test suite parallelization is an important approach to address this problem. This paper reports our findings on the usage and impact of test suite parallelization in open-source projects. It provides recommendations to practitioners and tool developers to speed up test execution. Considering a set of 468 popular Java projects we analyzed, we found that 24% of the projects contain costly test suites but parallelization features still seem underutilized in practice - only 19.1% of costly projects use parallelization. The main reported reason for adoption resistance was the concern to deal with concurrency issues. Results suggest that, on average, developers prefer high predictability than high performance in running tests.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115695','10.1109/ASE.2017.8115695',42,1,'IEEE','IEEE Conferences',0),(949,'The impact of continuous integration on other software development practices: A large-scale empirical study',8,60,71,'Continuous Integration (CI) has become a disruptive innovation in software development: with proper tool support and adoption, positive effects have been demonstrated for pull request throughput and scaling up of project sizes. As any other innovation, adopting CI implies adapting existing practices in order to take full advantage of its potential, and \'best practices\' to that end have been proposed. Here we study the adaptation and evolution of code writing and submission, issue and pull request closing, and testing practices as TRAVIS CI is adopted by hundreds of established projects on GITHUB. To help essentialize the quantitative results, we also survey a sample of GITHUB developers about their experiences with adopting TRAVIS CI. Our findings suggest a more nuanced picture of how GITHUB teams are adapting to, and benefiting from, continuous integration technology than suggested by prior work.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115619','10.1109/ASE.2017.8115619',56,14,'IEEE','IEEE Conferences',0),(950,'SentiCR: A customized sentiment analysis tool for code review interactions',8,106,111,'Sentiment Analysis tools, developed for analyzing social media text or product reviews, work poorly on a Software Engineering (SE) dataset. Since prior studies have found developers expressing sentiments during various SE activities, there is a need for a customized sentiment analysis tool for the SE domain. On this goal, we manually labeled 2000 review comments to build a training dataset and used our dataset to evaluate seven popular sentiment analysis tools. The poor performances of the existing sentiment analysis tools motivated us to build SentiCR, a sentiment analysis tool especially designed for code review comments. We evaluated SentiCR using one hundred 10-fold cross-validations of eight supervised learning algorithms. We found a model, trained using the Gradient Boosting Tree (GBT) algorithm, providing the highest mean accuracy (83%), the highest mean precision (67.8%), and the highest mean recall (58.4%) in identifying negative review comments.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115623','10.1109/ASE.2017.8115623',48,8,'IEEE','IEEE Conferences',0),(951,'Performance Prediction of Configurable Software Systems by Fourier Learning (T)',9,365,373,'Understanding how performance varies across a large number of variants of a configurable software system is important for helping stakeholders to choose a desirable variant. Given a software system with n optional features, measuring all its 2n possible configurations to determine their performances is usually infeasible. Thus, various techniques have been proposed to predict software performances based on a small sample of measured configurations. We propose a novel algorithm based on Fourier transform that is able to make predictions of any configurable software system with theoretical guarantees of accuracy and confidence level specified by the user, while using minimum number of samples up to a constant factor. Empirical results on the case studies constructed from real-world configurable systems demonstrate the effectiveness of our algorithm.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372025','10.1109/ASE.2015.15',20,18,'IEEE','IEEE Conferences',0),(952,'Gremlin-ATL: A scalable model transformation framework',8,462,472,'Industrial use of Model Driven Engineering techniques has emphasized the need for efficiently store, access, and transform very large models. While scalable persistence frameworks, typically based on some kind of NoSQL database, have been proposed to solve the model storage issue, the same level of performance improvement has not been achieved for the model transformation problem. Existing model transformation tools (such as the well-known ATL) often require the input models to be loaded in memory prior to the start of the transformation and are not optimized to benefit from lazy-loading mechanisms, mainly due to their dependency on current low-level APIs offered by the most popular modeling frameworks nowadays. In this paper we present Gremlin-ATL, a scalable and efficient model-to-model transformation framework that translates ATL transformations into Gremlin, a query language supported by several NoSQL databases. With Gremlin-ATL, the transformation is computed within the database itself, bypassing the modeling framework limitations and improving its performance both in terms of execution time and memory consumption. Tool support is available online.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115658','10.1109/ASE.2017.8115658',33,0,'IEEE','IEEE Conferences',0),(953,'A comprehensive study of real-world numerical bug characteristics',8,509,519,'Numerical software is used in a wide variety of applications including safety-critical systems, which have stringent correctness requirements, and whose failures have catastrophic consequences that endanger human life. Numerical bugs are known to be particularly difficult to diagnose and fix, largely due to the use of approximate representations of numbers such as floating point. Understanding the characteristics of numerical bugs is the first step to combat them more effectively. In this paper, we present the first comprehensive study of real-world numerical bugs. Specifically, we identify and carefully examine 269 numerical bugs from five widely-used numerical software libraries: NumPy, SciPy, LAPACK, GNU Scientific Library, and Elemental. We propose a categorization of numerical bugs, and discuss their frequency, symptoms and fixes. Our study opens new directions in the areas of program analysis, testing, and automated program repair of numerical software, and provides a collection of real-world numerical bugs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115662','10.1109/ASE.2017.8115662',45,3,'IEEE','IEEE Conferences',0),(954,'Environment rematching: Toward dependability improvement for self-adaptive applications',6,592,597,'Self-adaptive applications can easily contain faults. Existing approaches detect faults, but can still leave some undetected and manifesting into failures at runtime. In this paper, we study the correlation between occurrences of application failure and those of consistency failure. We propose fixing consistency failure to reduce application failure at runtime. We name this environment rematching, which can systematically reconnect a self-adaptive application to its environment in a consistent way. We also propose enforcing atomicity for application semantics during the rematching to avoid its side effect. We evaluated our approach using 12 self-adaptive robot-car applications by both simulated and real experiments. The experimental results confirmed our approach\'s effectiveness in improving dependability for all applications by 12.5-52.5%.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693118','10.1109/ASE.2013.6693118',25,1,'IEEE','IEEE Conferences',0),(955,'Randomizing regression tests using game theory',6,616,621,'As software evolves, the number of test-cases in the regression test suites continues to increase, requiring testers to prioritize their execution. Usually only a subset of the test cases is executed due to limited testing resources. This subset is often known to the developers who may try to 鈥済ame鈥� the system by committing insufficiently tested code for parts of the software that will not be tested. In this new ideas paper, we propose a novel approach for randomizing regression test scheduling, based on Stackelberg games for deployment of scarce resources. We apply this approach to randomizing test cases in such a way as to maximize the testers\' expected payoff when executing the test cases. Our approach accounts for resource limitations (e.g., number of testers) and provides a probabilistic distribution for scheduling test cases. We provide an example application of our approach showcasing the idea of using Stackelberg games for randomized regression test scheduling.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693122','10.1109/ASE.2013.6693122',20,5,'IEEE','IEEE Conferences',0),(956,'\'What Parts of Your Apps are Loved by Users?\' (T)',9,760,770,'Recently, Begel et al. found that one of the most important questions software developers ask is \'what parts of software are used/loved by users.\' User reviews provide an effective channel to address this question. However, most existing review summarization tools treat reviews as bags-of-words (i.e., mixed review categories) and are limited to extract software aspects and user preferences. We present a novel review summarization framework, SUR-Miner. Instead of a bags-of-words assumption, it classifies reviews into five categories and extracts aspects for sentences which include aspect evaluation using a pattern-based parser. Then, SUR-Miner visualizes the summaries using two interactive diagrams. Our evaluation on seventeen popular apps shows that SUR-Miner summarizes more accurate and clearer aspects than state-of-the-art techniques, with an F1-score of 0.81, significantly greater than that of ReviewSpotlight (0.56) and Guzmans\' method (0.55). Feedback from developers shows that 88% developers agreed with the usefulness of the summaries from SUR-Miner.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372064','10.1109/ASE.2015.57',38,35,'IEEE','IEEE Conferences',0),(957,'Detecting bad smells in source code using change history information',6,268,278,'Code smells represent symptoms of poor implementation choices. Previous studies found that these smells make source code more difficult to maintain, possibly also increasing its fault-proneness. There are several approaches that identify smells based on code analysis techniques. However, we observe that many code smells are intrinsically characterized by how code elements change over time. Thus, relying solely on structural information may not be sufficient to detect all the smells accurately. We propose an approach to detect five different code smells, namely Divergent Change, Shotgun Surgery, Parallel Inheritance, Blob, and Feature Envy, by exploiting change history information mined from versioning systems. We applied approach, coined as HIST (Historical Information for Smell deTection), to eight software projects written in Java, and wherever possible compared with existing state-of-the-art smell detectors based on source code analysis. The results indicate that HIST\'s precision ranges between 61% and 80%, and its recall ranges between 61% and 100%. More importantly, the results confirm that HIST is able to identify code smells that cannot be identified through approaches solely based on code analysis.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693086','10.1109/ASE.2013.6693086',31,83,'IEEE','IEEE Conferences',0),(958,'A scalable approach for malware detection through bounded feature space behavior modeling',6,312,322,'In recent years, malware (malicious software) has greatly evolved and has become very sophisticated. The evolution of malware makes it difficult to detect using traditional signature-based malware detectors. Thus, researchers have proposed various behavior-based malware detection techniques to mitigate this problem. However, there are still serious shortcomings, related to scalability and computational complexity, in existing malware behavior modeling techniques. This raises questions about the practical applicability of these techniques. This paper proposes and evaluates a bounded feature space behavior modeling (BOFM) framework for scalable malware detection. BOFM models the interactions between software (which can be malware or benign) and security-critical OS resources in a scalable manner. Information collected at run-time according to this model is then used by machine learning algorithms to learn how to accurately classify software as malware or benign. One of the key problems with simple malware behavior modeling (e.g., n-gram model) is that the number of malware features (i.e., signatures) grows proportional to the size of execution traces, with a resulting malware feature space that is so large that it makes the detection process very challenging. On the other hand, in BOFM, the malware feature space is bounded by an upper limit N, a constant, and the results of our experiments show that its computation time and memory usage are vastly lower than in currently reported, malware detection techniques, while preserving or even improving their high detection accuracy.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693090','10.1109/ASE.2013.6693090',32,9,'IEEE','IEEE Conferences',0),(959,'Automatically reducing tree-structured test inputs',8,861,871,'Reducing the test input given to a program while preserving some property of interest is important, e.g., to localize faults or to reduce test suites. The well-known delta debugging algorithm and its derivatives automate this task by repeatedly reducing a given input. Unfortunately, these approaches are limited to blindly removing parts of the input and cannot reduce the input by restructuring it. This paper presents the Generalized Tree Reduction (GTR) algorithm, an effective and efficient technique to reduce arbitrary test inputs that can be represented as a tree, such as program code, PDF files, and XML documents. The algorithm combines tree transformations with delta debugging and a greedy backtracking algorithm. To reduce the size of the considered search space, the approach automatically specializes the tree transformations applied by the algorithm based on examples of input trees. We evaluate GTR by reducing Python files that cause interpreter crashes, JavaScript files that cause browser inconsistencies, PDF documents with malicious content, and XML files used to tests an XML validator. The GTR algorithm reduces the trees of these files to 45.3%, 3.6%, 44.2%, and 1.3% of the original size, respectively, outperforming both delta debugging and another state-of-the-art algorithm.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115697','10.1109/ASE.2017.8115697',46,4,'IEEE','IEEE Conferences',0),(960,'Improving software text retrieval using conceptual knowledge in source code',8,123,134,'A large software project usually has lots of various textual learning resources about its API, such as tutorials, mailing lists, user forums, etc. Text retrieval technology allows developers to search these API learning resources for related documents using free-text queries, but it suffers from the lexical gap between search queries and documents. In this paper, we propose a novel approach for improving the retrieval of API learning resources through leveraging software-specific conceptual knowledge in software source code. The basic idea behind this approach is that the semantic relatedness between queries and documents could be measured according to software-specific concepts involved in them, and software source code contains a large amount of software-specific conceptual knowledge. In detail, firstly we extract an API graph from software source code and use it as software-specific conceptual knowledge. Then we discover API entities involved in queries and documents, and infer semantic document relatedness through analyzing structural relationships between these API entities. We evaluate our approach in three popular open source software projects. Comparing to the state-of-the-art text retrieval approaches, our approach lead to at least 13.77% improvement with respect to mean average precision (MAP).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115625','10.1109/ASE.2017.8115625',53,3,'IEEE','IEEE Conferences',0),(961,'Configuration-Aware Change Impact Analysis (T)',9,385,395,'Understanding variability is essential to allow the configuration of software systems to diverse requirements. Variability-aware program analysis techniques have been proposed for analyzing the space of program variants. Such techniques are highly beneficial, e.g., to determine the potential impact of changes during maintenance. This paper presents an interprocedural and configuration-aware change impact analysis (CIA) approach for determining possibly impacted products when changing source code of a product family. The approach further supports engineers, who are adapting specific product variants after an initial pre-configuration. The approach can be adapted to work with different variability mechanism, it provides more precise results than existing CIA approaches, and it can be implemented using standard control flow and data flow analysis. Using an industrial product line we report evaluation results on the benefit and performance of the approach.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372027','10.1109/ASE.2015.58',33,15,'IEEE','IEEE Conferences',0),(962,'Automated Test Input Generation for Android: Are We There Yet? (E)',9,429,440,'Like all software, mobile applications (\'apps\') must be adequately tested to gain confidence that they behave correctly. Therefore, in recent years, researchers and practitioners alike have begun to investigate ways to automate apps testing. In particular, because of Android\'s open source nature and its large share of the market, a great deal of research has been performed on input generation techniques for apps that run on the Android operating systems. At this point in time, there are in fact a number of such techniques in the literature, which differ in the way they generate inputs, the strategy they use to explore the behavior of the app under test, and the specific heuristics they use. To better understand the strengths and weaknesses of these existing approaches, and get general insight on ways they could be made more effective, in this paper we perform a thorough comparison of the main existing test input generation tools for Android. In our comparison, we evaluate the effectiveness of these tools, and their corresponding techniques, according to four metrics: ease of use, ability to work on multiple platforms, code coverage, and ability to detect faults. Our results provide a clear picture of the state of the art in input generation for Android apps and identify future research directions that, if suitably investigated, could lead to more effective and efficient testing tools for Android.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372031','10.1109/ASE.2015.89',35,119,'IEEE','IEEE Conferences',0),(963,'Visualization support for requirements monitoring in systems of systems',8,889,894,'Industrial software systems are often systems of systems (SoS) whose full behavior only emerges at runtime. The systems and their interactions thus need to be continuously monitored and checked during operation to determine compliance with requirements. Many requirements monitoring approaches have been proposed. However, only few of these come with tools that present and visualize monitoring results and details on requirements violations to end users such as industrial engineers. In this tool demo paper we present visualization capabilities we have been developing motivated by industrial scenarios. Our tool complements ReMinds, an existing requirements monitoring framework, which supports collecting, aggregating, and analyzing events and event data in architecturally heterogeneous SoS. Our visualizations support a `drill-down\' scenario for monitoring and diagnosis: starting from a graphical status overview of the monitored systems and their relations, engineers can view trends and statistics about performed analyses and diagnose the root cause of problems by inspecting the events and event data that led to a specific violation. Initial industry feedback we received confirms the usefulness of our tool support. Demo video: https://youtu.be/iv7kWzeNkdk..','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115700','10.1109/ASE.2017.8115700',19,4,'IEEE','IEEE Conferences',0),(964,'Generating simpler AST edit scripts by considering copy-and-paste',8,532,542,'In software development, there are many situations in which developers need to understand given source code changes in detail. Until now, a variety of techniques have been proposed to support understanding source code changes. Tree-based differencing techniques are expected to have better understandability than text-based ones, which are widely used nowadays (e.g., diff in Unix). In this paper, we propose to consider copy-and-paste as a kind of editing action forming tree-based edit script, which is an editing sequence that transforms a tree to another one. Software developers often perform copy- and-paste when they are writing source code. Introducing copy- and-paste action into edit script contributes to not only making simpler (more easily understandable) edit scripts but also making edit scripts closer to developers\' actual editing sequences. We conducted experiments on an open dataset. As a result, we confirmed that our technique made edit scripts shorter for 18% of the code changes with a little more computational time. For the other 82% code changes, our technique generated the same edit scripts as an existing technique. We also confirmed that our technique provided more helpful visualizations.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115664','10.1109/ASE.2017.8115664',24,5,'IEEE','IEEE Conferences',0),(965,'Adding context to fault localization with integration coverage',6,628,633,'Fault localization is a costly task in the debugging process. Several techniques to automate fault localization have been proposed aiming at reducing effort and time spent. Some techniques use heuristics based on code coverage data. The goal is to indicate program code excerpts more likely to contain faults. The coverage data mostly used in automated debugging is based on white-box unit testing (e.g., statements, basic blocks, predicates). This paper presents a technique which uses integration coverage data to guide the fault localization process. By ranking most suspicious pairs of method invocations, roadmaps-sorted lists of methods to be investigated-are created. At each method, unit coverage (e.g., basic blocks) is used to locate the fault site. Fifty-five bugs of four programs containing 2K to 80K lines of code (LOC) were analyzed. The results indicate that, by using the roadmaps, the effectiveness of the fault localization process is improved: 78% of all the faults are reached within a fixed amount of basic blocks; 40% more than an approach based on the Tarantula technique. Furthermore, fewer blocks have to be investigated until reaching the fault.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693124','10.1109/ASE.2013.6693124',20,1,'IEEE','IEEE Conferences',0),(966,'The ReMinds Tool Suite for Runtime Monitoring of Systems of Systems',9,777,782,'The behavior of systems of systems (SoS) emerges only fully during operation and is hard to predict. SoS thus need to be monitored at runtime to detect deviations from important requirements. However, existing approaches for checking runtime behavior and performance characteristics are limited with respect to the kinds of checks and the types of technologies supported, which impedes their use in industrial SoS. In this tool demonstration paper we describe the ReMinds tool suite for runtime monitoring of SoS developed in response to industrial monitoring scenarios. ReMinds provides comprehensive tool support for instrumenting systems, extracting events and data at runtime, defining constraints to check expected behavior and properties, and visualizing constraint violations to facilitate diagnosis.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372066','10.1109/ASE.2015.91',33,1,'IEEE','IEEE Conferences',0),(967,'FLYAQ: Enabling Non-expert Users to Specify and Generate Missions of Autonomous Multicopters',9,801,806,'Multicopters are increasingly popular since they promise to simplify a myriad of everyday tasks. Currently, vendors provide low-level APIs and basic primitives to program multicopters, making mission development a task-specific and error-prone activity. As a consequence, current approaches are affordable only for users that have a strong technical expertise. Then, software engineering techniques are needed to support the definition, development, and realization of missions at the right level of abstraction and involving teams of autonomous multicopters that guarantee the safety today\'s users expect. In this paper we describe a tool that enables end-users with no technical expertise, e.g., firefighters and rescue workers, to specify missions for a team of multicopters. The detailed flight plan that each multicopter must perform to accomplish the specified mission is automatically generated by preventing collisions between multicopters and obstacles, and ensuring the preservation of no-fly zones.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372070','10.1109/ASE.2015.104',14,10,'IEEE','IEEE Conferences',0),(968,'Automatic recommendation of API methods from feature requests',6,290,300,'Developers often receive many feature requests. To implement these features, developers can leverage various methods from third party libraries. In this work, we propose an automated approach that takes as input a textual description of a feature request. It then recommends methods in library APIs that developers can use to implement the feature. Our recommendation approach learns from records of other changes made to software systems, and compares the textual description of the requested feature with the textual descriptions of various API methods. We have evaluated our approach on more than 500 feature requests of Axis2/Java, CXF, Hadoop Common, HBase, and Struts 2. Our experiments show that our approach is able to recommend the right methods from 10 libraries with an average recall-rate@5 of 0.690 and recall-rate@10 of 0.779 respectively. We also show that the state-of-the-art approach by Chan et al., that recommends API methods based on precise text phrases, is unable to handle feature requests.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693088','10.1109/ASE.2013.6693088',37,28,'IEEE','IEEE Conferences',0),(969,'Finding architectural flaws using constraints',6,334,344,'During Architectural Risk Analysis (ARA), security architects use a runtime architecture to look for security vulnerabilities that are architectural flaws rather than coding defects. The current ARA process, however, is mostly informal and manual. In this paper, we propose Scoria, a semi-automated approach for finding architectural flaws. Scoria uses a sound, hierarchical object graph with abstract objects and dataflow edges, where edges can refer to nodes in the graph. The architects can augment the object graph with security properties, which can express security information unavailable in code. Scoria allows architects to write queries on the graph in terms of the hierarchy, reachability, and provenance of a dataflow object. Based on the query results, the architects enhance their knowledge of the system security and write expressive constraints. The expressiveness is richer than previous approaches that check only for the presence or absence of communication or do not track a dataflow as an object. To evaluate Scoria, we apply these constraints to several extended examples adapted from the CERT standard for Java to confirm that Scoria can detect injected architectural flaws. Next, we write constraints to enforce an Android security policy and find one architectural flaw in one Android application.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693092','10.1109/ASE.2013.6693092',47,3,'IEEE','IEEE Conferences',0),(970,'SEALANT: A detection and visualization tool for inter-app security vulnerabilities in androic',8,883,888,'Android\'s flexible communication model allows interactions among third-party apps, but it also leads to inter-app security vulnerabilities. Specifically, malicious apps can eavesdrop on interactions between other apps or exploit the functionality of those apps, which can expose a user\'s sensitive information to attackers. While the state-of-the-art tools have focused on detecting inter-app vulnerabilities in Android, they neither accurately analyze realistically large numbers of apps nor effectively deliver the identified issues to users. This paper presents SEALANT, a novel tool that combines static analysis and visualization techniques that, together, enable accurate identification of inter-app vulnerabilities as well as their systematic visualization. SEALANT statically analyzes architectural information of a given set of apps, infers vulnerable communication channels where inter-app attacks can be launched, and visualizes the identified information in a compositional representation. SEALANT has been demonstrated to accurately identify inter-app vulnerabilities from hundreds of real-world Android apps and to effectively deliver the identified information to users. (Demo Video: https://youtu.be/E4lLQonOdUw)','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115699','10.1109/ASE.2017.8115699',25,1,'IEEE','IEEE Conferences',0),(971,'Improving missing issue-commit link recovery using positive and unlabeled data',8,147,152,'Links between issue reports and corresponding fix commits are widely used in software maintenance. The quality of links directly affects maintenance costs. Currently, such links are mainly maintained by error-prone manual efforts, which may result in missing links. To tackle this problem, automatic link recovery approaches have been proposed by building traditional classifiers with positive and negative links. However, these traditional classifiers may not perform well due to the inherent characteristics of missing links. Positive links, which can be used to build link recovery model, are quite limited as the result of missing links. Since the construction of negative links depends on the number of positive links in many existing approaches, the available negative links also become restricted. In this paper, we point out that it is better to consider the missing link problem as a model learning problem by using positive and unlabeled data, rather than the construction of traditional classifier. We propose PULink, an approach that constructs the link recovery model with positive and unlabeled links. Our experiment results show that compared to existing state-of-the-art technologies built on traditional classifier, PULink can achieve competitive performance by utilizing only 70% positive links that are used in those approaches.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115627','10.1109/ASE.2017.8115627',11,1,'IEEE','IEEE Conferences',0),(972,'More effective interpolations in software model checking',8,183,193,'An approach to CEGAR-based model checking which has proved to be successful on large models employs Craig interpolation to efficiently construct parsimonious abstractions. Following this design, we introduce new applications, universal safety interpolant and existential error interpolant, of Craig interpolation that can systematically reduce the program state space to be explored for safety verification. Whenever the universal safety interpolant is implied by the current path, all paths emanating from that location are guaranteed to be safe. Dually whenever the existential error interpolant is implied by the current path, there is guaranteed to be an unsafe path from the location. We show how these interpolants are computed and applied in safety verification. We have implemented our approach in a tool named InterpChecker by building on an open source software model checker. Experiments on a large number of benchmark programs show that both the interpolations and the auxiliary optimization strategies are effective in improving scalability of software model checking.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115631','10.1109/ASE.2017.8115631',39,0,'IEEE','IEEE Conferences',0),(973,'Scaling Size and Parameter Spaces in Variability-Aware Software Performance Models (T)',9,407,417,'In software performance engineering, what-if scenarios, architecture optimization, capacity planning, run-time adaptation, and uncertainty management of realistic models typically require the evaluation of many instances. Effective analysis is however hindered by two orthogonal sources of complexity. The first is the infamous problem of state space explosion -- the analysis of a single model becomes intractable with its size. The second is due to massive parameter spaces to be explored, but such that computations cannot be reused across model instances. In this paper, we efficiently analyze many queuing models with the distinctive feature of more accurately capturing variability and uncertainty of execution rates by incorporating general (i.e., non-exponential) distributions. Applying product-line engineering methods, we consider a family of models generated by a core that evolves into concrete instances by applying simple delta operations affecting both the topology and the model\'s parameters. State explosion is tackled by turning to a scalable approximation based on ordinary differential equations. The entire model space is analyzed in a family-based fashion, i.e., at once using an efficient symbolic solution of a super-model that subsumes every concrete instance. Extensive numerical tests show that this is orders of magnitude faster than a naive instance-by-instance analysis.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372029','10.1109/ASE.2015.16',41,13,'IEEE','IEEE Conferences',0),(974,'CLAMI: Defect Prediction on Unlabeled Datasets (T)',9,452,463,'Defect prediction on new projects or projects with limited historical data is an interesting problem in software engineering. This is largely because it is difficult to collect defect information to label a dataset for training a prediction model. Cross-project defect prediction (CPDP) has tried to address this problem by reusing prediction models built by other projects that have enough historical data. However, CPDP does not always build a strong prediction model because of the different distributions among datasets. Approaches for defect prediction on unlabeled datasets have also tried to address the problem by adopting unsupervised learning but it has one major limitation, the necessity for manual effort. In this study, we propose novel approaches, CLA and CLAMI, that show the potential for defect prediction on unlabeled datasets in an automated manner without need for manual effort. The key idea of the CLA and CLAMI approaches is to label an unlabeled dataset by using the magnitude of metric values. In our empirical study on seven open-source projects, the CLAMI approach led to the promising prediction performances, 0.636 and 0.723 in average f-measure and AUC, that are comparable to those of defect prediction based on supervised learning.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372033','10.1109/ASE.2015.56',63,39,'IEEE','IEEE Conferences',0),(975,'TREM: A tool for mining timed regular specifications from system traces',8,901,906,'Software specifications are useful for software validation, model checking, runtime verification, debugging, monitoring, etc. In context of safety-critical real-time systems, temporal properties play an important role. However, temporal properties are rarely present due to the complexity and evolutionary nature of software systems. We propose Timed Regular Expression Mining (TREM) a hosted tool for specification mining using timed regular expressions (TREs). It is designed for easy and robust mining of dominant temporal properties. TREM uses an abstract structure of the property; the framework constructs a finite state machine to serve as an acceptor. TREM is scalable, easy to access/use, and platform independent specification mining framework. The tool is tested on industrial strength software system traces such as the QNX real-time operating system using traces with more than 1.5 Million entries. The tool demonstration video can be accessed here: youtu.be/cSd_aj3_LH8.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115702','10.1109/ASE.2017.8115702',27,1,'IEEE','IEEE Conferences',0),(976,'Semantics-assisted code review: An efficient tool chain and a user study',8,554,565,'Code changes are often reviewed before they are deployed. Popular source control systems aid code review by presenting textual differences between old and new versions of the code, leaving developers with the difficult task of determining whether the differences actually produced the desired behavior. Fortunately, we can mine such information from code repositories. We propose aiding code review with inter-version semantic differential analysis. During review of a new commit, a developer is presented with summaries of both code differences and behavioral differences, which are expressed as diffs of likely invariants extracted by running the system\'s test cases. As a result, developers can more easily determine that the code changes produced the desired effect. We created an invariant-mining tool chain, Getty, to support our concept of semantically-assisted code review. To validate our approach, 1) we applied Getty to the commits of 6 popular open source projects, 2) we assessed the performance and cost of running Getty in different configurations, and 3) we performed a comparative user study with 18 developers. Our results demonstrate that semantically-assisted code review is feasible, effective, and that real programmers can leverage it to improve the quality of their reviews.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115666','10.1109/ASE.2017.8115666',38,0,'IEEE','IEEE Conferences',0),(977,'Floating-point symbolic execution: A case study in N-version programming',8,601,612,'Symbolic execution is a well-known program analysis technique for testing software, which makes intensive use of constraint solvers. Recent support for floating-point constraint solving has made it feasible to support floating-point reasoning in symbolic execution tools. In this paper, we present the experience of two research teams that independently added floating-point support to KLEE, a popular symbolic execution engine. Since the two teams independently developed their extensions, this created the rare opportunity to conduct a rigorous comparison between the two implementations, essentially a modern case study on N-version programming. As part of our comparison, we report on the different design and implementation decisions taken by each team, and show their impact on a rigorously assembled and tested set of benchmarks, itself a contribution of the paper.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115670','10.1109/ASE.2017.8115670',82,2,'IEEE','IEEE Conferences',0),(978,'Class level fault prediction using software clustering',6,640,645,'Defect prediction approaches use software metrics and fault data to learn which software properties associate with faults in classes. Existing techniques predict fault-prone classes in the same release (intra) or in a subsequent releases (inter) of a subject software system. We propose an intra-release fault prediction technique, which learns from clusters of related classes, rather than from the entire system. Classes are clustered using structural information and fault prediction models are built using the properties of the classes in each cluster. We present an empirical investigation on data from 29 releases of eight open source software systems from the PROMISE repository, with predictors built using multivariate linear regression. The results indicate that the prediction models built on clusters outperform those built on all the classes of the system.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693126','10.1109/ASE.2013.6693126',35,21,'IEEE','IEEE Conferences',0),(979,'Semi-automatic generation of metamodels from model sketches',6,664,669,'Traditionally, metamodeling is an upfront activity performed by experts for defining modeling languages. Modeling tools then typically restrict modelers to using only constructs defined in the metamodel. This is inappropriate when users want to sketch graphical models without any restrictions and only later assign meanings to the sketched elements. Upfront metamodeling also complicates the creation of domain-specific languages, as it requires experts with both domain and metamodeling expertise. In this paper we present a new approach that supports modelers in creating metamodels for diagrams they have sketched or are currently sketching. Metamodels are defined in a semi-automatic, interactive way by annotating diagram elements and automated model analysis. Our approach requires no metamodeling expertise and supports the co-evolution of models and meta-models.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693130','10.1109/ASE.2013.6693130',31,8,'IEEE','IEEE Conferences',0),(980,'SpyREST in Action: An Automated RESTful API Documentation Tool',9,813,818,'RESTful APIs are often manually documented. As a result, the process of maintaining the documentation of RESTful APIs is both expensive and error-prone. In this demonstration paper, we present SpyREST as an automated software as a service tool that can be used to document RESTful APIs. SpyREST leverages an HTTP Proxy server to intercept real API calls to automatically collect and generate RESTful API documentation by processing HTTP traffic involved in API calls. SpyREST provides an automated yet customizable example based documentation solution for RESTful APIs. RESTful API developers can use SpyREST to automatically generate and maintain updated API documentation.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372072','10.1109/ASE.2015.92',16,3,'IEEE','IEEE Conferences',0),(981,'Leveraging program equivalence for adaptive program repair: Models and first results',6,356,366,'Software bugs remain a compelling problem. Automated program repair is a promising approach for reducing cost, and many methods have recently demonstrated positive results. However, success on any particular bug is variable, as is the cost to find a repair. This paper focuses on generate-and-validate repair methods that enumerate candidate repairs and use test cases to define correct behavior. We formalize repair cost in terms of test executions, which dominate most test-based repair algorithms. Insights from this model lead to a novel deterministic repair algorithm that computes a patch quotient space with respect to an approximate semantic equivalence relation. This allows syntactic and dataflow analysis techniques to dramatically reduce the repair search space. Generate-and-validate program repair is shown to be a dual of mutation testing, suggesting several possible cross-fertilizations. Evaluating on 105 real-world bugs in programs totaling 5MLOC and involving 10,000 tests, our new algorithm requires an order-of-magnitude fewer test evaluations than the previous state-of-the-art and is over three times more efficient monetarily.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693094','10.1109/ASE.2013.6693094',55,84,'IEEE','IEEE Conferences',0),(982,'Extracting Visual Contracts from Java Programs (T)',9,104,114,'Visual contracts model the operations of components or services by pre-and post-conditions formalised as graph transformation rules. They provide a precise intuitive notation to support testing, understanding and analysis of software. However, due to their detailed specification of data states and transformations, modelling real applications is an error-prone process. In this paper we propose a dynamic approach to reverse engineering visual contracts from Java based on tracing the execution of Java operations. The resulting contracts give an accurate description of the observed object transformations, their effects and preconditions in terms of object structures, parameter and attribute values, and their generalised specification by universally quantified (multi) objects. While this paper focusses on the fundamental technique rather than a particular application, we explore potential uses in our evaluation, including in program understanding, review of test reports and debugging.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372000','10.1109/ASE.2015.63',31,6,'IEEE','IEEE Conferences',0),(983,'Automatic summarization of API reviews',8,159,170,'With the proliferation of online developer forums as informal documentation, developers often share their opinions about the APIs they use. However, given the plethora of opinions available for an API in various online developer forums, it can be challenging for a developer to make informed decisions about the APIs. While automatic summarization of opinions have been explored for other domains (e.g., cameras, cars), we found little research that investigates the benefits of summaries of public API reviews. In this paper, we present two algorithms (statistical and aspect-based) to summarize opinions about APIs. To investigate the usefulness of the techniques, we developed, Opiner, an online opinion summarization engine that presents summaries of opinions using both our proposed techniques and existing six off-the-shelf techniques. We investigated the usefulness of Opiner using two case studies, both involving professional software engineers. We found that developers were interested to use our proposed summaries much more frequently than other summaries (daily vs once a year) and that while combined with Stack Overflow, Opiner helped developers to make the right decision with more accuracy and confidence and in less time.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115629','10.1109/ASE.2017.8115629',64,6,'IEEE','IEEE Conferences',0),(984,'Model checker execution reports',8,200,205,'Software model checking constitutes an undecidable problem and, as such, even an ideal tool will in some cases fail to give a conclusive answer. In practice, software model checkers fail often and usually do not provide any information on what was effectively checked. The purpose of this work is to provide a conceptual framing to extend software model checkers in a way that allows users to access information about incomplete checks. We characterize the information that model checkers themselves can provide, in terms of analyzed traces, i.e. sequences of statements, and safe canes, and present the notion of execution reports (ERs), which we also formalize. We instantiate these concepts for a family of techniques based on Abstract Reachability Trees and implement the approach using the software model checker CPAchecker. We evaluate our approach empirically and provide examples to illustrate the ERs produced and the information that can be extracted.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115633','10.1109/ASE.2017.8115633',23,0,'IEEE','IEEE Conferences',0),(985,'Combining Deep Learning with Information Retrieval to Localize Buggy Files for Bug Reports (N)',9,476,481,'Bug localization refers to the automated process of locating the potential buggy files for a given bug report. To help developers focus their attention to those files is crucial. Several existing automated approaches for bug localization from a bug report face a key challenge, called lexical mismatch, in which the terms used in bug reports to describe a bug are different from the terms and code tokens used in source files. This paper presents a novel approach that uses deep neural network (DNN) in combination with rVSM, an information retrieval (IR) technique. rVSM collects the feature on the textual similarity between bug reports and source files. DNN is used to learn to relate the terms in bug reports to potentially different code tokens and terms in source files and documentation if they appear frequently enough in the pairs of reports and buggy files. Our empirical evaluation on real-world projects shows that DNN and IR complement well to each other to achieve higher bug localization accuracy than individual models. Importantly, our new model, HyLoc, with a combination of the features built from DNN, rVSM, and project\'s bug-fixing history, achieves higher accuracy than the state-of-the-art IR and machine learning techniques. In half of the cases, it is correct with just a single suggested file. Two out of three cases, a correct buggy file is in the list of three suggested files.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372035','10.1109/ASE.2015.73',10,32,'IEEE','IEEE Conferences',0),(986,'Incrementally slicing editable submodels',8,913,918,'Model slicers are tools which provide two services: (a) finding parts of interest in a model and (b) displaying these parts somehow or extract these parts as a new, autonomous model, which is referred to as slice or sub-model. This paper focuses on the creation of editable slices, which can be processed by model editors, analysis tools, model management tools etc. Slices are useful if, e.g., only a part of a large model shall be analyzed, compared or processed by time-consuming algorithms, or if sub-models shall be modified independently. We present a new generic incremental slicer which can slice models of arbitrary type and which creates slices which are consistent in the sense that they are editable by standard editors. It is built on top of a model differencing framework and does not require additional configuration data beyond those available in the differencing framework. The slicer can incrementally extend or reduce an existing slice if model elements shall be added or removed, even if the slice has been edited meanwhile. We demonstrate the usefulness of our slicer in several scenarios using a large UML model. A screencast of the demonstrated scenarios is provided at http://pi.informatik.uni-siegen.de/projects/SiLift/ase2017.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115704','10.1109/ASE.2017.8115704',21,2,'IEEE','IEEE Conferences',0),(987,'Round-up: Runtime checking quasi linearizability of concurrent data structures',6,4,14,'We propose a new method for runtime checking of a relaxed consistency property called quasi linearizability for concurrent data structures. Quasi linearizability generalizes the standard notion of linearizability by intentionally introducing nondeterminism into the parallel computations and exploiting such nondeterminism to improve the performance. However, ensuring the quantitative aspects of this correctness condition in the low level code is a difficult task. Our method is the first fully automated method for checking quasi linearizability in the unmodified C/C++ code of concurrent data structures. It guarantees that all the reported quasi linearizability violations are real violations. We have implemented our method in a software tool based on LLVM and a concurrency testing tool called Inspect. Our experimental evaluation shows that the new method is effective in detecting quasi linearizability violations in the source code of concurrent data structures.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693061','10.1109/ASE.2013.6693061',43,5,'IEEE','IEEE Conferences',0),(988,'Why and how JavaScript developers use linters',8,578,589,'Automatic static analysis tools help developers to automatically spot code issues in their software. They can be of extreme value in languages with dynamic characteristics, such as JavaScript, where developers can easily introduce mistakes which can go unnoticed for a long time, e.g. a simple syntactic or spelling mistake. Although research has already shown how developers perceive such tools for strongly-typed languages such as Java, little is known about their perceptions when it comes to dynamic languages. In this paper, we investigate what motivates and how developers make use of such tools in JavaScript projects. To that goal, we apply a qualitative research method to conduct and analyze a series of 15 interviews with developers responsible for the linter configuration in reputable OSS JavaScript projects that apply the most commonly used linter, ESLint. The results describe the benefits that developers obtain when using ESLint, the different ways one can configure the tool and prioritize its rules, and the existing challenges in applying linters in the real world. These results have direct implications for developers, tool makers, and researchers, such as tool improvements, and a research agenda that aims to increase our knowledge about the usefulness of such analyzers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115668','10.1109/ASE.2017.8115668',59,5,'IEEE','IEEE Conferences',0),(989,'Leveraging abstract interpretation for efficient dynamic symbolic execution',8,619,624,'Dynamic Symbolic Execution (DSE) is a technique to automatically generate test inputs by executing a program with concrete and symbolic values simultaneously. A key challenge in DSE is scalability; executing all feasible program paths is not possible, owing to the potentially exponential or infinite number of paths. Loops are a main source of path explosion, in particular where the number of iterations depends on a program\'s input. Problems arise because DSE maintains symbolic values that capture only the dependencies on symbolic inputs. This ignores control dependencies, including loop dependencies that depend indirectly on the inputs. We propose a method to increase the coverage achieved by DSE in the presence of input-data dependent loops and loop dependent branches. We combine DSE with abstract interpretation to find indirect control dependencies, including loop and branch indirect dependencies. Preliminary results show that this results in better coverage, within considerably less time compared to standard DSE.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115672','10.1109/ASE.2017.8115672',21,2,'IEEE','IEEE Conferences',0),(990,'Flow Permissions for Android',6,652,657,'This paper proposes Flow Permissions, an extension to the Android permission mechanism. Unlike the existing permission mechanism our permission mechanism contains semantic information based on information flows. Flow Permissions allow users to examine and grant explicit information flows within an application (e.g., a permission for reading the phone number and sending it over the network) as well as implicit information flows across multiple applications (e.g., a permission for reading the phone number and sending it to another application already installed on the user\'s phone). Our goal with Flow Permissions is to provide visibility into the holistic behavior of the applications installed on a user\'s phone. Our evaluation compares our approach to dynamic flow tracking techniques; our results with 600 popular applications and 1,200 malicious applications show that our approach is practical and effective in deriving Flow Permissions statically.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693128','10.1109/ASE.2013.6693128',20,17,'IEEE','IEEE Conferences',0),(991,'Natural language requirements quality analysis based on business domain models',6,676,681,'Quality of requirements written in natural language has always been a critical concern in software engineering. Poorly written requirements lead to ambiguity and false interpretation in different phases of a software delivery project. Further, incomplete requirements lead to partial implementation of the desired system behavior. In this paper, we present a model for harvesting domain (functional or business) knowledge. Subsequently we present natural language processing and ontology based techniques for leveraging the model to analyze requirements quality and for requirements comprehension. The prototype also provides an advisory to business analysts so that the requirements can be aligned to the expected domain standard. The prototype developed is currently being used in practice, and the initial results are very encouraging.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693132','10.1109/ASE.2013.6693132',21,3,'IEEE','IEEE Conferences',0),(992,'Pseudogen: A Tool to Automatically Generate Pseudo-Code from Source Code',9,824,829,'Understanding the behavior of source code written in an unfamiliar programming language is difficult. One way to aid understanding of difficult code is to add corresponding pseudo-code, which describes in detail the workings of the code in a natural language such as English. In spite of its usefulness, most source code does not have corresponding pseudo-code because it is tedious to create. This paper demonstrates a tool Pseudogen that makes it possible to automatically generate pseudo-code from source code using statistical machine translation (SMT). Pseudogen currently supports generation of English or Japanese pseudo-code from Python source code, and the SMT framework makes it easy for users to create new generators for their preferred source code/pseudo-code pairs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372074','10.1109/ASE.2015.107',24,2,'IEEE','IEEE Conferences',0),(993,'Lightweight control-flow instrumentation and postmortem analysis in support of debugging',6,378,388,'Debugging is difficult and costly. As a human programmer looks for a bug, it would be helpful to see a complete trace of events leading to the point of failure. Unfortunately, full tracing is simply too slow to use in deployment, and may even be impractical during testing. We aid post-deployment debugging by giving programmers additional information about program activity shortly before failure. We use latent information in post-failure memory dumps, augmented by low-overhead, tunable run-time tracing. Our results with a realistically-tuned tracing scheme show low enough overhead (0-5%) to be used in production runs. We demonstrate several potential uses of this enhanced information, including a novel postmortem static slice restriction technique and a reduced view of potentially-executed code. Experimental evaluation shows our approach to be very effective, such as shrinking stack-sensitive interprocedural static slices by 49-78% in larger applications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693096','10.1109/ASE.2013.6693096',45,8,'IEEE','IEEE Conferences',0),(994,'Evolutionary Robustness Testing of Data Processing Systems Using Models and Data Mutation (T)',9,126,137,'System level testing of industrial data processing software poses several challenges. Input data can be very large, even in the order of gigabytes, and with complex constraints that define when an input is valid. Generating the right input data to stress the system for robustness properties (e.g. to test how faulty data is handled) is hence very complex, tedious and error prone when done manually. Unfortunately, this is the current practice in industry. In previous work, we defined a methodology to model the structure and the constraints of input data by using UML class diagrams and OCL constraints. Tests were automatically derived to cover predefined fault types in a fault model. In this paper, to obtain more effective system level test cases, we developed a novel search-based test generation tool. Experiments on a real-world, large industrial data processing system show that our automated approach can not only achieve better code coverage, but also accomplishes this using significantly smaller test suites.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372002','10.1109/ASE.2015.13',42,1,'IEEE','IEEE Conferences',0),(995,'BProVe: A formal verification framework for business process models',8,217,228,'Business Process Modelling has acquired increasing relevance in software development. Available notations, such as BPMN, permit to describe activities of complex organisations. On the one hand, this shortens the communication gap between domain experts and IT specialists. On the other hand, this permits to clarify the characteristics of software systems introduced to provide automatic support for such activities. Nevertheless, the lack of formal semantics hinders the automatic verification of relevant properties. This paper presents a novel verification framework for BPMN 2.0, called BProVe. It is based on an operational semantics, implemented using MAUDE, devised to make the verification general and effective. A complete tool chain, based on the Eclipse modelling environment, allows for rigorous modelling and analysis of Business Processes. The approach has been validated using more than one thousand models available on a publicly accessible repository. Besides showing the performance of BProVe, this validation demonstrates its practical benefits in identifying correctness issues in real models.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115635','10.1109/ASE.2017.8115635',58,2,'IEEE','IEEE Conferences',0),(996,'Learning to Rank for Question-Oriented Software Text Retrieval (T)',9,1,11,'Question-oriented text retrieval, aka natural language-based text retrieval, has been widely used in software engineering. Earlier work has concluded that questions with the same keywords but different interrogatives (such as how, what) should result in different answers. But what is the difference? How to identify the right answers to a question? In this paper, we propose to investigate the \'answer style\' of software questions with different interrogatives. Towards this end, we build classifiers in a software text repository and propose a re-ranking approach to refine search results. The classifiers are trained by over 16,000 answers from the StackOverflow forum. Each answer is labeled accurately by its question\'s explicit or implicit interrogatives. We have evaluated the performance of our classifiers and the refinement of our re-ranking approach in software text retrieval. Our approach results in 13.1% and 12.6% respectively improvement with respect to text retrieval criteria nDCG@1 and nDCG@10 compared to the baseline. We also apply our approach to FAQs of 7 open source projects and show 13.2% improvement with respect to nDCG@1. The results of our experiments suggest that our approach could find answers to FAQs more precisely.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7371990','10.1109/ASE.2015.24',40,10,'IEEE','IEEE Conferences',0),(997,'TCA: An Efficient Two-Mode Meta-Heuristic Algorithm for Combinatorial Test Generation (T)',9,494,505,'Covering arrays (CAs) are often used as test suites for combinatorial interaction testing to discover interaction faults of real-world systems. Most real-world systems involve constraints, so improving algorithms for covering array generation (CAG) with constraints is beneficial. Two popular methods for constrained CAG are greedy construction and meta-heuristic search. Recently, a meta-heuristic framework called two-mode local search has shown great success in solving classic NPhard problems. We are interested whether this method is also powerful in solving the constrained CAG problem. This work proposes a two-mode meta-heuristic framework for constrained CAG efficiently and presents a new meta-heuristic algorithm called TCA. Experiments show that TCA significantly outperforms state-of-the-art solvers on 3-way constrained CAG. Further experiments demonstrate that TCA also performs much better than its competitors on 2-way constrained CAG.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372037','10.1109/ASE.2015.61',57,13,'IEEE','IEEE Conferences',0),(998,'Model Checking Task Parallel Programs Using Gradual Permissions (N)',9,535,540,'Habanero is a task parallel programming model that provides correctness guarantees to the programmer. Even so, programs may contain data races that lead to non-determinism, which complicates debugging and verification. This paper presents a sound algorithm based on permission regions to prove data race and deadlock freedom in Habanero programs. Permission regions are user annotations to indicate the use of shared variables over spans of code. The verification algorithm restricts scheduling to permission region boundaries and isolation to reduce verification cost. The effectiveness of the algorithm is shown in benchmarks with an implementation in the Java Pathfinder (JPF) model checker. The implementation uses a verification specific library for Habanero that is tested using JPF for correctness. The results show significant reductions in cost, where cost is controlled with the size of the permission regions, at the risk of rejecting programs that are actually free of any data race or deadlock.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372041','10.1109/ASE.2015.75',14,2,'IEEE','IEEE Conferences',0),(999,'A static analysis tool with optimizations for reachability determination',8,925,930,'To reduce the false positives of static analysis, many tools collect path constraints and integrate SMT solvers to filter unreachable execution paths. However, the accumulated calling and computing of SMT solvers are time and resource consuming. This paper presents TsmartLW, an alternate static analysis tool in which we implement a path constraint solving engine to speed up reachability determination. Within the engine, typical types of constraint-patterns are firstly defined based on an empirical study of a large number of code repositories. For each pattern, a constraint solving algorithm is designed and implemented. For each program, the engine predicts the most suitable strategy and then applies the strategy to solve path constraints. The experimental results on some well-known benchmarks and real-world applications show that TsmartLW is faster than some state-of-the-art static analysis tools. For example, it is 1.32脳 faster than CPAchecker and our engine is 369脳 faster than SMT solvers in solving path constraints. The demo video is available at https://www.youtube.com/watch?v=5c3ARhFclHA&t=2s.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115706','10.1109/ASE.2017.8115706',15,2,'IEEE','IEEE Conferences',0),(1000,'STARTS: STAtic regression test selection',8,949,954,'Regression testing is an important part of software development, but it can be very time consuming. Regression test selection (RTS) aims to speed up regression testing by running only impacted tests-the subset of tests that can change behavior due to code changes. We present STARTS, a tool for STAtic Regression Test Selection. Unlike dynamic RTS, STARTS requires no code instrumentation or runtime information to find impacted tests; instead, STARTS uses only compile-time information. Specifically, STARTS builds a dependency graph of program types and finds, as impacted, tests that can reach some changed type in the transitive closure of the dependency graph. STARTS is a Maven plugin that can be easily integrated into any Maven-based Java project. We find that STARTS selects on average 35.2% of tests, leading to an end-to-end runtime that is on average 81.0% of running all the tests. A video demo of STARTS can be found at https://youtu.be/PCNtk8jphrM.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115710','10.1109/ASE.2017.8115710',22,5,'IEEE','IEEE Conferences',0),(1001,'Proving MCAPI executions are correct using SMT',6,26,36,'Asynchronous message passing is an important paradigm in writing applications for embedded heterogeneous multicore systems. The Multicore Association (MCA), an industry consortium promoting multicore technology, is working to standardize message passing into a single API, MCAPI, for bare metal implementation and portability across platforms. Correctness in such an API is difficult to reason about manually, and testing against reference solutions is equally difficult as reference solutions implement an unknown set of allowed behaviors, and programmers have no way to directly control API internals to expose or reproduce errors. This paper provides a way to encode an MCAPI execution as a Satisfiability Modulo Theories (SMT) problem, which if satisfiable, yields a feasible execution schedule on the same trace, such that it resolves non-determinism in the MCAPI runtime in a way that it now fails user provided assertions. The paper proves the problem is NP-complete. The encoding is useful for test, debug, and verification of MCAPI program execution. The novelty in the encoding is the direct use of match pairs (potential send and receive couplings). Match-pair encoding for MCAPI executions, when compared to other encoding strategies, is simpler to reason about, results in significantly fewer terms in the SMT problem, and captures feasible behaviors that are ignored in previously published techniques. Further, to our knowledge, this is the first SMT encoding that is able to run in infinite-buffer semantics, meaning the runtime has unlimited internal buffering as opposed to no internal buffering. Results demonstrate that the SMT encoding, restricted to zero-buffer semantics, uses fewer clauses when compared to another zero-buffer technique, and it runs faster and uses less memory. As a result the encoding scales well for programs with high levels of non-determinism in how sends and receives may potentially match.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693063','10.1109/ASE.2013.6693063',29,4,'IEEE','IEEE Conferences',0),(1002,'Contract-based program repair without the contracts',8,637,647,'Automated program repair (APR) is a promising approach to automatically fixing software bugs. Most APR techniques use tests to drive the repair process; this makes them readily applicable to realistic code bases, but also brings the risk of generating spurious repairs that overfit the available tests. Some techniques addressed the overfitting problem by targeting code using contracts (such as pre- and postconditions), which provide additional information helpful to characterize the states of correct and faulty computations; unfortunately, mainstream programming languages do not normally include contract annotations, which severely limits the applicability of such contract-based techniques. This paper presents JAID, a novel APR technique for Java programs, which is capable of constructing detailed state abstractions-similar to those employed by contract-based techniques-that are derived from regular Java code without any special annotations. Grounding the repair generation and validation processes on rich state abstractions mitigates the overfitting problem, and helps extend APR\'s applicability: in experiments with the DEFECTS4J benchmark, a prototype implementation of JAID produced genuinely correct repairs, equivalent to those written by programmers, for 25 bugs-improving over the state of the art of comparable Java APR techniques in the number and kinds of correct fixes.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115674','10.1109/ASE.2017.8115674',37,13,'IEEE','IEEE Conferences',0),(1003,'Recovering model transformation traces using multi-objective optimization',6,688,693,'Model Driven Engineering (MDE) is based on a large set of models that are used and manipulated throughout the development cycle. These models are manually or automatically produced and/or exploited using model transformations. To allow engineers to maintain the models and track their changes, recovering transformation traces is essential. In this paper, we propose an automated approach, based on multi-objective optimization, to recover transformation traces between models. Our approach takes as input a source model in the form of a set of fragments (fragments are defined using the source meta-model cardinalities and OCL constraints), and a target model. The recovered transformation traces take the form of many-to-many mappings between the constructs of the two models.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693134','10.1109/ASE.2013.6693134',19,7,'IEEE','IEEE Conferences',0),(1004,'Refactorings for Android Asynchronous Programming',9,836,841,'Running compute-intensive or blocking I/O operationsin the UI event thread of smartphone apps can severelydegrade responsiveness. Despite the fact that Android provides several async constructs that developers can use, developers can still miss opportunities to encapsulate long-running operations in async constructs. On the other hand, they can use the inappropriate async constructs, which result in memory leaks, lost results, and wasted energy. Fortunately, refactoring tools can eliminate these problems by retrofitting asynchrony to sequential code and transforming async code to use the appropriate constructs. This demo presents two refactoring tools for Android apps: (i) ASYNCHRONIZER, a refactoring tool that enables developers to extract long-running operations into Android AsyncTask. (ii) ASYNCDROID, a refactoring tool which enables developers to transform existing improperly-used AsyncTask into Android IntentService.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372076','10.1109/ASE.2015.100',37,3,'IEEE','IEEE Conferences',0),(1005,'Model-Based Testing of Stateful APIs with Modbat',9,858,863,'Modbat makes testing easier by providing a user-friendly modeling language to describe the behavior of systems, from such a model, test cases are generated and executed. Modbat\'s domain-specific language is based on Scala, its features include probabilistic and non-deterministic transitions, component models with inheritance, and exceptions. We demonstrate the versatility of Modbat by finding a confirmed defect in the currently latest version of Java, and by testing SAT solvers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372080','10.1109/ASE.2015.95',31,2,'IEEE','IEEE Conferences',0),(1006,'Dangling references in multi-configuration and dynamic PHP-based Web applications',6,399,409,'PHP is a dynamic language popularly used in Web development for writing server-side code to dynamically create multiple versions of client-side pages at run time for different configurations. A PHP program contains code to be executed or produced for multiple configurations/versions. That dynamism and multi-configuration nature leads to dangling references. Specifically, in the execution for a configuration, a reference to a variable or a call to a function is dangling if its corresponding declaration cannot be found. We conducted an exploratory study to confirm the existence of such dangling reference errors including dangling cross-language and embedded references in the client-side HTML/JavaScript code and in data-accessing SQL code that are embedded in scattered PHP code. Dangling references have caused run-time fatal failures and security vulnerabilities. We developed DRC, a static analysis method to detect such dangling references. DRC uses symbolic execution to collect PHP declarations/references and to approximate all versions of the generated output, and then extracts embedded declarations/references. It associates each detected declaration/reference with a conditional constraint that represents the execution paths (i.e. configurations/versions) containing that declaration/reference. It then validates references against declarations via a novel dangling reference detection algorithm. Our empirical evaluation shows that DRC detects dangling references with high accuracy. It revealed 83 yet undiscovered defects caused by dangling references.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693098','10.1109/ASE.2013.6693098',34,5,'IEEE','IEEE Conferences',0),(1007,'Test Analysis: Searching for Faults in Tests (N)',9,149,154,'Tests are increasingly specified as programs. Expressing tests as code is advantageous in that developers are comfortable writing and running code, and tests can be automated and reused as the software evolves. Tests expressed as code, however, can also contain faults. Some test faults are similar to those found in application code, while others are more subtle, caused by incorrect implementation of testing concepts and processes. These faults may cause a test to fail when it should not, or allow program faults to go undetected. In this work we explore whether lightweight static analyses can be cost-effective in pinpointing patterns associated with faults tests. Our exploration includes a categorization and explanation of test patterns, and their application to 12 open source projects that include over 40K tests. We found that several patterns, detectable through simple and efficient static analyses of just the test code, can detect faults with a low false positive rate, while other patterns would require a more sophisticated and extensive code analysis to be useful.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372004','10.1109/ASE.2015.37',21,1,'IEEE','IEEE Conferences',0),(1008,'PAD: Programming third-party web advertisement censorship',8,240,251,'In the current online advertisement delivery, an ad slot on a publisher\'s website may go through multiple layers of bidding and reselling until the final ad content is delivered. The publishers have little control on the ads being displayed on their web pages. As a result, website visitors may suffer from unwanted ads such as malvertising, intrusive ads, and information disclosure ads. Unfortunately, the visitors often blame the publisher for their unpleasant experience and switch to competitor websites. In this paper, we propose a novel programming support system for ad delivery, called PAD, for publisher programmers, who specify their policies on regulating third-party ads shown on their websites. PAD features an expressive specification language and a novel persistent policy enforcement runtime that can self-install and self-protect throughout the entire ad delegation chain. It also provides an ad-specific memory protection scheme that prevents malvertising by corrupting malicious payloads. Our experiments show that PAD has negligible runtime overhead. It effectively suppresses a set of malvertising cases and unwanted ad behaviors reported in the real world, without affecting normal functionalities and regular ads.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115637','10.1109/ASE.2017.8115637',64,0,'IEEE','IEEE Conferences',0),(1009,'Learning to share: Engineering adaptive decision-support for online social networks',8,280,285,'Some online social networks (OSNs) allow users to define friendship-groups as reusable shortcuts for sharing information with multiple contacts. Posting exclusively to a friendship-group gives some privacy control, while supporting communication with (and within) this group. However, recipients of such posts may want to reuse content for their own social advantage, and can bypass existing controls by copy-pasting into a new post; this cross-posting poses privacy risks. This paper presents a learning to share approach that enables the incorporation of more nuanced privacy controls into OSNs. Specifically, we propose a reusable, adaptive software architecture that uses rigorous runtime analysis to help OSN users to make informed decisions about suitable audiences for their posts. This is achieved by supporting dynamic formation of recipient-groups that benefit social interactions while reducing privacy risks. We exemplify the use of our approach in the context of Facebook.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115641','10.1109/ASE.2017.8115641',42,0,'IEEE','IEEE Conferences',0),(1010,'CodeExchange: Supporting Reformulation of Internet-Scale Code Queries in Context (T)',9,24,35,'Programming today regularly involves searching for source code online, whether through a general search engine such as Google or a specialized code search engine such as SearchCode, Ohloh, or GitHub. Searching typically is an iterative process, with develop-ers adjusting the keywords they use based on the results of the previous query. However, searching in this manner is not ideal, because just using keywords places limits on what developers can express as well as the overall interaction that is required. Based on the observation that the results from one query create a con-text in which a next is formulated, we present CodeExchange, a new code search engine that we developed to explicitly leverage this context to support fluid, expressive reformulation of queries. We motivate the need for CodeExchange, highlight its key design decisions and overall architecture, and evaluate its use in both a field deployment and a laboratory study.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7371992','10.1109/ASE.2015.51',60,10,'IEEE','IEEE Conferences',0),(1011,'TzuYu: Learning stateful typestates',6,432,442,'Behavioral models are useful for various software engineering tasks. They are, however, often missing in practice. Thus, specification mining was proposed to tackle this problem. Existing work either focuses on learning simple behavioral models such as finite-state automata, or relies on techniques (e.g., symbolic execution) to infer finite-state machines equipped with data states, referred to as stateful typestates. The former is often inadequate as finite-state automata lack expressiveness in capturing behaviors of data-rich programs, whereas the latter is often not scalable. In this work, we propose a fully automated approach to learn stateful typestates by extending the classic active learning process to generate transition guards (i.e., propositions on data states). The proposed approach has been implemented in a tool called TzuYu and evaluated against a number of Java classes. The evaluation results show that TzuYu is capable of learning correct stateful typestates more efficiently.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693101','10.1109/ASE.2013.6693101',37,14,'IEEE','IEEE Conferences',0),(1012,'Region and Effect Inference for Safe Parallelism (T)',9,512,523,'In this paper, we present the first full regions-and-effects inference algorithm for explicitly parallel fork-join programs. We infer annotations inspired by Deterministic Parallel Java (DPJ) for a type-safe subset of C++. We chose the DPJ annotations because they give the strongest safety guarantees of any existing concurrency-checking approach we know of, static or dynamic, and it is also the most expressive static checking system we know of that gives strong safety guarantees. This expressiveness, however, makes manual annotation difficult and tedious, which motivates the need for automatic inference, but it also makes the inference problem very challenging: the code may use region polymorphism, imperative updates with complex aliasing, arbitrary recursion, hierarchical region specifications, and wildcard elements to describe potentially infinite sets of regions. We express the inference as a constraint satisfaction problem and develop, implement, and evaluate an algorithm for solving it. The region and effect annotations inferred by the algorithm constitute a checkable proof of safe parallelism, and it can be recorded both for documentation and for fast and modular safety checking.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372039','10.1109/ASE.2015.59',49,1,'IEEE','IEEE Conferences',0),(1013,'Static Analysis of JavaScript Web Applications in the Wild via Practical DOM Modeling (T)',9,552,562,'We present SAFEWapp, an open-source static analysis framework for JavaScript web applications. It provides a faithful (partial) model of web application execution environments of various browsers, based on empirical data from the main web pages of the 9,465 most popular websites. A main feature of SAFEWapp is the configurability of DOM tree abstraction levels to allow users to adjust a trade-off between analysis performance and precision depending on their applications. We evaluate SAFEWapp on the 5 most popular JavaScript libraries and the main web pages of the 10 most popular websites in terms of analysis performance, precision, and modeling coverage. Additionally, as an application of SAFEWapp, we build a bug detector for JavaScript web applications that uses static analysis results from SAFEWapp. Our bug detector found previously undiscovered bugs including ones from wikipedia.org and amazon.com.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372043','10.1109/ASE.2015.27',29,14,'IEEE','IEEE Conferences',0),(1014,'BProVe: Tool support for business process verification',8,937,942,'This demo introduces BProVe, a tool supporting automated verification of Business Process models. BProVe analysis is based on a formal operational semantics defined for the BPMN 2.0 modelling language, and is provided as a freely accessible service that uses open standard formats as input data. Furthermore a plug-in for the Eclipse platform has been developed making available a tool chain supporting users in modelling and visualising, in a friendly manner, the results of the verification. Finally we have conducted a validation through more than one thousand models, showing the effectiveness of our verification tool in practice. (Demo video: https://youtu.be/iF5OM7vKtDA).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115708','10.1109/ASE.2017.8115708',26,1,'IEEE','IEEE Conferences',0),(1015,'ANDROFLEET: Testing WiFi peer-to-peer mobile apps in the large',8,961,966,'WiFi P2P allows mobile apps to connect to each other via WiFi without an intermediate access point. This communication mode is widely used by mobile apps to support interactions with one or more devices simultaneously. However, testing such P2P apps remains a challenge for app developers as i) existing testing frameworks lack support for WiFi P2P, and ii) WiFi P2P testing fails to scale when considering a deployment on more than two devices. In this paper, we therefore propose an acceptance testing framework, named Androfleet, to automate testing of WiFi P2P mobile apps at scale. Beyond the capability of testing point-to-point interactions under various conditions, An-drofleet supports the deployment and the emulation of a fleet of mobile devices as part of an alpha testing phase in order to assess the robustness of a WiFi P2P app once deployed in the field. To validate Androfleet, we demonstrate the detection of failing black-box acceptance tests for WiFi P2P apps and we capture the conditions under which such a mobile app can correctly work in the field. The demo video of Androfleet is made available from https://youtu.be/gJ5_Ed7XL04.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115712','10.1109/ASE.2017.8115712',38,2,'IEEE','IEEE Conferences',0),(1016,'PIEtrace: Platform independent executable trace',6,48,58,'To improve software dependability, a large number of software engineering tools have been developed over years. Many of them are difficult to apply in practice because their system and library requirements are incompatible with those of the subject software. We propose a technique called platform independent executable trace. Our technique traces and virtualizes a regular program execution that is platform dependent, and generates a stand-alone program called the trace program. Running the trace program re-generates the original execution. More importantly, trace program execution is completely independent of the underlying operating system and libraries such that it can be compiled and executed on arbitrary platforms. As such, it can be analyzed by a third party tool on a platform preferred by the tool. We have implemented the technique on x86 and sensor platforms. We show that buggy executions of 10 real-world Windows and sensor applications can be traced and virtualized, and later analyzed by existing Linux tools. We also demonstrate how the technique can be used in cross-platform malware analysis.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693065','10.1109/ASE.2013.6693065',47,2,'IEEE','IEEE Conferences',0),(1017,'Leveraging syntax-related code for automated program repair',8,660,670,'We present our automated program repair technique ssFix which leverages existing code (from a code database) that is syntax-related to the context of a bug to produce patches for its repair. Given a faulty program and a fault-exposing test suite, ssFix does fault localization to identify suspicious statements that are likely to be faulty. For each such statement, ssFix identifies a code chunk (or target chunk) including the statement and its local context. ssFix works on the target chunk to produce patches. To do so, it first performs syntactic code search to find candidate code chunks that are syntax-related, i.e., structurally similar and conceptually related, to the target chunk from a code database (or codebase) consisting of the local faulty program and an external code repository. ssFix assumes the correct fix to be contained in the candidate chunks, and it leverages each candidate chunk to produce patches for the target chunk. To do so, ssFix translates the candidate chunk by unifying the names used in the candidate chunk with those in the target chunk; matches the chunk components (expressions and statements) between the translated candidate chunk and the target chunk; and produces patches for the target chunk based on the syntactic differences that exist between the matched components and in the unmatched components. ssFix finally validates the patched programs generated against the test suite and reports the first one that passes the test suite. We evaluated ssFix on 357 bugs in the Defects4J bug dataset. Our results show that ssFix successfully repaired 20 bugs with valid patches generated and that it outperformed five other repair techniques for Java.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115676','10.1109/ASE.2017.8115676',54,14,'IEEE','IEEE Conferences',0),(1018,'Predicting relevance of change recommendations',8,694,705,'Software change recommendation seeks to suggest artifacts (e.g., files or methods) that are related to changes made by a developer, and thus identifies possible omissions or next steps. While one obvious challenge for recommender systems is to produce accurate recommendations, a complimentary challenge is to rank recommendations based on their relevance. In this paper, we address this challenge for recommendation systems that are based on evolutionary coupling. Such systems use targeted association-rule mining to identify relevant patterns in a software system\'s change history. Traditionally, this process involves ranking artifacts using interestingness measures such as confidence and support. However, these measures often fall short when used to assess recommendation relevance. We propose the use of random forest classification models to assess recommendation relevance. This approach improves on past use of various interestingness measures by learning from previous change recommendations. We empirically evaluate our approach on fourteen open source systems and two systems from our industry partners. Furthermore, we consider complimenting two mining algorithms: Co-Change and Tarmaq. The results find that random forest classification significantly outperforms previous approaches, receives lower Brier scores, and has superior trade-off between precision and recall. The results are consistent across software system and mining algorithm.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115680','10.1109/ASE.2017.8115680',44,2,'IEEE','IEEE Conferences',0),(1019,'Smart Cloud Broker: Finding your home in the clouds',6,698,701,'As the rate of cloud computing adoption grows, so does the need for consumption assistance. Enterprises looking to migrate their IT systems to the cloud require assistance in identifying providers that offer resources with the most appropriate pricing and performance levels to match their specific business needs. In this paper, we present Smart Cloud Broker - a suite of software tools that allows cloud infrastructure consumers to evaluate and compare the performance of different Infrastructure as a Service (IaaS) offerings from competing cloud service providers, and consequently supports selection of the cloud configuration and provider with the specifications that best meet the user\'s requirements. Using Smart Cloud Broker, prospective cloud users can estimate the performance of the different cloud platforms by running live tests against representative benchmark applications under representative load conditions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693136','10.1109/ASE.2013.6693136',14,5,'IEEE','IEEE Conferences',0),(1020,'Automated testing of cloud-based elastic systems with AUToCLES',6,714,717,'Cloud-based elastic computing systems dynamically change their resources allocation to provide consistent quality of service and minimal usage of resources in the face of workload fluctuations. As elastic systems are increasingly adopted to implement business critical functions in a cost-efficient way, their reliability is becoming a key concern for developers. Without proper testing, cloud-based systems might fail to provide the required functionalities with the expected service level and costs. Using system testing techniques, developers can expose problems that escaped the previous quality assurance activities and have a last chance to fix bugs before releasing the system in production. System testing of cloud-based systems accounts for a series of complex and time demanding activities, from the deployment and configuration of the elastic system, to the execution of synthetic clients, and the collection and persistence of execution data. Furthermore, clouds enable parallel executions of the same elastic system that can reduce the overall test execution time. However, manually managing the concurrent testing of multiple system instances might quickly overwhelm developers\' capabilities, and automatic support for test generation, system test execution, and management of execution data is needed. In this demo we showcase AUToCLES, our tool for automatic testing of cloud-based elastic systems. Given specifications of the test suite and the system under test, AUToCLES implements testing as a service (TaaS): It automatically instantiates the SUT, configures the testing scaffoldings, and automatically executes test suites. If required, AUToCLES can generate new test inputs. Designers can inspect executions both during and after the tests.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693140','10.1109/ASE.2013.6693140',18,10,'IEEE','IEEE Conferences',0),(1021,'Investigating Program Behavior Using the Texada LTL Specifications Miner',9,870,875,'Temporal specifications, relating program events through time, are useful for tasks ranging from bug detection to program comprehension. Unfortunately, such specifications are often lacking from system descriptions, leading researchers to investigate methods for inferring these specifications from code, execution traces, code comments, and other artifacts. This paper describes Texada, a tool to dynamically mine temporal specifications in LTL from traces of program activity. We review Texada\'s key features and demonstrate how it can be used to investigate program behavior through two scenarios: validating an implementation that solves the dining philosophers problem and supporting comprehension of a stack implementation. We also detail Texada\'s other, more advanced, usage options. Texada is an open source tool: https://bitbucket.org/bestchai/texada.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372082','10.1109/ASE.2015.94',19,1,'IEEE','IEEE Conferences',0),(1022,'Fast and Precise Symbolic Analysis of Concurrency Bugs in Device Drivers (T)',9,166,177,'Concurrency errors, such as data races, make device drivers notoriously hard to develop and debug without automated tool support. We present Whoop, a new automated approach that statically analyzes drivers for data races. Whoop is empowered by symbolic pairwise lockset analysis, a novel analysis that can soundly detect all potential races in a driver. Our analysis avoids reasoning about thread interleavings and thus scales well. Exploiting the race-freedom guarantees provided by Whoop, we achieve a sound partial-order reduction that significantly accelerates Corral, an industrial-strength bug-finder for concurrent programs. Using the combination of Whoop and Corral, we analyzed 16 drivers from the Linux 4.0 kernel, achieving 1.5 -- 20脳 speedups over standalone Corral.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372006','10.1109/ASE.2015.30',57,9,'IEEE','IEEE Conferences',0),(1023,'GRT: Program-Analysis-Guided Random Testing (T)',9,212,223,'We propose Guided Random Testing (GRT), which uses static and dynamic analysis to include information on program types, data, and dependencies in various stages of automated test generation. Static analysis extracts knowledge from the system under test. Test coverage is further improved through state fuzzing and continuous coverage analysis. We evaluated GRT on 32 real-world projects and found that GRT outperforms major peer techniques in terms of code coverage (by 13 %) and mutation score (by 9 %). On the four studied benchmarks of Defects4J, which contain 224 real faults, GRT also shows better fault detection capability than peer techniques, finding 147 faults (66 %). Furthermore, in an in-depth evaluation on the latest versions of ten popular real-world projects, GRT successfully detects over 20 unknown defects that were confirmed by developers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372010','10.1109/ASE.2015.49',66,19,'IEEE','IEEE Conferences',0),(1024,'Detecting information flow by mutating input data',8,263,273,'Analyzing information flow is central in assessing the security of applications. However, static and dynamic analyses of information flow are easily challenged by non-available or obscure code. We present a lightweight mutation-based analysis that systematically mutates dynamic values returned by sensitive sources to assess whether the mutation changes the values passed to sensitive sinks. If so, we found a flow between source and sink. In contrast to existing techniques, mutation-based flow analysis does not attempt to identify the specific path of the flow and is thus resilient to obfuscation. In its evaluation, our MUTAFLOW prototype for Android programs showed that mutation-based flow analysis is a lightweight yet effective complement to existing tools. Compared to the popular FlowDroid static analysis tool, MutaFlow requires less than 10% of source code lines but has similar accuracy; on 20 tested real-world apps, it is able to detect 75 flows that FlowDroid misses.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115639','10.1109/ASE.2017.8115639',24,2,'IEEE','IEEE Conferences',0),(1025,'SimplyDroid: Efficient event sequence simplification for android application',8,297,307,'To ensure the quality of Android applications, many automatic test case generation techniques have been proposed. Among them, the Monkey fuzz testing tool and its variants are simple, effective and widely applicable. However, one major drawback of those Monkey tools is that they often generate many events in a failure-inducing input trace, which makes the follow-up debugging activities hard to apply. It is desirable to simplify or reduce the input event sequence while triggering the same failure. In this paper, we propose an efficient event trace representation and the SimplyDroid tool with three hierarchical delta-debugging algorithms each operating on this trace representation to simplify crash traces. We have evaluated SimplyDroid on a suite of real-life Android applications with 92 crash traces. The empirical result shows that our new algorithms in SimplyDroid are both efficient and effective in reducing these event traces.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115643','10.1109/ASE.2017.8115643',41,2,'IEEE','IEEE Conferences',0),(1026,'Efficient Data Model Verification with Many-Sorted Logic (T)',9,42,52,'Misuse or loss of web application data can have catastrophic consequences in today\'s Internet oriented world. Hence, verification of web application data models is of paramount importance. We have developed a framework for verification of web application data models via translation to First Order Logic (FOL), followed by automated theorem proving. Due to the undecidability of FOL, this automated approach does not always produce a conclusive answer. In this paper, we investigate the use of many-sorted logic in data model verification in order to improve the effectiveness of this approach. Many-sorted logic allows us to specify type information explicitly, thus lightening the burden of reasoning about type information during theorem proving. Our experiments demonstrate that using many-sorted logic improves the verification performance significantly, and completely eliminates inconclusive results in all cases over 7 real world web applications, down from an 17% inconclusive rate.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7371994','10.1109/ASE.2015.48',41,4,'IEEE','IEEE Conferences',0),(1027,'Measuring the structural complexity of feature models',6,454,464,'The automated analysis of feature models (FM) is based on SAT, BDD, and CSP - known NP-complete problems. Therefore, the analysis could have an exponential worst-case execution time. However, for many practical relevant analysis cases, state-of-the-art (SOTA) analysis tools quite successfully master the problem of exponential worst-case execution time based on heuristics. So far, however, very little is known about the structure of FMs that cause the cases in which the execution time (hardness) for analyzing a given FM increases unpredictably for SOTA analysis tools. In this paper, we propose to use width measures from graph theory to characterize the structural complexity of FMs as a basis for an estimation of the hardness of analysis operations on FMs with SOTA analysis tools. We present an experiment that we use to analyze the reasonability of graph width measures as metric for the structural complexity of FMs and the hardness of FM analysis. Such a complexity metric can be used as a basis for a unified method to systematically improve SOTA analysis tools.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693103','10.1109/ASE.2013.6693103',37,10,'IEEE','IEEE Conferences',0),(1028,'Learning to Generate Pseudo-Code from Source Code Using Statistical Machine Translation (T)',9,574,584,'Pseudo-code written in natural language can aid the comprehension of source code in unfamiliar programming languages. However, the great majority of source code has no corresponding pseudo-code, because pseudo-code is redundant and laborious to create. If pseudo-code could be generated automatically and instantly from given source code, we could allow for on-demand production of pseudo-code without human effort. In this paper, we propose a method to automatically generate pseudo-code from source code, specifically adopting the statistical machine translation (SMT) framework. SMT, which was originally designed to translate between two natural languages, allows us to automatically learn the relationship between source code/pseudo-code pairs, making it possible to create a pseudo-code generator with less human effort. In experiments, we generated English or Japanese pseudo-code from Python statements using SMT, and find that the generated pseudo-code is largely accurate, and aids code understanding.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372045','10.1109/ASE.2015.36',36,31,'IEEE','IEEE Conferences',0),(1029,'TiQi: A natural language interface for querying software project data',8,973,977,'Software projects produce large quantities of data such as feature requests, requirements, design artifacts, source code, tests, safety cases, release plans, and bug reports. If leveraged effectively, this data can be used to provide project intelligence that supports diverse software engineering activities such as release planning, impact analysis, and software analytics. However, project stakeholders often lack skills to formulate complex queries needed to retrieve, manipulate, and display the data in meaningful ways. To address these challenges we introduce TiQi, a natural language interface, which allows users to express software-related queries verbally or written in natural language. TiQi is a web-based tool. It visualizes available project data as a prompt to the user, accepts Natural Language (NL) queries, transforms those queries into SQL, and then executes the queries against a centralized or distributed database. Raw data is stored either directly in the database or retrieved dynamically at runtime from case tools and repositories such as Github and Jira. The transformed query is visualized back to the user as SQL and augmented UML, and raw data results are returned. Our tool demo can be found on YouTube at the following link:http://tinyurl.com/TIQIDemo.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115714','10.1109/ASE.2017.8115714',20,1,'IEEE','IEEE Conferences',0),(1030,'Efficient parametric runtime verification with deterministic string rewriting',6,70,80,'Early efforts in runtime verification show that parametric regular and temporal logic specifications can be monitored efficiently. These approaches, however, have limited expressiveness: their specifications always reduce to monitors with finite state. More recent developments showed that parametric context-free properties can be efficiently monitored with overheads generally lower than 12-15%. While context-free grammars are more expressive than finite-state languages, they still do not allow every computable safety property. This paper presents a monitor synthesis algorithm for string rewriting systems (SRS). SRSs are well known to be Turing complete, allowing for the formal specification of any computable safety property. Earlier attempts at Turing complete monitoring have been relatively inefficient. This paper demonstrates that monitoring parametric SRSs is practical. The presented algorithm uses a modified version of Aho-Corasick string searching for quick pattern matching with an incremental rewriting approach that avoids reexamining parts of the string known to contain no redexes.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693067','10.1109/ASE.2013.6693067',30,6,'IEEE','IEEE Conferences',0),(1031,'Testing properties of dataflow program operators',6,103,113,'Dataflow programming languages, which represent programs as graphs of data streams and operators, are becoming increasingly popular and being used to create a wide array of commercial software applications. The dependability of programs written in these languages, as well as the systems used to compile and run these programs, hinges on the correctness of the semantic properties associated with operators. Unfortunately, these properties are often poorly defined, and frequently are not checked, and this can lead to a wide range of problems in the programs that use the operators. In this paper we present an approach for improving the dependability of dataflow programs by checking operators for necessary properties. Our approach is dynamic, and involves generating tests whose results are checked to determine whether specific properties hold or not. We present empirical data that shows that our approach is both effective and efficient at assessing the status of properties.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693071','10.1109/ASE.2013.6693071',26,7,'IEEE','IEEE Conferences',0),(1032,'A language model for statements of software code',8,682,687,'Building language models for source code enables a large set of improvements on traditional software engineering tasks. One promising application is automatic code completion. State-of-the-art techniques capture code regularities at token level with lexical information. Such language models are more suitable for predicting short token sequences, but become less effective with respect to long statement level predictions. In this paper, we have proposed PCC to optimize the token-level based language modeling. Specifically, PCC introduced an intermediate representation (IR) for source code, which puts tokens into groups using lexeme and variable relative order. In this way, PCC is able to handle long token sequences, i.e., group sequences, to suggest a complete statement with the precise synthesizer. Further more, PCC employed a fuzzy matching technique which combined genetic and longest common subsequence algorithms to make the prediction more accurate. We have implemented a code completion plugin for Eclipse and evaluated it on open-source Java projects. The results have demonstrated the potential of PCC in generating precise long statement level predictions. In 30%-60% of the cases, it can correctly suggest the complete statement with only six candidates, and 40%-90% of the cases with ten candidates.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115678','10.1109/ASE.2017.8115678',15,2,'IEEE','IEEE Conferences',0),(1033,'Recommending crowdsourced software developers in consideration of skill improvement',8,717,722,'Finding suitable developers for a given task is critical and challenging for successful crowdsourcing software development. In practice, the development skills will be improved as developers accomplish more development tasks. Prior studies on crowdsourcing developer recommendation do not consider the changing of skills, which can underestimate developers\' skills to fulfill a task. In this work, we first conducted an empirical study of the performance of 74 developers on Topcoder. With a difficulty-weighted algorithm, we re-compute the scores of each developer by eliminating the effect of task difficulty from the performance. We find out that the skill improvement of Topcoder developers can be fitted well with the negative exponential learning curve model. Second, we design a skill prediction method based on the learning curve. Then we propose a skill improvement aware framework for recommending developers for software development with crowdsourcing.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115682','10.1109/ASE.2017.8115682',13,3,'IEEE','IEEE Conferences',0),(1034,'CCmutator: A mutation generator for concurrency constructs in multithreaded C/C++ applications',6,722,725,'We introduce CCmutator, a mutation generation tool for multithreaded C/C++ programs written using POSIX threads and the recently standardized C++11 concurrency constructs. CCmutator is capable of performing partial mutations and generating higher order mutants, which allow for more focused and complex combinations of elementary mutation operators leading to higher quality mutants. We have implemented CCmutator based on the popular Clang/LLVM compiler framework, which allows CCmutator to be extremely scalable and robust in handling real-world C/C++ applications. CCmutator is also designed in such a way that all mutants of the same order can be generated in parallel, which allows the tool to be easily parallelized on commodity multicore hardware to improve performance.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693142','10.1109/ASE.2013.6693142',21,13,'IEEE','IEEE Conferences',0),(1035,'Generating Fixtures for JavaScript Unit Testing (T)',9,190,200,'In today\'s web applications, JavaScript code interacts with the Document Object Model (DOM) at runtime. This runtime interaction between JavaScript and the DOM is error-prone and challenging to test. In order to unit test a JavaScript function that has read/write DOM operations, a DOM instance has to be provided as a test fixture. This DOM fixture needs to be in the exact structure expected by the function under test. Otherwise, the test case can terminate prematurely due to a null exception. Generating these fixtures is challenging due to the dynamic nature of JavaScript and the hierarchical structure of the DOM. We present an automated technique, based on dynamic symbolic execution, which generates test fixtures for unit testing JavaScript functions. Our approach is implemented in a tool called ConFix. Our empirical evaluation shows that ConFix can effectively generate tests that cover DOM-dependent paths. We also find that ConFix yields considerably higher coverage compared to an existing JavaScript input generation technique.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372008','10.1109/ASE.2015.26',41,7,'IEEE','IEEE Conferences',0),(1036,'Tracking the Software Quality of Android Applications Along Their Evolution (T)',9,236,247,'Mobile apps are becoming complex software systems that must be developed quickly and evolve continuously to fit new user requirements and execution contexts. However, addressing these requirements may result in poor design choices, also known as antipatterns, which may incidentally degrade software quality and performance. Thus, the automatic detection and tracking of antipatterns in this apps are important activities in order to ease both maintenance and evolution. Moreover, they guide developers to refactor their applications and thus, to improve their quality. While antipatterns are well-known in object-oriented applications, their study in mobile applications is still in its infancy. In this paper, we analyze the evolution of mobile apps quality on 3, 568 versions of 106 popular Android applications downloaded from the Google Play Store. For this purpose, we use a tooled approach, called PAPRIKA, to identify 3 object-oriented and 4 Android-specific antipatterns from binaries of mobile apps, and to analyze their quality along evolutions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372012','10.1109/ASE.2015.46',56,29,'IEEE','IEEE Conferences',0),(1037,'In-memory fuzzing for binary code similarity analysis',8,319,330,'Detecting similar functions in binary executables serves as a foundation for many binary code analysis and reuse tasks. By far, recognizing similar components in binary code remains a challenge. Existing research employs either static or dynamic approaches to capture program syntax or semantics-level features for comparison. However, there exist multiple design limitations in previous work, which result in relatively high cost, low accuracy and scalability, and thus severely impede their practical use. In this paper, we present a novel method that leverages in-memory fuzzing for binary code similarity analysis. Our prototype tool IMF-SIM applies in-memory fuzzing to launch analysis towards every function and collect traces of different kinds of program behaviors. The similarity score of two behavior traces is computed according to their longest common subsequence. To compare two functions, a feature vector is generated, whose elements are the similarity scores of the behavior trace-level comparisons. We train a machine learning model through labeled feature vectors; later, for a given feature vector by comparing two functions, the trained model gives a final score, representing the similarity score of the two functions. We evaluate IMF-SIM against binaries compiled by different compilers, optimizations, and commonly-used obfuscation methods, in total over one thousand binary executables. Our evaluation shows that IMF-SIM notably outperforms existing tools with higher accuracy and broader application scopes.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115645','10.1109/ASE.2017.8115645',65,4,'IEEE','IEEE Conferences',0),(1038,'Interpolation Guided Compositional Verification (T)',9,65,74,'Model checking suffers from the state space explosion problem. Compositional verification techniques such as assume-guarantee reasoning (AGR) have been proposed to alleviate the problem. However, there are at least three challenges in applying AGR. Firstly, given a system M1 ? M2, how do we automatically construct and refine (in the presence of spurious counterexamples) an assumption A2, which must be an abstraction of M2? Previous approaches suggest to incrementally learn and modify the assumption through multiple invocations of a model checker, which could be often time consuming. Secondly, how do we keep the state space small when checking M1 ? A2 = f if multiple refinements of A2 are necessary? Lastly, in the presence of multiple parallel components, how do we partition the components? In this work, we propose interpolation-guided compositional verification. The idea is to tackle three challenges by using interpolations to generate and refine the abstraction of M2, to abstract M1 at the same time (so that the state space is reduced even if A2 is refined all the way to M2), and to find good partitions. Experimental results show that the proposed approach outperforms existing approaches consistently.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7371996','10.1109/ASE.2015.33',39,3,'IEEE','IEEE Conferences',0),(1039,'Software analytics for incident management of online services: An experience report',6,475,485,'As online services become more and more popular, incident management has become a critical task that aims to minimize the service downtime and to ensure high quality of the provided services. In practice, incident management is conducted through analyzing a huge amount of monitoring data collected at runtime of a service. Such data-driven incident management faces several significant challenges such as the large data scale, complex problem space, and incomplete knowledge. To address these challenges, we carried out two-year software-analytics research where we designed a set of novel data-driven techniques and developed an industrial system called the Service Analysis Studio (SAS) targeting real scenarios in a large-scale online service of Microsoft. SAS has been deployed to worldwide product datacenters and widely used by on-call engineers for incident management. This paper shares our experience about using software analytics to solve engineers\' pain points in incident management, the developed data-analysis techniques, and the lessons learned from the process of research development and technology transfer.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693105','10.1109/ASE.2013.6693105',27,18,'IEEE','IEEE Conferences',0),(1040,'Experiences from Designing and Validating a Software Modernization Transformation (E)',9,597,607,'Software modernization often involves complex code transformations that convert legacy code to new architectures or platforms, while preserving the semantics of the original programs. We present the lessons learnt from an industrial software modernization project of considerable size. This includes collecting requirements for a code-to-model transformation, designing and implementing the transformation algorithm, and then validating correctness of this transformation for the code-base at hand. Our transformation is implemented in the TXL rewriting language and assumes specifically structured C++ code as input, which it translates to a declarative configuration model. The correctness criterion for the transformation is that the produced model admits the same configurations as the input code. The transformation converts C++ functions specifying around a thousand configuration parameters. We verify the correctness for each run individually, using translation validation and symbolic execution. The technique is formally specified and is applicable automatically for most of the code-base.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372047','10.1109/ASE.2015.84',30,7,'IEEE','IEEE Conferences',0),(1041,'Detecting Broken Pointcuts Using Structural Commonality and Degree of Interest (N)',9,641,646,'Pointcut fragility is a well-documented problem in Aspect-Oriented Programming, changes to the base-code can lead to join points incorrectly falling in or out of the scope of pointcuts. Deciding which pointcuts have broken due to base-code changes is a daunting venture, especially in large and complex systems. We present an automated approach that recommends pointcuts that are likely to require modification due to a particular base-code change, as well as ones that do not. Our hypothesis is that join points selected by a pointcut exhibit common structural characteristics. Patterns describing such commonality are used to recommend pointcuts that have potentially broken to the developer. The approach is implemented as an extension to the popular Mylyn Eclipse IDE plug-in, which maintains focused contexts of entities relevant to the task at hand using a Degree of Interest (DOI) model.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372051','10.1109/ASE.2015.80',25,1,'IEEE','IEEE Conferences',0),(1042,'Defaultification refactoring: A tool for automatically converting Java methods to default',8,984,989,'Enabling interfaces to declare (instance) method implementations, Java 8 default methods can be used as a substitute for the ubiquitous skeletal implementation software design pattern. Performing this transformation on legacy software manually, though, may be non-trivial. The refactoring requires analyzing complex type hierarchies, resolving multiple implementation inheritance issues, reconciling differences between class and interface methods, and analyzing tie-breakers (dispatch precedence) with overriding class methods. All of this is necessary to preserve type-correctness and confirm semantics preservation. We demonstrate an automated refactoring tool called MIGRATE Skeletal Implementation to Interface for transforming legacy Java code to use the new default construct. The tool, implemented as an Eclipse plug-in, is driven by an efficient, fully-automated, type constraint-based refactoring approach. It features an extensive rule set covering various corner-cases where default methods cannot be used. The resulting code is semantically equivalent to the original, more succinct, easier to comprehend, less complex, and exhibits increased modularity. A demonstration can be found at http://youtu.be/YZHIy0yePh8.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115716','10.1109/ASE.2017.8115716',19,3,'IEEE','IEEE Conferences',0),(1043,'Identifying execution points for dynamic analyses',6,81,91,'Dynamic analyses rely on the ability to identify points within or across executions. In spite of this being a core task for dynamic analyses, new solutions are frequently developed without an awareness of existing solutions, their strengths, their weaknesses, or their caveats. This paper surveys the existing approaches for identifying execution points and examines their analytical and empirical properties that researchers and developers should be aware of when using them within an analysis. In addition, based on limitations in precision, correctness, and efficiency for techniques that identify corresponding execution points across multiple executions, we designed and implemented a new technique, Precise Execution Point IDs. This technique avoids correctness and precision issues in prior solutions, enabling analyses that use our approach to also produce more correct results. Empirical comparison with the surveyed techniques shows that our approach has 25% overhead on average, several times less than existing solutions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693069','10.1109/ASE.2013.6693069',39,3,'IEEE','IEEE Conferences',0),(1044,'SABRINE: State-based robustness testing of operating systems',6,125,135,'The assessment of operating systems robustness with respect to unexpected or anomalous events is a fundamental requirement for mission-critical systems. Robustness can be tested by deliberately exposing the system to erroneous events during its execution, and then analyzing the OS behavior to evaluate its ability to gracefully handle these events. Since OSs are complex and stateful systems, robustness testing needs to account for the timing of erroneous events, in order to evaluate the robust behavior of the OS under different states. This paper presents SABRINE (StAte-Based Robustness testIng of operatiNg systEms), an approach for state-aware robustness testing of OSs. SABRINE automatically extracts state models from execution traces, and generates a set of test cases that cover different OS states. We evaluate the approach on a Linux-based Real-Time Operating System adopted in the avionic domain. Experimental results show that SABRINE can automatically identify relevant OS states, and find robustness vulnerabilities while keeping low the number of test cases.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693073','10.1109/ASE.2013.6693073',47,11,'IEEE','IEEE Conferences',0),(1045,'UNDEAD: Detecting and preventing deadlocks in production software',8,729,740,'Deadlocks are critical problems afflicting parallel applications, causing software to hang with no further progress. Existing detection tools suffer not only from significant recording performance overhead, but also from excessive memory and/or storage overhead. In addition, they may generate numerous false alarms. Subsequently, after problems have been reported, tremendous manual effort is required to confirm and fix these deadlocks. This paper designs a novel system, UnDead, that helps defeat deadlocks in production software. Different from existing detection tools, UnDead imposes negligible runtime performance overhead (less than 3 % on average) and small memory overhead (around 6%), without any storage consumption. After detection, UnDead automatically strengthens erroneous programs to prevent future occurrences of both existing and potential deadlocks, which is similar to the existing work-Dimmunix. However, UnDead exceeds Dimmunix with several orders of magnitude lower performance overhead, while eliminating numerous false positives. Extremely low runtime and memory overhead, convenience, and automatic prevention make UnDead an always-on detection tool, and a \'band-aid\' prevention system for production software.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115684','10.1109/ASE.2017.8115684',42,4,'IEEE','IEEE Conferences',0),(1046,'Pex4Fun: A web-based environment for educational gaming via automated test generation',6,730,733,'Pex4Fun (http://www.pex4fun.com/) is a web-based educational gaming environment for teaching and learning programming and software engineering. Pex4Fun can be used to teach and learn programming and software engineering at many levels, from high school all the way through graduate courses. With Pex4Fun, a student edits code in any browser - with Intellisense - and Pex4Fun executes it and analyzes it in the cloud. Pex4Fun connects teachers, curriculum authors, and students in a unique social experience, tracking and streaming progress updates in real time. In particular, Pex4Fun finds interesting and unexpected input values (with Pex, an advanced test-generation tool) that help students understand what their code is actually doing. The real fun starts with coding duels where a student writes code to implement a teacher\'s secret specification (in the form of sample-solution code not visible to the student). Pex4Fun finds any discrepancies in behavior between the student\'s code and the secret specification. Such discrepancies are given as feedback to the student to guide how to fix the student\'s code to match the behavior of the secret specification. This tool demonstration shows how Pex4Fun can be used in teaching and learning, such as solving coding duels, exploring course materials in feature courses, creating and teaching a course, creating and publishing coding duels, and learning advanced topics behind Pex4Fun.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693144','10.1109/ASE.2013.6693144',25,6,'IEEE','IEEE Conferences',0),(1047,'CodeHow: Effective Code Search Based on API Understanding and Extended Boolean Model (E)',9,260,270,'Over the years of software development, a vast amount of source code has been accumulated. Many code search tools were proposed to help programmers reuse previously-written code by performing free-text queries over a large-scale codebase. Our experience shows that the accuracy of these code search tools are often unsatisfactory. One major reason is that existing tools lack of query understanding ability. In this paper, we propose CodeHow, a code search technique that can recognize potential APIs a user query refers to. Having understood the potentially relevant APIs, CodeHow expands the query with the APIs and performs code retrieval by applying the Extended Boolean model, which considers the impact of both text similarity and potential APIs on code search. We deploy the backend of CodeHow as a Microsoft Azure service and implement the front-end as a Visual Studio extension. We evaluate CodeHow on a large-scale codebase consisting of 26K C# projects downloaded from GitHub. The experimental results show that when the top 1 results are inspected, CodeHow achieves a precision score of 0.794 (i.e., 79.4% of the first returned results are relevant code snippets). The results also show that CodeHow outperforms conventional code search tools. Furthermore, we perform a controlled experiment and a survey of Microsoft developers. The results confirm the usefulness and effectiveness of CodeHow in programming practices.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372014','10.1109/ASE.2015.42',43,29,'IEEE','IEEE Conferences',0),(1048,'Towards robust instruction-level trace alignment of binary code',8,342,352,'Program trace alignment is the process of establishing a correspondence between dynamic instruction instances in executions of two semantically similar but syntactically different programs. In this paper we present what is, to the best of our knowledge, the first method capable of aligning realistically long execution traces of real programs. To maximize generality, our method works entirely on the machine code level, i.e. it does not require access to source code. Moreover, the method is based entirely on dynamic analysis, which avoids the many challenges associated with static analysis of binary code, and which additionally makes our approach inherently resilient to e.g. static code obfuscation. Therefore, we believe that our trace alignment method could prove to be a useful aid in many program analysis tasks, such as debugging, reverse-engineering, investigating plagiarism, and malware analysis. We empirically evaluate our method on 11 popular Linux programs, and show that it is capable of producing meaningful alignments in the presence of various code transformations such as optimization or obfuscation, and that it easily scales to traces with tens of millions of instructions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115647','10.1109/ASE.2017.8115647',25,0,'IEEE','IEEE Conferences',0),(1049,'General LTL Specification Mining (T)',9,81,92,'Temporal properties are useful for describing and reasoning about software behavior, but developers rarely write down temporal specifications of their systems. Prior work on inferring specifications developed tools to extract likely program specifications that fit particular kinds of tool-specific templates. This paper introduces Texada, a new temporal specification mining tool for extracting specifications in linear temporal logic (LTL) of arbitrary length and complexity. Texada takes a user-defined LTL property type template and a log of traces as input and outputs a set of instantiations of the property type (i.e., LTL formulas) that are true on the traces in the log. Texada also supports mining of almost invariants: properties with imperfect confidence. We formally describe Texada\'s algorithms and evaluate the tool\'s performance and utility.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7371998','10.1109/ASE.2015.71',47,32,'IEEE','IEEE Conferences',0),(1050,'RuntimeSearch: Ctrl+F for a running program',8,388,393,'Developers often try to find occurrences of a certain term in a software system. Traditionally, a text search is limited to static source code files. In this paper, we introduce a simple approach, RuntimeSearch, where the given term is searched in the values of all string expressions in a running program. When a match is found, the program is paused and its runtime properties can be explored with a traditional debugger. The feasibility and usefulness of RuntimeSearch is demonstrated on a medium-sized Java project.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115651','10.1109/ASE.2017.8115651',27,1,'IEEE','IEEE Conferences',0),(1051,'Towards contextual and on-demand code clone management by continuous monitoring',6,497,507,'Effective clone management is essential for developers to recognize the introduction and evolution of code clones, to judge their impact on software quality, and to take appropriate measures if required. Our previous study shows that cloning practice is not simply a technical issue. It must be interpreted and considered in a larger context from technical, personal, and organizational perspectives. In this paper, we propose a contextual and on-demand code clone management approach called CCEvents (Code Cloning Events). Our approach provides timely notification about relevant code cloning events for different stakeholders through continuous monitoring of code repositories. It supports on-demand customization of clone monitoring strategies in specific technical, personal, and organizational contexts using a domain-specific language. We implemented the proposed approach and conducted an empirical study with an industrial project. The results confirm the requirements for contextual and on-demand code clone management and show the effectiveness of CCEvents in providing timely code cloning notifications and in helping to achieve effective clone management.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693107','10.1109/ASE.2013.6693107',30,5,'IEEE','IEEE Conferences',0),(1052,'Model based test validation and oracles for data acquisition systems',6,540,550,'This paper presents an automated, model based test validation and oracle approach for systems with complex input and output structures, such as Data Acquisition (DAQ) systems, which are common in many sectors including the satellite communications industry. We present a customised modelling methodology for such systems and a tool that automatically validates test inputs and, after test execution, applies an oracle that is based on mappings between the input and output. We also apply our proposed approach and tool to a complex industrial DAQ system and investigate the scalability and effectiveness of the approach in validating test cases, the DAQ system, or its specifications (captured as models). The results of the case study show that the approach is indeed scalable with respect to two dimensions: (1) model size and (2) test validation and oracle execution time. The size of the model for the DAQ system under study remains within practical bounds, and far below that of typical system models, as it includes a class diagram with 68 classes and 49 constraints. The developed test validation and oracles tool can handle satellite transmission files up to two GB within practical time constraints, taking, on a standard PC, less than three minutes for test validation and less than 50 minutes for applying the oracle. The approach was also effective in automatically applying the oracle successfully for the actual test suite of the DAQ system, accurately identifying all issues and violations that were expected, thus showing that an approach based on models can be sufficiently accurate.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693111','10.1109/ASE.2013.6693111',32,6,'IEEE','IEEE Conferences',0),(1053,'Access-Path Abstraction: Scaling Field-Sensitive Data-Flow Analysis with Unbounded Access Paths (T)',9,619,629,'Precise data-flow analyses frequently model field accesses through access paths with varying length. While using longer access paths increases precision, their size must be bounded to assure termination, and should anyway be small to enable a scalable analysis. We present Access-Path Abstraction, which for the first time combines efficiency with maximal precision. At control-flow merge points Access-Path Abstraction represents all those access paths that are rooted at the same base variable through this base variable only. The full access paths are reconstructed on demand where required. This makes it unnecessary to bound access paths to a fixed maximal length. Experiments with Stanford SecuriBench and the Java Class Library compare our open-source implementation against a field-based approach and against a field-sensitive approach that uses bounded access paths. The results show that the proposed approach scales as well as a field-based approach, whereas the approach using bounded access paths runs out of memory.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372049','10.1109/ASE.2015.9',20,8,'IEEE','IEEE Conferences',0),(1054,'Static Window Transition Graphs for Android (T)',9,658,668,'This work develops a static analysis to create a model of the behavior of an Android application\'s GUI. We propose the window transition graph (WTG), a model representing the possible GUI window sequences and their associated events and callbacks. A key component and contribution of our work is the careful modeling of the stack of currently-active windows, the changes to this stack, and the effects of callbacks related to these changes. To the best of our knowledge, this is the first detailed study of this important static analysis problem for Android. We develop novel analysis algorithms for WTG construction and traversal, based on this modeling of the window stack. We also describe an application of the WTG for GUI test generation, using path traversals. The evaluation of the proposed algorithms indicates their effectiveness and practicality.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372053','10.1109/ASE.2015.76',52,24,'IEEE','IEEE Conferences',0),(1055,'IntPTI: Automatic integer error repair with proper-type inference',8,996,1001,'Integer errors in C/C++ are caused by arithmetic operations yielding results which are unrepresentable in certain type. They can lead to serious safety and security issues. Due to the complicated semantics of C/C++ integers, integer errors are widely harbored in real-world programs and it is error-prone to repair them even for experts. An automatic tool is desired to 1) automatically generate fixes which assist developers to correct the buggy code, and 2) provide sufficient hints to help developers review the generated fixes and better understand integer types in C/C++. In this paper, we present a tool IntPTI that implements the desired functionalities for C programs. IntPTI infers appropriate types for variables and expressions to eliminate representation issues, and then utilizes the derived types with fix patterns codified from the successful human-written patches. IntPTI provides a user-friendly web interface which allows users to review and manage the fixes. We evaluate IntPTI on 7 real-world projects and the results show its competitive repair accuracy and its scalability on large code bases. The demo video for IntPTI is available at: https://youtu.be/9Tgd4A_FgZM.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115718','10.1109/ASE.2017.8115718',31,1,'IEEE','IEEE Conferences',0),(1056,'Managing software evolution through semantic history slicing',8,1014,1017,'Software change histories are results of incremental updates made by developers. As a side-effect of the software development process, version history is a surprisingly useful source of information for understanding, maintaining and reusing software. However, traditional commit-based sequential organization of version histories lacks semantic structure and thus are insufficient for many development tasks that require high-level, semantic understanding of program functionality, such as locating feature implementations and porting hot fixes. In this work, we propose to use well-organized unit tests as identifiers for corresponding software functionalities. We then present a family of automated techniques which analyze the semantics of historical changes and assist developers in many everyday practical settings. For validation, we evaluate our approaches on a benchmark of developer-annotated version history instances obtained from real-world open source software projects on GitHub.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115722','10.1109/ASE.2017.8115722',24,0,'IEEE','IEEE Conferences',0),(1057,'Ranger: Parallel analysis of alloy models by range partitioning',6,147,157,'We present a novel approach for parallel analysis of models written in Alloy, a declarative extension of first-order logic based on relations. The Alloy language is supported by the fully automatic Alloy Analyzer, which translates models into propositional formulas and uses off-the-shelf SAT technology to solve them. Our key insight is that the underlying constraint satisfaction problem can be split into subproblems of lesser complexity by using ranges of candidate solutions, which partition the space of all candidate solutions. Conceptually, we define a total ordering among the candidate solutions, split this space of candidates into ranges, and let independent SAT searches take place within these ranges\' endpoints. Our tool, Ranger, embodies our insight. Experimental evaluation shows that Ranger provides substantial speedups (in several cases, superlinear ones) for a variety of hard-to-solve Alloy models, and that adding more hardware reduces analysis costs almost linearly.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693075','10.1109/ASE.2013.6693075',40,6,'IEEE','IEEE Conferences',0),(1058,'Parallel bug-finding in concurrent programs via reduced interleaving instances',8,753,764,'Concurrency poses a major challenge for program verification, but it can also offer an opportunity to scale when subproblems can be analysed in parallel. We exploit this opportunity here and use a parametrizable code-to-code translation to generate a set of simpler program instances, each capturing a reduced set of the original program\'s interleavings. These instances can then be checked independently in parallel. Our approach does not depend on the tool that is chosen for the final analysis, is compatible with weak memory models, and amplifies the effectiveness of existing tools, making them find bugs faster and with fewer resources. We use Lazy-CSeq as an off-the-shelf final verifier to demonstrate that our approach is able, already with a small number of cores, to find bugs in the hardest known concurrency benchmarks in a matter of minutes, whereas other dynamic and static tools fail to do so in hours.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115686','10.1109/ASE.2017.8115686',50,3,'IEEE','IEEE Conferences',0),(1059,'FiB: Squeezing loop invariants by interpolation between forward/backward predicate transformers',8,793,803,'Loop invariant generation is a fundamental problem in program analysis and verification. In this work, we propose a new approach to automatically constructing inductive loop invariants. The key idea is to aggressively squeeze an inductive invariant based on Craig interpolants between forward and backward reachability analysis. We have evaluated our approach by a set of loop benchmarks, and experimental results show that our approach is promising.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115690','10.1109/ASE.2017.8115690',53,1,'IEEE','IEEE Conferences',0),(1060,'Crowd intelligence enhances automated mobile testing',8,16,26,'We show that information extracted from crowd-based testing can enhance automated mobile testing. We introduce Polariz, which generates replicable test scripts from crowd-based testing, extracting cross-app `motif\' events: automatically-inferred reusable higher-level event sequences composed of lower-level observed event actions. Our empirical study used 434 crowd workers from Mechanical Turk to perform 1,350 testing tasks on 9 popular Google Play apps, each with at least 1 million user installs. The findings reveal that the crowd was able to achieve 60.5% unique activity coverage and proved to be complementary to automated search-based testing in 5 out of the 9 subjects studied. Our leave-one-out evaluation demonstrates that coverage attainment can be improved (6 out of 9 cases, with no disimprovement on the remaining 3) by combining crowd-based and search-based testing.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115614','10.1109/ASE.2017.8115614',42,9,'IEEE','IEEE Conferences',0),(1061,'Supporting bug investigation using history analysis',6,754,757,'In my research, I propose an automated technique to support bug investigation by using a novel analysis of the history of the source code. During the bug-fixing process, developers spend a high amount of manual effort investigating the bug in order to answer a series of questions about it. My research will support developers in answering the following questions about a bug: Who is the most suitable developer to fix the bug?, Where is the bug located?, When was the bug inserted? and Why was the bug inserted?','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693150','10.1109/ASE.2013.6693150',25,1,'IEEE','IEEE Conferences',0),(1062,'Tracking and Analyzing Cross-Cutting Activities in Developers\' Daily Work (N)',9,277,282,'Developers use many software applications to process large amounts of diverse information in their daily work. The information is usually meaningful beyond the context of an application that manages it. However, as different applications function independently, developers have to manually track, correlate and re-find cross-cutting information across separate applications. We refer to this difficulty as information fragmentation problem. In this paper, we present ActivitySpace, an interapplication activity tracking and analysis framework for tackling information fragmentation problem in software development. ActivitySpace can monitor the developer\'s activity in many applications at a low enough level to obviate application-specific support while accounting for the ways by which low-level activity information can be effectively aggregated to reflect the developer\'s activity at higher-level of abstraction. A system prototype has been implemented on Microsoft Windows. Our preliminary user study showed that the ActivitySpace system is promising in supporting interapplication information needs in developers\' daily work.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372016','10.1109/ASE.2015.43',22,8,'IEEE','IEEE Conferences',0),(1063,'Fixing Recurring Crash Bugs via Analyzing Q&A Sites (T)',9,307,318,'Recurring bugs are common in software systems, especially in client programs that depend on the same framework. Existing research uses human-written templates, and is limited to certain types of bugs. In this paper, we propose a fully automatic approach to fixing recurring crash bugs via analyzing Q&A sites. By extracting queries from crash traces and retrieving a list of Q&A pages, we analyze the pages and generate edit scripts. Then we apply these scripts to target source code and filter out the incorrect patches. The empirical results show that our approach is accurate in fixing real-world crash bugs, and can complement existing bug-fixing approaches.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372020','10.1109/ASE.2015.81',58,27,'IEEE','IEEE Conferences',0),(1064,'Comprehensive failure characterization',8,365,376,'There is often more than one way to trigger a fault. Standard static and dynamic approaches focus on exhibiting a single witness for a failing execution. In this paper, we study the problem of computing a comprehensive characterization which safely bounds all failing program behavior while exhibiting a diversity of witnesses for those failures. This information can be used to facilitate software engineering tasks ranging from fault localization and repair to quantitative program analysis for reliability. Our approach combines the results of overapproximating and underapproximating static analyses in an alternating iterative framework to produce upper and lower bounds on the failing input space of a program, which we call a comprehensive failure characterization (CFC). We evaluated a prototype implementation of this alternating framework on a set of 168 C programs from the SV-COMP benchmarks, and the data indicate that it is possible to efficiently, accurately, and safely characterize failure spaces.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115649','10.1109/ASE.2017.8115649',52,1,'IEEE','IEEE Conferences',0),(1065,'Exploring regular expression comprehension',8,405,416,'The regular expression (regex) is a powerful tool employed in a large variety of software engineering tasks. However, prior work has shown that regexes can be very complex and that it could be difficult for developers to compose and understand them. This work seeks to identify code smells that impact comprehension. We conduct an empirical study on 42 pairs of behaviorally equivalent but syntactically different regexes using 180 participants and evaluate the understandability of various regex language features. We further analyze regexes in GitHub to find the community standards or the common usages of various features. We found that some regex expression representations are more understandable than others. For example, using a range (e.g., [0-9]) is often more understandable than a default character class (e.g., [d]). We also found that the DFA size of a regex significantly affects comprehension for the regexes studied. The larger the DFA of a regex (up to size eight), the more understandable it was. Finally, we identify smelly and non-smelly regex representations based on a combination of community standards and understandability metrics.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115653','10.1109/ASE.2017.8115653',43,8,'IEEE','IEEE Conferences',0),(1066,'Automated unit testing of large industrial embedded software using concolic testing',6,519,528,'Current testing practice in industry is often ineffective and slow to detect bugs, since most projects utilize manually generated test cases. Concolic testing alleviates this problem by automatically generating test cases that achieve high coverage. However, specialized execution platforms and resource constraints of embedded software hinder application of concolic testing to embedded software. To overcome these limitations, we have developed CONcrete and symBOLic (CONBOL) testing framework to unit test large size industrial embedded software automatically. To address the aforementioned limitations, CONBOL tests target units on a host PC platform by generating symbolic unit testing drivers/stubs automatically and applying heuristics to reduce false alarms caused by the imprecise drivers/stubs. We have applied CONBOL to four million lines long industrial embedded software and detected 24 new crash bugs. Furthermore, the development team of the target software adopted CONBOL to their development process to apply CONBOL to the revised target software regularly.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693109','10.1109/ASE.2013.6693109',36,18,'IEEE','IEEE Conferences',0),(1067,'AutoComment: Mining question and answer sites for automatic comment generation',6,562,567,'Code comments improve software maintainability. To address the comment scarcity issue, we propose a new automatic comment generation approach, which mines comments from a large programming Question and Answer (Q&A) site. Q&A sites allow programmers to post questions and receive solutions, which contain code segments together with their descriptions, referred to as code-description mappings.We develop AutoComment to extract such mappings, and leverage them to generate description comments automatically for similar code segments matched in open-source projects. We apply AutoComment to analyze Java and Android tagged Q&A posts to extract 132,767 code-description mappings, which help AutoComment to generate 102 comments automatically for 23 Java and Android projects. The user study results show that the majority of the participants consider the generated comments accurate, adequate, concise, and useful in helping them understand the code.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693113','10.1109/ASE.2013.6693113',23,61,'IEEE','IEEE Conferences',0),(1068,'String Analysis of Android Applications (N)',9,680,685,'The desire to understand mobile applications has resulted in researchers adapting classical static analysis techniques to the mobile domain. Examination of data and control flows in Android apps is now a common practice to classify them. Important to these analyses is a fine-grained examination and understanding of strings, since in Android they are heavily used in intents, URLs, reflection, and content providers. Rigorous analysis of string creation, usage, and value characteristics offers additional information to increase precision of app classification. This paper shows that inter-procedural static analysis that specifically targets string construction and usage can be used to reveal valuable insights for classifying Android apps. To this end, we first present case studies to illustrate typical uses of strings in Android apps. We then present the results of our analysis on real-world malicious and benign apps. Our analysis examines how strings are created and used for URL objects, Java reflection, and Android intents, and infers the actual string values used as much as possible. Our results demonstrate that string disambiguation based on creation, usage, and value indeed provides additional information that may be used to improve precision of classifying application behaviors.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372055','10.1109/ASE.2015.20',23,1,'IEEE','IEEE Conferences',0),(1069,'Towards a software vulnerability prediction model using traceable code patterns and software metrics',8,1022,1025,'Software security is an important aspect of ensuring software quality. The goal of this study is to help developers evaluate software security using traceable patterns and software metrics during development. The concept of traceable patterns is similar to design patterns but they can be automatically recognized and extracted from source code. If these patterns can better predict vulnerable code compared to traditional software metrics, they can be used in developing a vulnerability prediction model to classify code as vulnerable or not. By analyzing and comparing the performance of traceable patterns with metrics, we propose a vulnerability prediction model. This study explores the performance of some code patterns in vulnerability prediction and compares them with traditional software metrics. We use the findings to build an effective vulnerability prediction model. We evaluate security vulnerabilities reported for Apache Tomcat, Apache CXF and three stand-alone Java web applications. We use machine learning and statistical techniques for predicting vulnerabilities using traceable patterns and metrics as features. We found that patterns have a lower false negative rate and higher recall in detecting vulnerable code than the traditional software metrics.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115724','10.1109/ASE.2017.8115724',14,2,'IEEE','IEEE Conferences',0),(1070,'Software model checking for distributed systems with selector-based, non-blocking communication',6,169,179,'Many modern software systems are implemented as client/server architectures, where a server handles multiple clients concurrently. Testing does not cover the outcomes of all possible thread and communication schedules reliably. Software model checking, on the other hand, covers all possible outcomes but is often limited to subsets of commonly used protocols and libraries. Earlier work in cache-based software model checking handles implementations using socket-based TCP/IP networking, with one thread per client connection using blocking input/output. Recently, servers using non-blocking, selector-based input/output have become prevalent. This paper describes our work extending the Java PathFinder extension net-iocache to such software, and the application of our tool to modern server software.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693077','10.1109/ASE.2013.6693077',23,10,'IEEE','IEEE Conferences',0),(1071,'Automated planning for software architecture evolution',6,213,223,'In previous research, we have developed a theoretical framework to help software architects make better decisions when planning software evolution. Our approach is based on representation and analysis of candidate evolution paths-sequences of transitional architectures leading from the current system to a desired target architecture. One problem with this kind of approach is that it imposes a heavy burden on the software architect, who must explicitly define and model these candidate paths. In this paper, we show how automated planning techniques can be used to support automatic generation of evolution paths, relieving this burden on the architect. We illustrate our approach by applying it to a data migration scenario, showing how this architecture evolution problem can be translated into a planning problem and solved using existing automated planning tools.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693081','10.1109/ASE.2013.6693081',28,12,'IEEE','IEEE Conferences',0),(1072,'Quick verification of concurrent programs by iteratively relaxed scheduling',8,776,781,'The most prominent advantage of software verification over testing is a rigorous check of every possible software behavior. However, large state spaces of concurrent systems, due to non-deterministic scheduling, result in a slow automated verification process. Therefore, verification introduces a large delay between completion and deployment of concurrent software. This paper introduces a novel iterative approach to verification of concurrent programs that drastically reduces this delay. By restricting the execution of concurrent programs to a small set of admissible schedules, verification complexity and time is drastically reduced. Iteratively adding admissible schedules after their verification eventually restores non-deterministic scheduling. Thereby, our framework allows to find a sweet spot between a low verification delay and sufficient execution time performance. Our evaluation of a prototype implementation on well-known benchmark programs shows that after verifying only few schedules of the program, execution time overhead is competitive to existing deterministic multi-threading frameworks.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115688','10.1109/ASE.2017.8115688',19,0,'IEEE','IEEE Conferences',0),(1073,'Parsimony: An IDE for example-guided synthesis of lexers and parsers',8,815,825,'We present Parsimony, a programming-by-example development environment for synthesizing lexers and parsers by example. Parsimony provides a graphical interface in which the user presents examples simply by selecting and labeling sample text in a text editor. An underlying synthesis engine then constructs syntactic rules to solve the system of constraints induced by the supplied examples. Parsimony is more expressive and usable than prior programming-by-example systems for parsers in several ways: Parsimony can (1) synthesize lexer rules in addition to productions, (2) solve for much larger constraint systems over multiple examples, rather than handling examples one-at-a-time, and (3) infer much more complex sets of productions, such as entire algebraic expression grammars, by detecting instances of well-known grammar design patterns. The results of a controlled user study across 18 participants show that users are able to perform lexing and parsing tasks faster and with fewer mistakes when using Parsimony as compared to a traditional parsing workflow.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115692','10.1109/ASE.2017.8115692',28,0,'IEEE','IEEE Conferences',0),(1074,'Sketch-guided GUI test generation for mobile applications',8,38,43,'Mobile applications with complex GUIs are very popular today. However, generating test cases for these applications is often tedious professional work. On the one hand, manually designing and writing elaborate GUI scripts requires expertise. On the other hand, generating GUI scripts with record and playback techniques usually depends on repetitive work that testers need to interact with the application over and over again, because only one path is recorded in an execution. Automatic GUI testing focuses on exploring combinations of GUI events. As the number of combinations is huge, it is still necessary to introduce a test interface for testers to reduce its search space. This paper presents a sketch-guided GUI test generation approach for testing mobile applications, which provides a simple but expressive interface for testers to specify their testing purposes. Testers just need to draw a few simple strokes on the screenshots. Then our approach translates the strokes to a testing model and initiates a model-based automatic GUI testing. We evaluate our sketch-guided approach on a few real-world Android applications collected from the literature. The results show that our approach can achieve higher coverage than existing automatic GUI testing techniques with just 10-minute sketching for an application.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115616','10.1109/ASE.2017.8115616',23,2,'IEEE','IEEE Conferences',0),(1075,'Detecting and fixing emergent behaviors in Distributed Software Systems using a message content independent method',6,746,749,'This research is intended to automatically detect emergent behaviors of scenario based Distributed Software Systems (DSS) in design phase. The direct significance of our work is reducing the cost of verifying DSS for unexpected behavior in execution time. Existing approaches have some drawbacks which we try to cover in our work. The main contributions are modeling the DSS components as a social network and not using behavioral modeling, detecting components with no emergent behavior, and investigating the interactions of instances of one type.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693148','10.1109/ASE.2013.6693148',27,0,'IEEE','IEEE Conferences',0),(1076,'Perceived language complexity in GitHub issue discussions and their effect on issue resolution',8,72,83,'Modern software development is increasingly collaborative. Open Source Software (OSS) are the bellwether; they support dynamic teams, with tools for code sharing, communication, and issue tracking. The success of an OSS project is reliant on team communication. E.g., in issue discussions, individuals rely on rhetoric to argue their position, but also maintain technical relevancy. Rhetoric and technical language are on opposite ends of a language complexity spectrum: the former is stylistically natural; the latter is terse and concise. Issue discussions embody this duality, as developers use rhetoric to describe technical issues. The style mix in any discussion can define group culture and affect performance, e.g., issue resolution times may be longer if discussion is imprecise. Using GitHub, we studied issue discussions to understand whether project-specific language differences exist, and to what extent users conform to a language norm. We built project-specific and overall GitHub language models to study the effect of perceived language complexity on multiple responses. We find that experienced users conform to project-specific language norms, popular individuals use overall GitHub language rather than project-specific language, and conformance to project-specific language norms reduces issue resolution times. We also provide a tool to calculate project-specific perceived language complexity.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115620','10.1109/ASE.2017.8115620',50,1,'IEEE','IEEE Conferences',0),(1077,'Preventing erosion of architectural tactics through their strategic implementation, preservation, and visualization',6,762,765,'Nowadays, a successful software production is increasingly dependent on how the final deployed system addresses customers\' and users\' quality concerns such as security, reliability, availability, interoperability, performance and many other types of such requirements. In order to satisfy such quality concerns, software architects are accountable for devising and comparing various alternate solutions, assessing the trade-offs, and finally adopting strategic design decisions which optimize the degree to which each of the quality concerns is satisfied. Although designing and implementing a good architecture is necessary, it is not usually enough. Even a good architecture can deteriorate in subsequent releases and then fail to address those concerns for which it was initially designed. In this work, we present a novel traceability approach for automating the construction of traceabilty links for architectural tactics and utilizing those links to implement a change impact analysis infrastructure to mitigate the problem of architecture degradation. Our approach utilizes machine learning methods to detect tactic-related classes. The detected tactic-related classes are then mapped to a Tactic Traceability Pattern. We train our trace algorithm using code extracted from fifty performance-centric and safety-critical open source software systems and then evaluate it against a real case study.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693152','10.1109/ASE.2013.6693152',25,1,'IEEE','IEEE Conferences',0),(1078,'Automated Tagging of Software Projects Using Bytecode and Dependencies (N)',9,289,294,'Several open and closed source repositories group software systems and libraries to allow members of particular organizations or the open source community to take advantage of them. However, to make this possible, it is necessary to have effective ways of searching and browsing the repositories. Software tagging is the process of assigning terms (i.e., tags or labels) to software assets in order to describe features and internal details, making the task of understanding software easier and potentially browsing and searching through a repository more effective. We present Sally, an automatic software tagging approach that is able to produce meaningful tags for Maven-based software projects by analyzing their bytecode and dependency relations without any special requirements from developers. We compared tags generated by Sally to the ones in two widely used online repositories, and the tags generated by a state-of-the-art categorization approach. The results suggest that Sally is able to generate expressive tags without relying on machine learning-based models.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372018','10.1109/ASE.2015.38',21,5,'IEEE','IEEE Conferences',0),(1079,'Synthesizing Web Element Locators (T)',9,331,341,'To programmatically interact with the user interface of a web application, element locators are used to select and retrieve elements from the Document Object Model (DOM). Element locators are used in JavaScript code, Cascading stylesheets, and test cases to interact with the runtime DOM of the webpage. Constructing these element locators is, however, challenging due to the dynamic nature of the DOM. We find that locators written by web developers can be quite complex, and involve selecting multiple DOM elements. We present an automated technique for synthesizing DOM element locators using examples provided interactively by the developer. The main insight in our approach is that the problem of synthesizing complex multi-element locators can be expressed as a constraint solving problem over the domain of valid DOM states in a web application. We implemented our synthesis technique in a tool called LED, which provides an interactive drag and drop support inside the browser for selecting positive and negative examples. We find that LED supports at least 86% of the locators used in the JavaScript code of deployed web applications, and that the locators synthesized by LED have a recall of 98% and a precision of 63%. LED is fast, taking only 0.23 seconds on average to synthesize a locator.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372022','10.1109/ASE.2015.23',36,2,'IEEE','IEEE Conferences',0),(1080,'Improved query reformulation for concept location using CodeRank and document structures',8,428,439,'During software maintenance, developers usually deal with a significant number of software change requests. As a part of this, they often formulate an initial query from the request texts, and then attempt to map the concepts discussed in the request to relevant source code locations in the software system (a.k.a., concept location). Unfortunately, studies suggest that they often perform poorly in choosing the right search terms for a change task. In this paper, we propose a novel technique-ACER-that takes an initial query, identifies appropriate search terms from the source code using a novel term weight-CodeRank, and then suggests effective reformulation to the initial query by exploiting the source document structures, query quality analysis and machine learning. Experiments with 1,675 baseline queries from eight subject systems report that our technique can improve 71% of the baseline queries which is highly promising. Comparison with five closely related existing techniques in query reformulation not only validates our empirical findings but also demonstrates the superiority of our technique.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115655','10.1109/ASE.2017.8115655',55,5,'IEEE','IEEE Conferences',0),(1081,'Multi-user variability configuration: A game theoretic approach',6,574,579,'Multi-user configuration is a neglected problem in variability-intensive systems area. The appearance of conflicts among user configurations is a main concern. Current approaches focus on avoiding such conflicts, applying the mutual exclusion principle. However, this perspective has a negative impact on users satisfaction, who cannot make any decision fairly. In this work, we propose an interpretation of multi-user configuration as a game theoretic problem. Game theory is a well-known discipline which analyzes conflicts and cooperation among intelligent rational decision-makers. We present a taxonomy of multi-user configuration approaches, and how they can be interpreted as different problems of game theory. We focus on cooperative game theory to propose and automate a tradeoff-based bargaining approach, as a way to solve the conflicts and maximize user satisfaction at the same time.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693115','10.1109/ASE.2013.6693115',17,1,'IEEE','IEEE Conferences',0),(1082,'Development History Granularity Transformations (N)',9,697,702,'Development histories can simplify some software engineering tasks, butdifferent tasks require different history granularities. For example, a history that includes every edit that resulted in compiling code is needed when searching for the cause of a regression, whereas a history that contains only changes relevant to a feature is needed for understanding the evolution of the feature. Unfortunately, today, both manual and automated history generation result in a single-granularity history. This paper introduces the concept of multi-grained development history views and the architecture of Codebase Manipulation, a tool that automatically records a fine-grained history and manages its granularity by applying granularity transformations.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372057','10.1109/ASE.2015.53',50,6,'IEEE','IEEE Conferences',0),(1083,'Generating Qualifiable Avionics Software: An Experience Report (E)',9,726,736,'We report on our experience with enhancing the data-management component in the avionics software of the NH90 helicopter at Airbus Helicopters. We describe challenges regarding the evolution of avionics software by means of real-world evolution scenarios that arise in industrial practice. A key role plays a legally-binding certification process, called qualification, which is responsible for most of the development effort and cost. To reduce effort and cost, we propose a novel generative approach to develop qualifiable avionics software by combining model-based and product-line technology. Using this approach, we have already generated code that is running on the NH90 helicopter and that is in the process of replacing the current system code. Based on an interview with two professional developers at Airbus and an analysis of the software repository of the NH90, we systematically compare our approach with established development approaches in the avionics domain, in terms of implementation and qualification effort.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372061','10.1109/ASE.2015.35',26,0,'IEEE','IEEE Conferences',0),(1084,'Consistency-preserving edit scripts in model versioning',6,191,201,'In model-based software development, models are iteratively evolved. To optimally support model evolution, developers need adequate tools for model versioning tasks, including comparison, patching, and merging of models. A significant disadvantage of tools currently available is that they display, and operate with, low-level model changes which refer to internal model representations and which can lead to intermediate inconsistent states. Higher-level consistency-preserving edit operations including refactorings are better suited to explain changes or to resolve conflicts. This paper presents an automatic procedure which transforms a low-level difference into an executable edit script which uses consistency-preserving edit operations only. Edit scripts support consistent model patching and merging on a higher abstraction level. Our approach to edit script generation has been evaluated in a larger real-world case study.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693079','10.1109/ASE.2013.6693079',41,21,'IEEE','IEEE Conferences',0),(1085,'SEDGE: Symbolic example data generation for dataflow programs',6,235,245,'Exhaustive, automatic testing of dataflow (esp. mapreduce) programs has emerged as an important challenge. Past work demonstrated effective ways to generate small example data sets that exercise operators in the Pig platform, used to generate Hadoop map-reduce programs. Although such prior techniques attempt to cover all cases of operator use, in practice they often fail. Our SEDGE system addresses these completeness problems: for every dataflow operator, we produce data aiming to cover all cases that arise in the dataflow program (e.g., both passing and failing a filter). SEDGE relies on transforming the program into symbolic constraints, and solving the constraints using a symbolic reasoning engine (a powerful SMT solver), while using input data as concrete aids in the solution process. The approach resembles dynamic-symbolic (a.k.a. 鈥渃oncolic鈥�) execution in a conventional programming language, adapted to the unique features of the dataflow domain. In third-party benchmarks, SEDGE achieves higher coverage than past techniques for 5 out of 20 PigMix benchmarks and 7 out of 11 SDSS benchmarks and (with equal coverage for the rest of the benchmarks). We also show that our targeting of the high-level dataflow language pays off: for complex programs, state-of-the-art dynamic-symbolic execution at the level of the generated map-reduce code (instead of the original dataflow program) requires many more test cases or achieves much lower coverage than our approach.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693083','10.1109/ASE.2013.6693083',26,5,'IEEE','IEEE Conferences',0),(1086,'Programming bots by synthesizing natural language expressions into API invocations',8,832,837,'At present, bots are still in their preliminary stages of development. Many are relatively simple, or developed ad-hoc for a very specific use-case. For this reason, they are typically programmed manually, or utilize machine-learning classifiers to interpret a fixed set of user utterances. In reality, real world conversations with humans require support for dynamically capturing users expressions. Moreover, bots will derive immeasurable value by programming them to invoke APIs for their results. Today, within the Web and Mobile development community, complex applications are being stringed together with a few lines of code - all made possible by APIs. Yet, developers today are not as empowered to program bots in much the same way. To overcome this, we introduce BotBase, a bot programming platform that dynamically synthesizes natural language user expressions into API invocations. Our solution is two faceted: Firstly, we construct an API knowledge graph to encode and evolve APIs; secondly, leveraging the above we apply techniques in NLP, ML and Entity Recognition to perform the required synthesis from natural language user expressions into API calls.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115694','10.1109/ASE.2017.8115694',27,1,'IEEE','IEEE Conferences',0),(1087,'Learn&Fuzz: Machine learning for input fuzzing',8,50,59,'Fuzzing consists of repeatedly testing an application with modified, or fuzzed, inputs with the goal of finding security vulnerabilities in input-parsing code. In this paper, we show how to automate the generation of an input grammar suitable for input fuzzing using sample inputs and neural-network-based statistical machine-learning techniques. We present a detailed case study with a complex input format, namely PDF, and a large complex security-critical parser for this format, namely, the PDF parser embedded in Microsoft\'s new Edge browser. We discuss and measure the tension between conflicting learning and fuzzing goals: learning wants to capture the structure of well-formed inputs, while fuzzing wants to break that structure in order to cover unexpected code paths and find bugs. We also present a new algorithm for this learn&fuzz challenge which uses a learnt input probability distribution to intelligently guide where to fuzz inputs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115618','10.1109/ASE.2017.8115618',31,25,'IEEE','IEEE Conferences',0),(1088,'Are developers aware of the architectural impact of their changes?',8,95,105,'Although considered one of the most important decisions in a software development lifecycle, empirical evidence on how developers perform and perceive architectural changes is still scarce. Given the large implications of architectural decisions, we do not know whether developers are aware of their changes\' impact on the software\'s architecture, whether awareness leads to better changes, and whether automatically making developers aware would prevent degradation. Therefore, we use code review data of 4 open source systems to investigate the intent and awareness of developers when performing changes. We extracted 8,900 reviews for which the commits are available. 2,152 of the commits have changes in their computed architectural metrics, and 338 present significant changes to the architecture. We manually inspected all reviews for commits with significant changes and found that only in 38% of the time developers are discussing the impact of their changes on the architectural structure, suggesting a lack of awareness. Finally, we observed that developers tend to be more aware of the architectural impact of their changes when the architectural structure is improved, suggesting that developers should be automatically made aware when their changes degrade the architectural structure.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115622','10.1109/ASE.2017.8115622',44,8,'IEEE','IEEE Conferences',0),(1089,'Predicting Delays in Software Projects Using Networked Classification (T)',9,353,364,'Software projects have a high risk of cost and schedule overruns, which has been a source of concern for the software engineering community for a long time. One of the challenges in software project management is to make reliable prediction of delays in the context of constant and rapid changes inherent in software projects. This paper presents a novel approach to providing automated support for project managers and other decision makers in predicting whether a subset of software tasks (among the hundreds to thousands of ongoing tasks) in a software project have a risk of being delayed. Our approach makes use of not only features specific to individual software tasks (i.e. local data) -- as done in previous work -- but also their relationships (i.e. networked data). In addition, using collective classification, our approach can simultaneously predict the degree of delay for a group of related tasks. Our evaluation results show a significant improvement over traditional approaches which perform classification on each task independently: achieving 46% -- 97% precision (49% improved), 46% -- 97% recall (28% improved), 56% -- 75% F-measure (39% improved), and 78% -- 95% Area Under the ROC Curve (16% improved).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372024','10.1109/ASE.2015.55',57,5,'IEEE','IEEE Conferences',0),(1090,'O2O service composition with social collaboration',8,451,461,'In Online-to-Offline (O2O) commerce, customer services may need to be composed from online and offline services. Such composition is challenging, as it requires effective selection of appropriate services that, in turn, support optimal combination of both online and offline services. In this paper, we address this challenge by proposing an approach to O2O service composition which combines offline route planning and social collaboration to optimize service selection. We frame general O2O service composition problems using timed automata and propose an optimization procedure that incorporates: (1) a Markov Chain Monte Carlo (MCMC) algorithm to stochastically select a concrete composite service, and (2) a model checking approach to searching for an optimal collaboration plan with the lowest cost given certain time constraint. Our procedure has been evaluated using the simulation of a rich scenario on effectiveness and scalability.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115657','10.1109/ASE.2017.8115657',31,2,'IEEE','IEEE Conferences',0),(1091,'Transfer learning for performance modeling of configurable systems: An exploratory analysis',8,497,508,'Modern software systems provide many configuration options which significantly influence their non-functional properties. To understand and predict the effect of configuration options, several sampling and learning strategies have been proposed, albeit often with significant cost to cover the highly dimensional configuration space. Recently, transfer learning has been applied to reduce the effort of constructing performance models by transferring knowledge about performance behavior across environments. While this line of research is promising to learn more accurate models at a lower cost, it is unclear why and when transfer learning works for performance modeling. To shed light on when it is beneficial to apply transfer learning, we conducted an empirical study on four popular software systems, varying software configurations and environmental conditions, such as hardware, workload, and software versions, to identify the key knowledge pieces that can be exploited for transfer learning. Our results show that in small environmental changes (e.g., homogeneous workload change), by applying a linear transformation to the performance model, we can understand the performance behavior of the target environment, while for severe environmental changes (e.g., drastic workload change) we can transfer only knowledge that makes sampling more efficient, e.g., by reducing the dimensionality of the configuration space.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115661','10.1109/ASE.2017.8115661',64,10,'IEEE','IEEE Conferences',0),(1092,'Learning effective query transformations for enhanced requirements trace retrieval',6,586,591,'In automated requirements traceability, significant improvements can be realized through incorporating user feedback into the trace retrieval process. However, existing feedback techniques are designed to improve results for individual queries. In this paper we present a novel technique designed to extend the benefits of user feedback across multiple trace queries. Our approach, named Trace Query Transformation (TQT), utilizes a novel form of Association Rule Mining to learn a set of query transformation rules which are used to improve the efficacy of future trace queries. We evaluate TQT using two different kinds of training sets. The first represents an initial set of queries directly modified by human analysts, while the second represents a set of queries generated by applying a query optimization process based on initial relevance feedback for trace links between a set of source and target documents. Both techniques are evaluated using requirements from theWorldVista Healthcare system, traced against certification requirements for the Commission for Healthcare Information Technology. Results show that the TQT technique returns significant improvements in the quality of generated trace links.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693117','10.1109/ASE.2013.6693117',23,10,'IEEE','IEEE Conferences',0),(1093,'PYTHIA: Generating test cases with oracles for JavaScript applications',6,610,615,'Web developers often write test cases manually using testing frameworks such as Selenium. Testing JavaScript-based applications is challenging as manually exploring various execution paths of the application is difficult. Also JavaScript\'s highly dynamic nature as well as its complex interaction with the DOM make it difficult for the tester to achieve high coverage. We present a framework to automatically generate unit test cases for individual JavaScript functions. These test cases are strengthened by automatically generated test oracles capable of detecting faults in JavaScript code. Our approach is implemented in a tool called Pythia. Our preliminary evaluation results point to the efficacy of the approach in achieving high coverage and detecting faults.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693121','10.1109/ASE.2013.6693121',20,7,'IEEE','IEEE Conferences',0),(1094,'Automatic Detection of Potential Layout Faults Following Changes to Responsive Web Pages (N)',9,709,714,'Due to the exponential increase in the number ofmobile devices being used to access the World Wide Web, it iscrucial that Web sites are functional and user-friendly across awide range of Web-enabled devices. This necessity has resulted in the introduction of responsive Web design (RWD), which usescomplex cascading style sheets (CSS) to fluidly modify a Web site\'s appearance depending on the viewport width of the device in use. Although existing tools may support the testing of responsive Web sites, they are time consuming and error-prone to use because theyrequire manual screenshot inspection at specified viewport widths. Addressing these concerns, this paper presents a method thatcan automatically detect potential layout faults in responsively designed Web sites. To experimentally evaluate this approach, weimplemented it as a tool, called ReDeCheck, and applied itto 5 real-world web sites that vary in both their approach toresponsive design and their complexity. The experiments revealthat ReDeCheck finds 91% of the inserted layout faults.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372059','10.1109/ASE.2015.31',22,13,'IEEE','IEEE Conferences',0),(1095,'Mining User Opinions in Mobile App Reviews: A Keyword-Based Approach (T)',9,749,759,'User reviews of mobile apps often contain complaints or suggestions which are valuable for app developers to improve user experience and satisfaction. However, due to the large volume and noisy-nature of those reviews, manually analyzing them for useful opinions is inherently challenging. To address this problem, we propose MARK, a keyword-based framework for semi-automated review analysis. MARK allows an analyst describing his interests in one or some mobile apps by a set of keywords. It then finds and lists the reviews most relevant to those keywords for further analysis. It can also draw the trends over time of those keywords and detect their sudden changes, which might indicate the occurrences of serious issues. To help analysts describe their interests more effectively, MARK can automatically extract keywords from raw reviews and rank them by their associations with negative reviews. In addition, based on a vector-based semantic representation of keywords, MARK can divide a large set of keywords into more cohesive subsets, or suggest keywords similar to the selected ones.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372063','10.1109/ASE.2015.85',32,27,'IEEE','IEEE Conferences',0),(1096,'Entropy-based test generation for improved fault localization',6,257,267,'Spectrum-based Bayesian reasoning can effectively rank candidate fault locations based on passing/failing test cases, but the diagnostic quality highly depends on the size and diversity of the underlying test suite. As test suites in practice often do not exhibit the necessary properties, we present a technique to extend existing test suites with new test cases that optimize the diagnostic quality. We apply probability theory concepts to guide test case generation using entropy, such that the amount of uncertainty in the diagnostic ranking is minimized. Our ENTBUG prototype extends the search-based test generation tool EVOSUITE to use entropy in the fitness function of its underlying genetic algorithm, and we applied it to seven real faults. Empirical results show that our approach reduces the entropy of the diagnostic ranking by 49% on average (compared to using the original test suite), leading to a 91% average reduction of diagnosis candidates needed to inspect to find the true faulty one.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693085','10.1109/ASE.2013.6693085',40,23,'IEEE','IEEE Conferences',0),(1097,'Systematic reduction of GUI test sequences',8,849,860,'Graphic user interface (GUI) is an integral part of many software applications. However, GUI testing remains a challenging task. The main problem is to generate a set of high-quality test cases, i.e., sequences of user events to cover the often large input space. Since manually crafting event sequences is labor-intensive and automated testing tools often have poor performance, we propose a new GUI testing framework to efficiently generate progressively longer event sequences while avoiding redundant sequences. Our technique for identifying the redundancy among these sequences relies on statically checking a set of simple and syntactic-level conditions, whose reduction power matches and sometimes exceeds that of classic techniques based on partial order reduction. We have evaluated our method on 17 Java Swing applications. Our experimental results show the new technique, while being sound and systematic, can achieve more than 10X reduction in the number of test sequences compared to the state-of-the-art GUI testing tools.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115696','10.1109/ASE.2017.8115696',60,0,'IEEE','IEEE Conferences',0),(1098,'Detecting fragile comments',8,112,122,'Refactoring is a common software development practice and many simple refactorings can be performed automatically by tools. Identifier renaming is a widely performed refactoring activity. With tool support, rename refactorings can rely on the program structure to ensure correctness of the code transformation. Unfortunately, the textual references to the renamed identifier present in the unstructured comment text cannot be formally detected through the syntax of the language, and are thus fragile with respect to identifier renaming. We designed a new rule-based approach to detect fragile comments. Our approach, called Fraco, takes into account the type of identifier, its morphology, the scope of the identifier and the location of comments. We evaluated the approach by comparing its precision and recall against hand-annotated benchmarks created for six target Java systems, and compared the results against the performance of Eclipse\'s automated in-comment identifier replacement feature. Fraco performed with near-optimal precision and recall on most components of our evaluation data set, and generally outperformed the baseline Eclipse feature. As part of our evaluation, we also noted that more than half of the total number of identifiers in our data set had fragile comments after renaming, which further motivates the need for research on automatic comment refactoring.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115624','10.1109/ASE.2017.8115624',30,5,'IEEE','IEEE Conferences',0),(1099,'Model-Driven Allocation Engineering (T)',9,374,384,'Cyber-physical systems (CPSs) provide sophisticated functionality and are controlled by networked electronic control units (ECUs). Nowadays, software engineers use component-based development approaches to develop their software. Moreover, software components have to be allocated to an ECU to be executed. Engineers have to cope with topology-, software-, and timing-dependencies and memory-, scheduling-, and routing-constraints. Currently, engineers use linear programs to specify allocation constraints and to derive a feasible allocation automatically. However, encoding the allocation problem as a linear program is a complex and error-prone task. This paper contributes a model-driven, OCL-based allocation engineering approach for reducing the engineering effort and to avoid failures. We validate our approach with an automotive case study modeled with MechatronicUML. Our validation shows that we can specify allocation constraints with less engineering effort and are able to derive feasible allocations automatically.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372026','10.1109/ASE.2015.18',27,4,'IEEE','IEEE Conferences',0),(1100,'Executing Model-Based Tests on Platform-Specific Implementations (T)',9,418,428,'Model-based testing of embedded real-time systems is challenging because platform-specific details are often abstracted away to make the models amenable to various analyses. Testing an implementation to expose non-conformance to such a model requires reconciling differences arising from these abstractions. Due to stateful behavior, naive comparisons of model and system behaviors often fail causing numerous false positives. Previously proposed approaches address this by being reactively permissive: passing criteria are relaxed to reduce false positives, but may increase false negatives, which is particularly bothersome for safety-critical systems. To address this concern, we propose an automated approach that is proactively adaptive: test stimuli and system responses are suitably modified taking into account platform-specific aspects so that the modified test when executed on the platform-specific implementation exercises the intended scenario captured in the original model-based test. We show that the new framework eliminates false negatives while keeping the number of false positives low for a variety of platform-specific configurations.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372030','10.1109/ASE.2015.64',25,0,'IEEE','IEEE Conferences',0),(1101,'Diagnosing assumption problems in safety-critical products',8,473,484,'Problems with the correctness and completeness of environmental assumptions contribute to many accidents in safety-critical systems. The problem is exacerbated when products are modified in new releases or in new products of a product line. In such cases existing sets of environmental assumptions are often carried forward without sufficiently rigorous analysis. This paper describes a new technique that exploits the traceability required by many certifying bodies to reason about the likelihood that environmental assumptions are omitted or incorrectly retained in new products. An analysis of over 150 examples of environmental assumptions in historical systems informs the approach. In an evaluation on three safety-related product lines the approach caught all but one of the assumption-related problems. It also provided clearly defined steps for mitigating the identified issues. The contribution of the work is to arm the safety analyst with useful information for assessing the validity of environmental assumptions for a new product.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115659','10.1109/ASE.2017.8115659',62,1,'IEEE','IEEE Conferences',0),(1102,'A comprehensive study on real world concurrency bugs in Node.js',8,520,531,'Node.js becomes increasingly popular in building server-side JavaScript applications. It adopts an event-driven model, which supports asynchronous I/O and non-deterministic event processing. This asynchrony and non-determinism can introduce intricate concurrency bugs, and leads to unpredictable behaviors. An in-depth understanding of real world concurrency bugs in Node.js applications will significantly promote effective techniques in bug detection, testing and fixing for Node.js. In this paper, we present NodeCB, a comprehensive study on real world concurrency bugs in Node.js applications. Specifically, we have carefully studied 57 real bug cases from open-source Node.js applications, and have analyzed their bug characteristics, e.g., bug patterns and root causes, bug impacts, bug manifestation, and fix strategies. Through this study, we obtain several interesting findings, which may open up many new research directions in combating concurrency bugs in Node.js. For example, one finding is that two thirds of the bugs are caused by atomicity violation. However, due to lack of locks and transaction mechanism, Node.js cannot easily express and guarantee the atomic intention.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115663','10.1109/ASE.2017.8115663',65,5,'IEEE','IEEE Conferences',0),(1103,'Cloud Twin: Native execution of android applications on the Windows Phone',6,598,603,'To successfully compete in the software marketplace, modern mobile applications must run on multiple competing platforms, such as Android, iOS, and Windows Phone. Companies producing mobile applications spend substantial amounts of time, effort, and money to port applications across platforms. Creating individual program versions for different platforms further exacerbates the maintenance burden. This paper presents Cloud Twin, a novel approach to natively executing the functionality of a mobile application written for another platform. The functionality is accessed by means of dynamic cross-platform replay, in which the source application\'s execution in the cloud is mimicked natively on the target platform. The reference implementation of Cloud Twin natively emulates the behavior of Android applications on a Windows Phone. Specifically, Cloud Twin transmits, via web sockets, the UI actions performed on the Windows Phone to the cloud server, which then mimics the received actions on the Android emulator. The UI updates on the emulator are efficiently captured by means of Aspect Oriented Programming and sent back to be replayed on the Windows Phone. Our case studies with third-party applications indicate that the Cloud Twin approach can become a viable solution to the heterogeneity of the mobile application market.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693119','10.1109/ASE.2013.6693119',19,2,'IEEE','IEEE Conferences',0),(1104,'Automated inference of classifications and dependencies for combinatorial testing',6,622,627,'Even for small programs, the input space is huge - often unbounded. Partition testing divides the input space into disjoint equivalence classes and combinatorial testing selects a subset of all possible input class combinations, according to criteria such as pairwise coverage. The down side of this approach is that the partitioning of the input space into equivalence classes (input classification) is done manually. It is expensive and requires deep domain and implementation understanding. In this paper, we propose a novel approach to classify test inputs and their dependencies automatically. Firstly, random (or automatically generated) input vectors are sent to the system under test (SUT). For each input vector, an observed 鈥渉it vector鈥� is produced by monitoring the execution of the SUT. Secondly, hit vectors are grouped into clusters using machine learning. Each cluster contains similar hit vectors, i.e., similar behaviors, and from them we obtain corresponding clusters of input vectors. Input classes are then extracted for each input parameter straightforwardly. Our experiments with a number of subjects show good results as the automatically generated classifications are the same or very close to the expected ones.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693123','10.1109/ASE.2013.6693123',13,0,'IEEE','IEEE Conferences',0),(1105,'Ensemble Methods for App Review Classification: An Approach for Software Evolution (N)',9,771,776,'App marketplaces are distribution platforms for mobile applications that serve as a communication channel between users and developers. These platforms allow users to write reviews about downloaded apps. Recent studies found that such reviews include information that is useful for software evolution. However, the manual analysis of a large amount of user reviews is a tedious and time consuming task. In this work we propose a taxonomy for classifying app reviews into categories relevant for software evolution. Additionally, we describe an experiment that investigates the performance of individual machine learning algorithms and its ensembles for automatically classifying the app reviews. We evaluated the performance of the machine learning techniques on 4550 reviews that were systematically labeled using content analysis methods. Overall, the ensembles had a better performance than the individual classifiers, with an average precision of 0.74 and 0.59 recall.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372065','10.1109/ASE.2015.88',27,33,'IEEE','IEEE Conferences',0),(1106,'Personalized defect prediction',6,279,289,'Many defect prediction techniques have been proposed. While they often take the author of the code into consideration, none of these techniques build a separate prediction model for each developer. Different developers have different coding styles, commit frequencies, and experience levels, causing different defect patterns. When the defects of different developers are combined, such differences are obscured, hurting prediction performance. This paper proposes personalized defect prediction-building a separate prediction model for each developer to predict software defects. As a proof of concept, we apply our personalized defect prediction to classify defects at the file change level. We evaluate our personalized change classification technique on six large software projects written in C and Java-the Linux kernel, PostgreSQL, Xorg, Eclipse, Lucene and Jackrabbit. Our personalized approach can discover up to 155 more bugs than the traditional change classification (210 versus 55) if developers inspect the top 20% lines of code that are predicted buggy. In addition, our approach improves the F1-score by 0.01-0.06 compared to the traditional change classification.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693087','10.1109/ASE.2013.6693087',59,61,'IEEE','IEEE Conferences',0),(1107,'Automatically partition software into least privilege components using dynamic data dependency analysis',6,323,333,'The principle of least privilege requires that software components should be granted only necessary privileges, so that compromising one component does not lead to compromising others. However, writing privilege separated software is difficult and as a result, a large number of software is monolithic, i.e., it runs as a whole without separation. Manually rewriting monolithic software into privilege separated software requires significant effort and can be error prone. We propose ProgramCutter, a novel approach to automatically partitioning monolithic software using dynamic data dependency analysis. ProgramCutter works by constructing a data dependency graph whose nodes are functions and edges are data dependencies between functions. The graph is then partitioned into subgraphs where each subgraph represents a least privilege component. The privilege separated software runs each component in a separated process with confined system privileges. We evaluate it by applying it on four open source software. We can reduce the privileged part of the program from 100% to below 22%, while having a reasonable execution time overhead. Since ProgramCutter does not require any expert knowledge of the software, it not only can be used by its developers for software refactoring, but also by end users or system administrators. Our contributions are threefold: (i) we define a quantitative measure of the security and performance of privilege separation; (ii) we propose a graph-based approach to compute the optimal separation based on dynamic information flow analysis; and (iii) the separation process is automatic and does not require expert knowledge of the software.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693091','10.1109/ASE.2013.6693091',31,8,'IEEE','IEEE Conferences',0),(1108,'Synthetic data generation for statistical testing',8,872,882,'Usage-based statistical testing employs knowledge about the actual or anticipated usage profile of the system under test for estimating system reliability. For many systems, usage-based statistical testing involves generating synthetic test data. Such data must possess the same statistical characteristics as the actual data that the system will process during operation. Synthetic test data must further satisfy any logical validity constraints that the actual data is subject to. Targeting data-intensive systems, we propose an approach for generating synthetic test data that is both statistically representative and logically valid. The approach works by first generating a data sample that meets the desired statistical characteristics, without taking into account the logical constraints. Subsequently, the approach tweaks the generated sample to fix any logical constraint violations. The tweaking process is iterative and continuously guided toward achieving the desired statistical characteristics. We report on a realistic evaluation of the approach, where we generate a synthetic population of citizens\' records for testing a public administration IT system. Results suggest that our approach is scalable and capable of simultaneously fulfilling the statistical representativeness and logical validity requirements.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115698','10.1109/ASE.2017.8115698',35,2,'IEEE','IEEE Conferences',0),(1109,'Automatically generating commit messages from diffs using neural machine translation',8,135,146,'Commit messages are a valuable resource in comprehension of software evolution, since they provide a record of changes such as feature additions and bug repairs. Unfortunately, programmers often neglect to write good commit messages. Different techniques have been proposed to help programmers by automatically writing these messages. These techniques are effective at describing what changed, but are often verbose and lack context for understanding the rationale behind a change. In contrast, humans write messages that are short and summarize the high level rationale. In this paper, we adapt Neural Machine Translation (NMT) to automatically \'translate\' diffs into commit messages. We trained an NMT algorithm using a corpus of diffs and human-written commit messages from the top 1k Github projects. We designed a filter to help ensure that we only trained the algorithm on higher-quality commit messages. Our evaluation uncovered a pattern in which the messages we generate tend to be either very high or very low quality. Therefore, we created a quality-assurance filter to detect cases in which we are unable to produce good messages, and return a warning instead.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115626','10.1109/ASE.2017.8115626',59,15,'IEEE','IEEE Conferences',0),(1110,'ICoq: Regression proof selection for large-scale verification projects',8,171,182,'Proof assistants such as Coq are used to construct and check formal proofs in many large-scale verification projects. As proofs grow in number and size, the need for tool support to quickly find failing proofs after revising a project increases. We present a technique for large-scale regression proof selection, suitable for use in continuous integration services, e.g., Travis CI. We instantiate the technique in a tool dubbed ICOQ. ICOQ tracks fine-grained dependencies between Coq definitions, propositions, and proofs, and only checks those proofs affected by changes between two revisions. ICOQ additionally saves time by ignoring changes with no impact on semantics. We applied ICOQ to track dependencies across many revisions in several large Coq projects and measured the time savings compared to proof checking from scratch and when using Coq\'s timestamp-based toolchain for incremental checking. Our results show that proof checking with ICOQ is up to 10 times faster than the former and up to 3 times faster than the latter.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115630','10.1109/ASE.2017.8115630',64,1,'IEEE','IEEE Conferences',0),(1111,'Automating the Extraction of Model-Based Software Product Lines from Model Variants (T)',9,396,406,'We address the problem of automating 1) the analysis of existing similar model variants and 2) migrating them into a software product line. Our approach, named MoVaPL, considers the identification of variability and commonality in model variants, as well as the extraction of a CVL-compliant Model-based Software Product Line (MSPL) from the features identified on these variants. MoVaPL builds on a generic representation of models making it suitable to any MOF-based models. We apply our approach on variants of the open source ArgoUML UML modeling tool as well as on variants of an In-flight Entertainment System. Evaluation with these large and complex case studies contributed to show how our feature identification with structural constraints discovery and the MSPL generation process are implemented to make the approach valid (i.e., the extracted software product line can be used to regenerate all variants considered) and sound (i.e., derived variants We address the problem of automating 1) the analysis of existing similar model variants and 2) migrating them into a software product line. Our approach, named MoVaPL, considers the identification of variability and commonality in model variants, as well as the extraction of a CVL-compliant Model-based Software Product Line (MSPL) from the features identified on these variants. MoVaPL builds on a generic representation of models making it suitable to any MOF-based models. We apply our approach on variants of the open source ArgoUML UML modeling tool as well as on variants of an In-flight Entertainment System. Evaluation with these large and complex case studies contributed to show how our feature identification with structural constraints discovery and the MSPL generation process are implemented to make the approach valid (i.e., the extracted software product line can be used to regenerate all variants considered) and sound (i.e., derived variants which did not exist are at least structurally valid).which did not exist are at least structurally valid).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372028','10.1109/ASE.2015.44',39,19,'IEEE','IEEE Conferences',0),(1112,'Testing Cross-Platform Mobile App Development Frameworks (T)',9,441,451,'Mobile app developers often wish to make their apps available on a wide variety of platforms, e.g., Android, iOS, and Windows devices. Each of these platforms uses a different programming environment, each with its own language and APIs for app development. Small app development teams lack the resources and the expertise to build and maintain separate code bases of the app customized for each platform. As a result, we are beginning to see a number of cross-platform mobile app development frameworks. These frameworks allow the app developers to specify the business logic of the app once, using the language and APIs of a home platform (e.g., Windows Phone), and automatically produce versions of the app for multiple target platforms (e.g., iOS and Android). In this paper, we focus on the problem of testing cross-platform app development frameworks. Such frameworks are challenging to develop because they must correctly translate the home platform API to the (possibly disparate) target platform API while providing the same behavior. We develop a differential testing methodology to identify inconsistencies in the way that these frameworks handle the APIs of the home and target platforms. We have built a prototype testing tool, called X-Checker, and have applied it to test Xamarin, a popular framework that allows Windows Phone apps to be cross-compiled into native Android (and iOS) apps. To date, X-Checker has found 47 bugs in Xamarin, corresponding to inconsistencies in the way that Xamarin translates between the semantics of the Windows Phone and the Android APIs. We have reported these bugs to the Xamarin developers, who have already committed patches for twelve of them.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372032','10.1109/ASE.2015.21',43,4,'IEEE','IEEE Conferences',0),(1113,'A demonstration of simultaneous execution and editing in a development environment',8,895,900,'We introduce a tool within the Code Bubbles development environment that allows for continuous execution as the programmer edits. The tool, SEEDE, shows both the intermediate and final results of execution in terms of variables, control flow, output, and graphics. These results are updated as the user edits. The user can explore the execution to find or fix bugs or use the intermediate values to help write appropriate code. A demonstration video is available at https://www.you-tube.com/watch?v=GpibSxX3Wlw.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115701','10.1109/ASE.2017.8115701',36,0,'IEEE','IEEE Conferences',0),(1114,'Renaming and shifted code in structured merging: Looking ahead for precision and performance',8,543,553,'Diffing and merging of source-code artifacts is an essential task when integrating changes in software versions. While state-of-the-art line-based merge tools (e.g., git merge) are fast and independent of the programming language used, they have only a low precision. Recently, it has been shown that the precision of merging can be substantially improved by using a language-aware, structured approach that works on abstract syntax trees. But, precise structured merging is NP hard, especially, when considering the notoriously difficult scenarios of renamings and shifted code. To address these scenarios without compromising scalability, we propose a syntax-aware, heuristic optimization for structured merging that employs a lookahead mechanism during tree matching. The key idea is that renamings and shifted code are not arbitrarily distributed, but their occurrence follows patterns, which we address with a syntax-specific lookahead. Our experiments with 48 real-world open-source projects (4,878 merge scenarios with over 400 million lines of code) demonstrate that we can significantly improve matching precision in 28 percent of cases while maintaining performance.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115665','10.1109/ASE.2017.8115665',30,3,'IEEE','IEEE Conferences',0),(1115,'Using automatically generated invariants for regression testing and bug localization',6,634,639,'We present Preambl, an approach that applies automatically generated invariants to regression testing and bug localization. Our invariant generation methodology is Precis, an automatic and scalable engine that uses program predicates to guide clustering of dynamically obtained path information. In this paper, we apply it for regression testing and for capturing program predicates information to guide statistical analysis based bug localization. We present a technique to localize bugs in paths of variable lengths. We are able to map the localized post-deployment bugs on a path to pre-release invariants generated along that path. Our experimental results demonstrate the efficacy of the use of PRECIS for regression testing, as well as the ability of Preambl to zone in on relevant segments of program paths.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693125','10.1109/ASE.2013.6693125',17,0,'IEEE','IEEE Conferences',0),(1116,'DRIVER -- A Platform for Collaborative Framework Understanding',9,783,788,'Application frameworks are a powerful technique for large-scale reuse but often very hard to learn from scratch. Although good documentation helps on reducing the learning curve, it is often found lacking, and costly, as it needs to attend different audiences with disparate learning needs. When code and documentation prove insufficient, developers turn to their network of experts. The lack of awareness about the experts, interrupting the wrong people, and experts unavailability are well known hindrances to effective collaboration. This paper presents the DRIVER platform, a collaborative learning environment for framework users to share their knowledge. It provides the documentation on a wiki, where the learning paths of the community of learners can be captured, shared, rated, and recommended, thus tapping into the collective knowledge of the community of framework users. The tool can be obtained at http://bit.ly/driverTool.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372067','10.1109/ASE.2015.105',23,1,'IEEE','IEEE Conferences',0),(1117,'Lazy-CSeq: A Context-Bounded Model Checking Tool for Multi-threaded C-Programs',9,807,812,'Lazy-CSeq is a context-bounded verification tool for sequentially consistent C programs using POSIX threads. It first translates a multi-threaded C program into a bounded nondeterministic sequential C program that preserves bounded reachability for all round-robin schedules up to a given number of rounds. It then reuses existing high-performance bounded model checkers as sequential verification backends. Lazy-CSeq handles the full C language and the main parts of the POSIX thread API, such as dynamic thread creation and deletion, and synchronization via thread join, locks, and condition variables. It supports assertion checking and deadlock detection, and returns counterexamples in case of errors. Lazy-CSeq outperforms other concurrency verification tools and has won the concurrency category of the last two SV-COMP verification competitions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372071','10.1109/ASE.2015.108',39,20,'IEEE','IEEE Conferences',0),(1118,'Variability-aware performance prediction: A statistical learning approach',6,301,311,'Configurable software systems allow stakeholders to derive program variants by selecting features. Understanding the correlation between feature selections and performance is important for stakeholders to be able to derive a program variant that meets their requirements. A major challenge in practice is to accurately predict performance based on a small sample of measured variants, especially when features interact. We propose a variability-aware approach to performance prediction via statistical learning. The approach works progressively with random samples, without additional effort to detect feature interactions. Empirical results on six real-world case studies demonstrate an average of 94% prediction accuracy based on small random samples. Furthermore, we investigate why the approach works by a comparative analysis of performance distributions. Finally, we compare our approach to an existing technique and guide users to choose one or the other in practice.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693089','10.1109/ASE.2013.6693089',27,36,'IEEE','IEEE Conferences',0),(1119,'Improving bug localization using structured information retrieval',6,345,355,'Locating bugs is important, difficult, and expensive, particularly for large-scale systems. To address this, natural language information retrieval techniques are increasingly being used to suggest potential faulty source files given bug reports. While these techniques are very scalable, in practice their effectiveness remains low in accurately localizing bugs to a small number of files. Our key insight is that structured information retrieval based on code constructs, such as class and method names, enables more accurate bug localization. We present BLUiR, which embodies this insight, requires only the source code and bug reports, and takes advantage of bug similarity data if available. We build BLUiR on a proven, open source IR toolkit that anyone can use. Our work provides a thorough grounding of IR-based bug localization research in fundamental IR theoretical and empirical knowledge and practice. We evaluate BLUiR on four open source projects with approximately 3,400 bugs. Results show that BLUiR matches or outperforms a current state-of-the-art tool across applications considered, even when BLUiR does not use bug similarity data used by the other tool.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693093','10.1109/ASE.2013.6693093',46,95,'IEEE','IEEE Conferences',0),(1120,'APIBot: Question answering bot for API documentation',8,153,158,'As the carrier of Application Programming Interfaces (APIs) knowledge, API documentation plays a crucial role in how developers learn and use an API. It is also a valuable information resource for answering API-related questions, especially when developers cannot find reliable answers to their questions online/offline. However, finding answers to API-related questions from API documentation might not be easy because one may have to manually go through multiple pages before reaching the relevant page, and then read and understand the information inside the relevant page to figure out the answers. To deal with this challenge, we develop APIBot, a bot that can answer API questions given API documentation as an input. APIBot is built on top of SiriusQA, the QA system from Sirius, a state of the art intelligent personal assistant. To make SiriusQA work well under software engineering scenario, we make several modifications over SiriusQA by injecting domain specific knowledge. We evaluate APIBot on 92 API questions, answers of which are known to be present in Java 8 documentation. Our experiment shows that APIBot can achieve a Hit@5 score of 0.706.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115628','10.1109/ASE.2017.8115628',21,2,'IEEE','IEEE Conferences',0),(1121,'Proof-based coverage metrics for formal verification',8,194,199,'When using formal verification on critical software, an important question involves whether we have we specified enough properties for a given implementation model. To address this question, coverage metrics for property-based formal verification have been proposed. Existing metrics are usually based on mutation, where the implementation model is repeatedly modified and re-analyzed to determine whether mutant models are \'killed\' by the property set. These metrics tend to be very expensive to compute, as they involve many additional verification problems. This paper proposes an alternate family of metrics that can be computed using the recently introduced idea of Inductive Validity Cores (IVCs). IVCs determine a minimal set of model elements necessary to establish a proof. One of the proposed metrics is both rigorous and substantially cheaper to compute than mutation-based metrics. In addition, unlike the mutation-based techniques, the design elements marked as necessary by the metric are guaranteed to preserve provability. We demonstrate the metrics on a large corpus of examples.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115632','10.1109/ASE.2017.8115632',33,2,'IEEE','IEEE Conferences',0),(1122,'Mutation-Based Fault Localization for Real-World Multilingual Programs (T)',9,464,475,'Programmers maintain and evolve their software in a variety of programming languages to take advantage of various control/data abstractions and legacy libraries. The programming language ecosystem has diversified over the last few decades, and non-trivial programs are likely to be written in more than a single language. Unfortunately, language interfaces such as Java Native Interface and Python/C are difficult to use correctly and the scope of fault localization goes beyond language boundaries, which makes debugging multilingual bugs challenging. To overcome the aforementioned limitations, we propose a mutation-based fault localization technique for real-world multilingual programs. To improve the accuracy of locating multilingual bugs, we have developed and applied new mutation operators as well as conventional mutation operators. The results of the empirical evaluation for six non-trivial real-world multilingual bugs are promising in that the proposed technique identifies the buggy statements as the most suspicious statements for all six bugs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372034','10.1109/ASE.2015.14',51,15,'IEEE','IEEE Conferences',0),(1123,'ModelWriter: Text and model-synchronized document engineering platform',8,907,912,'The ModelWriter platform provides a generic framework for automated traceability analysis. In this paper, we demonstrate how this framework can be used to trace the consistency and completeness of technical documents that consist of a set of System Installation Design Principles used by Airbus to ensure the correctness of aircraft system installation. We show in particular, how the platform allows the integration of two types of reasoning: reasoning about the meaning of text using semantic parsing and description logic theorem proving; and reasoning about document structure using first-order relational logic and finite model finding for traceability analysis.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115703','10.1109/ASE.2017.8115703',32,1,'IEEE','IEEE Conferences',0),(1124,'Detecting unknown inconsistencies in web applications',8,566,577,'Although there has been increasing demand for more reliable web applications, JavaScript bugs abound in web applications. In response to this issue, researchers have proposed automated fault detection tools, which statically analyze the web application code to find bugs. While useful, these tools either only target a limited set of bugs based on predefined rules, or they do not detect bugs caused by cross-language interactions, which occur frequently in web application code. To address this problem, we present an anomaly-based inconsistency detection approach, implemented in a tool called HOLOCRON. The main novelty of our approach is that it does not look for hard-coded inconsistency classes. Instead, it applies subtree pattern matching to infer inconsistency classes and association rule mining to detect inconsistencies that occur both within a single language, and between two languages. We evaluated HOLOCRON, and it successfully detected 51 previously unreported inconsistencies - including 18 bugs and 33 code smells - in 12 web applications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115667','10.1109/ASE.2017.8115667',55,1,'IEEE','IEEE Conferences',0),(1125,'Rethinking pointer reasoning in symbolic execution',8,613,618,'Symbolic execution is a popular program analysis technique that allows seeking for bugs by reasoning over multiple alternative execution states at once. As the number of states to explore may grow exponentially, a symbolic executor may quickly run out of space. For instance, a memory access to a symbolic address may potentially reference the entire address space, leading to a combinatorial explosion of the possible resulting execution states. To cope with this issue, state-of-the-art executors concretize symbolic addresses that span memory intervals larger than some threshold. Unfortunately, this could result in missing interesting execution states, e.g., where a bug arises. In this paper we introduce MEMSIGHT, a new approach to symbolic memory that reduces the need for concretization, hence offering the opportunity for broader state explorations and more precise pointer reasoning. Rather than mapping address instances to data as previous tools do, our technique maps symbolic address expressions to data, maintaining the possible alternative states resulting from the memory referenced by a symbolic address in a compact, implicit form. A preliminary experimental investigation on prominent benchmarks from the DARPA Cyber Grand Challenge shows that MemSight enables the exploration of states unreachable by previous techniques.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115671','10.1109/ASE.2017.8115671',12,1,'IEEE','IEEE Conferences',0),(1126,'ExPort: Detecting and visualizing API usages in large source code repositories',6,646,651,'This paper presents a technique for automatically mining and visualizing API usage examples. In contrast to previous approaches, our technique is capable of finding examples of API usage that occur across several functions in a program. This distinction is important because of a gap between what current API learning tools provide and what programmers need: current tools extract relatively small examples from single files/functions, even though programmers use APIs to build large software. The small examples are helpful in the initial stages of API learning, but leave out details that are helpful in later stages. Our technique is intended to fill this gap. It works by representing software as a Relational Topic Model, where API calls and the functions that use them are modeled as a document network. Given a starting API, our approach can recommend complex API usage examples mined from a repository of over 14 million Java methods.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693127','10.1109/ASE.2013.6693127',27,26,'IEEE','IEEE Conferences',0),(1127,'Assessing the maturity of requirements through argumentation: A good enough approach',6,670,675,'Requirements engineers need to be confident that enough requirements analysis has been done before a project can move forward. In the context of KAOS, this information can be derived from the soundness of the refinements: sound refinements indicate that the requirements in the goal-graph are mature enough or good enough for implementation. We can estimate how close we are to `good enough\' requirements using the judgments of experts and other data from the goals. We apply Toulmin\'s model of argumentation to evaluate how sound refinements are. We then implement the resulting argumentation model using Bayesian Belief Networks and provide a semi-automated way aided by Natural Language Processing techniques to carry out the proposed evaluation. We have performed an initial validation on our work using a small case-study involving an electronic document management system.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693131','10.1109/ASE.2013.6693131',32,1,'IEEE','IEEE Conferences',0),(1128,'Recommending API Usages for Mobile Apps with Hidden Markov Model',9,795,800,'Mobile apps often rely heavily on standard API frameworks and libraries. However, learning to use those APIs is often challenging due to the fast-changing nature of API frameworks and the insufficiency of documentation and code examples. This paper introduces DroidAssist, a recommendation tool for API usages of Android mobile apps. The core of DroidAssist is HAPI, a statistical, generative model of API usages based on Hidden Markov Model. With HAPIs trained from existing mobile apps, DroidAssist could perform code completion for method calls. It can also check existing call sequences to detect and repair suspicious (i.e. unpopular) API usages.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372069','10.1109/ASE.2015.109',22,13,'IEEE','IEEE Conferences',0),(1129,'Detecting and characterizing semantic inconsistencies in ported code',6,367,377,'Adding similar features and bug fixes often requires porting program patches from reference implementations and adapting them to target implementations. Porting errors may result from faulty adaptations or inconsistent updates. This paper investigates (1) the types of porting errors found in practice, and (2) how to detect and characterize potential porting errors. Analyzing version histories, we define five categories of porting errors, including incorrect control- and data-flow, code redundancy, inconsistent identifier renamings, etc. Leveraging this categorization, we design a static control- and data-dependence analysis technique, SPA, to detect and characterize porting inconsistencies. Our evaluation on code from four open-source projects shows that SPA can detect porting inconsistencies with 65% to 73% precision and 90% recall, and identify inconsistency types with 58% to 63% precision and 92% to 100% recall. In a comparison with two existing error detection tools, SPA improves precision by 14 to 17 percentage points.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693095','10.1109/ASE.2013.6693095',22,14,'IEEE','IEEE Conferences',0),(1130,'Synergizing Specification Miners through Model Fissions and Fusions (T)',9,115,125,'Software systems are often developed and released without formal specifications. For those systems that are formally specified, developers have to continuously maintain and update the specifications or have them fall out of date. To deal with the absence of formal specifications, researchers have proposed techniques to infer the missing specifications of an implementation in a variety of forms, such as finite state automaton (FSA). Despite the progress in this area, the efficacy of the proposed specification miners needs to improve if these miners are to be adopted. We propose SpecForge, a new specification mining approach that synergizes many existing specification miners. SpecForge decomposes FSAs that are inferred by existing miners into simple constraints, through a process we refer to as model fission. It then filters the outlier constraints and fuses the constraints back together into a single FSA (i.e., model fusion). We have evaluated SpecForge on execution traces of 10 programs, which includes 5 programs from DaCapo benchmark, to infer behavioral models of 13 library classes. Our results show that SpecForge achieves an average precision, recall and F-measure of 90.57%, 54.58%, and 64.21% respectively. SpecForge outperforms the best performing baseline by 13.75% in terms of F-measure.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372001','10.1109/ASE.2015.83',37,16,'IEEE','IEEE Conferences',0),(1131,'Modular verification of interrupt-driven software',8,206,216,'Interrupts have been widely used in safety-critical computer systems to handle outside stimuli and interact with the hardware, but reasoning about interrupt-driven software remains a difficult task. Although a number of static verification techniques have been proposed for interrupt-driven software, they often rely on constructing a monolithic verification model. Furthermore, they do not precisely capture the complete execution semantics of interrupts such as nested invocations of interrupt handlers. To overcome these limitations, we propose an abstract interpretation framework for static verification of interrupt-driven software that first analyzes each interrupt handler in isolation as if it were a sequential program, and then propagates the result to other interrupt handlers. This iterative process continues until results from all interrupt handlers reach a fixed point. Since our method never constructs the global model, it avoids the up-front blowup in model construction that hampers existing, non-modular, verification techniques. We have evaluated our method on 35 interrupt-driven applications with a total of 22,541 lines of code. Our results show the method is able to quickly and more accurately analyze the behavior of interrupts.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115634','10.1109/ASE.2017.8115634',45,1,'IEEE','IEEE Conferences',0),(1132,'Fuzzing the Rust Typechecker Using CLP (T)',9,482,493,'Language fuzzing is a bug-finding technique for testing compilers and interpreters, its effectiveness depends upon the ability to automatically generate valid programs in the language under test. Despite the proven success of language fuzzing, there is a severe lack of tool support for fuzzing statically-typed languages with advanced type systems because existing fuzzing techniques cannot effectively and automatically generate well-typed programs that use sophisticated types. In this work we describe how to automatically generate well-typed programs that use sophisticated type systems by phrasing the problem of well-typed program generation in terms of Constraint Logic Programming (CLP). In addition, we describe how to specifically target the typechecker implementation for testing, unlike all existing work which ignores the typechecker. We focus on typechecker precision bugs, soundness bugs, and consistency bugs. We apply our techniques to Rust, a complex, industrial-strength language with a sophisticated type system.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372036','10.1109/ASE.2015.65',61,5,'IEEE','IEEE Conferences',0),(1133,'Optimistic Shared Memory Dependence Tracing (T)',9,524,534,'Inter-thread shared memory dependences are crucial to understanding the behavior of concurrent systems, as such dependences are the cornerstone of time-travel debugging and further predictive trace analyses. To enable effective and efficient shared memory dependence tracing, we present an optimistic scheme addressing the challenge of capturing exact dependences between unsynchronized events to reduce the probe effect of program instrumentation. Specifically, our approach achieved a wait-free fast path for thread-local reads on x86-TSO relaxed memory systems, and simultaneously achieved precise tracing of exact read-after-write, write-after-write and write-after-read dependences on the fly. We implemented an open-source RWTrace tool, and evaluation results show that our approach not only achieves efficient shared memory dependence tracing, but also scales well on a multi-core computer system.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372040','10.1109/ASE.2015.11',35,2,'IEEE','IEEE Conferences',0),(1134,'DSSynth: An automated digital controller synthesis tool for physical plants',8,919,924,'We present an automated MATLAB Toolbox, named DSSynth (Digital-System Synthesizer), to synthesize sound digital controllers for physical plants that are represented as linear timeinvariant systems with single input and output. In particular, DSSynth synthesizes digital controllers that are sound w.r.t. stability and safety specifications. DSSynth considers the complete range of approximations, including time discretization, quantization effects and finite-precision arithmetic (and its rounding errors). We demonstrate the practical value of this toolbox by automatically synthesizing stable and safe controllers for intricate physical plant models from the digital control literature. The resulting toolbox enables the application of program synthesis to real-world control engineering problems. A demonstration can be found at https://youtu.be_hLQslRcee8.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115705','10.1109/ASE.2017.8115705',30,0,'IEEE','IEEE Conferences',0),(1135,'Constraint-based automatic symmetry detection',6,15,25,'We present an automatic approach to detecting symmetry relations for general concurrent models. Despite the success of symmetry reduction in mitigating state explosion problem, one essential step towards its soundness and effectiveness, i.e., how to discover sufficient symmetries with least human efforts, is often either overlooked or oversimplified. In this work, we show how a concurrent model can be viewed as a constraint satisfaction problem (CSP), and present an algorithm capable of detecting symmetries arising from the CSP which induce automorphisms of the model. To the best of our knowledge, our method is the first approach that can automatically detect both process and data symmetries as demonstrated via a number of systems.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693062','10.1109/ASE.2013.6693062',37,1,'IEEE','IEEE Conferences',0),(1136,'Automatic testing of symbolic execution engines via program generation and differential testing',8,590,600,'Symbolic execution has attracted significant attention in recent years, with applications in software testing, security, networking and more. Symbolic execution tools, like CREST, KLEE, FuzzBALL, and Symbolic PathFinder, have enabled researchers and practitioners to experiment with new ideas, scale the technique to larger applications and apply it to new application domains. Therefore, the correctness of these tools is of critical importance. In this paper, we present our experience extending compiler testing techniques to find errors in both the concrete and symbolic execution components of symbolic execution engines. The approach used relies on a novel way to create program versions, in three different testing modes-concrete, single-path and multi-path-each exercising different features of symbolic execution engines. When combined with existing program generation techniques and appropriate oracles, this approach enables differential testing within a single symbolic execution engine. We have applied our approach to the KLEE, CREST and FuzzBALL symbolic execution engines, where it has discovered 20 different bugs exposing a variety of important errors having to do with the handling of structures, division, modulo, casting, vector instructions and more, as well as issues related to constraint solving, compiler optimisations and test input replay.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115669','10.1109/ASE.2017.8115669',34,1,'IEEE','IEEE Conferences',0),(1137,'Tortoise: Interactive system configuration repair',8,625,636,'System configuration languages provide powerful abstractions that simplify managing large-scale, networked systems. Thousands of organizations now use configuration languages, such as Puppet. However, specifications written in configuration languages can have bugs and the shell remains the simplest way to debug a misconfigured system. Unfortunately, it is unsafe to use the shell to fix problems when a system configuration language is in use: a fix applied from the shell may cause the system to drift from the state specified by the configuration language. Thus, despite their advantages, configuration languages force system administrators to give up the simplicity and familiarity of the shell. This paper presents a synthesis-based technique that allows administrators to use configuration languages and the shell in harmony. Administrators can fix errors using the shell and the technique automatically repairs the higher-level specification written in the configuration language. The approach (1) produces repairs that are consistent with the fix made using the shell; (2) produces repairs that are maintainable by minimizing edits made to the original specification; (3) ranks and presents multiple repairs when relevant; and (4) supports all shells the administrator may wish to use. We implement our technique for Puppet, a widely used system configuration language, and evaluate it on a suite of benchmarks under 42 repair scenarios. The top-ranked repair is selected by humans 76% of the time and the human-equivalent repair is ranked 1.31 on average.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115673','10.1109/ASE.2017.8115673',63,6,'IEEE','IEEE Conferences',0),(1138,'A pattern-based approach to parametric specification mining',6,658,663,'This paper presents a technique for using execution traces to mine parametric temporal specifications in the form of quantified event automata (QEA) - previously introduced as an expressive and efficient formalism for runtime verification. We consider a pattern-based mining approach that uses a pattern library to generate and check potential properties over given traces, and then combines successful patterns. By using predefined models to measure the tool\'s precision and recall we demonstrate that our approach can effectively and efficiently extract specifications in realistic scenarios.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693129','10.1109/ASE.2013.6693129',18,13,'IEEE','IEEE Conferences',0),(1139,'Model/code co-refactoring: An MDE approach',6,682,687,'Model-driven engineering suggests that models are the primary artefacts of software development. This means that models may be refactored even after code has been generated from them, in which case the code must be changed to reflect the refactoring. However, as we show neither re-generating the code from the refactored model nor applying an equivalent refactoring to the generated code is sufficient to keep model and code in sync - rather, model and code need to be refactored jointly. To enable this, we investigate the technical requirements of model/code co-refactoring, and implement a model-driven solution that we evaluate using a set of open-source programs and their structural models. Results suggest that our approach is feasible.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693133','10.1109/ASE.2013.6693133',19,7,'IEEE','IEEE Conferences',0),(1140,'CIVL: Formal Verification of Parallel Programs',9,830,835,'CIVL is a framework for static analysis and verification of concurrent programs. One of the main challenges to practical application of these techniques is the large number of ways to express concurrency: MPI, OpenMP, CUDA, and Pthreads, for example, are just a few of many \'concurrency dialects\' in wide use today. These dialects are constantly evolving and it is increasingly common to use several of them in a single \'hybrid\' program. CIVL addresses these problems by providing a concurrency intermediate verification language, CIVL-C, as well as translators that consume C programs using these dialects and produce CIVL-C. Analysis and verification tools which operate on CIVL-C can then be applied easily to a wide variety of concurrent C programs. We demonstrate CIVL\'s error detection and verification capabilities on (1) an MPI+OpenMP program that estimates 蟺 and contains a subtle race condition, and (2) an MPI-based 1d-wave simulator that fails to conform to a simple sequential implementation.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372075','10.1109/ASE.2015.99',34,8,'IEEE','IEEE Conferences',0),(1141,'Characterizing and detecting resource leaks in Android applications',6,389,398,'Android phones come with a host of hardware components embedded in them, such as Camera, Media Player and Sensor. Most of these components are exclusive resources or resources consuming more memory/energy than general. And they should be explicitly released by developers. Missing release operations of these resources might cause serious problems such as performance degradation or system crash. These kinds of defects are called resource leaks. This paper focuses on resource leak problems in Android apps, and presents our lightweight static analysis tool called Relda, which can automatically analyze an application\'s resource operations and locate the resource leaks. We propose an automatic method for detecting resource leaks based on a modified Function Call Graph, which handles the features of event-driven mobile programming by analyzing the callbacks defined in Android framework. Our experimental data shows that Relda is effective in detecting resource leaks in real Android apps.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693097','10.1109/ASE.2013.6693097',49,36,'IEEE','IEEE Conferences',0),(1142,'Dynamically Testing GUIs Using Ant Colony Optimization (T)',9,138,148,'In this paper we introduce a dynamic GUI test generator that incorporates ant colony optimization. We created two ant systems for generating tests. Our first ant system implements the normal ant colony optimization algorithm in order to traverse the GUI and find good event sequences. Our second ant system, called AntQ, implements the antq algorithm that incorporates Q-Learning, which is a behavioral reinforcement learning technique. Both systems use the same fitness function in order to determine good paths through the GUI. Our fitness function looks at the amount of change in the GUI state that each event causes. Events that have a larger impact on the GUI state will be favored in future tests. We compared our two ant systems to random selection. We ran experiments on six subject applications and report on the code coverage and fault finding abilities of all three algorithms.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372003','10.1109/ASE.2015.70',38,5,'IEEE','IEEE Conferences',0),(1143,'Static detection of asymptotic resource side-channel vulnerabilities in web applications',8,229,239,'Web applications can leak confidential user information due to the presence of unintended side-channel vulnerabilities in code. One particularly subtle class of side-channel vulnerabilities arises due to resource usage imbalances along different execution paths of a program. Such side-channel vulnerabilities are especially severe if the resource usage imbalance is asymptotic. This paper formalizes the notion of asymptotic resource side-channels and presents a lightweight static analysis algorithm for automatically detecting them. Based on these ideas, we have developed a tool called SCANNER that detects resource-related side-channel vulnerabilities in PHP applications. SCANNER has found 18 zero-day security vulnerabilities in 10 different web applications and reports only 2 false positives. The vulnerabilities uncovered by SCANNER can be exploited using cross-site search attacks to extract various kinds of confidential information, such as a user\'s medications or purchase history.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115636','10.1109/ASE.2017.8115636',48,0,'IEEE','IEEE Conferences',0),(1144,'Automatically assessing crashes from heap overflows',8,274,279,'Heap overflow is one of the most widely exploited vulnerabilities, with a large number of heap overflow instances reported every year. It is important to decide whether a crash caused by heap overflow can be turned into an exploit. Efficient and effective assessment of exploitability of crashes facilitates to identify severe vulnerabilities and thus prioritize resources. In this paper, we propose the first metrics to assess heap overflow crashes based on both the attack aspect and the feasibility aspect. We further present HCSIFTER, a novel solution to automatically assess the exploitability of heap overflow instances under our metrics. Given a heap-based crash, HCSIFTER accurately detects heap overflows through dynamic execution without any source code or debugging information. Then it uses several novel methods to extract program execution information needed to quantify the severity of the heap overflow using our metrics. We have implemented a prototype HCSIFTER and applied it to assess nine programs with heap overflow vulnerabilities. HCSIFTER successfully reports that five heap overflow vulnerabilities are highly exploitable and two overflow vulnerabilities are unlikely exploitable. It also gave quantitatively assessments for other two programs. On average, it only takes about two minutes to assess one heap overflow crash. The evaluation result demonstrates both effectiveness and efficiency of HC Sifter.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115640','10.1109/ASE.2017.8115640',25,0,'IEEE','IEEE Conferences',0),(1145,'Development Emails Content Analyzer: Intention Mining in Developer Discussions (T)',9,12,23,'Written development communication (e.g. mailing lists, issue trackers) constitutes a precious source of information to build recommenders for software engineers, for example aimed at suggesting experts, or at redocumenting existing source code. In this paper we propose a novel, semi-supervised approach named DECA (Development Emails Content Analyzer) that uses Natural Language Parsing to classify the content of development emails according to their purpose (e.g. feature request, opinion asking, problem discovery, solution proposal, information giving etc), identifying email elements that can be used for specific tasks. A study based on data from Qt and Ubuntu, highlights a high precision (90%) and recall (70%) of DECA in classifying email content, outperforming traditional machine learning strategies. Moreover, we successfully used DECA for re-documenting source code of Eclipse and Lucene, improving the recall, while keeping high precision, of a previous approach based on ad-hoc heuristics.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7371991','10.1109/ASE.2015.12',59,24,'IEEE','IEEE Conferences',0),(1146,'Towards precise metrics for predicting graph query performance',6,421,431,'Queries are the foundations of data intensive applications. In model-driven software engineering (MDSE), model queries are core technologies of tools and transformations. As software models are rapidly increasing in size and complexity, most MDSE tools frequently exhibit scalability issues that decrease developer productivity and increase costs. As a result, choosing the right model representation and query evaluation approach is a significant challenge for tool engineers. In the current paper, we aim to provide a benchmarking framework for the systematic investigation of query evaluation performance. More specifically, we experimentally evaluate (existing and novel) query and instance model metrics to highlight which provide sufficient performance estimates for different MDSE scenarios in various model query tools. For that purpose, we also present a comparative benchmark, which is designed to differentiate model representation and graph query evaluation approaches according to their performance when using large models and complex queries.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693100','10.1109/ASE.2013.6693100',39,5,'IEEE','IEEE Conferences',0),(1147,'Automatically Generating Test Templates from Test Names (N)',9,506,511,'Existing specification-based testing techniques require specifications that either do not exist or are too difficult to create. As a result, they often fall short of their goal of helping developers test expected behaviors. In this paper we present a novel, natural language-based approach that exploits the descriptive nature of test names to generate test templates. Similar to how modern IDEs simplify development by providing templates for common constructs such as loops, test templates can save time and lower the cognitive barrier for writing tests. The results of our evaluation show that the approach is feasible: despite the difficulty of the task, when test names contain a sufficient amount of information, the approach\'s accuracy is over 80% when parsing the relevant information from the test name and generating the template.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372038','10.1109/ASE.2015.68',21,3,'IEEE','IEEE Conferences',0),(1148,'Practically Tunable Static Analysis Framework for Large-Scale JavaScript Applications (T)',9,541,551,'We present a novel approach to analyze large-scale JavaScript applications statically by tuning the analysis scalability possibly giving up its soundness. For a given sound static baseline analysis of JavaScript programs, our framework allows users to define a sound approximation of selected executions that they are interested in analyzing, and it derives a tuned static analysis that can analyze the selected executions practically. The selected executions serve as parameters of the framework by taking trade-off between the scalability and the soundness of derived analyses. We formally describe our framework in abstract interpretation, and implement two instances of the framework. We evaluate them by analyzing large-scale real-world JavaScript applications, and the evaluation results show that the framework indeed empowers users to experiment with different levels of scalability and soundness. Our implementation provides an extra level of scalability by deriving sparse versions of derived analyses, and the implementation is publicly available.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372042','10.1109/ASE.2015.28',34,6,'IEEE','IEEE Conferences',0),(1149,'CogniCrypt: Supporting developers in using cryptography',8,931,936,'Previous research suggests that developers often struggle using low-level cryptographic APIs and, as a result, produce insecure code. When asked, developers desire, among other things, more tool support to help them use such APIs. In this paper, we present CogniCrypt, a tool that supports developers with the use of cryptographic APIs. CogniCrypt assists the developer in two ways. First, for a number of common cryptographic tasks, CogniCrypt generates code that implements the respective task in a secure manner. Currently, CogniCrypt supports tasks such as data encryption, communication over secure channels, and long-term archiving. Second, CogniCrypt continuously runs static analyses in the background to ensure a secure integration of the generated code into the developer\'s workspace. This video demo showcases the main features of CogniCrypt: youtube.com/watch?v=JUq5mRHfAWY.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115707','10.1109/ASE.2017.8115707',28,6,'IEEE','IEEE Conferences',0),(1150,'EventFlowSlicer: A tool for generating realistic goal-driven GUI tests',8,955,960,'Most automated testing techniques for graphical user interfaces (GUIs) produce test cases that are only concerned with covering the elements (widgets, menus, etc.) on the interface, or the underlying program code, with little consideration of test case semantics. This is effective for functional testing where the aim is to find as many faults as possible. However, when one wants to mimic a real user for evaluating usability, or when it is necessary to extensively test important end-user tasks of a system, or to generate examples of how to use an interface, this generation approach fails. Capture and replay techniques can be used, however there are often multiple ways to achieve a particular goal, and capturing all of these is usually too time consuming and unrealistic. Prior work on human performance regression testing introduced a constraint based method to filter test cases created by a functional test case generator, however that work did not capture the specifications, or directly generate only the required tests and considered only a single type of test goal. In this paper we present EventFlowSlicer, a tool that allows the GUI tester to specify and generate all realistic test cases relevant to achieve a stated goal. The user first captures relevant events on the interface, then adds constraints to provide restrictions on the task. An event flow graph is extracted containing only the widgets of interest for that goal. Next all test cases are generated for edges in the graph which respect the constraints. The test cases can then be replayed using a modified version of GUITAR. A video demonstration of EventFlowSlicer can be found at https://youtu.be/hw7WYz8WYVU.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115711','10.1109/ASE.2017.8115711',21,1,'IEEE','IEEE Conferences',0),(1151,'Efficient data race prediction with incremental reasoning on time-stamped lock history',6,37,47,'We present an efficient data race prediction algorithm that uses lock-reordering based incremental search on time-stamped lock histories for solving multiple races effectively. We balance prediction accuracy, coverage, and performance with a specially designed pairwise reachability algorithm that can store and re-use past search results, thereby, amortizing the cost of reasoning over redundant and overlapping search space. Compared to graph-based search algorithms, our algorithm incurs much smaller overhead due to amortization, and can potentially be used while a program under test is executing. To demonstrate such a possibility, we implemented our approach as an incremental Predictive Analysis (iPA) module in a predictive testing framework. Our approach can handle traces with a few hundreds to half a million events, and predict known/unknown real data races with a performance penalty of less than 4% in addition to what is incurred by runtime race detectors.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693064','10.1109/ASE.2013.6693064',37,1,'IEEE','IEEE Conferences',0),(1152,'Elixir: Effective object-oriented program repair',8,648,659,'This work is motivated by the pervasive use of method invocations in object-oriented (OO) programs, and indeed their prevalence in patches of OO-program bugs. We propose a generate-and-validate repair technique, called ELIXIR designed to be able to generate such patches. ELIXIR aggressively uses method calls, on par with local variables, fields, or constants, to construct more expressive repair-expressions, that go into synthesizing patches. The ensuing enlargement of the repair space, on account of the wider use of method calls, is effectively tackled by using a machine-learnt model to rank concrete repairs. The machine-learnt model relies on four features derived from the program context, i.e., the code surrounding the potential repair location, and the bug report. We implement ELIXIR and evaluate it on two datasets, the popular Defects4J dataset and a new dataset Bugs.jar created by us, and against 2 baseline versions of our technique, and 5 other techniques representing the state of the art in program repair. Our evaluation shows that ELIXIR is able to increase the number of correctly repaired bugs in Defects4J by 85% (from 14 to 26) and by 57% in Bugs.jar (from 14 to 22), while also significantly out-performing other state-of-the-art repair techniques including ACS, HD-Repair, NOPOL, PAR, and jGenProg.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115675','10.1109/ASE.2017.8115675',45,17,'IEEE','IEEE Conferences',0),(1153,'Model repair and transformation with Echo',6,694,697,'Models are paramount in model-driven engineering. In a software project many models may coexist, capturing different views of the system or different levels of abstraction. A key and arduous task in this development method is to keep all such models consistent, both with their meta-models (and the respective constraints) and among themselves. This paper describes Echo, a tool that aims at simplifying this task by automating inconsistency detection and repair using a solver based engine. Consistency between different models can be specified by bidirectional model transformations, and is guaranteed to be recovered by minimal updates on the inconsistent models. The tool is freely available as an Eclipse plugin, developed on top of the popular EMF framework, and supports constraints and transformations specified in the OMG standard languages OCL and QVT-R, respectively.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693135','10.1109/ASE.2013.6693135',15,11,'IEEE','IEEE Conferences',0),(1154,'GRT: An Automated Test Generator Using Orchestrated Program Analysis',9,842,847,'While being highly automated and easy to use, existing techniques of random testing suffer from low code coverage and defect detection ability for practical software applications. Most tools use a pure black-box approach, which does not use knowledge specific to the software under test. Mining and leveraging the information of the software under test can be promising to guide random testing to overcome such limitations. Guided Random Testing (GRT) implements this idea. GRT performs static analysis on software under test to extract relevant knowledge and further combines the information extracted at run-time to guide the whole test generation procedure. GRT is highly configurable, with each of its six program analysis components implemented as a pluggable module whose parameters can be adjusted. Besides generating test cases, GRT also automatically creates a test coverage report. We show our experience in GRT tool development and demonstrate its practical usage using two concrete application scenarios.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372077','10.1109/ASE.2015.102',38,8,'IEEE','IEEE Conferences',0),(1155,'ActivitySpace: A Remembrance Framework to Support Interapplication Information Needs',9,864,869,'Developers\' daily work produces, transforms, and communicates cross-cutting information across applications, including IDEs, emails, Q&A sites, Twitter, and many others. However, these applications function independently of one another. Even though each application has their own effective information management mechanisms, cross-cutting information across separate applications creates a problem of information fragmentation, forcing developers to manually track, correlate, and re-find cross-cutting information across applications. In this paper, we present ActivitySpace, a remembrance framework that unobtrusively tracks and analyze a developer\'s daily work in separate applications, and provides various semantic and episodic UIs that help developers correlate and re-find cross-cutting information across applications based on information content, time and place of his/her activities. Through a user study of 8 participants, we demonstrate how ActivitySpace helps to tackle information fragmentation problem in developers\' daily work.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372081','10.1109/ASE.2015.90',21,7,'IEEE','IEEE Conferences',0),(1156,'Dynamically transforming data structures',6,410,420,'Fine-tuning which data structure implementation to use for a given problem is sometimes tedious work since the optimum solution depends on the context, i.e., on the operation sequences, actual parameters as well as on the hardware available at run time. Sometimes a data structure with higher asymptotic time complexity performs better in certain contexts because of lower constants. The optimal solution may not even be possible to determine at compile time. We introduce transformation data structures that dynamically change their internal representation variant based on a possibly changing context. The most suitable variant is selected at run time rather than at compile time. We demonstrate the effect on performance with a transformation ArrayList data structure using an array variant and a linked hash bag variant as alternative internal representations. Using our transformation ArrayList, the standard DaCapo benchmark suite shows a performance gain of 5.19% in average.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693099','10.1109/ASE.2013.6693099',15,1,'IEEE','IEEE Conferences',0),(1157,'Array Shadow State Compression for Precise Dynamic Race Detection (T)',9,155,165,'Precise dynamic race detectors incur significant time and space overheads, particularly for array-intensive programs, due to the need to store and manipulate analysis (or shadow) state for every element of every array. This paper presents SlimState, a precise dynamic race detector that uses an adaptive, online algorithm to optimize array shadow state representations. SlimState is based on the insight that common array access patterns lead to analogous patterns in array shadow state, enabling optimized, space efficient representations of array shadow state with no loss in precision. We have implemented SlimState for Java. Experiments on a variety of benchmarks show that array shadow compression reduces the space and time overhead of race detection by 27% and 9%, respectively. It is particularly effective for array-intensive programs, reducing space and time overheads by 35% and 17%, respectively, on these programs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372005','10.1109/ASE.2015.19',46,11,'IEEE','IEEE Conferences',0),(1158,'All about activity injection: Threats, semantics, and detection',8,252,262,'Android supports seamless user experience by maintaining activities from different apps in the same activity stack. While such close inter-app communication is essential in the Android framework, the powerful inter-app communication contains vulnerabilities that can inject malicious activities into a victim app\'s activity stack to hijack user interaction flows. In this paper, we demonstrate activity injection attacks with a simple malware, and formally specify the activity activation mechanism using operational semantics. Based on the operational semantics, we develop a static analysis tool, which analyzes Android apps to detect activity injection attacks. Our tool is fast enough to analyze real-world Android apps in 6 seconds on average, and our experiments found that 1,761 apps out of 129,756 real-world Android apps inject their activities into other apps\' tasks.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115638','10.1109/ASE.2017.8115638',55,0,'IEEE','IEEE Conferences',0),(1159,'UI driven Android application reduction',8,286,296,'While smartphones and mobile apps have been an integral part of our life, modern mobile apps tend to contain a lot of rarely used functionalities. For example, applications contain advertisements and offer extra features such as recommended news stories in weather apps. While these functionalities are not essential to an app, they nonetheless consume power, CPU cycles and bandwidth. In this paper, we design a UI driven approach that allows customizing an Android app by removing its unwanted functionalities. In particular, our technique displays the UI and allows the user to select elements denoting functionalities that she wants to remove. Using this information, our technique automatically removes all the code elements related to the selected functionalities, including all the relevant background tasks. The underlying analysis is a type system, in which each code element is tagged with a type indicating if it should be removed. From the UI hints, our technique infers types for all other code elements and reduces the app accordingly. We implement a prototype and evaluate it on 10 real-world Android apps. The results show that our approach can accurately discover the removable code elements and lead to substantial resource savings in the reduced apps.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115642','10.1109/ASE.2017.8115642',38,0,'IEEE','IEEE Conferences',0),(1160,'How do Developers Document Database Usages in Source Code? (N)',9,36,41,'Database-centric applications (DCAs) usually contain a large number of tables, attributes, and constraints describing the underlying data model. Understanding how database tables and attributes are used in the source code along with the constraints related to these usages is an important component of DCA maintenance. However, documenting database-related operations and their constraints in the source code is neither easy nor common in practice. In this paper, we present a two-fold empirical study aimed at identifying how developers document database usages at source code method level. In particular, (i) we surveyed open source developers to understand their practices on documenting database usages in source code, and (ii) we mined a large set of open source projects to measure to what extent database-related methods are commented and if these comments are updated during evolution. Although 58% of the developers claimed to find value in method comments describing database usages, our findings suggest that 77% of 33K+ methods in 3.1K+ open-source Java projects with database accesses were completely undocumented.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7371993','10.1109/ASE.2015.67',31,7,'IEEE','IEEE Conferences',0),(1161,'Mining branching-time scenarios',6,443,453,'Specification mining extracts candidate specification from existing systems, to be used for downstream tasks such as testing and verification. Specifically, we are interested in the extraction of behavior models from execution traces. In this paper we introduce mining of branching-time scenarios in the form of existential, conditional Live Sequence Charts, using a statistical data-mining algorithm. We show the power of branching scenarios to reveal alternative scenario-based behaviors, which could not be mined by previous approaches. The work contrasts and complements previous works on mining linear-time scenarios. An implementation and evaluation over execution trace sets recorded from several real-world applications shows the unique contribution of mining branching-time scenarios to the state-of-the-art in specification mining.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693102','10.1109/ASE.2013.6693102',42,17,'IEEE','IEEE Conferences',0),(1162,'Variable Feature Usage Patterns in PHP (T)',9,563,573,'PHP allows the names of variables, classes, functions, methods, and properties to be given dynamically, as expressions that, when evaluated, return an identifier as a string. While this provides greater flexibility for programmers, it also makes PHP programs harder to precisely analyze and understand. In this paper we present a number of patterns designed to recognize idiomatic uses of these features that can be statically resolved to a precise set of possible names. We then evaluate these patterns across a corpus of 20 open-source systems totaling more than 3.7 million lines of PHP, showing how often these patterns occur in actual PHP code, demonstrating their effectiveness at statically determining the names that can be used at runtime, and exploring anti-patterns that indicate when the identifier computation is truly dynamic.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372044','10.1109/ASE.2015.72',22,6,'IEEE','IEEE Conferences',0),(1163,'Taco: A tool to generate tensor algebra kernels',8,943,948,'Tensor algebra is an important computational abstraction that is increasingly used in data analytics, machine learning, engineering, and the physical sciences. However, the number of tensor expressions is unbounded, which makes it hard to develop and optimize libraries. Furthermore, the tensors are often sparse (most components are zero), which means the code has to traverse compressed formats. To support programmers we have developed taco, a code generation tool that generates dense, sparse, and mixed kernels from tensor algebra expressions. This paper describes the taco web and command-line tools and discusses the benefits of a code generator over a traditional library. See also the demo video at tensor-compiler.org/ase2017.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115709','10.1109/ASE.2017.8115709',25,2,'IEEE','IEEE Conferences',0),(1164,'FEMIR: A tool for recommending framework extension examples',8,967,972,'Software frameworks enable developers to reuse existing well tested functionalities instead of taking the burden of implementing everything from scratch. However, to meet application specific requirements, the frameworks need to be customized via extension points. This is often done by passing a framework related object as an argument to an API call. To enable such customizations, the object can be created by extending a framework class, implementing an interface, or changing the properties of the object via API calls. However, it is both a common and non-trivial task to find all the details related to the customizations. In this paper, we present a tool, called FEMIR, that utilizes partial program analysis and graph mining technique to detect, group, and rank framework extension examples. The tool extends existing code completion infrastructure to inform developers about customization choices, enabling them to browse through extension points of a framework, and frequent usages of each point in terms of code examples. A video demo is made available at https://asaduzzamanparvez.wordpress.com/femir.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115713','10.1109/ASE.2017.8115713',8,1,'IEEE','IEEE Conferences',0),(1165,'Improving efficiency of dynamic analysis with dynamic dependence summaries',6,59,69,'Modern applications make heavy use of third-party libraries and components, which poses new challenges for efficient dynamic analysis. To perform such analyses, transitive dependent components at all layers of the call stack must be monitored and analyzed, and as such may be prohibitively expensive for systems with large libraries and components. As an approach to address such expenses, we record, summarize, and reuse dynamic dataflows between inputs and outputs of components, based on dynamic control and data traces. These summarized dataflows are computed at a fine-grained instruction level; the result of which, we call 鈥渄ynamic dependence summaries.鈥� Although static summaries have been proposed, to the best of our knowledge, this work presents the first technique for dynamic dependence summaries. The benefits to efficiency of such summarization may be afforded with losses of accuracy. As such, we evaluate the degree of accuracy loss and the degree of efficiency gain when using dynamic dependence summaries of library methods. On five large programs from the DaCapo benchmark (for which no existing whole-program dynamic dependence analyses have been shown to scale) and 21 versions of NANOXML, the summarized dependence analysis provided 90% accuracy and a speed-up of 100% (i.e., 脳2), on average, when compared to traditional exhaustive dynamic dependence analysis.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693066','10.1109/ASE.2013.6693066',34,6,'IEEE','IEEE Conferences',0),(1166,'Operator-based and random mutant selection: Better together',6,92,102,'Mutation testing is a powerful methodology for evaluating the quality of a test suite. However, the methodology is also very costly, as the test suite may have to be executed for each mutant. Selective mutation testing is a well-studied technique to reduce this cost by selecting a subset of all mutants, which would otherwise have to be considered in their entirety. Two common approaches are operator-based mutant selection, which only generates mutants using a subset of mutation operators, and random mutant selection, which selects a subset of mutants generated using all mutation operators. While each of the two approaches provides some reduction in the number of mutants to execute, applying either of the two to medium-sized, real-world programs can still generate a huge number of mutants, which makes their execution too expensive. This paper presents eight random sampling strategies defined on top of operator-based mutant selection, and empirically validates that operator-based selection and random selection can be applied in tandem to further reduce the cost of mutation testing. The experimental results show that even sampling only 5% of mutants generated by operator-based selection can still provide precise mutation testing results, while reducing the average mutation testing time to 6.54% (i.e., on average less than 5 minutes for this study).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693070','10.1109/ASE.2013.6693070',65,27,'IEEE','IEEE Conferences',0),(1167,'Boosting complete-code tool for partial program',8,671,681,'To improve software quality, researchers and practitioners have proposed static analysis tools for various purposes (e.g., detecting bugs, anomalies, and vulnerabilities). Although many such tools are powerful, they typically need complete programs where all the code names (e.g., class names, method names) are resolved. In many scenarios, researchers have to analyze partial programs in bug fixes (the revised source files can be viewed as a partial program), tutorials, and code search results. As a partial program is a subset of a complete program, many code names in partial programs are unknown. As a result, despite their syntactical correctness, existing complete-code tools cannot analyze partial programs, and existing partial-code tools are limited in both their number and analysis capability. Instead of proposing another tool for analyzing partial programs, we propose a general approach, called GRAPA, that boosts existing tools for complete programs to analyze partial programs. Our major insight is that after unknown code names are resolved, tools for complete programs can analyze partial programs with minor modifications. In particular, GRAPA locates Java archive files to resolve unknown code names, and resolves the remaining unknown code names from resolved code names. To illustrate GRAPA, we implement a tool that leverages the state-of-the-art tool, WALA, to analyze Java partial programs. We thus implemented the first tool that is able to build system dependency graphs for partial programs, complementing existing tools. We conduct an evaluation on 8,198 partial-code commits from four popular open source projects. Our results show that GRAPA fully resolved unknown code names for 98.5% bug fixes, with an accuracy of 96.1% in total. Furthermore, our results show the significance of GRAPA\'s internal techniques, which provides insights on how to integrate with more complete-code tools to analyze partial programs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115677','10.1109/ASE.2017.8115677',44,3,'IEEE','IEEE Conferences',0),(1168,'AnswerBot: Automated generation of answer summary to developers\' technical questions',8,706,716,'The prevalence of questions and answers on domain-specific Q&A sites like Stack Overflow constitutes a core knowledge asset for software engineering domain. Although search engines can return a list of questions relevant to a user query of some technical question, the abundance of relevant posts and the sheer amount of information in them makes it difficult for developers to digest them and find the most needed answers to their questions. In this work, we aim to help developers who want to quickly capture the key points of several answer posts relevant to a technical question before they read the details of the posts. We formulate our task as a query-focused multi-answer-posts summarization task for a given technical question. Our proposed approach AnswerBot contains three main steps : 1) relevant question retrieval, 2) useful answer paragraph selection, 3) diverse answer summary generation. To evaluate our approach, we build a repository of 228,817 Java questions and their corresponding answers from Stack Overflow. We conduct user studies with 100 randomly selected Java questions (not in the question repository) to evaluate the quality of the answer summaries generated by our approach, and the effectiveness of its relevant question retrieval and answer paragraph selection components. The user study results demonstrate that answer summaries generated by our approach are relevant, useful and diverse; moreover, the two components are able to effectively retrieve relevant questions and select salient answer paragraphs for summarization.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115681','10.1109/ASE.2017.8115681',30,7,'IEEE','IEEE Conferences',0),(1169,'OCRA: A tool for checking the refinement of temporal contracts',6,702,705,'Contract-based design enriches a component model with properties structured in pairs of assumptions and guarantees. These properties are expressed in term of the variables at the interface of the components, and specify how a component interacts with its environment: the assumption is a property that must be satisfied by the environment of the component, while the guarantee is a property that the component must satisfy in response. Contract-based design has been recently proposed in many methodologies for taming the complexity of embedded systems. In fact, contract-based design enables stepwise refinement, compositional verification, and reuse of components. However, only few tools exist to support the formal verification underlying these methods. OCRA (Othello Contracts Refinement Analysis) is a new tool that provides means for checking the refinement of contracts specified in a linear-time temporal logic. The specification language allows to express discrete as well as metric real-time constraints. The underlying reasoning engine allows checking if the contract refinement is correct. OCRA has been used in different projects and integrated in CASE tools.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693137','10.1109/ASE.2013.6693137',26,44,'IEEE','IEEE Conferences',0),(1170,'SiPL -- A Delta-Based Modeling Framework for Software Product Line Engineering',9,852,857,'Model-based development has become a widely-used approach to implement software, e.g. for embedded systems. Models replace source code as primary executable artifacts in these cases. Software product line technologies for these domains must be able to generate models as instances of an SPL. This need is addressed among others by an implementation technology for SPLs known as delta modeling. Current approaches to delta modeling require deltas to be written manually using delta languages, and they offer only very limited support for creating and testing a network of deltas. This paper presents a new approach to delta modeling and a supporting tool suite: the abstract notion of a delta is refined to be a consistency-preserving edit script which is generated by comparing two models. The rich structure of edit scripts allows us to detect conflicts and further relations between deltas statically and to implement restructurings in delta sets such as the merging of two deltas. We illustrate the tooling using a case study.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372079','10.1109/ASE.2015.106',30,4,'IEEE','IEEE Conferences',0),(1171,'The iMPAcT Tool: Testing UI Patterns on Mobile Applications',9,876,881,'This paper presents the iMPAcT tool that tests recurring behaviour, i.e., UI Patterns, on mobile applications. This tool is implemented in Java and makes use of Android\'s APIs UI Automator and UiAutomation. The tool automatically explores a mobile application in order to automatically identify and test UI Patterns. Each UI Pattern has a test strategy, Test Patterns, associated, which is applied when an UI Pattern is found. The approach works on top of a catalogue of UI Patterns, which determines which UI Patterns are to be tested, and what should their correct behaviour be, and may be used for any application.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372083','10.1109/ASE.2015.96',34,9,'IEEE','IEEE Conferences',0),(1172,'JaConTeBe: A Benchmark Suite of Real-World Java Concurrency Bugs (T)',9,178,189,'Researchers have proposed various approaches to detect concurrency bugs and improve multi-threaded programs, but performing evaluations of the effectiveness of these approaches still remains a substantial challenge. We survey the existing evaluations and find out that they often use code or bugs not representative of real world. To improve representativeness, we have prepared JaConTeBe, a benchmark suite of 47 confirmed concurrency bugs from 8 popular open-source projects, supplemented with test cases for reproducing buggy behaviors. Running three approaches on JaConTeBe shows that our benchmark suite confirms some limitations of the three approaches. We submitted JaConTeBe to the SIR repository (a software-artifact repository for rigorous controlled experiments), and it was included as a part of SIR.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372007','10.1109/ASE.2015.87',85,8,'IEEE','IEEE Conferences',0),(1173,'Study and Refactoring of Android Asynchronous Programming (T)',9,224,235,'To avoid unresponsiveness, a core part of mobile development is asynchronous programming. Android providesseveral async constructs that developers can use. However, developers can still use the inappropriate async constructs, which result in memory leaks, lost results, and wasted energy. Fortunately, refactoring tools can eliminate these problems by transforming async code to use the appropriate constructs. In this paper we conducted a formative study on a corpusof 611 widely-used Android apps to map the asynchronouslandscape of Android apps, understand how developers retrofit asynchrony, and learn about barriers encountered by developers. Based on this study, we designed, implemented, and evaluated ASYNCDROID, a refactoring tool which enables Android developers to transform existing improperly-used async constructs into correct constructs. Our empirical evaluation shows that ASYNCDROID is applicable, accurate, and saves developers effort. We submitted 45 refactoring patches, and developers consider that the refactorings are useful.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372011','10.1109/ASE.2015.50',51,23,'IEEE','IEEE Conferences',0),(1174,'Automated cross-platform inconsistency detection for mobile apps',8,308,318,'Testing of Android apps is particularly challenging due to the fragmentation of the Android ecosystem in terms of both devices and operating system versions. Developers must in fact ensure not only that their apps behave as expected, but also that the apps\' behavior is consistent across platforms. To support this task, we propose DiffDroid, a new technique that helps developers automatically find cross-platform inconsistencies (CPIs) in mobile apps. DiffDroid combines input generation and differential testing to compare the behavior of an app on different platforms and identify possible inconsistencies. Given an app, DiffDroid (1) generates test inputs for the app, (2) runs the app with these inputs on a reference device and builds a model of the app behavior, (3) runs the app with the same inputs on a set of other devices, and (4) compares the behavior of the app on these different devices with the model of its behavior on the reference device. We implemented DiFFDRoiD and performed an evaluation of our approach on 5 benchmarks and over 130 platforms. our results show that DiFFDRoiD can identify CPis on real apps efficiently and with a limited number of false positives. DiFFDRoiD and our experimental infrastructure are publicly available.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115644','10.1109/ASE.2017.8115644',45,6,'IEEE','IEEE Conferences',0),(1175,'Synthesising Interprocedural Bit-Precise Termination Proofs (T)',9,53,64,'Proving program termination is key to guaranteeing absence of undesirable behaviour, such as hanging programs and even security vulnerabilities such as denial-of-service attacks. To make termination checks scale to large systems, interprocedural termination analysis seems essential, which is a largely unexplored area of research in termination analysis, where most effort has focussed on difficult single-procedure problems. We present a modular termination analysis for C programs using template-based interprocedural summarisation. Our analysis combines a context-sensitive, over-approximating forward analysis with the inference of under-approximating preconditions for termination. Bit-precise termination arguments are synthesised over lexicographic linear ranking function templates. Our experimental results show that our tool 2LS outperforms state-of-the-art alternatives, and demonstrate the clear advantage of interprocedural reasoning over monolithic analysis in terms of efficiency, while retaining comparable precision.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7371995','10.1109/ASE.2015.10',64,9,'IEEE','IEEE Conferences',0),(1176,'Scalable product line configuration: A straw to break the camel\'s back',6,465,474,'Software product lines are hard to configure. Techniques that work for medium sized product lines fail for much larger product lines such as the Linux kernel with 6000+ features. This paper presents simple heuristics that help the Indicator-Based Evolutionary Algorithm (IBEA) in finding sound and optimum configurations of very large variability models in the presence of competing objectives. We employ a combination of static and evolutionary learning of model structure, in addition to utilizing a pre-computed solution used as a 鈥渟eed鈥� in the midst of a randomly-generated initial population. The seed solution works like a single straw that is enough to break the camel\'s back -given that it is a feature-rich seed. We show promising results where we can find 30 sound solutions for configuring upward of 6000 features within 30 minutes.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693104','10.1109/ASE.2013.6693104',34,44,'IEEE','IEEE Conferences',0),(1177,'Divide-and-Conquer Approach for Multi-phase Statistical Migration for Source Code (T)',9,585,596,'Prior research shows that directly applying phrase-based SMT on lexical tokens to migrate Java to C# produces much semantically incorrect code. A key limitation is the use of sequences in phrase-based SMT to model and translate source code with well-formed structures. We propose mppSMT, a divide-and-conquer technique to address that with novel training and migration algorithms using phrase-based SMT in three phases. First, mppSMT treats a program as a sequence of syntactic units and maps/translates such sequences in two languages to one another. Second, with a syntax-directed fashion, it deals with the tokens within syntactic units by encoding them with semantic symbols to represent their data and token types. This encoding via semantic symbols helps better migration of API usages. Third, the lexical tokens corresponding to each sememe are mapped or migrated. The resulting sequences of tokens are merged together to form the final migrated code. Such divide-and-conquer and syntax-direction strategies enable phrase-based SMT to adapt well to syntactical structures in source code, thus, improving migration accuracy. Our empirical evaluation on several real-world systems shows that 84.8 -- 97.9% and 70 -- 83% of the migrated methods are syntactically and semantically correct, respectively. 26.3 -- 51.2% of total migrated methods are exactly matched to the human-written C# code in the oracle. Compared to Java2CSharp, a rule-based migration tool, it achieves higher semantic accuracy from 6.6 -- 57.7% relatively. Importantly, it does not require manual labeling for training data or manual definition of rules.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372046','10.1109/ASE.2015.74',51,18,'IEEE','IEEE Conferences',0),(1178,'Copy and Paste Redeemed (T)',9,630,640,'Modern software development relies on code reuse, which software engineers typically realise through handwritten abstractions, such as functions, methods, or classes. However, such abstractions can be challenging to develop and maintain. One alternative form of re-use is copy-paste-modify, a methodology in which developers explicitly duplicate source code to adapt the duplicate for a new purpose. We observe that copy-paste-modify can be substantially faster to use than manual abstraction, and past research strongly suggests that it is a popular technique among software developers. We therefore propose that software engineers should forego hand-written abstractions in favour of copying and pasting. However, empirical evidence also shows that copy-paste-modify complicates software maintenance and increases the frequency of bugs. To address this concern, we propose a software tool that merges together similar pieces of code and automatically creates suitable abstractions. This allows software developers to get the best of both worlds: custom abstraction together with easy re-use. To demonstrate the feasibility of our approach, we have implemented and evaluated a prototype merging tool for C++ on a number of near-miss clones (clones with some modifications) in popular Open Source packages. We found that maintainers find our algorithmically created abstractions to be largely preferable to existing duplicated code.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372050','10.1109/ASE.2015.39',18,6,'IEEE','IEEE Conferences',0),(1179,'Opiner: An opinion search and summarization engine for APIs',8,978,983,'Opinions are key determinants to many of the activities related to software development. The perceptions of developers about an API, and the choices they make about whether and how they should use it, may, to a considerable degree, be conditioned upon how other developers see and evaluate the API. Given the plethora of APIs available for a given development task and the advent of developer forums as the media to share opinions about those APIs, it can be challenging for a developer to make informed decisions about an API to support the task. We introduce Opiner, our opinion search and summarization engine for API reviews. The server side of Opiner collects and summarizes opinions about APIs by crawling online developer forums and by associating the opinions found in the forum posts to the APIs discussed in the posts. The client side of Opiner is a Website that presents different summarized viewpoints of the opinions about the APIs in an online search engine. We evaluated Opiner by asking Industrial developers to select APIs for two development tasks. We found that developers were interested to use our proposed summaries of API reviews and that while combined with Stack Overflow, Opiner helped developers to make the right decision with more accuracy and confidence. The Opiner online search engine is available at: http://opiner.polymtl.ca. A video demo is available at: https://youtu.be/XAXpfmg5Lqs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115715','10.1109/ASE.2017.8115715',28,2,'IEEE','IEEE Conferences',0),(1180,'Bita: Coverage-guided, automatic testing of actor programs',6,114,124,'Actor programs are concurrent programs where concurrent entities communicate asynchronously by exchanging messages. Testing actor programs is challenging because the order of message receives depends on the non-deterministic scheduler and because exploring all schedules does not scale to large programs. This paper presents Bita, a scalable, automatic approach for testing non-deterministic behavior of actor programs. The key idea is to generate and explore schedules that are likely to reveal concurrency bugs because these schedules increase the schedule coverage. We present three schedule coverage criteria for actor programs, an algorithm to generate feasible schedules that increase coverage, and a technique to force a program to comply with a schedule. Applying Bita to real-world actor programs implemented in Scala reveals eight previously unknown concurrency bugs, of which six have already been fixed by the developers. Furthermore, we show our approach to find bugs 122脳 faster than random scheduling, on average.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693072','10.1109/ASE.2013.6693072',54,8,'IEEE','IEEE Conferences',0),(1181,'Context-aware integrated development environment command recommender systems',8,688,693,'Integrated development environments (IDEs) are complex applications that integrate multiple tools for creating and manipulating software project artifacts. To improve users\' knowledge and the effectiveness of usage of the available functionality, the inclusion of recommender systems into IDEs has been proposed. We present a novel IDE command recommendation algorithm that, by taking into account the contexts in which a developer works and in which different commands are usually executed, is able to provide relevant recommendations. We performed an empirical comparison of the proposed algorithm with state-of-the-art IDE command recommenders on a real-world data set. The algorithms were evaluated in terms of precision, recall, F1, k-tail, and with a new evaluation metric that is specifically measuring the usefulness of contextual recommendations. The experiments revealed that in terms of the contextual relevance and usefulness of recommendations the proposed algorithm outperforms existing algorithms.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115679','10.1109/ASE.2017.8115679',17,2,'IEEE','IEEE Conferences',0),(1182,'The rise of the (modelling) bots: Towards assisted modelling via social networks',8,723,728,'We are witnessing a rising role of mobile computing and social networks to perform all sorts of tasks. This way, social networks like Twitter or Telegram are used for leisure, and they frequently serve as a discussion media for work-related activities. In this paper, we propose taking advantage of social networks to enable the collaborative creation of models by groups of users. The process is assisted by modelling bots that orchestrate the collaboration and interpret the users\' inputs (in natural language) to incrementally build a (meta-)model. The advantages of this modelling approach include ubiquity of use, automation, assistance, natural user interaction, traceability of design decisions, possibility to incorporate coordination protocols, and seamless integration with the user\'s normal daily usage of social networks. We present a prototype implementation called SOCIO, able to work over several social networks like Twitter and Telegram, and a preliminary evaluation showing promising results.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115683','10.1109/ASE.2017.8115683',17,5,'IEEE','IEEE Conferences',0),(1183,'CSeq: A concurrency pre-processor for sequential C verification tools',6,710,713,'Sequentialization translates concurrent programs into equivalent nondeterministic sequential programs so that the different concurrent schedules no longer need to be handled explicitly. It can thus be used as a concurrency preprocessing technique for automated sequential program verification tools. Our CSeq tool implements a novel sequentialization for C programs using pthreads, which extends the Lal/Reps sequentialization to support dynamic thread creation. CSeq now works with three different backend tools, CBMC, ESBMC, and LLBMC, and is competitive with state-of-the-art verification tools for concurrent programs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693139','10.1109/ASE.2013.6693139',18,18,'IEEE','IEEE Conferences',0),(1184,'Stability of Self-Adaptive Software Architectures',9,886,889,'Stakeholders and organisations are increasingly looking for long-lived software. As architectures have a profound effect on the operational life-time of the software and the quality of the service provision, architectural stability could be considered a primary criterion towards achieving the long-livety of the software. Architectural stability is envisioned as the next step in quality attributes, combining many inter-related qualities. This research suggests the notion of behavioural stability as a primary criterion for evaluating whether the architecture maintains achieving the expected quality attributes, maintaining architecture robustness, and evaluating how well the architecture accommodates run-time evolutionary changes. The research investigates the notion of architecture stability at run-time in the context of self-adaptive software architectures. We expect to define, characterise and analyse this intuitive concept, as well as identify the consequent trade-offs to be dynamically managed and enhance the self-adaptation process for a long-lived software.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372085','10.1109/ASE.2015.93',12,1,'IEEE','IEEE Conferences',0),(1185,'Do Automatically Generated Unit Tests Find Real Faults? An Empirical Study of Effectiveness and Challenges (T)',9,201,211,'Rather than tediously writing unit tests manually, tools can be used to generate them automatically - sometimes even resulting in higher code coverage than manual testing. But how good are these tests at actually finding faults? To answer this question, we applied three state-of-the-art unit test generation tools for Java (Randoop, EvoSuite, and Agitar) to the 357 real faults in the Defects4J dataset and investigated how well the generated test suites perform at detecting these faults. Although the automatically generated test suites detected 55.7% of the faults overall, only 19.9% of all the individual test suites detected a fault. By studying the effectiveness and problems of the individual tools and the tests they generate, we derive insights to support the development of automated unit test generators that achieve a higher fault detection rate. These insights include 1) improving the obtained code coverage so that faulty statements are executed in the first instance, 2) improving the propagation of faulty program states to an observable output, coupled with the generation of more sensitive assertions, and 3) improving the simulation of the execution environment to detect faults that are dependent on external factors such as date and time.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372009','10.1109/ASE.2015.86',46,50,'IEEE','IEEE Conferences',0),(1186,'Reverse Engineering Mobile Application User Interfaces with REMAUI (T)',9,248,259,'When developing the user interface code of a mobile application, in practice a big gap exists between the digital conceptual drawings of graphic artists and working user interface code. Currently, programmers bridge this gap manually, by reimplementing the conceptual drawings in code, which is cumbersome and expensive. To bridge this gap, we introduce the first technique to automatically Reverse Engineer Mobile Application User Interfaces (REMAUI). On a given input bitmap REMAUI identifies user interface elements such as images, texts, containers, and lists, via computer vision and optical character recognition (OCR) techniques. In our experiments on 488 screenshots of over 100 popular third-party Android and iOS applications, REMAUI-generated user interfaces were similar to the originals, both pixel-by-pixel and in terms of their runtime user interface hierarchies. REMAUI\'s average overall runtime on a standard desktop computer was 9 seconds.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372013','10.1109/ASE.2015.32',55,15,'IEEE','IEEE Conferences',0),(1187,'DSIbin: Identifying dynamic data structures in C/C++ binaries',8,331,341,'Reverse engineering binary code is notoriously difficult and, especially, understanding a binary\'s dynamic data structures. Existing data structure analyzers are limited wrt. program comprehension: they do not detect complex structures such as skip lists, or lists running through nodes of different types such as in the Linux kernel\'s cyclic doubly-linked list. They also do not reveal complex parent-child relationships between structures. The tool DSI remedies these shortcomings but requires source code, where type information on heap nodes is available. We present DSIbin, a combination of DSI and the type excavator Howard for the inspection of C/C++ binaries. While a naive combination already improves upon related work, its precision is limited because Howard\'s inferred types are often too coarse. To address this we auto-generate candidates of refined types based on speculative nested-struct detection and type merging; the plausibility of these hypotheses is then validated by DSI. We demonstrate via benchmarking that DSIbin detects data structures with high precision.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115646','10.1109/ASE.2017.8115646',39,4,'IEEE','IEEE Conferences',0),(1188,'Crust: A Bounded Verifier for Rust (N)',9,75,80,'Rust is a modern systems language that provides guaranteed memory safety through static analysis. However, Rust includes an escape hatch in the form of \'unsafe code,\' which the compiler assumes to be memory safe and to preserve crucial pointer aliasing invariants. Unsafe code appears in many data structure implementations and other essential libraries, and bugs in this code can lead to memory safety violations in parts of the program that the compiler otherwise proved safe. We present CRUST, a tool combining exhaustive test generation and bounded model checking to detect memory safety errors, as well as violations of Rust\'s pointer aliasing invariants within unsafe library code. CRUST requires no programmer annotations, only an indication of the modules to check. We evaluate CRUSTon data structures from the Rust standard library. It detects memory safety bugs that arose during the library\'s development and remained undetected for several months.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7371997','10.1109/ASE.2015.77',10,5,'IEEE','IEEE Conferences',0),(1189,'TrEKer: Tracing error propagation in operating system kernels',8,377,387,'Modern operating systems (OSs) consist of numerous interacting components, many of which are developed and maintained independently of one another. In monolithic systems, the boundaries of and interfaces between such components are not strictly enforced at runtime. Therefore, faults in individual components may directly affect other parts of the system in various ways. Software fault injection (SFI) is a testing technique to assess the resilience of a software system in the presence of faulty components. Unfortunately, SFI tests of OSs are inconclusive if they do not lead to observable failures, as corruptions of the internal software state may not be visible at its interfaces and, yet, affect the subsequent execution of the OS beyond the duration of the test. In this paper we present TrEKer, a fully automated approach for identifying how faulty OS components affect other parts of the system. TrEKer combines static and dynamic analyses to achieve efficient tracing on the granularity of memory accesses. We demonstrate TrEKer\'s ability to support SFI oracles by accurately tracing the effects of faults injected into three widely used Linux kernel modules.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115650','10.1109/ASE.2017.8115650',40,1,'IEEE','IEEE Conferences',0),(1190,'A comparative analysis of software architecture recovery techniques',6,486,496,'Many automated techniques of varying accuracy have been developed to help recover the architecture of a software system from its implementation. However, rigorously assessing these techniques has been hampered by the lack of architectural 鈥済round truths鈥�. Over the past several years, we have collected a set of eight architectures that have been recovered from open-source systems and independently, carefully verified. In this paper, we use these architectures as ground truths in performing a comparative analysis of six state-of-the-art software architecture recovery techniques. We use a number of metrics to assess each technique for its ability to identify a system\'s architectural components and overall architectural structure. Our results suggest that two of the techniques routinely outperform the rest, but even the best of the lot has surprisingly low accuracy. Based on the empirical data, we identify several avenues of future research in software architecture recovery.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693106','10.1109/ASE.2013.6693106',51,37,'IEEE','IEEE Conferences',0),(1191,'Minimizing CPU time shortage risks in integrated embedded software',6,529,539,'A major activity in many industries is to integrate software artifacts such that the functional and performance requirements are properly taken care of. In this paper, we focus on the problem of minimizing the risk of CPU time shortage in integrated embedded systems. In order to minimize this risk, we manipulate the start time (offset) of the software executables such that the system real-time constraints are satisfied, and further, the maximum CPU time usage is minimized. We develop a number of search-based optimization algorithms, specifically designed to work for large search spaces, to compute offsets for concurrent software executables with the objective of minimizing CPU usage. We evaluated and compared our algorithms by applying them to a large automotive software system. Our experience shows that our algorithms can automatically generate offsets such that the maximum CPU usage is very close to the known lower bound imposed by the domain constraints. Further, our approach finds limits on the maximum CPU usage lower than those found by a random strategy, and is not slower than a random strategy. Finally, our work achieves better results than the CPU usage minimization techniques devised by domain experts.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693110','10.1109/ASE.2013.6693110',27,3,'IEEE','IEEE Conferences',0),(1192,'Exploiting Domain and Program Structure to Synthesize Efficient and Precise Data Flow Analyses (T)',9,608,618,'A key challenge in implementing an efficient and precise data flow analysis is determining how to abstract the domain of values that a program variable can take on and how to update abstracted values to reflect program semantics. Such updates are performed by a transfer function and recent work by Thakur, Elder and Reps defined the bilateral algorithm for computing the most precise transfer function for a given abstract domain. In this paper, we identify and exploit the special case where abstract domains are comprised of disjoint subsets. For such domains, transfer functions computed using a customized algorithm can improve performance and in combination with symbolic modeling of block-level transfer functions improve precision as well. We implemented these algorithms in Soot and used them to perform data flow analysis on more than 100 non-trivial Java methods drawn from open source projects. Our experimental data are promising as they demonstrate that a 25-fold reduction in analysis time can be achieved and precision can be increased relative to existing methods.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372048','10.1109/ASE.2015.41',29,3,'IEEE','IEEE Conferences',0),(1193,'Covert Communication in Mobile Applications (T)',9,647,657,'This paper studies communication patterns in mobile applications. Our analysis shows that 63% of the external communication made by top-popular free Android applications from Google Play has no effect on the user-observable application functionality. To detect such covert communication in an efficient manner, we propose a highly precise and scalable static analysis technique: it achieves 93% precision and 61% recall compared to the empirically determined \'ground truth\', and runs in a matter of a few minutes. Furthermore, according to human evaluators, in 42 out of 47 cases, disabling connections deemed covert by our analysis leaves the delivered application experience either completely intact or with only insignificant interference. We conclude that our technique is effective for identifying and disabling covert communication. We then use it to investigate communication patterns in the 500 top-popular applications from Google Play.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7372052','10.1109/ASE.2015.66',36,7,'IEEE','IEEE Conferences',0),(1194,'Kobold: Web usability as a service',8,990,995,'While Web applications have become pervasive in today\'s business, social interaction and information exchange, their usability is often deficient, even being a key factor for a website success. Usability problems repeat across websites, and many of them have been catalogued, but usability evaluation and repair still remains expensive. There are efforts from both the academy and industry to automate usability testing or to provide automatic statistics, but they rarely offer concrete solutions. These solutions appear as guidelines or patterns that developers can follow manually. This paper presents Kobold, a tool that detects usability problems from real user interaction (UI) events and repairs them automatically when possible, at least suggesting concrete solutions. By using the refactoring technique and its associated concept of bad smell, Kobold mines UI events to detect usability smells and applies usability refactorings on the client to correct them. The purpose of Kobold is to deliver usability advice and solutions as a service (SaaS) for developers, allowing them to respond to feedback of the real use of their applications and improve usability incrementally, even when there are no usability experts on the team. Kobold is available at: http://autorefactoring.lifia.info.unlp.edu.ar. A screencast is available at https://youtu.be/c-myYPMUh0Q.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115717','10.1109/ASE.2017.8115717',13,2,'IEEE','IEEE Conferences',0),(1195,'BLITZ: Compositional bounded model checking for real-world programs',6,136,146,'Bounded Model Checking (BMC) for software is a precise bug-finding technique that builds upon the efficiency of modern SAT and SMT solvers. BMC currently does not scale to large programs because the size of the generated formulae exceeds the capacity of existing solvers. We present a new, compositional and property-sensitive algorithm that enables BMC to automatically find bugs in large programs. A novel feature of our technique is to decompose the behaviour of a program into a sequence of BMC instances and use a combination of satisfying assignments and unsatisfiability proofs to propagate information across instances. A second novelty is to use the control- and data-flow of the program as well as information from proofs to prune the set of variables and procedures considered and hence, generate smaller instances. Our tool BLITZ outperforms existing tools and scales to programs with over 100,000 lines of code. BLITZ automatically and efficiently discovers bugs in widely deployed software including new vulnerabilities in Internet infrastructure software.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6693074','10.1109/ASE.2013.6693074',21,9,'IEEE','IEEE Conferences',0),(1196,'Promoting secondary orders of event pairs in randomized scheduling using a randomized stride',8,741,752,'Because of the wide use of randomized scheduling in concurrency testing research, it is important to understand randomized scheduling and its limitations. This work analyzes how randomized scheduling discovers concurrency bugs by focusing on the probabilities of the two possible orders of a pair of events. Analysis shows that the disparity between probabilities can be large for programs that encounter a large number of events during execution. Because sets of ordered event pairs define conditions for discovering concurrency bugs, this disparity can make some concurrency bugs highly unlikely. The complementary nature of the two possible orders also indicates a potential trade-off between the probability of discovering frequently-occurring and infrequently-occurring concurrency bugs. To help address this trade-off in a more balanced way, randomized-stride scheduling is proposed, where scheduling granularity for each thread is adjusted using a randomized stride calculated based on thread length. With some assumptions, strides can be calculated to allow covering the least likely event pair orders. Experiments confirm the analysis results and also suggest that randomized-stride scheduling is more effective for discovering concurrency bugs compared to the original randomized scheduling implementation, and compared to other algorithms in recent literature.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115685','10.1109/ASE.2017.8115685',53,0,'IEEE','IEEE Conferences',0),(1197,'Systematically testing background services of mobile apps',8,4,15,'Contrary to popular belief, mobile apps can spend a large fraction of time running \'hidden\' as background services. And, bugs in services can translate into crashes, energy depletion, device slow-down, etc. Unfortunately, without necessary testing tools, developers can only resort to telemetries from user devices in the wild. To this end, Snowdrop is a testing framework that systematically identifies and automates background services in Android apps. Snowdrop realizes a service-oriented approach that does not assume all inter-component communication messages are explicitly coded in the app bytecode. Furthermore, to improve the completeness of test inputs generated, Snowdrop infers field values by exploiting the similarity in how developers name variables. We evaluate Snowdrop by testing 848 commercially available mobile apps. Empirical results show that Snowdrop can achieve 20.91% more code path coverage than pathwise test input generators, and 64.11% more coverage than random test input generators.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8115613','10.1109/ASE.2017.8115613',46,4,'IEEE','IEEE Conferences',0),(1198,'The interactive verification debugger: Effective understanding of interactive proof attempts',10,846,851,'The Symbolic Execution Debugger (SED) is an extension of the Eclipse debug platform for interactive symbolic execution. Like a traditional debugger, the SED can be used to locate the origin of a defect and to increase program understanding. However, as it is based on symbolic execution, all execution paths are explored simultaneously. We demonstrate an extension of the SED called Interactive Verification Debugger (IVD) for inspection and understanding of formal verification attempts. By a number of novel views, the IVD allows to quickly comprehend interactive proof situations and to debug the reasons for a proof attempt that got stuck. It is possible to perform interactive proofs completely from within the IVD. It can be experimentally demonstrated that the IVD is more effective in understanding proof attempts than a conventional prover user interface. A screencast explaining proof attempt inspection with the IVD is available at youtu.be/8e-q9Jf1h_w.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582826','',15,0,'IEEE','IEEE Conferences',0),(1199,'Automated testing and notification of mobile app privacy leak-cause behaviours',10,880,883,'I describe the design, implementation and evaluation of a novel hybrid static/dynamic analysis system for automatically uncovering and testing for the user-triggered causes and paths of privacy leaks in Android applications (privacy `leak-causes\'). I describe how I plan to further evaluate and demonstrate improvements in accuracy, coverage and testing speed of my hybrid testing approach against other currently available systems. I also show how user privacy is improved by the presentation of information on leak-causes in a field study as privacy notices. I present plans to investigate which of the commonly utilized mobile notification mechanisms is best suited to the presentation of leak-causes, as well as how users may set better privacy control policies with the information provided.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582832','',16,0,'IEEE','IEEE Conferences',0),(1200,'Statistical analysis of large sets of models',10,888,891,'Many applications in Model-Driven Engineering involve processing multiple models, e.g. for comparing and merging of model variants into a common domain model. Despite many sophisticated techniques for model comparison, little attention has been given to the initial data analysis and filtering activities. These are hard to ignore especially in the case of a large dataset, possibly with outliers and sub-groupings. We would like to develop a generic approach for model comparison and analysis for large datasets; using techniques from information retrieval, natural language processing and machine learning. We are implementing our approach as an open framework and have so far evaluated it on public datasets involving domain analysis, repository management and model searching scenarios.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582834','',17,0,'IEEE','IEEE Conferences',0),(1201,'API recommendation system for software development',10,896,899,'Nowadays, software developers often utilize existing third party libraries and make use of Application Programming Interface (API) to develop a software. However, it is not always obvious which library to use or whether the chosen library will play well with other libraries in the system. Furthermore, developers need to spend some time to understand the API to the point that they can freely use the API methods and putting the right parameters inside them. In this work, I plan to automatically recommend relevant APIs to developers. This API recommendation can be divided into multiple stages. First, we can recommend relevant libraries provided a given task to complete. Second, we can recommend relevant API methods that developer can use to program the required task. Third, we can recommend correct parameters for a given method according to its context. Last but not least, we can recommend how different API methods can be combined to achieve a given task. In effort to realize this API recommendation system, I have published two related papers. The first one deals with recommending additional relevant API libraries given known useful API libraries for the target program. This system can achieve recall rate@5 of 0.852 and recall rate@10 of 0.894 in recommending additional relevant libraries. The second one deals with recommending relevant API methods a given target API and a textual description of the task. This system can achieve recall-rate@5 of 0.690 and recall-rate@10 of 0.779. The results for both system indicate that the systems are useful and capable in recommending the right API/library reasonably well. Currently, I am working on another system which can recommend web APIs (i.e., libraries) given a description of the task. I am also working on a system that recommends correct parameters given an API method. In the future, I also plan to realize API composition recommendation for the given task.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582836','',25,0,'IEEE','IEEE Conferences',0),(1202,'Changing microsoft\'s build: Revolution or evolution',10,2,2,'Tens of thousands of Microsoft engineers build and test hundreds of software products several times a day. It is essential that this continuous integration scales, guarantees short feedback cycles, and functions reliably with minimal human intervention. During the past three years TSE\'s charter has been to shorten this cycle time. We went after this goal in two ways: Evolution via CloudBuild and Revolution via Concord. CloudBuild is a build service infrastructure, now being used by all major product groups in Microsoft, like Azure, Bing, Office, SQL except for Windows. CloudBuild addresses all aspects of a continuous integration workflow, like builds, test and code analysis, but also drops, package and symbol creation and storage. CloudBuild supports multiple build languages as long as they fulfill a coarse grained IO based contract. CloudBuild uses content based caching to run build-related tasks only when needed. Lastly, it builds on many machines in parallel. The speed ups of build and testing range from 1.2x to 10x. CloudBuild aims to rapidly onboard teams and hence has to support non-deterministic build tools and specification languages that under-declare dependencies. CloudBuild, being a reliable build service in the presence of unreliable components, currently achieves service availability better than 99%. Windows went a different path. Their past build exhaust was so massive that building Windows in the cloud and bringing the build results back for testing on corp.-net. was considered infeasible. So they decided to move to a new build language, codename Concord. By construction, Concord guarantees reliable builds, no over-build, and allows for efficient distribution. Adopting Concord has led to immense performance improvements, we have seen up to 100X speedup for Windows builds. But the path has been long and rocky, since it not only requires a substantial rewrite of existing build logic, but also all related developer and build lab processes have to change. Whether evolution or revolution is the right path forward - the verdict is still out.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582738','',0,0,'IEEE','IEEE Conferences',0),(1203,'AnModeler: A tool for generating domain models from textual specifications',10,828,833,'This paper presents AnModeler, a tool for generating analysis models from software requirements specified using use cases. The tool uses the Stanford natural language parser to extract type dependencies (TDs) and parts of speech tags (POS-tags) of sentences from input Use Case Specification (UCS). Then, it identifies sentence structures using a set of rules framed based on Hornby\'s verb patterns. With the information of the TDs, POS tags, and the identified sentence structures, the tool discovers domain elements, viz.: domain objects (including their attributes and operations) and interactions between them; it consolidates the domain information as a class diagram (as well as a sequence diagram). An experiment conducted on 10 UCSs with two industry experts as subjects showed that the analysis class diagrams generated by AnModeler were remarkably close to those generated by the two industry experts. Being lightweight and easy to use, the tool can also be used to assist students and young developers in acquiring object-oriented domain modeling skills quickly. Link to a short demonstration video: https://youtu.be/_Ct-qF4Y1fU.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582823','',23,0,'IEEE','IEEE Conferences',0),(1204,'Factoring requirement dependencies in software requirement selection using graphs and integer programming',10,884,887,'Software requirement selection is to find a subset of requirements (so-called optimal set) that gives the highest customer value for a release of software while keeping the cost within the budget. Several industrial studies however, have demonstrated that requirements of software projects are intricately interdependent and these interdependencies impact the values of requirements. Furthermore, the strengths of dependency relations among requirements vary in the context of real-world projects. For instance, requirements can be strongly or weakly interdependent. Therefore, it is important to consider both the existence and the strengths of dependency relations during requirement selection. The existing selection models however, have ignored either requirement dependencies altogether or the strengths of those dependencies. This research proposes an Integer programming model for requirement selection which considers both the existence and strengths of requirement dependencies. We further contribute a graph-based dependency modeling technique for capturing requirement dependencies and the their corresponding strengths. Automated/semi-automated techniques will also be devised to identify requirement dependencies and the strengths of those dependencies.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582833','',38,0,'IEEE','IEEE Conferences',0),(1205,'Developer targeted analytics: Supporting software development decisions with runtime information',10,892,895,'Runtime information of deployed software has been used by business and operations units to make informed decisions under the term 鈥渁nalytics鈥�. However, decisions made by software engineers in the course of evolving software have, for the most part, been based on personal belief and gut-feeling. This could be attributed to software development being, for the longest time, viewed as an activity that is detached from the notion of operating software in a production environment. In recent years, this view has been challenged with the emergence of the DevOps movement, which aim is to promote cross-functional capabilities of development and operations activities within teams. This shift in process and mindset requires analytics tools that specifically target software developers. In this research, I investigate approaches to support developers in their decision-making by incorporating runtime information in source code and provide live feedback in IDEs by predicting the impact of code changes.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582835','',31,0,'IEEE','IEEE Conferences',0),(1206,'Program generation for performance',10,1,1,'It has become extraordinarily difficult to write software that performs close to optimally on complex modern microarchitectures. Particularly plagued are domains that require complex mathematical computations such as multimedia processing, communication, control, graphics, and machine learning. In these domains, performance-critical components are usually written in C (with possible extensions) and often even in assembly, carefully 鈥渢uned鈥� to the platform\'s architecture and microarchitecture. The result is usually long, rather unreadable code that needs to be re-written or re-tuned with every platform upgrade. On the other hand, the performance penalty for relying on straightforward, non-tuned, 鈥渕ore elegant鈥� implementations can be often a factor of 10, 100, or even more. The overall problem is one of productivity, maintainability, and quality (namely performance), i.e., software engineering. However, even though a large set of sophisticated software engineering theory and tools exist, it appears that to date this community has not focused much on mathematical computations nor performance in the detailed, close-to-optimal sense above. The reason for the latter may be that performance, unlike various aspects of correctness, is not syntactic in nature (and in reality is often even unpredictable and, well, messy). The aim of this talk is to draw attention to the performance/productivity problem for mathematical applications and to make the case for a more interdisciplinary attack. As a set of thoughts in this direction we offer some of the lessons we have learned in the last decade in our own research on Spiral (www.spiral.net), a program generation framework for numerical kernels. Key techniques used in Spiral include staged declarative domain-specific languages to express algorithm knowledge and algorithm transformations, the use of platform-cognizant rewriting systems for parallelism and locality optimizations, and the use of search and machine learning techniques to navigate possible spaces of choices. Experimental results show that the codegenerated by Spiral competes with, and sometimes outperforms, the best available human-written code. Spiral has been used to generate part of Intel\'s commercial libraries IPP and MKL.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582737','',0,0,'IEEE','IEEE Conferences',0),(1207,'The power of probabilistic thinking',10,3,3,'Traditionally, software engineering has dealt in absolutes. For instance, we talk about a system being 鈥渃orrect鈥� or 鈥渋ncorrect鈥�, with the shades of grey in between occasionally acknowledged but rarely dealt with explicitly. And we typically employ logical, algebraic, relational and other representations and techniques that help us reason about software in such absolute terms. There of course have been notable exceptions to this, such as the use of statistical techniques in testing and debugging. But by and large, both researchers and practitioners have favored the relative comfort of an absolutist viewpoint in all aspects of development. In this talk, I will argue the benefits of taking a more thoroughly probabilistic approach in software engineering. Software engineering is rife with stochastic phenomena, and the vast majority of software systems operate in an environment of uncertain, random behavior, which suits an explicit probabilistic characterization. Furthermore, this uncertainty is becoming ever more pronounced in new software systems and platforms, such as the Internet of Things and autonomous vehicles, with their frequent imprecise outputs and heavy reliance on machine learning. To illustrate more deeply some of the considerations involved in taking a probabilistic approach, I will talk about some recent research I have been doing in probabilistic verification.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582739','',0,0,'IEEE','IEEE Conferences',0),(1208,'SimilarTech: Automatically recommend analogical libraries across different programming languages',10,834,839,'Third-party libraries are an integral part of many software projects. It often happens that developers need to find analogical libraries that can provide comparable features to the libraries they are already familiar with. Existing methods to find analogical libraries are limited by the community-curated list of libraries, blogs, or Q&A posts, which often contain overwhelming or out-of-date information. This paper presents our tool SimilarTech (https://graphofknowledge. appspot.com/similartech) that makes it possible to automatically recommend analogical libraries by incorporating tag embeddings and domain-specific relational and categorical knowledge mined from Stack Overflow. SimilarTech currently supports recommendation of 6,715 libraries across 6 different programming languages. We release our SimilarTech website for public use. The SimilarTech website attracts more than 2,400 users in the past 6 months. We observe two typical usage patterns of our website in the website visit logs which can satisfy different information needs of developers. The demo video can be seen at https://youtu.be/ubx8h4D4ieE.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582824','',19,0,'IEEE','IEEE Conferences',0),(1209,'Conc-iSE: Incremental symbolic execution of concurrent software',10,531,542,'Software updates often introduce new bugs to existing code bases. Prior regression testing tools focus mainly on test case selection and prioritization whereas symbolic execution tools only handle code changes in sequential software. In this paper, we propose the first incremental symbolic execution method for concurrent software to generate new tests by exploring only the executions affected by code changes between two program versions. Specifically, we develop an inter-thread and inter-procedural change-impact analysis to check if a statement is affected by the changes and then leverage the information to choose executions that need to be re-explored. We also check if execution summaries computed in the previous program can be used to avoid redundant explorations in the new program. We have implemented our method in an incremental symbolic execution tool called Conc-iSE and evaluated it on a large set of multithreaded C programs. Our experiments show that the new method can significantly reduce the overall symbolic execution time when compared with state-of-the-art symbolic execution tools such as KLEE.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582788','',49,0,'IEEE','IEEE Conferences',0),(1210,'Identifying domain elements from textual specifications',10,566,577,'Analysis modeling refers to the task of identifying domain objects, their attributes and operations, and the relationships between these objects from software requirements specifications which are usually written in some natural language. There have been a few efforts to automate this task, but they seem to be largely constrained by the language related issues as well as the lack of a systematic transformation process. In this paper, we propose a systematic, automated transformation approach which first interprets the specification sentences based on the Hornby\'s verb patterns, and then uses semantic relationships between the words in the sentences, obtained from Type Dependencies using Stanford NL Parser, to identify the domain elements from them. With the help of a controlled experiment, we show that the analysis class diagrams generated by the proposed approach are far more correct, far more complete and less redundant than those generated by the exiting automated approaches.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582792','',45,0,'IEEE','IEEE Conferences',0),(1211,'SOFIA: An automated security oracle for black-box testing of SQL-injection vulnerabilities',10,167,177,'Security testing is a pivotal activity in engineering secure software. It consists of two phases: generating attack inputs to test the system, and assessing whether test executions expose any vulnerabilities. The latter phase is known as the security oracle problem. In this work, we present SOFIA, a Security Oracle for SQL-Injection Vulnerabilities. SOFIA is programming-language and source-code independent, and can be used with various attack generation tools. Moreover, because it does not rely on known attacks for learning, SOFIA is meant to also detect types of SQLi attacks that might be unknown at learning time. The oracle challenge is recast as a one-class classification problem where we learn to characterise legitimate SQL statements to accurately distinguish them from SQLi attack statements. We have carried out an experimental validation on six applications, among which two are large and widely-used. SOFIA was used to detect real SQLi vulnerabilities with inputs generated by three attack generation tools. The obtained results show that SOFIA is computationally fast and achieves a recall rate of 100% (i.e., missing no attacks) with a low false positive rate (0.6%).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582755','',28,0,'IEEE','IEEE Conferences',0),(1212,'An extensible framework for variable-precision data-flow analyses in MPS',10,870,875,'Data-flow analyses are used as part of many software engineering tasks: they are the foundations of program understanding, refactorings and optimized code generation. Similar to general-purpose languages (GPLs), state-of-the-art domain-specific languages (DSLs) also require sophisticated data-flow analyses. However, as a consequence of the different economies of DSL development and their typically relatively fast evolution, the effort for developing and evolving such analyses must be lowered compared to GPLs. This tension can be resolved with dedicated support for data-flow analyses in language workbenches. In this tool paper we present MPS-DF, which is the component in the MPS language workbench that supports the definition of data-flow analyses for DSLs. Language developers can define data-flow graph builders declaratively as part of a language definition and compute analysis results efficiently based on these data-flow graphs. MPS-DF is extensible such that it does not compromise the support for language composition in MPS. Additionally, clients of MPS-DF analyses can run the analyses with variable precision thus trading off precision for performance. This allows clients to tailor an analysis to a particular use case.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582830','',19,0,'IEEE','IEEE Conferences',0),(1213,'Efficient detection of inconsistencies in a multi-developer engineering environment',10,590,601,'Software developers work concurrently on different kinds of development artifacts such as requirements, architecture, design, or source code. To keep these development artifacts consistent, developers have a wide range of consistency checking approaches available. However, most existing consistency checkers work best in context of single tools and they are not well suited when development artifacts are distributed among different tools and are being modified concurrently by many developers. This paper presents a novel, cloud-based approach to consistency checking in a multi-developer/-tool engineering environment. It allows instant consistency checking even if developers and their tools are distributed and even if they do not have access to all artifacts. It does this by systematically reusing consistency checking knowledge to keep the memory/CPU cost of consistency checking to a small constant overhead per developer. The feasibility and scalability of our approach is demonstrated through an empirical validation with 22 partly industrial system models. A prototype implementation implementation is available through the DesignSpace Engineering Cloud.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582794','',40,0,'IEEE','IEEE Conferences',0),(1214,'Local-based active classification of test report to assist crowdsourced testing',10,190,201,'In crowdsourced testing, an important task is to identify the test reports that actually reveal fault - true fault, from the large number of test reports submitted by crowd workers. Most existing approaches towards this problem utilized supervised machine learning techniques, which often require users to manually label a large amount of training data. Such process is time-consuming and labor-intensive. Thus, reducing the onerous burden of manual labeling while still being able to achieve good performance is crucial. Active learning is one potential technique to address this challenge, which aims at training a good classifier with as few labeled data as possible. Nevertheless, our observation on real industrial data reveals that existing active learning approaches generate poor and unstable performances on crowdsourced testing data. We analyze the deep reason and find that the dataset has significant local biases. To address the above problems, we propose LOcal-based Active ClassiFication (LOAF) to classify true fault from crowdsourced test reports. LOAF recommends a small portion of instances which are most informative within local neighborhood, and asks user their labels, then learns classifiers based on local neighborhood. Our evaluation on 14,609 test reports of 34 commercial projects from one of the Chinese largest crowdsourced testing platforms shows that our proposed LOAF can generate promising results. In addition, its performance is even better than existing supervised learning approaches which built on large amounts of labelled historical data. Moreover, we also implement our approach and evaluate its usefulness using real-world case studies. The feedbacks from testers demonstrate its practical value.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582757','',44,0,'IEEE','IEEE Conferences',0),(1215,'Taming Android fragmentation: Characterizing and detecting compatibility issues for Android apps',10,226,237,'Android ecosystem is heavily fragmented. The numerous combinations of different device models and operating system versions make it impossible for Android app developers to exhaustively test their apps. As a result, various compatibility issues arise, causing poor user experience. However, little is known on the characteristics of such fragmentation-induced compatibility issues and no mature tools exist to help developers quickly diagnose and fix these issues. To bridge the gap, we conducted an empirical study on 191 real-world compatibility issues collected from popular open-source Android apps. Our study characterized the symptoms and root causes of compatibility issues, and disclosed that the patches of these issues exhibit common patterns. With these findings, we propose a technique named FicFinder to automatically detect compatibility issues in Android apps. FicFinder performs static code analysis based on a model that captures Android APIs as well as their associated context by which compatibility issues are triggered. FicFinder reports actionable debugging information to developers when it detects potential issues. We evaluated FicFinder with 27 large-scale open-source Android apps. The results show that FicFinder can precisely detect compatibility issues in these apps and uncover previously-unknown issues.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582761','',70,0,'IEEE','IEEE Conferences',0),(1216,'GUICat: GUI testing as a service',10,858,863,'GUIs are event-driven applications where the flow of the program is determined by user actions such as mouse clicks and key presses. GUI testing is a challenging task not only because of the combinatorial explosion in the number of event sequences, but also because of the difficulty to cover the large number of data values. We propose GUICat, the first cloud-based GUI testing framework that simultaneously generates event sequences and data values. It is a white-box GUI testing tool that augments traditional sequence generation techniques with concolic execution. We also propose a cloud-based parallel algorithm for mitigating both event sequence explosion and data value explosion, by distributing the con-colic execution tasks over public clouds such as Amazon EC2. We have evaluated the tool on standard GUI testing benchmarks and showed that GUICat significantly outperforms state-of-the-art GUI testing tools. The video demo URL is https://youtu.be/rfnnQOmZqj4.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582828','',14,0,'IEEE','IEEE Conferences',0),(1217,'Greedy combinatorial test case generation using unsatisfiable cores',10,614,624,'Combinatorial testing aims at covering the interactions of parameters in a system under test, while some combinations may be forbidden by given constraints (forbidden tuples). In this paper, we illustrate that such forbidden tuples correspond to unsatisfiable cores, a widely understood notion in the SAT solving community. Based on this observation, we propose a technique to detect forbidden tuples lazily during a greedy test case generation, which significantly reduces the number of required SAT solving calls. We further reduce the amount of time spent in SAT solving by essentially ignoring constraints while constructing each test case, but then 鈥渁mending鈥� it to obtain a test case that satisfies the constraints, again using unsatisfiable cores. Finally, to complement a disturbance due to ignoring constraints, we implement an efficient approximative SAT checking function in the SAT solver Lingeling. Through experiments we verify that our approach significantly improves the efficiency of constraint handling in our greedy combinatorial testing algorithm.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582796','',38,0,'IEEE','IEEE Conferences',0),(1218,'CrowdService: Serving the individuals through mobile crowdsourcing and service composition',10,214,219,'Some user needs in real life can only be accomplished by leveraging the intelligence and labor of other people via crowdsourcing tasks. For example, one may want to confirm the validity of the description of a secondhand laptop by asking someone else to inspect the laptop on site. To integrate these crowdsourcing tasks into user applications, it is required that crowd intelligence and labor be provided as easily accessible services (e.g., Web services), which can be called crowd services. In this paper, we develop a framework named CrowdService which supplies crowd intelligence and labor as publicly accessible crowd services via mobile crowd-sourcing. We implement the proposed framework on the Android platform and evaluate its usability with a user study.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582759','',14,0,'IEEE','IEEE Conferences',0),(1219,'HybriDroid: Static analysis framework for Android hybrid applications',10,250,261,'Mobile applications (apps) have long invaded the realm of desktop apps, and hybrid apps become a promising solution for supporting multiple mobile platforms. Providing both platform-specific functionalities via native code like native apps and user interactions via JavaScript code like web apps, hybrid apps help developers build multiple apps for different platforms without much duplicated efforts. However, most hybrid apps are developed in multiple programming languages with different semantics, which may be vulnerable to programmer errors. Moreover, because untrusted JavaScript code may access device-specific features via native code, hybrid apps may be vulnerable to various security attacks. Unfortunately, no existing tools can help hybrid app developers by detecting errors or security holes. In this paper, we present HybriDroid, a static analysis framework for Android hybrid apps. We investigate the semantics of Android hybrid apps especially for the interoperation mechanism of Android Java and JavaScript. Then, we design and implement a static analysis framework that analyzes inter-communication between Android Java and JavaScript. As example analyses supported by HybriDroid, we implement a bug detector that identifies programmer errors due to the hybrid semantics, and a taint analyzer that finds information leaks cross language boundaries. Our empirical evaluation shows that the tools are practically usable in that they found previously uncovered bugs in real-world Android hybrid apps and possible information leaks via a widely-used advertising platform.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582763','',51,8,'IEEE','IEEE Conferences',0),(1220,'Applying combinatorial test data generation to big data applications',10,637,647,'Big data applications (e.g., Extract, Transform, and Load (ETL) applications) are designed to handle great volumes of data. However, processing such great volumes of data is time-consuming. There is a need to construct small yet effective test data sets during agile development of big data applications. In this paper, we apply a combinatorial test data generation approach to two real-world ETL applications at Medidata. In our approach, we first create Input Domain Models (IDMs) automatically by analyzing the original data source and incorporating constraints manually derived from requirements. Next, the IDMs are used to create test data sets that achieve t-way coverage, which has shown to be very effective in detecting software faults. The generated test data sets also satisfy all the constraints identified in the first step. To avoid creating IDMs from scratch when there is a change to the original data source or constraints, our approach extends the original IDMs with additional information. The new IDMs, which we refer to as Adaptive IDMs (AIDMs), are updated by comparing the changes against the additional information, and are then used to generate new test data sets. We implement our approach in a tool, called comBinatorial big daTa Test dAta Generator (BIT-TAG). Our experience shows that combinatorial testing can be effectively applied to big data applications. In particular, the test data sets created using our approach for the two ETL applications are only a small fraction of the original data source, but we were able to detect all the faults found with the original data source.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582798','',27,0,'IEEE','IEEE Conferences',0),(1221,'Move-optimized source code tree differencing',10,660,671,'When it is necessary to express changes between two source code files as a list of edit actions (an edit script), modern tree differencing algorithms are superior to most text-based approaches because they take code movements into account and express source code changes more accurately. We present 5 general optimizations that can be added to state-of-the-art tree differencing algorithms to shorten the resulting edit scripts. Applied to Gumtree, RTED, JSync, and ChangeDistiller, they lead to shorter scripts for 1898% of the changes in the histories of 9 open-source software repositories. These optimizations also are parts of our novel Move-optimized Tree DIFFerencing algorithm (MTD-IFF) that has a higher accuracy in detecting moved code parts. MTDIFF (which is based on the ideas of ChangeDistiller) further shortens the edit script for another 20% of the changes in the repositories. MTDIFF and all the benchmarks are available under an open-source license.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582801','',42,0,'IEEE','IEEE Conferences',0),(1222,'Fine-tuning spectrum based fault localisation with frequent method item sets',10,274,285,'Continuous integration is a best practice adopted in modern software development teams to identify potential faults immediately upon project build. Once a fault is detected it must be repaired immediately, hence continuous integration provides an ideal testbed for experimenting with the state of the art in fault localisation. In this paper we propose a variant of what is known as spectrum based fault localisation, which leverages patterns of method calls by means of frequent itemset mining. We compare our variant (we refer to it as patterned spectrum analysis) against the state of the art and demonstrate on 351 real faults drawn from five representative open source java projects that patterned spectrum analysis is more effective in localising the fault.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582765','',54,0,'IEEE','IEEE Conferences',0),(1223,'Automatic runtime recovery via error handler synthesis',10,684,695,'Software systems are often subject to unexpected runtime errors. Automatic runtime recovery (ARR) techniques aim to recover them from erroneous states and maintain them functional in the field. This paper proposes Ares, a novel, practical approach for ARR. Our key insight is leveraging a system\'s inherent error handling support to recover from unexpected errors. To this end, we synthesize error handlers in two ways: error transformation and early return. We also equip Ares with a lightweight in-vivo testing infrastructure to select the promising synthesis method and avoid potentially dangerous error handlers. Unlike existing ARR techniques with heavyweight mechanisms (e.g., checkpoint-restart and runtime monitoring), our approach expands the intrinsic capability of runtime error resilience in software systems to handle unexpected errors. Ares\'s lightweight mechanism makes it practical and easy to be integrated into production environments. We have implemented Ares on top of both the Java HotSpot VM and Android ART, and applied it to recover from 52 real-world bugs. The results are promising - Ares successfully recovers from 39 of them and incurs negligible overhead.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582803','',30,0,'IEEE','IEEE Conferences',0),(1224,'An empirical study on dependence clusters for effort-aware fault-proneness prediction',10,296,307,'A dependence cluster is a set of mutually inter-dependent program elements. Prior studies have found that large dependence clusters are prevalent in software systems. It has been suggested that dependence clusters have potentially harmful effects on software quality. However, little empirical evidence has been provided to support this claim. The study presented in this paper investigates the relationship between dependence clusters and software quality at the function-level with a focus on effort-aware fault-proneness prediction. The investigation first analyzes whether or not larger dependence clusters tend to be more fault-prone. Second, it investigates whether the proportion of faulty functions inside dependence clusters is significantly different from the proportion of faulty functions outside dependence clusters. Third, it examines whether or not functions inside dependence clusters playing a more important role than others are more fault-prone. Finally, based on two groups of functions (i.e., functions inside and outside dependence clusters), the investigation considers a segmented fault-proneness prediction model. Our experimental results, based on five well-known open-source systems, show that (1) larger dependence clusters tend to be more fault-prone; (2) the proportion of faulty functions inside dependence clusters is significantly larger than the proportion of faulty functions outside dependence clusters; (3) functions inside dependence clusters that play more important roles are more fault-prone; (4) our segmented prediction model can significantly improve the effectiveness of effort-aware fault-proneness prediction in both ranking and classification scenarios. These findings help us better understand how dependence clusters influence software quality.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582767','',42,0,'IEEE','IEEE Conferences',0),(1225,'DistIA: A cost-effective dynamic impact analysis for distributed programs',10,344,355,'Dynamic impact analysis is a fundamental technique for understanding the impact of specific program entities, or changes to them, on the rest of the program for concrete executions. However, existing techniques are either inapplicable or of very limited utility for distributed programs running in multiple concurrent processes. This paper presents DISTIA, a dynamic analysis of distributed systems that predicts impacts propagated both within and across process boundaries by partially ordering distributed method-execution events, inferring causality from the ordered events, and exploiting message-passing semantics. We applied DISTIA to large distributed systems of various architectures and sizes, for which it on average finishes the entire analysis within one minute and safely reduces impact-set sizes by over 43% relative to existing options with run-time overhead less than 8%. Moreover, two case studies initially demonstrated the precision of DISTIA and its utility in distributed system understanding. While conservative thus subject to false positives, DistIA balances precision and efficiency to offer cost-effective options for evolving distributed programs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582771','',67,0,'IEEE','IEEE Conferences',0),(1226,'Battery-aware transformations in mobile applications',10,702,707,'We present an adaptive binary transformation system for reducing the energy impact of advertisements and analytics in mobile applications. Our approach accommodates both the needs of mobile app developers to obtain income from advertisements and the desire of mobile device users for longer battery life. Our technique automatically identifies recurrent advertisement and analytics requests and throttles these requests based on a mobile device\'s battery status. Of the Android applications we analyzed, 75% have at least one connection that exhibits such recurrent requests. Our automated detection scheme classifies these requests with 100% precision and 80.5% recall. Applying the proposed battery-aware transformations to a representative mobile application reduces the power consumption of the mobile device by 5.8%, without the negative effect of completely removing advertisements.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582805','',17,0,'IEEE','IEEE Conferences',0),(1227,'IncA: A DSL for the definition of incremental program analyses',10,320,331,'Program analyses support software developers, for example, through error detection, code-quality assurance, and by enabling compiler optimizations and refactorings. To provide real-time feedback to developers within IDEs, an analysis must run efficiently even if the analyzed code base is large. To achieve this goal, we present a domain-specific language called IncA for the definition of efficient incremental program analyses that update their result as the program changes. IncA compiles analyses into graph patterns and relies on existing incremental matching algorithms. To scale IncA analyses to large programs, we describe optimizations that reduce caching and prune change propagation. Using IncA, we have developed incremental control flow and points-to analysis for C, well-formedness checks for DSLs, and 10 FindBugs checks for Java. Our evaluation demonstrates significant speedups for all analyses compared to their non-incremental counterparts.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582769','',41,0,'IEEE','IEEE Conferences',0),(1228,'LockPeeker: Detecting latent locks in Java APIs',10,368,378,'Detecting lock-related defects has long been a hot research topic in software engineering. Many efforts have been spent on detecting such deadlocks in concurrent software systems. However, latent locks may be hidden in application programming interface (API) methods whose source code may not be accessible to developers. Many APIs have latent locks. For example, our study has shown that J2SE alone can have 2,000+ latent locks. As latent locks are less known by developers, they can cause deadlocks that are hard to perceive or diagnose. Meanwhile, the state-of-the-art tools mostly handle API methods as black boxes, and cannot detect deadlocks that involve such latent locks. In this paper, we propose a novel black-box testing approach, called LockPeeker, that reveals latent locks in Java APIs. The essential idea of LockPeeker is that latent locks of a given API method can be revealed by testing the method and summarizing the locking effects during testing execution. We have evaluated LockPeeker on ten real-world Java projects. Our evaluation results show that (1) LockPeeker detects 74.9% of latent locks in API methods, and (2) it enables state-of-the-art tools to detect deadlocks that otherwise cannot be detected.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582773','',34,0,'IEEE','IEEE Conferences',0),(1229,'An empirical investigation into the nature of test smells',10,4,15,'Test smells have been defined as poorly designed tests and, as reported by recent empirical studies, their presence may negatively affect comprehension and maintenance of test suites. Despite this, there are no available automated tools to support identification and repair of test smells. In this paper, we firstly investigate developers\' perception of test smells in a study with 19 participants. The results show that developers generally do not recognize (potentially harmful) test smells, highlighting that automated tools for identifying such smells are much needed. However, to build effective tools, deeper insights into the test smells phenomenon are required. To this aim, we conducted a large-scale empirical investigation aimed at analyzing (i) when test smells occur in source code, (ii) what their survivability is, and (iii) whether their presence is associated with the presence of design problems in production code (code smells). The results indicate that test smells are usually introduced when the corresponding test code is committed in the repository for the first time, and they tend to remain in a system for a long time. Moreover, we found various unexpected relationships between test and code smells. Finally, we show how the results of this study can be used to build effective automated tools for test smell detection and refactoring.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582740','',45,0,'IEEE','IEEE Conferences',0),(1230,'Mining input grammars from dynamic taints',10,720,725,'Knowing which part of a program processes which parts of an input can reveal the structure of the input as well as the structure of the program. In a URL http://www.example.com/path/, for instance, the protocol http, the host www.example.com, and the path path would be handled by different functions and stored in different variables. Given a set of sample inputs, we use dynamic tainting to trace the data flow of each input character, and aggregate those input fragments that would be handled by the same function into lexical and syntactical entities. The result is a context-free grammar that reflects valid input structure. In its evaluation, our AUTOGRAM prototype automatically produced readable and structurally accurate grammars for inputs like URLs, spreadsheets or configuration files. The resulting grammars not only allow simple reverse engineering of input formats, but can also directly serve as input for test generators.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582807','',6,0,'IEEE','IEEE Conferences',0),(1231,'Reflection-aware static analysis of Android apps',10,756,761,'We demonstrate the benefits of DroidRA, a tool for taming reflection in Android apps. DroidRA first statically extracts reflection-related object values from a given Android app. Then, it leverages the extracted values to boost the app in a way that reflective calls are no longer a challenge for existing static analyzers. This is achieved through a bytecode instrumentation approach, where reflective calls are supplemented with explicit traditional Java method calls which can be followed by state-of-the-art analyzers which do not handle reflection. Instrumented apps can thus be completely analyzed by existing static analyzers, which are no longer required to be modified to support reflection-aware analysis. The video demo of DroidRA can be found at https://youtu.be/-HW0V68aAWc.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582811','',30,3,'IEEE','IEEE Conferences',0),(1232,'Static race detection for device drivers: The Goblint approach',10,391,402,'Device drivers rely on fine-grained locking to ensure safe access to shared data structures. For human testers, concurrency makes such code notoriously hard to debug; for automated reasoning, dynamically allocated memory and low-level pointer manipulation poses significant challenges. We present a flexible approach to data race analysis, implemented in the open source Goblint static analysis framework that combines different pointer and value analyses in order to handle a wide range of locking idioms, including locks allocated dynamically as well as locks stored in arrays. To the best of our knowledge, this is the most ambitious effort, having lasted well over ten years, to create a fully automated static race detection tool that can deal with most of the intricate locking schemes found in Linux device drivers. Our evaluation shows that these analyses are sufficiently precise, but practical use of these techniques requires inferring environmental and domain-specific assumptions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582775','',46,0,'IEEE','IEEE Conferences',0),(1233,'Optimizing customized program coverage',10,27,38,'Program coverage is used across many stages of software development. While common during testing, program coverage has also found use outside the test lab, in production software. However, production software has stricter requirements on run-time overheads, and may limit possible program instrumentation. Thus, optimizing the placement of probes to gather program coverage is important. We introduce and study the problem of customized program coverage optimization. We generalize previous work that optimizes for complete coverage instrumentation with a system that adapts optimization to customizable program coverage requirements. Specifically, our system allows a user to specify desired coverage locations and to limit legal instrumentation locations. We prove that the problem of determining optimal coverage probes is NP-hard, and we present a solution based on mixed integer linear programming. Due to the computational complexity of the problem, we also provide two practical approximation approaches. We evaluate the effectiveness of our approximations across a diverse set of benchmarks, and show that our techniques can substantially reduce instrumentation while allowing the user immense freedom in defining coverage requirements. When naive instrumentation is dense or expensive, our optimizations succeed in lowering execution time overheads.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582742','',40,0,'IEEE','IEEE Conferences',0),(1234,'Practical guidelines for change recommendation using association rule mining',10,732,743,'Association rule mining is an unsupervised learning technique that infers relationships among items in a data set. This technique has been successfully used to analyze a system\'s change history and uncover evolutionary coupling between system artifacts. Evolutionary coupling can, in turn, be used to recommend artifacts that are potentially affected by a given set of changes to the system. In general, the quality of such recommendations is affected by (1) the values selected for various parameters of the mining algorithm, (2) characteristics of the set of changes used to derive a recommendation, and (3) characteristics of the system\'s change history for which recommendations are generated. In this paper, we empirically investigate the extent to which certain choices for these factors affect change recommendation. Specifically, we conduct a series of systematic experiments on the change histories of two large industrial systems and eight large open source systems, in which we control the size of the change set for which to derive a recommendation, the measure used to assess the strength of the evolutionary coupling, and the maximum size of historical changes taken into account when inferring these couplings. We use the results from our study to derive a number of practical guidelines for applying association rule mining for change recommendation.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582809','',41,0,'IEEE','IEEE Conferences',0),(1235,'An end-user oriented tool suite for development of mobile applications',10,768,773,'In this paper, we show an end-user oriented tool suite for mobile application development. The advantages of this tool suite are that the graphical user interface (GUI), as well as the application logic can both be developed in a rapid and simple way, and web-based services on the Internet can be integrated into our platform by end-users. This tool suite involves three sub-systems, namely ServiceAccess, EasyApp and LSCE. ServiceAccess takes charge of the registration and management of heterogeneous services, and can export different form of services according to the requirements of the other sub-systems. EasyApp is responsible for developing GUI in the form of mobile app. LSCE takes charge of creating the application logic that can be invoked by mobile app directly. Finally, a development case is presented to illustrate the development process using this tool suite. The URL of demo video: https://youtu.be/mM2WkU1_k-w.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582813','',21,0,'IEEE','IEEE Conferences',0),(1236,'Traceability maintenance: Factors and guidelines',10,414,425,'Traceability is an important concern for numerous software engineering activities. Establishing traceability links is a challenging and cost-intensive task, which is uneconomical without suitable strategies for maintaining high link quality. Current approaches to Traceability Management (TM), however, often make important assumptions and choices without ensuring that the consequences and implications for trace-ability maintenance are feasible and desirable in practice. In this paper, therefore, we identify a set of core factors that influence how the quality of traceability links can be maintained. For each factor, we discuss relevant challenges and provide guidelines on how best to ensure viable traceability maintenance in a practical TM approach. Our guidelines are meant to be used by tool developers and users to select the most appropriate TM approach for their needs. Our results are based on and supported by data collected from interviews conducted with: (i) 9 of our industrial and academic project partners to elicit requirements for a TM tool, and (ii) 24 software development stakeholders from 15 industrial cases to provide a broader overview of the current state of the practice on TM. To evaluate the feasibility of our guidelines, we investigate a set of existing TM approaches used in industry with respect to our guidelines.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582777','',31,0,'IEEE','IEEE Conferences',0),(1237,'Inferring annotations for device drivers from verification histories',10,450,460,'This paper studies and optimizes automated program verification. Detailed reasoning about software behavior is often facilitated by program invariants that hold across all program executions. Finding program invariants is in fact an essential step in automated program verification. Automatic discovery of precise invariants, however, can be very difficult in practice. The problem can be simplified if one has access to a candidate set of assertions (or annotations) and the search for invariants is limited over the space defined by these annotations. Then, the main challenge is to automatically generate quality program annotations. We present an approach that infers program annotations automatically by leveraging the history of verifying related programs. Our algorithm extracts high-quality annotations from previous verification attempts, and then applies them for verifying new programs. We present a case study where we applied our algorithm to Microsoft\'s Static Driver Verifier (SDV). SDV is an industrial-strength tool for verification of Windows device drivers that uses manually-tuned heuristics for obtaining a set of annotations. Our technique inferred program annotations comparable in performance to the existing annotations used in SDV that were devised manually by human experts over years. Additionally, the inferred annotations together with the existing ones improved the performance of SDV overall, proving correct 47% of drivers more while running 22% faster in our experiments.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582781','',28,0,'IEEE','IEEE Conferences',0),(1238,'Test case permutation to improve execution time',10,45,50,'With the growing complexity of software, the number of test cases needed for effective validation is extremely large. Executing these large test suites is expensive, both in terms of time and energy. Cache misses are known to be one of the main factors contributing to execution time of a software. Cache misses are reduced by increasing the locality of memory references. For a single program run, compiler optimisations help improve data locality and code layout optimisations help improve spatial locality of instructions. Nevertheless, cache locality optimisations have not been proposed and explored across several program runs, which is the case when we run several test cases. In this paper, we propose and evaluate a novel approach to improve instruction locality across test case runs. Our approach measures the distance between test case runs (number of different instructions). We then permute the test cases for execution so that the distance between neighboring test cases is minimised. We hypothesize that test cases executed in this new order for improved instruction locality will reduce time consumed. We conduct a preliminary evaluation with four subject programs and test suites from the SIR repository to answer the following questions, 1. Is execution time of a test suite affected by the order in which test cases are executed? and 2. How does time consumed in executing our permutation compare to random test case permutations? We found that the order in which test cases are executed has a definite impact on execution time. The extent of impact varies, based on program characteristics and test cases. Our approach outperformed more than 97% of random test case permutations on 3 of the 4 subject programs and did better than 93% of the random orderings on the remaining subject program. Using the optimised permutation, we saw a maximum reduction of 7.4% over average random permutation execution time and 34.7% over the worst permutation.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582744','',23,0,'IEEE','IEEE Conferences',0),(1239,'MACKE: Compositional analysis of low-level vulnerabilities with symbolic execution',10,780,785,'Concolic (concrete+symbolic) execution has recently gained popularity as an effective means to uncover non-trivial vulnerabilities in software, such as subtle buffer overflows. However, symbolic execution tools that are designed to optimize statement coverage often fail to cover potentially vulnerable code because of complex system interactions and scalability issues of constraint solvers. In this paper, we present a tool (MACKE) that is based on the modular interactions inferred by static code analysis, which is combined with symbolic execution and directed inter-procedural path exploration. This provides an advantage in terms of statement coverage and ability to uncover more vulnerabilities. Our tool includes a novel feature in the form of interactive vulnerability report generation that helps developers prioritize bug fixing based on severity scores. A demo of our tool is available at https://youtu.be/icC3jc3mHEU.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582815','',34,0,'IEEE','IEEE Conferences',0),(1240,'DSL-maps: From requirements to design of domain-specific languages',10,438,443,'Domain-Specific Languages (DSLs) are central to Model-Driven Engineering, where they are used for creating models for particular domains. However, current research and tools for building DSLs focus on the design and implementation aspects of the DSL, while the requirements analysis phase, and its automated transition to design is largely neglected. In order to alleviate this situation, we propose DSL-maps, a notation inspired by mind-maps, to represent requirements for DSLs. The notation is supported by a tool, which helps in the automated transition into an initial meta-model design, using a customizable transformation and recommendations from a catalogue of meta-model design patterns.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582779','',16,0,'IEEE','IEEE Conferences',0),(1241,'APEx: Automated inference of error specifications for C APIs',10,472,482,'Although correct error handling is crucial to software robustness and security, developers often inadvertently introduce bugs in error handling code. Moreover, such bugs are hard to detect using existing bug-finding tools without correct error specifications. Creating error specifications manually is tedious and error-prone. In this paper, we present a new technique that automatically infers error specifications of API functions based on their usage patterns in C programs. Our key insight is that error-handling code tend to have fewer branching points and program statements than the code implementing regular functionality. Our scheme leverages this property to automatically identify error handling code at API call sites and infer the corresponding error constraints. We then use the error constraints from multiple call sites for robust inference of API error specifications. We evaluated our technique on 217 API functions from 6 different libraries across 28 projects written in C and found that it can identify error-handling paths with an average precision of 94% and recall of 66%. We also found that our technique can infer correct API error specifications with an average precision of 77% and recall of 47%. To further demonstrate the usefulness of the inferred error specifications, we used them to find 118 previously unknown potential bugs (including several security flaws that are currently being fixed by the corresponding developers) in the 28 tested projects.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582783','',42,0,'IEEE','IEEE Conferences',0),(1242,'Testing advanced driver assistance systems using multi-objective search and neural networks',10,63,74,'Recent years have seen a proliferation of complex Advanced Driver Assistance Systems (ADAS), in particular, for use in autonomous cars. These systems consist of sensors and cameras as well as image processing and decision support software components. They are meant to help drivers by providing proper warnings or by preventing dangerous situations. In this paper, we focus on the problem of design time testing of ADAS in a simulated environment. We provide a testing approach for ADAS by combining multi-objective search with surrogate models developed based on neural networks. We use multi-objective search to guide testing towards the most critical behaviors of ADAS. Surrogate modeling enables our testing approach to explore a larger part of the input search space within limited computational resources. We characterize the condition under which the multi-objective search algorithm behaves the same with and without surrogate modeling, thus showing the accuracy of our approach. We evaluate our approach by applying it to an industrial ADAS system. Our experiment shows that our approach automatically identifies test cases indicating critical ADAS behaviors. Further, we show that combining our search algorithm with surrogate modeling improves the quality of the generated test cases, especially under tight and realistic computational resources.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582746','',59,0,'IEEE','IEEE Conferences',0),(1243,'Evaluating the evaluations of code recommender systems: A reality check',10,111,121,'While researchers develop many new exciting code recommender systems, such as method-call completion, code-snippet completion, or code search, an accurate evaluation of such systems is always a challenge. We analyzed the current literature and found that most of the current evaluations rely on artificial queries extracted from released code, which begs the question: Do such evaluations reflect real-life usages? To answer this question, we capture 6,189 fine-grained development histories from real IDE interactions. We use them as a ground truth and extract 7,157 real queries for a specific method-call recommender system. We compare the results of such real queries with different artificial evaluation strategies and check several assumptions that are repeatedly used in research, but never empirically evaluated. We find that an evolving context that is often observed in practice has a major effect on the prediction quality of recommender systems, but is not commonly reflected in artificial evaluations.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582750','',29,0,'IEEE','IEEE Conferences',0),(1244,'CORRECT: Code reviewer recommendation at GitHub for Vendasta technologies',10,792,797,'Peer code review locates common coding standard violations and simple logical errors in the early phases of software development, and thus, reduces overall cost. Unfortunately, at GitHub, identifying an appropriate code reviewer for a pull request is challenging given that reliable information for reviewer identification is often not readily available. In this paper, we propose a code reviewer recommendation tool-CORRECT-that considers not only the relevant cross-project work experience (e.g., external library experience) of a developer but also her experience in certain specialized technologies (e.g., Google App Engine) associated with a pull request for determining her expertise as a potential code reviewer. We design our tool using client-server architecture, and then package the solution as a Google Chrome plug-in. Once the developer initiates a new pull request at GitHub, our tool automatically analyzes the request, mines two relevant histories, and then returns a ranked list of appropriate code reviewers for the request within the browser\'s context. Demo: https://www.youtube.com/watch?v=rXU1wTD6QQ0.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582817','',18,0,'IEEE','IEEE Conferences',0),(1245,'Visual contract extractor: A tool for reverse engineering visual contracts using dynamic analysis',10,816,821,'Visual contracts model the operations of classes, components or services by pre- and post-conditions formalised as graph transformation rules. They provide a precise but intuitive notation to test, document and analyse software systems. However, due to their detailed level of specification of data states and transformations, modelling a real application is a complex and error-prone process. Rather than adopting a top-down modelling approach, we follow a dynamic bottom-up approach to reverse engineer visual contracts from object-oriented programs based on tracing the execution of operations. We developed the Visual Contract Extractor (VCE), a dynamic analysis tool which supports the reverse engineering of visual operation contracts from Java programs. We explore the main features of the tool using two case studies and discuss usage scenarios ranging from traditional program understanding to novel applications in the field of model-based engineering. A screencast demonstrating the tool is provided at https://www.youtube.com/watch?v=VtTx8UHgRGo.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582821','',30,0,'IEEE','IEEE Conferences',0),(1246,'Precise semantic history slicing through dynamic delta refinement',10,495,506,'Semantic history slicing solves the problem of extracting changes related to a particular high-level functionality from the software version histories. State-of-the-art techniques combine static program analysis and dynamic execution tracing to infer an over-approximated set of changes that can preserve the functional behaviors captured by a test suite. However, due to the conservative nature of such techniques, the sliced histories may contain irrelevant changes. In this paper, we propose a divide-and-conquer-style partitioning approach enhanced by dynamic delta refinement to produce minimal semantic history slices. We utilize deltas in dynamic invariants generated from successive test executions to learn significance of changes with respect to the target functionality. Empirical results indicate that these measurements accurately rank changes according to their relevance to the desired test behaviors and thus partition history slices in an efficient and effective manner.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582785','',45,0,'IEEE','IEEE Conferences',0),(1247,'Deep learning code fragments for code clone detection',10,87,98,'Code clone detection is an important problem for software maintenance and evolution. Many approaches consider either structure or identifiers, but none of the existing detection techniques model both sources of information. These techniques also depend on generic, handcrafted features to represent code fragments. We introduce learning-based detection techniques where everything for representing terms and fragments in source code is mined from the repository. Our code analysis supports a framework, which relies on deep learning, for automatically linking patterns mined at the lexical level with patterns mined at the syntactic level. We evaluated our novel learning-based approach for code clone detection with respect to feasibility from the point of view of software maintainers. We sampled and manually evaluated 398 file- and 480 method-level pairs across eight real-world Java systems; 93% of the file- and method-level samples were evaluated to be true positives. Among the true positives, we found pairs mapping to all four clone types. We compared our approach to a traditional structure-oriented technique and found that our learning-based approach detected clones that were either undetected or suboptimally reported by the prominent tool Deckard. Our results affirm that our learning-based approach is suitable for clone detection and a tenable technique for researchers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582748','',115,0,'IEEE','IEEE Conferences',0),(1248,'Automatic microbenchmark generation to prevent dead code elimination and constant folding',10,132,143,'Microbenchmarking evaluates, in isolation, the execution time of small code segments that play a critical role in large applications. The accuracy of a microbenchmark depends on two critical tasks: wrap the code segment into a pay-load that faithfully recreates the execution conditions of the large application; build a scaffold that runs the payload a large number of times to get a statistical estimate of the execution time. While recent frameworks such as the Java Microbenchmark Harness (JMH) address the scaffold challenge, developers have very limited support to build a correct payload. This work focuses on the automatic generation of pay-loads, starting from a code segment selected in a large application. Our generative technique prevents two of the most common mistakes made in microbenchmarks: dead code elimination and constant folding. A microbenchmark is such a small program that can be 鈥渙ver-optimized鈥� by the JIT and result in distorted time measures, if not designed carefully. Our technique automatically extracts the segment into a compilable payload and generates additional code to prevent the risks of 鈥渙ver-optimization鈥�. The whole approach is embedded in a tool called AutoJMH, which generates payloads for JMH scaffolds. We validate the capabilities AutoJMH, showing that the tool is able to process a large percentage of segments in real programs. We also show that AutoJMH can match the quality of payloads handwritten by performance experts and outperform those written by professional Java developers without experience in microbenchmarking.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582752','',36,0,'IEEE','IEEE Conferences',0),(1249,'CVExplorer: Identifying candidate developers by mining and exploring their open source contributions',10,804,809,'Open source code contributions contain a large amount of technical skill information about developers, which can help to identify suitable candidates for a particular development job and therefore impact the success of a development team. We develop CVExplorer as a tool to extract, visualize, and explore relevant technical skills data from GitHub, such as languages and libraries used. It allows non-technical users to filter and identify developers according to technical skills demonstrated across all of their open source contributions, in order to support more accurate candidate identification. We demonstrate the usefulness of CVExplorer by using it to recommend candidates for open positions in two companies. A video demonstration of the tool is available at https:// youtu.be/xRxK-wa7PME.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582819','',27,1,'IEEE','IEEE Conferences',0),(1250,'Symbolic execution of stored procedures in database management systems',10,519,530,'Stored procedures in database management systems are often used to implement complex business logic. Correctness of these procedures is critical for correct working of the system. However, testing them remains difficult due to many possible states of data and database constraints. This leads to mostly manual testing. Newer tools offer automated execution for unit testing of stored procedures but the test cases are still written manually. In this paper, we propose a novel approach of using dynamic symbolic execution to automatically generate test cases and corresponding database states for stored procedures. We treat values in database tables as symbolic, model the constraints on data imposed by the schema and by the SQL statements executed by the stored procedure. We use an SMT solver to find values that will drive the stored procedure on a particular execution path. We instrument the internal execution plans generated by PostgreSQL database management system to extract constraints and use the Z3 SMT solver to generate test cases consisting of table data and procedure inputs. Our evaluation using stored procedures from a large business application shows that this technique can uncover bugs that lead to schema constraint violations and user defined exceptions.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582787','',36,0,'IEEE','IEEE Conferences',0),(1251,'Towards bounded model checking using nonlinear programming solver',10,560,565,'Due to their complexity, currently available bounded model checking techniques based on Boolean Satisfiability and Satisfiability Modulo Theories inadequately handle non-linear floating-point and integer arithmetic. Using a numerical approach, we reduce a bounded model checking problem to a constraint satisfaction problem. Currently available techniques attempt to solve the constraint problem but can guarantee neither global convergence nor correctness. Using the IPOPT and ANTIGONE non-linear programming (NLP) solvers, we transform the original constraint satisfaction problem from one having disjunctions of constraints into one having conjunctions of constraints with a few introduced auxiliary variables. The transformation lowers the computing cost and preserves the Boolean structure of the original problem while complying with limits of NLP solvers.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582791','',20,0,'IEEE','IEEE Conferences',0),(1252,'Finding access control bugs in web applications with CanCheck',10,155,166,'Access control bugs in web applications can have dire consequences since many web applications store private and sensitive data. In this paper we present an automated verification technique for access control in Ruby on Rails (Rails) applications. Our technique starts by automatically extracting a model that captures 1) the ways the data is accessed and modified by the application, 2) the access control policy of the application, and 3) the authorization checks used for access control policy enforcement. Then, it automatically translates this model to first order logic and uses automated theorem provers to check whether the declared access control policy is correctly enforced by the implementation. We implemented our technique in a tool called CanCheck. Using CanCheck on open source Rails applications, we found numerous previously unknown exploitable access control bugs as well as several deficiencies in access control policies.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582754','',38,0,'IEEE','IEEE Conferences',0),(1253,'TeeVML: Tool support for semi-automatic integration testing environment emulation',10,840,845,'Software environment emulation provides a means for simulating an operational environment of a system. This process involves approximation of systems\' external behaviors and their communications with a system to be tested in the environment. Development of such an environment is a tedious task and involves complex low level coding. Model driven engineering is an avenue to raise the level of abstraction beyond programming by specifying solution directly using problem domain concepts. In this paper we propose a novel domain-specific modeling tool to generate complex testing environments. Our tool employs a suite of domain-specific visual modeling languages for modeling emulation environment at a high level of abstraction. These high level specifications are then automatically transformed to runtime environment for application integration testing, boosting development productivity and ease of use. The tool demonstration video can be accessed here: https://youtu.be/H3Vg20Juq80.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582825','',13,0,'IEEE','IEEE Conferences',0),(1254,'Model-based whitebox fuzzing for program binaries',10,543,553,'Many real-world programs take highly structured and complex files as inputs. The automated testing of such programs is non-trivial. If the test does not adhere to a specific file format, the program returns a parser error. For symbolic execution-based whitebox fuzzing the corresponding error handling code becomes a significant time sink. Too much time is spent in the parser exploring too many paths leading to trivial parser errors. Naturally, the time is better spent exploring the functional part of the program where failure with valid input exposes deep and real bugs in the program. In this paper, we suggest to leverage information about the file format and data chunks of existing, valid files to swiftly carry the exploration beyond the parser code. We call our approach Modelbased Whitebox Fuzzing (MoWF) because the file format input model of blackbox fuzzers can be exploited as a constraint on the vast input space to rule out most invalid inputs during path exploration in symbolic execution. We evaluate on 13 vulnerabilities in 8 large program binaries with 6 separate file formats and found that MoWF exposes all vulnerabilities while both, traditional whitebox fuzzing and model-based blackbox fuzzing, expose only less than half, respectively. Our experiments also demonstrate that MoWF exposes 70% vulnerabilities without any seed inputs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582789','',27,0,'IEEE','IEEE Conferences',0),(1255,'Continuous detection of design flaws in evolving object-oriented programs using incremental multi-pattern matching',10,578,589,'Design flaws in object-oriented programs may seriously corrupt code quality thus increasing the risk for introducing subtle errors during software maintenance and evolution. Most recent approaches identify design flaws in an ad-hoc manner, either focusing on software metrics, locally restricted code smells, or on coarse-grained architectural anti-patterns. In this paper, we utilize an abstract program model capturing high-level object-oriented code entities, further augmented with qualitative and quantitative design-related information such as coupling/cohesion. Based on this model, we propose a comprehensive methodology for specifying object-oriented design flaws by means of compound rules integrating code metrics, code smells and anti-patterns in a modular way. This approach allows for efficient, automated design-flaw detection through incremental multi-pattern matching, by facilitating systematic information reuse among multiple detection rules as well as between subsequent detection runs on continuously evolving programs. Our tool implementation comprises well-known anti-patterns for Java programs. The results of our experimental evaluation show high detection precision, scalability to real-size programs, as well as a remarkable gain in efficiency due to information reuse.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582793','',42,0,'IEEE','IEEE Conferences',0),(1256,'Supporting oracle construction via static analysis',10,178,189,'In software testing, the program under test is usually executed with test inputs and checked against a test oracle, which is a mechanism to verify whether the program behaves as expected. Selecting the right oracle data to observe is crucial in test oracle construction. In the literature, researchers have proposed two dynamic approaches to oracle data selection by analyzing test execution information (e.g., variables\' values or interaction information). However, collecting such information during program execution may incur extra cost. In this paper, we present the first static approach to oracle data selection, SODS (Static Oracle Data Selection). In particular, SODS first identifies the substitution relationships between candidate oracle data by constructing a probabilistic substitution graph based on the definition-use chains of the program under test, then estimates the fault-observing capability of each candidate oracle data, and finally selects a subset of oracle data with strong fault-observing capability. For programs with analyzable test code, we further extend SODS via pruning the probabilistic substitution graph based on 0-1-CFA call graph analysis. The experimental study on 11 subject systems written in C or Java demonstrates that our static approach is more effective and much more efficient than state-of-the-art dynamic approaches in most cases.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582756','',79,0,'IEEE','IEEE Conferences',0),(1257,'QUICKAR: Automatic query reformulation for concept location using crowdsourced knowledge',10,220,225,'During maintenance, software developers deal with numerous change requests made by the users of a software system. Studies show that the developers find it challenging to select appropriate search terms from a change request during concept location. In this paper, we propose a novel technique-QUICKAR-that automatically suggests helpful reformulations for a given query by leveraging the crowdsourced knowledge from Stack Overflow. It determines semantic similarity or relevance between any two terms by analyzing their adjacent word lists from the programming questions of Stack Overflow, and then suggests semantically relevant queries for concept location. Experiments using 510 queries from two software systems suggest that our technique can improve or preserve the quality of 76% of the initial queries on average which is promising. Comparison with one baseline technique validates our preliminary findings, and also demonstrates the potential of our technique.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582760','',24,0,'IEEE','IEEE Conferences',0),(1258,'Verifying Simulink Stateflow model: Timed automata approach',10,852,857,'Simulink Stateflow is widely used for the model-driven development of software. However, the increasing demand of rigorous verification for safety critical applications brings new challenge to the Simulink Stateflow because of the lack of formal semantics. In this paper, we present STU, a self-contained toolkit to bridge the Simulink Stateflow and a well-defined rigorous verification. The tool translates the Simulink Stateflow into the Uppaal timed automata for verification. Compared to existing work, more advanced and complex modeling features in Stateflow such as the event stack, conditional action and timer are supported. Then, with the strong verification power of Uppaal, we can not only find design defects that are missed by the Simulink Design Verifier, but also check more important temporal properties. The evaluation on artificial examples and real industrial applications demonstrates the effectiveness.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582827','',15,1,'IEEE','IEEE Conferences',0),(1259,'Towards efficient and effective automatic program repair',10,876,879,'Automatic Program Repair (APR) has recently been an emerging research area, addressing an important challenge in software engineering. APR techniques, if effective and efficient, can greatly help software debugging and maintenance. Recently proposed APR techniques can be generally classified into two families, namely search-based and semantics-based APR methods. To produce repairs, search based APR techniques generate huge populations of possible repairs, i.e., search space, and lazily search for the best one among the search space. Semantics-based APR techniques utilize constraint solving and program synthesis to make search space more tractable, and find those repairs that conform to semantics constraints extracted via symbolic execution. Despite recent advances in APR, search-based APR still suffers from search space explosion problem, while the semantics-based APR could be hindered by limited capability of constraint solving and program synthesis. Furthermore, both APR families may be subject to overfitting, in which generated repairs do not generalize to other test sets. This thesis works towards enhancing both effectiveness and efficiency in order for APR to be practically adopted in foreseeable future. To achieve this goal, other than using test cases as the primary criteria for traversing the search space, we designed a new feature used for a new search-based APR technique to effectively traverse the search space, wherein bug fix history is used to evaluate the quality of repair candidates. We also developed a deductive-reasoning-based repair technique that combines search-based and semantics-based approaches to enhance the repair capability, while ensuring the soundness of generated repairs. We also leveraged machine-learning techniques to build a predictive model that predicts whether an APR technique is effective in fixing particular bugs. In the future, we plan to synergize many existing APR techniques, improve our predictive model, and adopt the advances of other fields such as test case generation and program synthesis for APR.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582831','',29,0,'IEEE','IEEE Conferences',0),(1260,'How good are the specs? A study of the bug-finding effectiveness of existing Java API specifications',10,602,613,'Runtime verification can be used to find bugs early, during software development, by monitoring test executions against formal specifications (specs). The quality of runtime verification depends on the quality of the specs. While previous research has produced many specs for the Java API, manually or through automatic mining, there has been no large-scale study of their bug-finding effectiveness. We present the first in-depth study of the bug-finding effectiveness of previously proposed specs. We used JavaMOP to monitor 182 manually written and 17 automatically mined specs against more than 18K manually written and 2.1M automatically generated tests in 200 open-source projects. The average runtime overhead was under 4.3x. We inspected 652 violations of manually written specs and (randomly sampled) 200 violations of automatically mined specs. We reported 95 bugs, out of which developers already fixed 74. However, most violations, 82.81% of 652 and 97.89% of 200, were false alarms. Our empirical results show that (1) runtime verification technology has matured enough to incur tolerable runtime overhead during testing, and (2) the existing API specifications can find many bugs that developers are willing to fix; however, (3) the false alarm rates are worrisome and suggest that substantial effort needs to be spent on engineering better specs and properly evaluating their effectiveness.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582795','',63,0,'IEEE','IEEE Conferences',0),(1261,'Multi-objective test report prioritization using image understanding',10,202,213,'In crowdsourced software testing, inspecting the large number of test reports is an overwhelming but inevitable software maintenance task. In recent years, to alleviate this task, many text-based test-report classification and prioritization techniques have been proposed. However in the mobile testing domain, test reports often consist of more screenshots and shorter descriptive text, and thus text-based techniques may be ineffective or inapplicable. The shortage and ambiguity of natural-language text information and the well defined screenshots of activity views within mobile applications motivate our novel technique based on using image understanding for multi-objective test-report prioritization. In this paper, by taking the similarity of screenshots into consideration, we present a multi-objective optimization-based prioritization technique to assist inspections of crowdsourced test reports. In our technique, we employ the Spatial Pyramid Matching (SPM) technique to measure the similarity of the screenshots, and apply the natural-language processing technique to measure the distance between the text of test reports. Furthermore, to validate our technique, an experiment with more than 600 test reports and 2500 images is conducted. The experimental results show that image-understanding techniques can provide benefit to test-report prioritization for most applications.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582758','',41,0,'IEEE','IEEE Conferences',0),(1262,'Automated model-based Android GUI testing using multi-level GUI comparison criteria',10,238,249,'Automated Graphical User Interface (GUI) testing is one of the most widely used techniques to detect faults in mobile applications (apps) and to test functionality and usability. GUI testing exercises behaviors of an application under test (AUT) by executing events on GUIs and checking whether the app behaves correctly. In particular, because Android leads in market share of mobile OS platforms, a lot of research on automated Android GUI testing techniques has been performed. Among various techniques, we focus on model-based Android GUI testing that utilizes a GUI model for systematic test generation and effective debugging support. Since test inputs are generated based on the underlying model, accurate GUI modeling of an AUT is the most crucial factor in order to generate effective test inputs. However, most modern Android apps contain a number of dynamically constructed GUIs that make accurate behavior modeling more challenging. To address this problem, we propose a set of multi-level GUI Comparison Criteria (GUICC) that provides the selection of multiple abstraction levels for GUI model generation. By using multilevel GUICC, we conducted empirical experiments to identify the influence of GUICC on testing effectiveness. Results show that our approach, which performs model-based testing with multi-level GUICC, achieved higher effectiveness than activity-based GUI model generation. We also found that multi-level GUICC can alleviate the inherent state explosion problems of existing a single-level GUICC for behavior modeling of real-world Android apps by flexibly manipulating GUICC.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582762','',27,2,'IEEE','IEEE Conferences',0),(1263,'An automated collaborative requirements engineering tool for better validation of requirements',10,864,869,'This demo introduces an automated collaborative requirements engineering tool, called TestMEReq, which is used to promote effective communication and collaboration between client-stakeholders and requirements engineers for better requirements validation. Our tool is augmented with real time communication and collaboration support to allow multiple stakeholders to collaboratively validate the same set of requirements. We have conducted a user study focusing on validating requirements using TestMEReq with a few groups of requirements engineers and client stakeholders. The study shows that our automated tool support is able to assist requirements engineers to effectively communicate with client-stakeholders to better validate the requirements virtually in real time. (Demo video: https://www.youtube.com/watch?v=7sWLOx-N4Jo).','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582829','',12,0,'IEEE','IEEE Conferences',0),(1264,'Towards automatically generating descriptive names for unit tests',10,625,636,'During maintenance, developers often need to understand the purpose of a test. One of the most potentially useful sources of information for understanding a test is its name. Ideally, test names are descriptive in that they accurately summarize both the scenario and the expected outcome of the test. Despite the benefits of being descriptive, test names often fall short of this goal. In this paper we present a new approach for automatically generating descriptive names for existing test bodies. Using a combination of natural-language program analysis and text generation, the technique creates names that summarize the test\'s scenario and the expected outcome. The results of our evaluation show that, (1) compared to alternative approaches, the names generated by our technique are significantly more similar to human-generated names and are nearly always preferred by developers, (2) the names generated by our technique are preferred over or are equivalent to the original test names in 83% of cases, and (3) our technique is several orders of magnitude faster than manually writing test names.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582797','',34,0,'IEEE','IEEE Conferences',0),(1265,'Automatic test image generation using procedural noise',10,654,659,'It is difficult to test programs that input images, due to the large number of (pixel) values that must be chosen and the complex ways these values interact. Typically, such programs are tested manually, using images that have known results. However, this is a laborious process and limited in the range of tests that can be applied. We introduce a new approach for testing programs that input images automatically, using procedural noise and spatial statistics to create inputs that are both realistic and can easily be tuned to have specific properties. The effectiveness of our approach is illustrated on an epidemiological simulation of a recently introduced tree pest in Great Britain: Oriental Chestnut Gall Wasp. Our approach produces images that match the real landscapes more closely than other techniques and can be used (alongside metamorphic relations) to detect smaller (artificially introduced) errors with greater accuracy.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582800','',18,0,'IEEE','IEEE Conferences',0),(1266,'Locus: Locating bugs from software changes',10,262,273,'Various information retrieval (IR) based techniques have been proposed recently to locate bugs automatically at the file level. However, their usefulness is often compromised by the coarse granularity of files and the lack of contextual information. To address this, we propose to locate bugs using software changes, which offer finer granularity than files and provide important contextual clues for bug-fixing. We observe that bug inducing changes can facilitate the bug fixing process. For example, it helps triage the bug fixing task to the developers who committed the bug inducing changes or enables developers to fix bugs by reverting these changes. Our study further identifies that change logs and the naturally small granularity of changes can help boost the performance of IR-based bug localization. Motivated by these observations, we propose an IR-based approach Locus to locate bugs from software changes, and evaluate it on six large open source projects. The results show that Locus outperforms existing techniques at the source file level localization significantly. MAP and MRR in particular have been improved, on average, by 20.1% and 20.5%, respectively. Locus is also capable of locating the inducing changes within top 5 for 41.0% of the bugs. The results show that Locus can significantly reduce the number of lines needing to be scanned to locate the bug compared with existing techniques.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582764','',46,0,'IEEE','IEEE Conferences',0),(1267,'Generating test cases to expose concurrency bugs in android applications',10,648,653,'Mobile systems usually support an event-based model of concurrent programming. This model, although advantageous to maintain responsive user interfaces, may lead to subtle concurrency errors due to unforeseen threads interleaving coupled with non-deterministic reordering of asynchronous events. These bugs are very difficult to reproduce even by the same user action sequences that trigger them, due to the undetermined schedules of underlying events and threads. In this paper, we proposed RacerDroid, a novel technique that aims to expose concurrency bugs in android applications by actively controlling event schedule and thread interleaving, given the test cases that have potential data races. By exploring the state model of the application constructed dynamically, our technique starts first to generate a test case that has potential data races based on the results obtained from existing static or dynamic race detection technique. Then it reschedules test cases execution by actively controlling event dispatching and thread interleaving to determine whether such potential races really lead to thrown exceptions or assertion violations. Our preliminary experiments show that RacerDroid is effective, and it confirms real data races, while at the same time eliminates false warnings for Android apps found in the wild.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582799','',28,0,'IEEE','IEEE Conferences',0),(1268,'Migrating cascading style sheets to preprocessors by introducing mixins',10,672,683,'Cascading Style Sheets (CSS) is the standard language for styling web documents and is extensively used in the industry. However, CSS lacks constructs that would allow code reuse (e.g., functions). Consequently, maintaining CSS code is often a cumbersome and error-prone task. Preprocessors (e.g., Less and Sass) have been introduced to fill this gap, by extending CSS with the missing constructs. Despite the clear maintainability benefits coming from the use of preprocessors, there is currently no support for migrating legacy CSS code to preprocessors. In this paper, we propose a technique for automatically detecting duplicated style declarations in CSS code that can be migrated to preprocessor functions (i.e., mixins). Our technique can parameterize differences in the style values of duplicated declarations, and ensure that the migration will not change the presentation semantics of the web documents. The evaluation has shown that our technique is able to detect 98% of the mix-ins that professional developers introduced in websites and Style Sheet libraries, and can safely migrate real CSS code.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582802','',44,0,'IEEE','IEEE Conferences',0),(1269,'Recommending relevant classes for bug reports using multi-objective search',10,286,295,'Developers may follow a tedious process to find the cause of a bug based on code reviews and reproducing the abnormal behavior. In this paper, we propose an automated approach to finding and ranking potential classes with the respect to the probability of containing a bug based on a bug report description. Our approach finds a good balance between minimizing the number of recommended classes and maximizing the relevance of the proposed solution using a multi-objective optimization algorithm. The relevance of the recommended classes (solution) is estimated based on the use of the history of changes and bug-fixing, and the lexical similarity between the bug report description and the API documentation. We evaluated our system on 6 open source Java projects, using the version of the project before fixing the bug of many bug reports. The experimental results show that the search-based approach significantly outperforms three state-of-the-art methods in recommending relevant files for bug reports. In particular, our multi-objective approach is able to successfully locate the true buggy methods within the top 10 recommendations for over 87% of the bug reports.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582766','',28,0,'IEEE','IEEE Conferences',0),(1270,'What developers want and need from program analysis: An empirical study',10,332,343,'Program Analysis has been a rich and fruitful field of research for many decades, and countless high quality program analysis tools have been produced by academia. Though there are some well-known examples of tools that have found their way into routine use by practitioners, a common challenge faced by researchers is knowing how to achieve broad and lasting adoption of their tools. In an effort to understand what makes a program analyzer most attractive to developers, we mounted a multi-method investigation at Microsoft. Through interviews and surveys of developers as well as analysis of defect data, we provide insight and answers to four high level research questions that can help researchers design program analyzers meeting the needs of software developers. First, we explore what barriers hinder the adoption of program analyzers, like poorly expressed warning messages. Second, we shed light on what functionality developers want from analyzers, including the types of code issues that developers care about. Next, we answer what non-functional characteristics an analyzer should have to be widely used, how the analyzer should fit into the development process, and how its results should be reported. Finally, we investigate defects in one of Microsoft\'s flagship software services, to understand what types of code issues are most important to minimize, potentially through program analysis.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582770','',52,0,'IEEE','IEEE Conferences',0),(1271,'Mining revision histories to detect cross-language clones without intermediates',10,696,701,'To attract more users on different platforms, many projects release their versions in multiple programming languages (e.g., Java and C#). They typically have many code snippets that implement similar functionalities, i.e., cross-language clones. Programmers often need to track and modify cross-language clones consistently to maintain similar functionalities across different language implementations. In literature, researchers have proposed approaches to detect cross-language clones, mostly for languages that share a common intermediate language (such as the .NET language family) so that techniques for detecting single-language clones can be applied. As a result, those approaches cannot detect cross-language clones for many projects that are not implemented in a .NET language. To overcome the limitation, in this paper, we propose a novel approach, CLCMiner, that detects cross-language clones automatically without the need of an intermediate language. Our approach mines such clones from revision histories, which reflect how programmers maintain cross-language clones in practice. We have implemented a prototype tool for our approach and conducted an evaluation on five open source projects that have versions in Java and C#. The results show that CLCMiner achieves high accuracy and point to promising future work.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582804','',21,1,'IEEE','IEEE Conferences',0),(1272,'StraightTaint: Decoupled offline symbolic taint analysis',10,308,319,'Taint analysis has been widely applied in ex post facto security applications, such as attack provenance investigation, computer forensic analysis, and reverse engineering. Unfortunately, the high runtime overhead imposed by dynamic taint analysis makes it impractical in many scenarios. The key obstacle is the strict coupling of program execution and taint tracking logic code. To alleviate this performance bottleneck, recent work seeks to offload taint analysis from program execution and run it on a spare core or a different CPU. However, since the taint analysis has heavy data and control dependencies on the program execution, the massive data in recording and transformation overshadow the benefit of decoupling. In this paper, we propose a novel technique to allow very lightweight logging, resulting in much lower execution slowdown, while still permitting us to perform full-featured offline taint analysis. We develop StraightTaint, a hybrid taint analysis tool that completely decouples the program execution and taint analysis. StraightTaint relies on very lightweight logging of the execution information to reconstruct a straight-line code, enabling an offline symbolic taint analysis without frequent data communication with the application. While StraightTaint does not log complete runtime or input values, it is able to precisely identify the causal relationships between sources and sinks, for example. Compared with traditional dynamic taint analysis tools, StraightTaint has much lower application runtime overhead.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582768','',54,0,'IEEE','IEEE Conferences',0),(1273,'Radius aware probabilistic testing of deadlocks with guarantees',10,356,367,'Concurrency bugs only occur under certain interleaving. Existing randomized techniques are usually ineffective. PCT innovatively generates scheduling, before executing a program, based on priorities and priority change points. Hence, it provides a probabilistic guarantee to trigger concurrency bugs. PCT randomly selects priority change points among all events, which might be effective for non-deadlock concurrency bugs. However, deadlocks usually involve two or more threads and locks, and require more ordering constraints to be triggered. We interestingly observe that, every two events of a deadlock usually occur within a short range. We generally formulate this range as the bug Radius, to denote the max distance of every two events of a concurrency bug. Based on the bug radius, we propose RPro (Radius aware Probabilistic testing) for triggering deadlocks. Unlike PCT, RPro selects priority change points within the radius of the targeted deadlocks but not among all events. Hence, it guarantees larger probabilities to trigger deadlocks. We have implemented RPro and PCT and evaluated them on a set of real-world benchmarks containing 10 unique deadlocks. The experimental results show that RPro triggered all deadlocks with higher probabilities (i.e., >7.7x times larger on average) than that by PCT. We also evaluated RPro with radius varying from 1 to 150 (or 300). The result shows that the radius of a deadlock is much smaller (i.e., from 2 to 114 in our experiment) than the number of all events. This further confirms our observation and makes RPro meaningful in practice.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582772','',66,0,'IEEE','IEEE Conferences',0),(1274,'Bugram: Bug detection with n-gram language models',10,708,719,'To improve software reliability, many rule-based techniques have been proposed to infer programming rules and detect violations of these rules as bugs. These rule-based approaches often rely on the highly frequent appearances of certain patterns in a project to infer rules. It is known that if a pattern does not appear frequently enough, rules are not learned, thus missing many bugs. In this paper, we propose a new approach - Bugram - that leverages n-gram language models instead of rules to detect bugs. Bugram models program tokens sequentially, using the n-gram language model. Token sequences from the program are then assessed according to their probability in the learned model, and low probability sequences are marked as potential bugs. The assumption is that low probability token sequences in a program are unusual, which may indicate bugs, bad practices, or unusual/special uses of code of which developers may want to be aware. We evaluate Bugram in two ways. First, we apply Bugram on the latest versions of 16 open source Java projects. Results show that Bugram detects 59 bugs, 42 of which are manually verified as correct, 25 of which are true bugs and 17 are code snippets that should be refactored. Among the 25 true bugs, 23 cannot be detected by PR-Miner. We have reported these bugs to developers, 7 of which have already been confirmed by developers (4 of them have already been fixed), while the rest await confirmation. Second, we further compare Bugram with three additional graph- and rule-based bug detection tools, i.e., JADET, Tikanga, and GrouMiner. We apply Bugram on 14 Java projects evaluated in these three studies. Bugram detects 21 true bugs, at least 10 of which cannot be detected by these three tools. Our results suggest that Bugram is complementary to existing rule-based bug detection approaches.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582806','',57,0,'IEEE','IEEE Conferences',0),(1275,'Learning a dual-language vector space for domain-specific cross-lingual question retrieval',10,744,755,'The lingual barrier limits the ability of millions of non-English speaking developers to make effective use of the tremendous knowledge in Stack Overflow, which is archived in English. For cross-lingual question retrieval, one may use translation-based methods that first translate the non-English queries into English and then perform monolingual question retrieval in English. However, translation-based methods suffer from semantic deviation due to inappropriate translation, especially for domain-specific terms, and lexical gap between queries and questions that share few words in common. To overcome the above issues, we propose a novel cross-lingual question retrieval based on word embed-dings and convolutional neural network (CNN) which are the state-of-the-art deep learning techniques to capture word- and sentence-level semantics. The CNN model is trained with large amounts of examples from Stack Overflow duplicate questions and their corresponding translation by machine, which guides the CNN to learn to capture informative word and sentence features to recognize and quantify semantic similarity in the presence of semantic deviations and lexical gaps. A uniqueness of our approach is that the trained CNN can map documents in two languages (e.g., Chinese queries and English questions) in a dual-language vector space, and thus reduce the cross-lingual question retrieval problem to a simple k-nearest neighbors search problem in the dual-language vector space, where no query or question translation is required. Our evaluation shows that our approach significantly outperforms the translation-based method, and can be extended to dual-language documents retrieval from different sources.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582810','',47,0,'IEEE','IEEE Conferences',0),(1276,'Sound static deadlock analysis for C/Pthreads',10,379,390,'We present a static deadlock analysis for C/Pthreads. The design of our method has been guided by the requirement to analyse real-world code. Our approach is sound (i.e., misses no deadlocks) for programs that have defined behaviour according to the C standard and the Pthreads specification, and is precise enough to prove deadlock-freedom for a large number of such programs. The method consists of a pipeline of several analyses that build on a new context- and thread-sensitive abstract interpretation framework. We further present a lightweight dependency analysis to identify statements relevant to deadlock analysis and thus speed up the overall analysis. In our experimental evaluation, we succeeded to prove deadlock-freedom for 292 programs from the Debian GNU/Linux distribution with in total 2.3 MLOC in 4 hours.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582774','',45,0,'IEEE','IEEE Conferences',0),(1277,'Evaluating non-adequate test-case reduction',10,16,26,'Given two test cases, one larger and one smaller, the smaller test case is preferred for many purposes. A smaller test case usually runs faster, is easier to understand, and is more convenient for debugging. However, smaller test cases also tend to cover less code and detect fewer faults than larger test cases. Whereas traditional research focused on reducing test suites while preserving code coverage, recent work has introduced the idea of reducing individual test cases, rather than test suites, while still preserving code coverage. Other recent work has proposed non-adequately reducing test suites by not even preserving all the code coverage. This paper empirically evaluates a new combination of these two ideas, non-adequate reduction of test cases, which allows for a wide range of trade-offs between test case size and fault detection. Our study introduces and evaluates C%-coverage reduction (where a test case is reduced to retain at least C% of its original coverage) and N-mutant reduction (where a test case is reduced to kill at least N of the mutants it originally killed). We evaluate the reduction trade-offs with varying values of C% and N for four real-world C projects: Mozilla\'s SpiderMonkey JavaScript engine, the YAFFS2 flash file system, Grep, and Gzip. The results show that it is possible to greatly reduce the size of many test cases while still preserving much of their fault-detection capability.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582741','',27,0,'IEEE','IEEE Conferences',0),(1278,'Phrase-based extraction of user opinions in mobile app reviews',10,726,731,'Mobile app reviews often contain useful user opinions like bug reports or suggestions. However, looking for those opinions manually in thousands of reviews is ineffective and time-consuming. In this paper, we propose PUMA, an automated, phrase-based approach to extract user opinions in app reviews. Our approach includes a technique to extract phrases in reviews using part-of-speech (PoS) templates; a technique to cluster phrases having similar meanings (each cluster is considered as a major user opinion); and a technique to monitor phrase clusters with negative sentiments for their outbreaks over time. We used PUMA to study two popular apps and found that it can reveal severe problems of those apps reported in their user reviews.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582808','',19,0,'IEEE','IEEE Conferences',0),(1279,'Relda2: An effective static analysis tool for resource leak detection in Android apps',10,762,767,'Resource leak is a common bug in Android applications (apps for short). In general, it is caused by missing release operations of the resources provided by Android (like Camera, Media Player and Sensors) that require programmers to explicitly release them. It might lead to several serious problems for the app and system, such as performance degradation and system crash. This paper presents Relda2, a light-weight, scalable and practical static analysis tool, for detecting resource leaks in the byte-code of Android apps automatically. It supports two analysis techniques (flow-insensitive for quick scanning and flow-sensitive for accurate scanning), and performs inter-procedural analysis to get more precise bug reports. In addition, our tool is practical to analyze real-world apps, and has been applied to 103 Android apps, including industry applications and open source programs. We have found 67 real resource leaks in these apps, which we confirmed manually. A demo video of our tool can be found at the website: https://www.youtube.com/watch?v=Mk-MFcHpTds.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582812','',14,0,'IEEE','IEEE Conferences',0),(1280,'An empirical evaluation of two user interfaces of an interactive program verifier',10,403,413,'Theorem provers have highly complex interfaces, but there are not many systematic studies of their usability and effectiveness. Specifically, for interactive theorem provers the ability to quickly comprehend intermediate proof situations is of pivotal importance. In this paper we present the (as far as we know) first empirical study that systematically compares the effectiveness of different user interfaces of an interactive theorem prover. We juxtapose two different user interfaces of the interactive verifier KeY: the traditional one which focuses on proof objects and a more recent one that provides a view akin to an interactive debugger. We carefully designed a controlled experiment where users were given various proof understanding tasks that had to be solved with alternating interfaces. We provide statistical evidence that the conjectured higher effectivity of the debugger-like interface is not just a hunch.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582776','',14,0,'IEEE','IEEE Conferences',0),(1281,'The IDE as a scriptable information system',10,444,449,'Software engineering is extremely information-intensive. Every day developers work with source code, version repositories, issue trackers, documentation, web-based and other information resources. However, three key aspects of information work lack good support: (i) combining information from different sources; (ii) flexibly presenting collected information to enable easier comprehension; and (iii) automatically acting on collected information, for example to perform a refactoring. Poor support for these activities makes many common development tasks time-consuming and error-prone. We propose an approach that directly addresses these three issues by integrating a flexible query mechanism into the development environment. Our approach enables diverse ways to process and visualize information and can be extended via scripts. We demonstrate how an implementation of the approach can be used to rapidly write queries that meet a wide range of information needs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582780','',19,0,'IEEE','IEEE Conferences',0),(1282,'What makes killing a mutant hard',10,39,44,'Mutation operators have been studied at length to determine which ones are the 鈥渂est鈥� at some metric (for example creates the least equivalent mutants, creates hard-to-kill mutants, etc.). These studies though have focused on specific test suites, where the test inputs and oracles are fixed, which leads to results that are strongly influenced by the test suites and thus makes the conclusions potentially less general. In this paper we consider all test inputs and we assume we have no prior knowledge about the likelihood of any specific inputs. We will also show how varying the strength of the oracle have a big impact on the results. We only consider a few mutation operators (mostly relational), only a handful of programs to mutate (amenable to probabilistic symbolic execution), and only consider how likely it is that a mutant is killed. A core finding is that the likelihood of reaching the source line where the mutation is applied, is an important contributor to the likelihood of killing the mutant and when we control for this we can see which operators create mutations that are too easy versus very hard to kill.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582743','',16,0,'IEEE','IEEE Conferences',0),(1283,'Model driven design of heterogeneous synchronous embedded systems',10,774,779,'Synchronous embedded systems are becoming more and more complicated and are usually implemented with integrated hardware/software solutions. This implementation manner brings new challenges to the traditional model-driven design environments such as SCADE and STATEMATE, that supports pure hardware or software design. In this paper, we propose a co-design tool Tsmart-Edola to facilitate the system developers, and automatically generate the executable VHDL code and C code from the formal verified SyncBlock computation model. SyncBlock is a lightweight high-level system specification model with well defined syntax, simulation and formal semantics. Based on which, the graphical model editor, graphical simulator, verification translator, and code generator are implemented and seamlessly integrated into the Tsmart-Edola. For evaluation, we apply Tsmart-Edola to the design of a real-world train controller based on the international standard IEC 61375. Several critical ambiguousness or bugs in the standard are detected during formal verification of the constructed system model. Furthermore, the generated VHDL code and C code of Tsmart-Edola outperform that of the state-of-the-art tools in terms of synthesized gate array resource consumption and binary code size. The abstract demo video address is : https://youtu.be/D9ROyJmKZ4s The tool, user manual and examples can be downloaded: http://sts.thss.tsinghua.edu.cn/Tsmart-Edola/.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582814','',19,0,'IEEE','IEEE Conferences',0),(1284,'Usage, costs, and benefits of continuous integration in open-source projects',10,426,437,'Continuous integration (CI) systems automate the compilation, building, and testing of software. Despite CI rising as a big success story in automated software engineering, it has received almost no attention from the research community. For example, how widely is CI used in practice, and what are some costs and benefits associated with CI? Without answering such questions, developers, tool builders, and researchers make decisions based on folklore instead of data. In this paper, we use three complementary methods to study the usage of CI in open-source projects. To understand which CI systems developers use, we analyzed 34,544 open-source projects from GitHub. To understand how developers use CI, we analyzed 1,529,291 builds from the most commonly used CI system. To understand why projects use or do not use CI, we surveyed 442 developers. With this data, we answered several key questions related to the usage, costs, and benefits of CI. Among our results, we show evidence that supports the claim that CI helps projects release more often, that CI is widely adopted by the most popular projects, as well as finding that the overall percentage of projects using CI continues to grow, making it important and timely to focus more research on CI.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582778','',56,2,'IEEE','IEEE Conferences',0),(1285,'Array length inference for C library bindings',10,461,471,'Simultaneous use of multiple programming languages (polyglot programming) assists in creating efficient, coherent, modern programs in the face of legacy code. However, manually creating bindings to low-level languages like C is tedious and error-prone. We offer relief in the form of an automated suite of analyses, designed to enhance the quality of automatically produced bindings. These analyses recover high-level array length information that is missing from C\'s type system. We emit annotations in the style of GObject-Introspection, which produces bindings from annotations on function signatures. We annotate each array argument as terminated by a special sentinel value, fixed-length, or of length determined by another argument. These properties help produce more idiomatic, efficient bindings. We correctly annotate at least 70% of all arrays with these length types, and our results are comparable to those produced by human annotators, but take far less time to produce.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582782','',24,0,'IEEE','IEEE Conferences',0),(1286,'Predicting semantically linkable knowledge in developer online forums via convolutional neural network',10,51,62,'Consider a question and its answers in Stack Overflow as a knowledge unit. Knowledge units often contain semantically relevant knowledge, and thus linkable for different purposes, such as duplicate questions, directly linkable for problem solving, indirectly linkable for related information. Recognising different classes of linkable knowledge would support more targeted information needs when users search or explore the knowledge base. Existing methods focus on binary relatedness (i.e., related or not), and are not robust to recognize different classes of semantic relatedness when linkable knowledge units share few words in common (i.e., have lexical gap). In this paper, we formulate the problem of predicting semantically linkable knowledge units as a multiclass classification problem, and solve the problem using deep learning techniques. To overcome the lexical gap issue, we adopt neural language model (word embeddings) and convolutional neural network (CNN) to capture word- and document-level semantics of knowledge units. Instead of using human-engineered classifier features which are hard to design for informal user-generated content, we exploit large amounts of different types of user-created knowledge-unit links to train the CNN to learn the most informative wordlevel and document-level features for the multiclass classification task. Our evaluation shows that our deep-learning based approach significantly and consistently outperforms traditional methods using traditional word representations and human-engineered classifier features.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582745','',51,0,'IEEE','IEEE Conferences',0),(1287,'BovInspector: Automatic inspection and repair of buffer overflow vulnerabilities',10,786,791,'Buffer overflow is one of the most common types of software vulnerabilities. Various static analysis and dynamic testing techniques have been proposed to detect buffer overflow vulnerabilities. With automatic tool support, static buffer overflow detection technique has been widely used in academia and industry. However, it tends to report too many false positives fundamentally due to the lack of software execution information. Currently, static warnings can only be validated by manual inspection, which significantly limits the practicality of the static analysis. In this paper, we present BovInspector, a tool framework for automatic static buffer overflow warnings inspection and validated bugs repair. Given the program source code and static buffer overflow vulnerability warnings, BovInspector first performs warning reachability analysis. Then, BovInspector executes the source code symbolically under the guidance of reachable warnings. Each reachable warning is validated and classified by checking whether all the path conditions and the buffer overflow constraints can be satisfied simultaneously. For each validated true warning, BovInspector fix it with three predefined strategies. BovInspector is complementary to prior static buffer overflow discovery schemes. Experimental results on real open source programs show that BovInspector can automatically inspect on average of 74.9% of total warnings, and false warnings account for about 25% to 100% (on average of 59.9%) of the total inspected warnings. In addition, the automatically generated patches fix all target vulnerabilities. Further information regarding the implementation and experimental results of BovInspector is available at http://bovinspectortool.github.io/project/. And a short video for demonstrating the capabilities of BovInspector is now available at https://youtu.be/IMdcksROJDg.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582816','',21,0,'IEEE','IEEE Conferences',0),(1288,'Lightweight collection and storage of software repository data with DataRover',10,810,815,'The ease of setting up collaboration infrastructures for software engineering projects creates a challenge for researchers that aim to analyze the resulting data. As teams can choose from various available software-as-a-service solutions and can configure them with a few clicks, researchers have to create and maintain multiple implementations for collecting and aggregating the collaboration data in order to perform their analyses across different setups. The DataRover system presented in this paper simplifies this task by only requiring custom source code for API authentication and querying. Data transformation and linkage is performed based on mappings, which users can define based on sample responses through a graphical front end. This allows storing the same input data in formats and databases most suitable for the intended analysis without requiring additional coding. Furthermore, API responses are continuously monitored to detect changes and allow users to update their mappings and data collectors accordingly. A screencast of the described use cases is available at https: //youtu.be/mt4ztff4SfU.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582820','',7,0,'IEEE','IEEE Conferences',0),(1289,'On essential configuration complexity: Measuring interactions in highly-configurable systems',10,483,494,'Quality assurance for highly-configurable systems is challenging due to the exponentially growing configuration space. Interactions among multiple options can lead to surprising behaviors, bugs, and security vulnerabilities. Analyzing all configurations systematically might be possible though if most options do not interact or interactions follow specific patterns that can be exploited by analysis tools. To better understand interactions in practice, we analyze program traces to characterize and identify where interactions occur on control flow and data. To this end, we developed a dynamic analysis for Java based on variability-aware execution and monitor executions of multiple small to medium-sized programs. We find that the essential configuration complexity of these programs is indeed much lower than the combinatorial explosion of the configuration space indicates. However, we also discover that the interaction characteristics that allow scalable and complete analyses are more nuanced than what is exploited by existing state-of-the-art quality assurance strategies.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582784','',70,0,'IEEE','IEEE Conferences',0),(1290,'Privacy preserving via interval covering based subclass division and manifold learning based bi-directional obfuscation for effort estimation',10,75,86,'When a company lacks local data in hand, engineers can build an effort model for the effort estimation of a new project by utilizing the training data shared by other companies. However, one of the most important obstacles for data sharing is the privacy concerns of software development organizations. In software engineering, most of existing privacy-preserving works mainly focus on the defect prediction, or debugging and testing, yet the privacy-preserving data sharing problem has not been well studied in effort estimation. In this paper, we aim to provide data owners with an effective approach of privatizing their data before release. We firstly design an Interval Covering based Subclass Division (ICSD) strategy. ICSD can divide the target data into several subclasses by digging a new attribute (i.e., class label) from the effort data. And the obtained class label is beneficial to maintaining the distribution of the target data after obfuscation. Then, we propose a manifold learning based bi-directional data obfuscation (MLBDO) algorithm, which uses two nearest neighbors, which are selected respectively from the previous and next subclasses by utilizing the manifold learning based nearest neighbor selector, as the disturbances to obfuscate the target sample. We call the entire approach as ICSD&MLBDO. Experimental results on seven public effort datasets show that: 1) ICSD&MLBDO can guarantee the privacy and maintain the utility of obfuscated data. 2) ICSD&MLBDO can achieve better privacy and utility than the compared privacy-preserving methods.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582747','',66,0,'IEEE','IEEE Conferences',0),(1291,'Too much automation? The bellwether effect and its implications for transfer learning',10,122,131,'鈥淭ransfer learning鈥�: is the process of translating quality predictors learned in one data set to another. Transfer learning has been the subject of much recent research. In practice, that research means changing models all the time as transfer learners continually exchange new models to the current project. This paper offers a very simple 鈥渂ellwether鈥� transfer learner. Given N data sets, we find which one produces the best predictions on all the others. This 鈥渂ellwether鈥� data set is then used for all subsequent predictions (or, until such time as its predictions start failing-at which point it is wise to seek another bellwether). Bellwethers are interesting since they are very simple to find (just wrap a for-loop around standard data miners). Also, they simplify the task of making general policies in SE since as long as one bellwether remains useful, stable conclusions for N data sets can be achieved just by reasoning over that bellwether. From this, we conclude (1) this bellwether method is a useful (and very simple) transfer learning method; (2) 鈥渂ellwethers鈥� are a baseline method against which future transfer learners should be compared; (3) sometimes, when building increasingly complex automatic methods, researchers should pause and compare their supposedly more sophisticated method against simpler alternatives.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582751','',50,0,'IEEE','IEEE Conferences',0),(1292,'ProcessPAIR: A tool for automated performance analysis and improvement recommendation in software development',10,798,803,'High-maturity software development processes can generate significant amounts of data that can be periodically analyzed to identify performance problems, determine their root causes and devise improvement actions. However, conducting that analysis manually is challenging because of the potentially large amount of data to analyze and the effort and expertise required. In this paper, we present ProcessPAIR, a novel tool designed to help developers analyze their performance data with less effort, by automatically identifying and ranking performance problems and potential root causes, so that subsequent manual analysis for the identification of deeper causes and improvement actions can be properly focused. The analysis is based on performance models defined manually by process experts and calibrated automatically from the performance data of many developers. We also show how ProcessPAIR was successfully applied for the Personal Software Process (PSP). A video about ProcessPAIR is available in https://youtu.be/dEk3fhhkduo.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582818','',14,0,'IEEE','IEEE Conferences',0),(1293,'SuperMod: Tool support for collaborative filtered model-driven software product line engineering',10,822,827,'The increase in productivity implied by model-driven software product line engineering is weakened by the complexity exposed to the user having to manage a multi-variant model. Recently, a new paradigm has emerged: filtered software product line engineering transfers the established check-out/modify/commit workflow from version control to variability management, allowing to iteratively develop the multi-variant model in a single-variant view. This paper demonstrates SuperMod, a tool that supports collaborative filtered model-driven product line engineering, implemented for and with the Eclipse Modeling Framework. Concerning variability management, the tool offers capabilities for editing feature models and specifying feature configurations, both being well-known formalisms in product line engineering. Furthermore, collaborative editing of product lines is provided through distributed version control. The accompanying video shows that SuperMod seamlessly integrates into existing tool landscapes, reduces the complexity of multi-variant editing, automates a large part of variability management, and ensures consistency. A tool demonstration video is available here: http://youtu.be/5XOk3x5kjFc.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582822','',22,0,'IEEE','IEEE Conferences',0),(1294,'Goal-conflict detection based on temporal satisfiability checking',10,507,518,'Goal-oriented requirements engineering approaches propose capturing how a system should behave through the specification of high-level goals, from which requirements can then be systematically derived. Goals may however admit subtle situations that make them diverge, i.e., not be satisfiable as a whole under specific circumstances feasible within the domain, called boundary conditions. While previous work allows one to identify boundary conditions for conflicting goals written in LTL, it does so through a pattern-based approach, that supports a limited set of patterns, and only produces pre-determined formulations of boundary conditions. We present a novel automated approach to compute boundary conditions for general classes of conflicting goals expressed in LTL, using a tableaux-based LTL satisfiability procedure. A tableau for an LTL formula is a finite representation of all its satisfying models, which we process to produce boundary conditions that violate the formula, indicating divergence situations. We show that our technique can automatically produce boundary conditions that are more general than those obtainable through existing previous pattern-based approaches, and can also generate boundary conditions for goals that are not captured by these patterns.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582786','',47,0,'IEEE','IEEE Conferences',0),(1295,'Symbolic execution of complex program driven by machine learning based constraint solving',10,554,559,'Symbolic execution is a widely-used program analysis technique. It collects and solves path conditions to guide the program traversing. However, due to the limitation of the current constraint solvers, it is difficult to apply symbolic execution on programs with complex path conditions, like nonlinear constraints and function calls. In this paper, we propose a new symbolic execution tool MLB to handle such problem. Instead of relying on the classical constraint solving, in MLB, the feasibility problems of the path conditions are transformed into optimization problems, by minimizing some dissatisfaction degree. The optimization problems are then handled by the underlying optimization solver through machine learning guided sampling and validation. MLB is implemented on the basis of Symbolic PathFinder and encodes not only the simple linear path conditions, but also nonlinear arithmetic operations, and even black-box function calls of library methods, into symbolic path conditions. Experiment results show that MLB can achieve much better coverage on complex real-world programs.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582790','',26,0,'IEEE','IEEE Conferences',0),(1296,'Automatically recommending code reviewers based on their expertise: An empirical comparison',10,99,110,'Code reviews are an essential part of quality assurance in Free, Libre, and Open Source Software (FLOSS) projects. However, finding a suitable reviewer can be difficult, and delayed or forgotten reviews are the consequence. Automating reviewer selection with suitable algorithms can mitigate this problem. We compare empirically six algorithms based on modification expertise and two algorithms based on review expertise on four major FLOSS projects. Our results indicate that the algorithms based on review expertise yield better recommendations than those based on modification expertise. The algorithm Weighted Review Count (WRC) recommends at least one out of five reviewers correctly in 69 % to 75 % of all cases, which is one of the best results achieved in the comparison.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582749','',57,0,'IEEE','IEEE Conferences',0),(1297,'Visualization of combinatorial models and test plans',10,144,154,'Combinatorial test design (CTD) is an effective and widely used test design technique. CTD provides automatic test plan generation, but it requires a manual definition of the test space in the form of a combinatorial model. One challenge for successful application of CTD in practice relates to this manual model definition and maintenance process. Another challenge relates to the comprehension and use of the test plan generated by CTD for prioritization purposes. In this work we introduce the use of visualizations as a means to address these challenges. We apply three different forms of visualization, matrices, graphs, and treemaps, to visualize the relationships between the different elements of the model, and to visualize the strength of each test in the test plan and the relationships between the different tests in terms of combinatorial coverage. We evaluate our visualizations via a user survey with 19 CTD practitioners, as well as via two industrial projects in which our visualization was used and allowed test designers to get vital insight into their models and into the coverage provided through CTD generated test plans.','https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582753','',25,0,'IEEE','IEEE Conferences',0);
/*!40000 ALTER TABLE `article_info` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article_to_affiliation`
--

DROP TABLE IF EXISTS `article_to_affiliation`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `article_to_affiliation` (
  `doc_id` int(11) NOT NULL,
  `affiliation_id` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article_to_affiliation`
--

LOCK TABLES `article_to_affiliation` WRITE;
/*!40000 ALTER TABLE `article_to_affiliation` DISABLE KEYS */;
INSERT INTO `article_to_affiliation` VALUES (1,1),(1,1),(1,2),(1,1),(2,2),(2,2),(3,3),(3,4),(3,3),(3,4),(3,5),(3,3),(4,6),(4,7),(4,8),(5,9),(5,10),(5,10),(5,9),(5,9),(5,9),(6,11),(6,11),(6,11),(7,12),(7,12),(8,13),(8,13),(8,14),(9,15),(9,15),(9,15),(9,15),(9,15),(10,16),(10,16),(10,17),(10,17),(10,18),(10,19),(11,20),(11,20),(12,21),(12,21),(12,21),(12,21),(13,22),(13,23),(13,22),(13,24),(13,22),(13,23),(14,25),(14,25),(14,25),(14,25),(14,25),(14,25),(14,26),(14,25),(15,27),(15,28),(15,27),(16,29),(16,30),(16,29),(16,29),(16,29),(16,29),(17,31),(17,32),(17,33),(17,32),(18,34),(18,35),(18,34),(18,36),(18,34),(18,34),(18,36),(19,37),(19,38),(19,37),(19,38),(19,37),(20,39),(20,39),(20,39),(20,39),(20,40),(21,41),(21,41),(21,41),(21,41),(22,42),(22,42),(23,43),(23,44),(23,45),(23,45),(24,46),(24,46),(24,46),(24,46),(24,47),(24,46),(25,2),(25,48),(26,49),(26,50),(26,51),(27,52),(27,52),(27,53),(27,53),(27,53),(27,52),(27,54),(27,52),(28,55),(28,55),(28,55),(28,55),(28,55),(28,55),(29,56),(29,57),(29,58),(29,56),(30,59),(30,59),(30,59),(30,59),(30,59),(30,60),(31,61),(31,62),(31,61),(31,63),(31,61),(31,64),(32,65),(32,65),(33,66),(33,67),(33,66),(33,68),(34,69),(34,69),(34,69),(34,69),(34,70),(35,71),(35,71),(35,71),(35,71),(35,72),(35,71),(36,73),(36,73),(36,74),(36,75),(36,76),(36,73),(36,77),(36,78),(37,79),(37,80),(37,80),(38,81),(38,81),(38,81),(39,82),(39,83),(39,82),(39,82),(39,84),(40,85),(40,86),(40,86),(40,86),(40,86),(40,86),(41,87),(41,87),(41,88),(41,87),(42,89),(42,90),(42,89),(43,91),(43,91),(43,92),(43,91),(43,91),(44,5),(44,5),(45,93),(45,94),(45,93),(46,95),(46,96),(46,97),(46,98),(46,97),(47,99),(47,100),(47,100),(47,101),(47,101),(47,100),(47,99),(48,102),(48,102),(48,103),(48,34),(48,104),(48,34),(48,104),(49,105),(49,106),(49,105),(49,107),(49,105),(49,108),(50,109),(50,109),(50,109),(51,110),(51,110),(51,110),(51,110),(51,110),(51,111),(52,112),(52,112),(53,113),(53,114),(53,113),(54,115),(54,115),(54,32),(54,32),(54,116),(55,117),(55,117),(55,118),(55,119),(55,117),(55,117),(55,117),(56,56),(56,120),(56,120),(56,120),(57,121),(57,121),(57,122),(57,121),(57,123),(57,123),(58,116),(58,124),(58,125),(59,126),(59,126),(60,127),(60,128),(60,128),(61,129),(61,130),(61,131),(61,129),(62,132),(62,132),(63,133),(63,134),(63,133),(64,135),(64,136),(64,137),(64,136),(64,137),(65,138),(65,138),(65,138),(65,139),(65,139),(65,140),(66,141),(66,142),(66,143),(66,142),(67,144),(67,144),(67,144),(67,144),(68,93),(68,145),(68,93),(68,93),(68,145),(68,146),(68,93),(69,147),(69,147),(69,148),(69,149),(69,147),(69,148),(69,148),(70,150),(70,151),(70,150),(70,150),(70,150),(71,152),(71,152),(71,153),(71,153),(72,154),(72,154),(72,155),(72,156),(72,154),(73,157),(73,158),(73,159),(74,160),(74,161),(74,93),(74,146),(74,162),(74,160),(75,163),(75,163),(75,164),(75,165),(75,164),(75,165),(75,165),(75,165),(76,166),(76,167),(76,168),(77,169),(77,170),(77,169),(77,120),(78,22),(78,171),(78,22),(79,172),(79,173),(80,174),(80,174),(80,175),(81,176),(81,176),(81,176),(82,177),(82,178),(82,177),(82,178),(83,179),(83,180),(83,181),(83,182),(83,181),(84,183),(84,184),(84,184),(84,183),(84,185),(85,105),(85,186),(85,187),(86,188),(86,189),(86,189),(86,188),(86,190),(86,188),(86,188),(86,189),(87,191),(87,191),(87,192),(87,192),(87,192),(87,192),(87,193),(87,192),(87,194),(88,195),(88,196),(88,196),(88,197),(89,14),(89,198),(89,14),(90,199),(90,200),(90,201),(90,200),(90,202),(90,199),(90,199),(90,199),(91,203),(91,203),(91,203),(91,204),(92,205),(92,205),(92,205),(93,15),(93,206),(93,15),(93,15),(93,15),(93,206),(94,207),(94,207),(94,207),(94,208),(94,207),(94,207),(94,208),(94,207),(95,48),(95,48),(96,209),(96,131),(96,209),(96,209),(97,210),(97,211),(97,210),(97,210),(97,211),(98,212),(98,212),(98,124),(98,124),(98,213),(98,213),(98,214),(99,215),(99,215),(100,216),(100,216),(100,216),(100,216),(101,2),(101,2),(101,2),(102,217),(102,217),(102,218),(102,218),(103,219),(103,219),(103,220),(103,27),(104,221),(104,222),(104,222),(104,223),(105,224),(105,11),(105,11),(105,224),(106,225),(106,226),(106,71),(106,226),(106,226),(106,227),(107,228),(107,229),(107,177),(107,177),(107,229),(108,230),(108,231),(109,232),(109,232),(109,232),(109,232),(109,232),(110,233),(110,233),(110,233),(110,233),(110,233),(111,234),(111,120),(111,235),(111,236),(111,237),(111,120),(112,226),(112,226),(112,226),(112,225),(112,226),(113,238),(113,239),(113,238),(113,238),(113,238),(113,240),(114,241),(114,242),(114,241),(115,241),(115,243),(115,244),(115,241),(116,245),(116,246),(116,246),(116,245),(117,247),(117,247),(117,248),(117,249),(118,250),(118,177),(118,250),(119,251),(119,251),(120,252),(120,253),(120,254),(120,254),(120,80),(121,255),(121,256),(121,255),(121,257),(121,255),(122,258),(122,258),(123,259),(123,259),(123,259),(123,260),(123,260),(123,259),(124,261),(124,262),(125,2),(125,2),(126,263),(126,264),(126,264),(126,263),(126,263),(127,46),(127,46),(127,265),(127,46),(127,266),(127,46),(127,46),(128,267),(128,268),(128,267),(128,267),(128,267),(128,269),(129,270),(129,271),(129,270),(129,272),(129,271),(130,273),(130,274),(130,81),(130,81),(130,275),(131,41),(131,41),(132,276),(132,277),(132,278),(132,278),(132,276),(133,2),(133,2),(133,2),(133,2),(134,120),(134,120),(134,120),(134,279),(135,227),(135,280),(135,281),(135,282),(135,227),(136,283),(136,283),(136,283),(136,284),(137,285),(137,285),(137,286),(137,287),(137,287),(137,287),(138,288),(138,288),(138,288),(139,11),(139,11),(139,11),(140,38),(140,279),(140,38),(140,279),(140,38),(141,165),(141,289),(141,290),(141,291),(141,165),(141,165),(141,165),(142,113),(142,113),(142,113),(142,113),(142,292),(143,34),(143,35),(143,34),(143,34),(144,293),(144,294),(144,293),(144,293),(144,295),(144,293),(144,293),(144,293),(144,293),(145,296),(145,297),(145,298),(145,299),(146,247),(146,247),(146,247),(146,300),(147,301),(147,302),(148,192),(148,192),(148,289),(148,192),(148,192),(149,303),(149,122),(149,304),(149,276),(150,305),(150,306),(150,307),(150,305),(150,305),(151,308),(151,309),(151,310),(151,310),(152,311),(152,312),(152,313),(152,314),(153,315),(153,315),(153,315),(154,14),(154,316),(154,317),(154,317),(154,317),(154,316),(154,316),(155,224),(155,224),(155,224),(155,224),(156,318),(156,318),(156,318),(157,319),(157,319),(158,51),(158,320),(158,320),(159,321),(159,321),(159,322),(159,322),(159,323),(159,321),(159,321),(160,26),(160,324),(160,325),(160,32),(160,239),(160,326),(161,327),(161,328),(162,329),(162,330),(162,331),(163,2),(163,2),(163,2),(164,332),(164,332),(164,3),(164,333),(164,332),(165,192),(165,192),(165,334),(165,192),(165,192),(165,192),(165,192),(165,192),(165,192),(165,192),(166,305),(166,305),(166,305),(166,335),(166,336),(166,305),(166,305),(167,337),(167,238),(167,338),(168,339),(168,340),(168,339),(168,339),(169,341),(169,342),(169,341),(170,343),(170,344),(170,343),(171,59),(171,59),(172,345),(172,346),(172,346),(173,347),(173,347),(173,347),(174,191),(174,348),(174,349),(174,191),(175,198),(175,198),(175,198),(175,198),(176,350),(176,350),(176,350),(176,350),(176,350),(176,351),(176,350),(176,350),(177,352),(177,352),(177,353),(177,238),(178,354),(178,354),(178,354),(178,354),(178,354),(178,354),(179,355),(179,355),(179,355),(179,250),(180,2),(180,2),(180,2),(180,2),(181,2),(181,2),(182,2),(182,2),(183,2),(183,2),(184,2),(184,2),(184,2),(185,2),(185,2),(185,2),(185,2),(186,2),(186,2),(186,2),(186,2),(186,2),(186,2),(187,2),(187,2),(187,2),(187,2),(187,2),(187,2),(187,2),(188,2),(188,2),(188,2),(189,14),(189,356),(189,357),(189,358),(189,358),(190,359),(190,360),(191,361),(191,361),(191,361),(191,361),(192,362),(192,363),(193,2),(193,2),(193,2),(194,364),(194,364),(194,364),(195,365),(195,366),(196,132),(196,132),(196,132),(196,132),(197,367),(198,368),(198,369),(198,368),(199,370),(200,2),(200,2),(200,2),(200,2),(201,371),(202,372),(202,372),(203,373),(204,374),(204,375),(204,376),(205,2),(205,2),(205,2),(205,2),(205,2),(205,2),(206,2),(206,2),(206,2),(206,2),(207,377),(208,160),(209,2),(209,2),(209,2),(209,2),(210,378),(211,379),(212,228),(212,228),(212,228),(213,380),(213,381),(213,381),(214,382),(215,383),(216,2),(216,2),(216,2),(216,2),(217,384),(217,384),(218,385),(219,386),(220,387),(221,2),(221,2),(221,2),(221,2),(221,2),(222,2),(222,2),(222,2),(222,2),(223,2),(224,229),(224,229),(224,229),(225,388),(226,389),(226,390),(226,389),(226,389),(226,389),(227,391),(227,391),(227,391),(228,392),(228,278),(228,278),(228,392),(228,392),(229,393),(230,361),(231,394),(232,2),(232,2),(232,2),(232,2),(232,2),(232,2),(233,2),(233,2),(233,2),(234,395),(234,395),(234,395),(234,395),(235,396),(235,396),(235,396),(235,396),(236,397),(237,398),(237,399),(237,398),(238,27),(238,27),(239,2),(239,2),(239,2),(239,2),(240,400),(241,401),(241,402),(241,402),(242,403),(242,403),(242,403),(243,404),(243,404),(243,404),(244,405),(244,405),(244,405),(244,405),(244,405),(245,228),(245,228),(245,228),(246,2),(247,406),(247,406),(248,2),(248,2),(249,407),(249,407),(249,407),(249,14),(250,408),(250,408),(250,408),(250,408),(250,408),(251,409),(251,409),(251,410),(251,410),(251,411),(252,412),(252,413),(252,412),(252,414),(253,415),(253,415),(253,415),(253,415),(254,361),(254,361),(254,361),(255,416),(255,416),(256,2),(256,2),(256,2),(256,2),(257,417),(257,418),(257,417),(257,418),(258,419),(258,93),(258,420),(259,421),(259,421),(259,421),(260,422),(260,422),(261,2),(261,2),(261,2),(261,2),(262,423),(263,424),(263,424),(264,2),(264,2),(264,2),(265,380),(265,425),(265,426),(266,427),(267,428),(268,429),(268,429),(268,430),(269,431),(269,431),(269,431),(270,432),(271,433),(271,433),(271,433),(272,434),(273,2),(273,2),(273,2),(274,46),(275,435),(276,436),(277,437),(278,2),(278,2),(278,2),(279,438),(280,439),(281,440),(282,441),(283,160),(284,442),(285,2),(285,2),(285,2),(285,2),(285,2),(286,443),(286,444),(286,443),(286,443),(287,2),(287,2),(287,2),(288,2),(289,445),(290,330),(290,446),(290,447),(290,448),(291,449),(291,449),(291,449),(292,123),(293,450),(293,450),(293,450),(294,2),(294,2),(294,2),(294,2),(294,2),(295,451),(295,452),(296,453),(297,2),(298,454),(298,454),(298,454),(299,455),(299,402),(299,455),(299,402),(299,402),(299,455),(300,2),(300,2),(300,2),(300,2),(301,2),(301,2),(301,2),(301,2),(302,456),(302,388),(302,457),(302,458),(302,459),(302,388),(302,456),(303,123),(303,123),(303,123),(304,460),(305,461),(305,462),(305,463),(306,361),(306,361),(306,361),(307,2),(307,2),(307,2),(308,464),(308,150),(308,464),(309,465),(310,466),(310,466),(310,466),(310,466),(311,177),(311,467),(311,468),(311,469),(312,470),(312,470),(312,470),(312,19),(313,305),(314,471),(314,472),(315,473),(315,474),(315,474),(315,475),(315,474),(315,474),(315,474),(316,476),(316,477),(317,478),(317,478),(317,7),(317,478),(318,162),(318,177),(318,177),(318,177),(318,177),(318,162),(319,479),(319,480),(319,480),(320,481),(320,481),(320,482),(320,483),(320,481),(321,2),(321,484),(321,484),(322,485),(322,485),(322,485),(322,486),(323,2),(323,2),(323,2),(323,2),(323,2),(324,487),(324,487),(324,487),(324,487),(324,487),(324,487),(324,487),(324,487),(324,487),(324,487),(325,488),(325,488),(325,489),(326,490),(326,491),(326,490),(326,490),(327,317),(327,14),(327,14),(327,492),(327,493),(328,18),(328,494),(328,494),(329,495),(329,495),(329,495),(330,496),(330,497),(330,498),(330,499),(331,357),(331,500),(331,501),(331,502),(331,503),(332,231),(332,504),(332,231),(332,231),(333,505),(334,381),(334,506),(334,507),(334,508),(334,381),(335,509),(336,510),(336,510),(337,511),(337,511),(337,511),(337,511),(337,511),(337,511),(338,2),(338,2),(338,2),(338,2),(338,2),(339,512),(339,512),(339,512),(339,513),(340,514),(340,415),(341,515),(341,515),(341,515),(341,515),(342,14),(342,14),(342,516),(342,14),(343,517),(343,517),(343,517),(344,490),(344,518),(344,490),(345,519),(345,519),(345,519),(345,519),(346,520),(346,520),(346,520),(346,521),(347,522),(347,177),(347,177),(347,177),(348,523),(348,523),(348,523),(348,523),(348,523),(349,2),(349,2),(349,2),(349,2),(349,2),(349,2),(349,2),(349,2),(349,2),(349,2),(349,2),(349,2),(350,201),(350,201),(350,201),(350,201),(351,2),(351,2),(351,2),(351,2),(351,2),(352,2),(352,2),(352,2),(352,2),(353,2),(353,2),(353,2),(353,2),(353,2),(354,524),(354,113),(354,524),(354,525),(354,113),(354,524),(354,526),(354,527),(355,113),(355,113),(355,113),(355,528),(355,113),(356,529),(356,529),(357,530),(357,530),(357,530),(357,530),(357,531),(358,532),(358,532),(358,532),(359,533),(359,533),(359,533),(359,533),(360,489),(360,489),(360,489),(361,534),(361,534),(361,534),(361,534),(361,534),(361,535),(362,536),(362,228),(362,537),(362,228),(362,228),(362,228),(363,2),(363,2),(363,2),(363,2),(363,2),(363,2),(364,231),(364,231),(364,200),(364,231),(365,538),(365,538),(365,539),(365,538),(366,540),(366,540),(366,540),(366,541),(367,397),(367,123),(367,397),(368,317),(368,93),(368,146),(368,492),(368,492),(368,493),(369,2),(369,2),(369,2),(369,2),(370,542),(370,368),(370,368),(371,543),(371,543),(371,543),(371,543),(371,543),(372,544),(372,544),(372,544),(373,430),(373,545),(373,430),(373,546),(373,430),(373,430),(374,109),(374,109),(374,109),(375,547),(375,547),(376,548),(376,548),(376,548),(377,549),(377,550),(377,550),(377,550),(377,551),(378,2),(378,2),(378,2),(378,2),(378,2),(379,552),(379,552),(379,552),(379,553),(380,554),(380,554),(380,554),(381,555),(381,555),(382,132),(382,132),(382,132),(382,132),(383,488),(383,556),(383,488),(384,557),(384,557),(385,558),(385,92),(385,92),(385,558),(385,558),(386,559),(386,392),(386,560),(386,114),(386,511),(386,392),(387,561),(387,523),(388,2),(388,2),(388,2),(388,2),(388,2),(389,562),(389,562),(389,562),(389,562),(390,563),(390,563),(390,563),(391,392),(391,114),(391,559),(391,560),(391,511),(392,564),(392,565),(392,380),(392,380),(392,426),(393,566),(393,566),(393,567),(393,567),(393,567),(393,566),(393,567),(394,2),(394,2),(394,2),(395,330),(395,2),(395,330),(395,330),(395,463),(396,2),(396,2),(396,2),(396,2),(396,2),(396,2),(397,568),(397,568),(397,568),(397,568),(398,569),(398,569),(398,569),(398,569),(398,569),(398,569),(398,569),(399,160),(399,570),(399,570),(399,160),(400,2),(400,2),(400,2),(401,65),(401,65),(402,478),(402,571),(402,478),(403,196),(403,196),(403,196),(403,196),(403,196),(404,572),(404,573),(404,573),(404,573),(405,2),(405,574),(405,575),(406,576),(406,576),(406,576),(406,2),(406,2),(407,577),(407,577),(407,577),(408,578),(408,14),(408,162),(408,14),(409,160),(409,316),(409,579),(409,492),(409,146),(409,316),(409,160),(410,380),(410,380),(410,380),(410,380),(410,380),(410,580),(410,123),(411,581),(411,581),(411,581),(411,582),(412,583),(413,410),(413,410),(413,410),(413,584),(414,319),(414,585),(414,585),(414,319),(415,586),(415,586),(415,586),(416,587),(416,587),(416,587),(417,387),(417,387),(417,588),(417,387),(417,419),(417,419),(417,419),(418,491),(418,491),(418,491),(418,491),(419,491),(420,589),(421,196),(421,196),(421,196),(422,590),(422,232),(422,232),(422,590),(422,232),(423,591),(423,511),(423,511),(423,591),(423,591),(424,592),(424,592),(425,571),(425,571),(425,571),(426,593),(426,593),(426,593),(427,594),(427,594),(427,595),(427,594),(427,595),(428,509),(428,579),(428,146),(428,596),(428,509),(429,571),(429,571),(430,597),(430,2),(430,597),(431,598),(431,598),(431,598),(432,599),(432,599),(432,599),(433,600),(433,601),(433,602),(433,603),(433,604),(434,231),(434,605),(434,283),(434,231),(435,14),(435,381),(436,606),(436,607),(436,486),(436,608),(437,609),(437,610),(437,610),(437,610),(438,611),(438,611),(439,612),(439,612),(440,613),(440,614),(440,614),(440,614),(441,46),(441,46),(441,46),(441,46),(441,527),(441,46),(442,615),(442,615),(442,615),(442,615),(443,616),(443,616),(443,617),(443,618),(444,619),(444,619),(445,620),(445,620),(445,620),(446,621),(446,622),(446,623),(447,1),(447,1),(448,548),(448,624),(448,624),(448,548),(448,548),(449,625),(449,625),(449,626),(449,626),(449,626),(449,626),(450,627),(450,628),(450,627),(450,627),(451,629),(451,177),(452,630),(452,631),(452,630),(452,632),(452,630),(452,630),(453,633),(453,633),(453,485),(454,396),(454,396),(454,396),(455,634),(455,634),(455,584),(456,2),(456,2),(456,2),(456,2),(456,2),(457,635),(457,635),(457,635),(457,635),(457,635),(458,636),(459,637),(459,637),(459,637),(460,638),(460,638),(460,639),(460,639),(461,640),(461,640),(461,640),(461,621),(462,623),(462,623),(462,623),(462,623),(463,2),(463,2),(463,2),(463,2),(464,641),(464,641),(465,2),(465,2),(465,2),(465,2),(465,2),(466,642),(466,402),(466,642),(466,402),(466,643),(467,228),(467,228),(467,75),(467,228),(468,2),(468,2),(468,2),(468,2),(468,2),(468,2),(468,2),(468,2),(468,2),(468,2),(469,644),(469,644),(469,645),(469,646),(469,647),(470,648),(470,649),(470,414),(470,605),(470,605),(470,648),(471,650),(471,651),(472,652),(472,652),(473,653),(473,654),(473,653),(474,655),(474,656),(474,655),(474,655),(474,657),(475,637),(475,658),(475,305),(475,637),(475,637),(475,305),(476,573),(476,573),(476,573),(476,573),(477,659),(477,660),(477,660),(477,660),(477,660),(477,661),(477,661),(477,661),(478,305),(478,2),(478,305),(479,548),(479,2),(480,662),(480,621),(480,663),(480,664),(480,665),(480,123),(480,666),(481,123),(481,123),(482,667),(482,667),(482,668),(482,667),(483,494),(483,494),(483,494),(484,669),(484,629),(484,669),(484,629),(484,669),(485,623),(485,670),(485,623),(485,671),(485,623),(485,623),(486,589),(486,589),(486,589),(487,672),(487,672),(487,672),(487,672),(487,672),(488,673),(488,173),(488,173),(489,519),(489,519),(489,215),(489,177),(490,674),(491,675),(491,675),(492,592),(492,592),(492,676),(492,677),(493,678),(493,679),(493,679),(493,678),(493,678),(493,679),(494,396),(494,396),(495,680),(495,177),(495,177),(496,562),(496,562),(496,681),(496,266),(496,562),(496,266),(497,682),(497,682),(497,682),(498,683),(498,374),(498,684),(499,2),(499,2),(499,2),(500,685),(500,685),(500,685),(500,685),(500,685),(500,2),(500,685),(500,685),(501,686),(501,687),(501,686),(501,687),(501,687),(501,687),(501,687),(501,687),(501,686),(502,433),(503,688),(503,689),(504,690),(504,690),(504,690),(504,690),(504,691),(504,692),(504,690),(504,693),(504,690),(504,694),(505,614),(505,614),(505,614),(506,46),(506,46),(506,46),(506,46),(506,46),(506,46),(506,46),(506,46),(507,695),(507,424),(508,696),(509,123),(509,123),(510,697),(510,697),(510,698),(510,697),(510,698),(511,2),(511,2),(511,2),(511,2),(511,2),(512,276),(512,276),(512,276),(512,276),(513,629),(513,229),(513,229),(513,629),(514,699),(514,699),(514,699),(514,699),(514,699),(514,699),(515,2),(515,2),(515,2),(516,700),(516,700),(516,250),(516,700),(517,215),(517,519),(517,519),(517,215),(518,610),(518,610),(518,610),(519,266),(519,266),(519,266),(519,701),(519,266),(519,266),(520,561),(520,10),(521,702),(521,703),(521,702),(522,704),(522,2),(522,705),(523,250),(523,489),(523,250),(523,250),(524,177),(524,177),(524,8),(524,177),(525,144),(526,2),(526,196),(526,196),(526,196),(526,196),(526,638),(527,706),(527,706),(527,706),(527,707),(527,707),(528,638),(528,638),(528,536),(528,638),(528,638),(528,231),(528,708),(529,709),(529,710),(529,710),(529,709),(530,2),(530,2),(531,711),(532,177),(532,162),(532,228),(532,712),(532,2),(533,713),(533,461),(533,461),(533,714),(533,714),(533,461),(533,461),(533,461),(533,714),(533,461),(534,195),(534,715),(534,196),(534,196),(534,716),(535,717),(535,717),(535,717),(535,717),(536,584),(536,584),(536,417),(537,2),(537,2),(537,2),(538,718),(538,653),(538,719),(538,719),(538,539),(538,720),(539,662),(539,662),(540,491),(540,491),(540,491),(540,491),(540,491),(541,721),(541,721),(542,2),(542,10),(542,74),(543,722),(543,723),(543,724),(543,722),(544,347),(544,725),(545,726),(545,727),(545,726),(545,726),(546,728),(546,729),(546,2),(546,728),(547,623),(547,623),(547,623),(547,623),(548,202),(548,730),(548,202),(549,731),(549,731),(549,731),(549,731),(549,731),(549,731),(550,526),(550,527),(550,526),(550,526),(550,527),(551,589),(552,552),(552,552),(552,552),(553,732),(553,732),(553,732),(554,733),(554,733),(554,733),(554,734),(555,735),(555,735),(555,736),(555,735),(556,737),(557,14),(557,14),(557,14),(558,738),(558,381),(558,381),(558,381),(558,381),(558,739),(558,740),(559,741),(559,741),(560,742),(560,742),(560,742),(560,742),(560,742),(560,742),(561,743),(561,744),(562,745),(562,745),(562,27),(562,27),(562,745),(563,527),(563,527),(563,527),(564,746),(564,746),(564,2),(565,250),(565,747),(565,250),(566,748),(566,748),(566,749),(566,748),(566,748),(567,750),(567,14),(567,162),(567,729),(567,317),(568,751),(568,752),(568,605),(568,751),(569,134),(569,134),(569,134),(569,134),(570,753),(570,753),(570,753),(570,754),(570,753),(571,2),(571,2),(571,2),(571,2),(571,2),(571,2),(572,755),(572,756),(572,757),(572,757),(573,758),(573,758),(573,758),(574,759),(574,760),(574,759),(574,760),(574,759),(574,761),(575,571),(575,571),(575,762),(575,762),(575,571),(576,276),(576,276),(576,276),(577,763),(577,763),(578,231),(578,231),(578,231),(578,231),(579,635),(579,635),(579,635),(580,764),(580,764),(580,764),(580,764),(580,765),(580,764),(581,766),(581,767),(582,2),(582,2),(583,2),(583,768),(583,2),(583,768),(583,2),(583,2),(583,768),(584,769),(584,770),(584,771),(584,771),(584,771),(585,75),(585,772),(585,773),(585,772),(585,75),(586,774),(586,774),(586,774),(587,751),(587,752),(587,605),(587,751),(588,305),(588,305),(589,775),(589,775),(589,775),(589,775),(589,487),(590,776),(590,776),(590,776),(591,777),(591,777),(591,778),(591,778),(591,777),(592,779),(592,780),(592,779),(592,779),(592,779),(592,780),(592,779),(592,779),(593,491),(593,781),(594,7),(594,782),(594,782),(594,152),(595,783),(595,783),(595,783),(595,783),(596,14),(596,14),(596,14),(597,46),(597,46),(597,46),(597,46),(597,46),(598,2),(598,2),(598,2),(599,2),(599,2),(599,2),(599,2),(600,784),(600,785),(600,785),(600,786),(601,787),(601,787),(601,787),(602,788),(602,788),(603,789),(603,789),(603,789),(603,790),(603,411),(603,411),(603,789),(604,91),(604,791),(604,792),(604,792),(604,91),(604,113),(604,91),(605,793),(605,793),(605,2),(605,793),(605,794),(606,2),(606,2),(607,579),(607,579),(607,579),(607,492),(607,146),(608,795),(608,795),(608,795),(608,795),(608,795),(608,795),(609,2),(609,2),(609,2),(609,2),(610,27),(610,27),(611,2),(611,2),(611,2),(611,2),(612,2),(612,2),(612,2),(612,2),(612,2),(613,640),(613,640),(613,640),(613,640),(613,621),(613,491),(614,796),(614,796),(614,796),(614,796),(615,552),(615,552),(615,552),(615,797),(616,2),(616,2),(616,2),(616,2),(616,2),(617,2),(617,2),(617,2),(617,2),(618,2),(618,2),(618,2),(618,2),(618,2),(618,2),(618,2),(619,2),(619,2),(619,2),(620,798),(620,799),(620,800),(620,798),(621,801),(621,802),(621,801),(621,801),(621,801),(622,548),(622,548),(622,548),(622,803),(622,548),(623,804),(623,804),(623,805),(623,804),(623,805),(624,727),(624,46),(624,727),(624,727),(624,46),(624,806),(624,46),(625,2),(625,2),(625,2),(625,2),(625,2),(625,2),(625,2),(625,2),(626,737),(626,177),(626,177),(627,2),(627,2),(627,2),(627,2),(628,807),(628,808),(628,807),(628,808),(629,809),(629,810),(629,811),(630,812),(630,812),(630,812),(630,812),(630,812),(630,812),(630,92),(631,813),(631,813),(631,813),(631,813),(631,537),(631,813),(632,2),(632,2),(632,2),(632,2),(632,2),(633,814),(633,815),(633,815),(634,816),(634,816),(635,2),(635,2),(635,2),(635,2),(636,717),(636,717),(637,558),(637,558),(637,558),(637,491),(637,558),(638,2),(638,2),(638,682),(639,2),(639,2),(639,2),(639,2),(639,2),(640,817),(640,380),(640,818),(641,819),(641,819),(641,819),(641,820),(641,821),(642,822),(642,823),(642,822),(643,537),(643,537),(643,537),(643,537),(643,824),(643,824),(644,554),(644,554),(644,554),(644,825),(645,2),(645,2),(646,748),(646,749),(646,748),(646,748),(646,748),(647,826),(647,827),(647,826),(648,828),(648,828),(648,829),(648,656),(649,249),(649,249),(649,249),(649,830),(650,466),(650,466),(650,474),(650,633),(650,466),(650,466),(651,428),(651,831),(651,428),(652,10),(652,485),(652,485),(652,485),(652,485),(652,485),(652,832),(652,832),(652,832),(652,833),(653,266),(653,266),(653,266),(653,266),(654,474),(654,474),(654,474),(654,751),(654,559),(654,474),(654,474),(655,548),(655,548),(655,548),(656,834),(656,834),(656,834),(657,91),(657,830),(657,92),(657,835),(658,836),(659,426),(659,177),(659,837),(659,380),(659,838),(659,838),(659,426),(659,426),(660,578),(660,162),(660,14),(661,839),(661,839),(661,752),(662,198),(662,198),(662,198),(662,840),(663,841),(663,841),(664,552),(664,552),(665,93),(665,579),(665,93),(665,146),(665,492),(665,413),(665,579),(665,413),(665,93),(666,511),(666,511),(666,842),(666,511),(667,48),(667,48),(667,48),(667,48),(668,774),(668,843),(668,843),(668,844),(668,843),(668,843),(669,2),(669,2),(669,2),(669,2),(670,812),(670,812),(670,812),(670,812),(670,812),(670,763),(671,388),(671,388),(671,388),(671,388),(671,388),(672,494),(672,494),(672,494),(673,845),(673,845),(673,846),(673,845),(673,845),(674,2),(674,2),(674,2),(675,494),(675,494),(675,494),(676,847),(676,629),(676,848),(677,849),(677,849),(677,849),(677,849),(677,849),(678,2),(678,2),(678,2),(679,850),(679,571),(679,571),(679,571),(680,2),(680,2),(680,2),(680,2),(680,2),(680,2),(681,215),(681,215),(681,215),(681,215),(681,215),(681,215),(681,215),(682,410),(682,410),(682,410),(683,2),(683,2),(683,2),(683,2),(683,2),(683,2),(683,2),(684,2),(684,2),(684,2),(684,2),(684,2),(684,2),(685,851),(685,778),(685,851),(685,851),(685,778),(686,46),(686,46),(686,46),(686,228),(686,852),(686,46),(686,46),(686,853),(687,2),(687,2),(687,2),(688,2),(688,2),(688,2),(688,2),(688,2),(688,2),(688,2),(689,278),(689,278),(689,854),(690,2),(690,2),(690,2),(690,2),(691,2),(691,2),(691,2),(691,2),(691,2),(691,2),(692,774),(692,855),(692,774),(692,774),(692,774),(693,123),(693,123),(694,813),(694,813),(694,813),(694,509),(694,813),(694,537),(694,537),(694,813),(695,162),(695,856),(695,162),(695,857),(695,858),(695,857),(696,571),(696,571),(696,2),(697,859),(697,162),(697,146),(697,610),(697,161),(697,859),(698,12),(698,12),(699,860),(699,861),(699,752),(699,861),(699,860),(700,402),(700,402),(700,402),(700,527),(700,402),(701,781),(701,29),(702,166),(702,166),(702,250),(702,250),(702,166),(703,494),(703,862),(703,494),(704,522),(704,177),(704,177),(704,177),(705,14),(705,14),(705,14),(705,317),(706,2),(706,2),(706,2),(706,2),(706,2),(706,2),(707,863),(707,863),(707,863),(707,814),(708,638),(708,17),(708,16),(708,19),(708,16),(709,2),(709,2),(710,552),(710,46),(710,552),(710,46),(710,552),(711,660),(711,660),(711,864),(711,660),(711,660),(712,317),(712,14),(712,14),(712,14),(712,317),(713,865),(713,433),(713,865),(714,836),(715,10),(715,10),(715,10),(715,10),(715,10),(716,866),(716,867),(716,276),(716,276),(717,868),(717,868),(717,868),(717,869),(718,870),(718,717),(718,870),(718,870),(718,717),(719,388),(719,388),(719,388),(719,388),(720,396),(720,396),(720,396),(721,305),(721,305),(722,592),(722,592),(722,509),(722,509),(722,2),(722,509),(723,871),(723,871),(724,2),(724,872),(724,2),(725,873),(725,874),(725,875),(725,873),(725,876),(725,873),(725,873),(726,2),(726,2),(726,2),(726,2),(726,266),(726,2),(726,2),(727,2),(727,2),(727,2),(727,2),(727,2),(727,2),(727,2),(728,877),(728,878),(728,177),(729,802),(729,802),(729,802),(729,879),(730,8),(730,880),(730,881),(730,8),(730,882),(731,2),(731,2),(731,2),(731,2),(732,379),(732,379),(732,379),(733,883),(734,884),(735,885),(735,885),(735,885),(735,885),(735,885),(736,886),(737,886),(737,886),(737,886),(737,886),(738,887),(739,888),(739,888),(739,888),(739,888),(739,888),(740,889),(740,889),(741,120),(742,890),(742,890),(742,891),(743,892),(744,885),(744,885),(744,885),(744,885),(744,885),(745,893),(746,894),(747,246),(747,246),(747,246),(747,886),(747,895),(748,893),(749,896),(749,896),(749,190),(749,896),(749,897),(750,898),(750,898),(750,898),(751,893),(751,893),(751,893),(751,893),(751,893),(752,899),(753,900),(753,900),(753,900),(753,900),(753,900),(754,898),(754,898),(754,898),(754,898),(755,901),(755,901),(756,26),(757,902),(757,902),(757,902),(758,325),(758,903),(758,325),(759,904),(759,904),(759,904),(759,904),(759,904),(759,904),(759,904),(759,904),(760,905),(760,905),(760,905),(760,906),(761,907),(761,908),(761,907),(761,907),(761,907),(761,907),(761,907),(762,890),(762,890),(762,890),(762,890),(762,890),(762,171),(762,890),(762,909),(763,910),(763,910),(763,910),(763,910),(763,911),(763,239),(763,912),(764,154),(765,287),(765,287),(765,34),(765,287),(765,34),(765,287),(766,893),(766,893),(766,893),(766,893),(766,893),(766,893),(767,26),(768,913),(769,914),(770,915),(771,35),(772,916),(773,905),(773,905),(773,905),(773,906),(774,917),(774,918),(774,919),(775,920),(775,921),(775,920),(775,922),(776,923),(776,924),(776,924),(777,925),(778,926),(778,927),(778,927),(778,927),(778,927),(778,32),(778,928),(779,82),(780,929),(780,930),(780,929),(780,930),(780,929),(780,930),(781,931),(782,932),(782,932),(782,933),(783,934),(784,26),(785,935),(785,935),(785,935),(785,935),(785,935),(785,935),(785,935),(785,935),(786,116),(786,116),(786,116),(787,936),(787,936),(787,936),(788,937),(788,937),(788,937),(789,116),(789,116),(789,116),(789,116),(789,116),(789,116),(790,893),(790,893),(790,893),(790,893),(790,884),(790,893),(791,938),(791,938),(791,939),(791,939),(792,940),(793,941),(793,941),(793,941),(793,941),(794,942),(795,494),(795,494),(795,494),(796,943),(796,943),(796,943),(797,944),(798,945),(799,946),(800,947),(801,948),(802,949),(802,949),(802,949),(803,228),(804,950),(805,2),(806,951),(807,952),(807,952),(807,953),(808,954),(809,955),(809,955),(809,955),(810,956),(811,957),(811,957),(811,957),(812,958),(813,893),(813,893),(813,893),(813,893),(813,893),(813,893),(813,893),(813,893),(814,959),(814,959),(814,960),(815,961),(815,898),(815,961),(816,962),(816,963),(816,962),(817,964),(817,964),(818,965),(818,965),(818,965),(818,965),(819,966),(819,886),(819,82),(819,967),(819,886),(820,212),(820,212),(820,212),(821,968),(821,115),(821,32),(821,116),(821,239),(822,969),(822,969),(822,969),(822,903),(822,903),(822,903),(823,970),(823,970),(824,148),(824,971),(824,971),(824,971),(824,148),(825,239),(825,32),(825,972),(825,325),(825,239),(826,973),(826,124),(826,124),(826,974),(826,974),(826,973),(826,124),(826,974),(826,973),(827,893),(827,975),(827,975),(827,975),(827,975),(827,975),(827,893),(827,976),(828,977),(828,977),(828,977),(828,977),(828,977),(828,978),(829,325),(829,979),(829,325),(830,973),(830,973),(830,973),(830,325),(830,980),(830,973),(831,189),(831,981),(831,189),(832,982),(832,982),(832,982),(832,982),(833,983),(833,983),(834,966),(834,966),(834,32),(834,984),(834,886),(834,966),(835,985),(835,986),(835,986),(835,986),(835,985),(836,933),(837,987),(837,987),(837,988),(838,989),(838,989),(838,154),(838,963),(839,990),(839,990),(839,990),(840,973),(840,128),(840,128),(840,981),(840,886),(840,991),(840,991),(840,991),(840,128),(841,11),(841,11),(841,11),(842,960),(842,82),(842,82),(842,960),(842,886),(843,779),(843,992),(843,779),(843,779),(844,989),(844,989),(844,989),(844,989),(845,993),(845,993),(845,212),(845,993),(845,993),(845,993),(845,886),(846,886),(846,128),(846,886),(846,886),(847,994),(847,994),(847,994),(847,994),(847,994),(847,994),(847,994),(847,994),(847,994),(847,994),(847,994),(847,995),(847,994),(848,26),(848,245),(848,996),(848,997),(849,886),(849,886),(849,886),(849,107),(849,886),(850,893),(850,893),(850,893),(850,998),(850,999),(850,893),(851,1000),(851,1000),(851,1000),(851,1000),(851,1000),(852,1001),(852,1002),(852,930),(852,1002),(852,930),(852,1002),(852,930),(852,1002),(852,930),(853,1003),(853,1004),(853,1004),(853,1005),(853,1006),(854,245),(854,245),(854,245),(854,1007),(854,245),(855,1008),(855,25),(855,1008),(855,1008),(856,1009),(856,341),(856,1010),(856,341),(857,1011),(857,1012),(857,1013),(858,1014),(858,1014),(858,1015),(858,1016),(858,1014),(859,885),(859,885),(859,885),(859,1017),(859,1018),(859,885),(860,1019),(860,1019),(861,55),(861,55),(862,124),(862,124),(862,124),(862,974),(862,124),(862,974),(863,205),(863,205),(864,190),(864,884),(864,884),(864,190),(864,190),(865,973),(865,886),(865,886),(865,886),(865,981),(865,886),(866,1020),(866,1020),(866,1021),(866,1021),(867,1022),(867,1022),(867,1022),(868,214),(868,214),(868,1023),(868,214),(869,1024),(869,1025),(869,1024),(869,1026),(869,1024),(870,921),(870,1027),(870,920),(871,1028),(871,148),(871,148),(871,148),(872,1029),(872,994),(872,893),(872,1029),(873,1030),(873,1030),(874,973),(874,124),(874,124),(874,974),(874,973),(874,973),(874,124),(874,1031),(874,1032),(874,1033),(875,896),(875,896),(875,1034),(875,1034),(875,1034),(876,1035),(876,1036),(876,148),(876,1035),(877,1037),(877,1037),(877,1037),(877,1038),(877,1038),(878,913),(879,59),(879,59),(880,1039),(880,1039),(881,1040),(881,1040),(881,1041),(881,290),(881,290),(881,1040),(882,1042),(882,1042),(882,32),(882,325),(882,1042),(882,1042),(883,26),(883,26),(883,1043),(883,128),(883,26),(883,26),(883,26),(884,961),(884,961),(884,961),(884,961),(884,961),(885,1044),(885,1044),(885,325),(885,1044),(885,1045),(886,345),(886,345),(886,345),(886,345),(887,1024),(887,1024),(887,1024),(887,1046),(888,341),(888,341),(888,341),(889,1047),(889,1048),(889,1042),(889,1049),(889,107),(889,1042),(890,205),(890,205),(890,898),(890,156),(890,156),(891,1050),(891,1050),(891,1051),(892,239),(892,239),(892,1052),(892,1052),(892,239),(892,239),(892,1053),(893,1054),(893,1055),(893,1055),(893,1054),(893,1054),(893,1054),(894,1022),(894,1022),(895,1056),(895,1057),(895,1056),(896,1058),(896,1058),(896,893),(896,884),(897,245),(897,1059),(897,1060),(897,1059),(897,1059),(898,884),(898,884),(899,1061),(899,1061),(899,88),(899,88),(900,1062),(900,884),(900,1062),(900,884),(900,1062),(900,1062),(901,103),(901,103),(901,103),(901,1063),(901,103),(902,905),(902,905),(902,905),(902,905),(903,342),(904,26),(904,26),(904,1064),(904,26),(904,26),(905,1065),(905,1066),(905,1061),(905,1065),(905,1065),(906,124),(906,124),(906,124),(906,974),(906,124),(906,974),(907,1067),(907,1067),(908,886),(908,886),(908,886),(908,884),(909,1068),(909,1068),(909,1068),(910,241),(910,241),(910,241),(910,241),(910,241),(910,1069),(910,241),(911,12),(911,12),(912,1070),(912,34),(912,34),(912,1071),(912,136),(912,35),(912,34),(912,35),(912,1070),(913,1072),(913,1072),(913,1072),(913,1072),(914,1073),(914,1074),(914,1074),(914,1075),(915,7),(915,75),(915,75),(915,75),(915,638),(915,2),(915,75),(916,1076),(917,1077),(918,1078),(918,1079),(918,1080),(918,1081),(919,1082),(919,1082),(920,1083),(920,1084),(920,1085),(920,1086),(920,1084),(921,1087),(921,1087),(921,1088),(922,1089),(922,1089),(922,1090),(923,1091),(923,1091),(923,1091),(923,1091),(923,1091),(924,1092),(925,1093),(925,1093),(926,652),(926,652),(927,430),(927,1094),(927,430),(928,1095),(928,1096),(928,1097),(928,322),(928,1097),(928,1095),(929,1098),(929,1098),(929,1098),(930,405),(930,717),(930,405),(931,1099),(931,1099),(931,1100),(931,1100),(932,225),(932,225),(932,225),(932,225),(932,225),(933,1101),(933,1101),(934,136),(934,136),(934,136),(934,1102),(934,1103),(935,1104),(935,1104),(935,1104),(936,1105),(936,1106),(936,1106),(937,1107),(938,1108),(938,1108),(939,2),(939,2),(939,2),(939,2),(940,638),(940,638),(940,196),(940,196),(940,638),(941,1109),(941,1110),(941,1109),(941,1109),(941,1110),(942,1111),(942,1112),(942,1111),(943,1113),(943,1113),(943,1113),(944,1114),(944,1115),(944,1114),(944,1115),(944,1114),(945,584),(945,1116),(945,723),(946,1117),(946,1117),(946,1117),(946,2),(947,1118),(947,176),(947,176),(947,1119),(948,1120),(948,1120),(948,1120),(949,192),(949,1121),(949,1122),(949,1123),(949,227),(950,1124),(950,1125),(950,1124),(950,1125),(951,638),(951,638),(951,638),(951,638),(952,1126),(952,1127),(952,1126),(952,1128),(953,1129),(953,1129),(953,1129),(954,1130),(954,1130),(954,1130),(954,1130),(954,1130),(955,1131),(955,1131),(955,1131),(956,552),(956,552),(957,1132),(957,1133),(957,1133),(957,1134),(957,1132),(957,1135),(958,1136),(958,1137),(958,1137),(958,1136),(958,1136),(959,1106),(959,1106),(959,1106),(960,1138),(960,1138),(960,1138),(960,1138),(961,1099),(961,1099),(961,1139),(961,1139),(962,478),(962,1140),(962,478),(963,1141),(963,1141),(963,1142),(963,1141),(963,1141),(964,1143),(964,1143),(964,1143),(965,1144),(965,1145),(966,1099),(966,1099),(966,1099),(966,1099),(967,782),(967,2),(967,782),(967,1146),(967,1146),(968,1010),(968,1010),(968,1010),(968,1147),(969,1148),(969,1148),(970,1149),(970,1149),(970,1149),(970,1149),(970,1149),(971,1150),(971,1151),(971,1150),(971,1151),(972,1152),(972,1152),(972,1152),(972,1153),(973,749),(973,1154),(973,1154),(973,749),(974,552),(974,552),(975,1155),(975,1155),(975,1155),(976,1156),(976,1156),(976,1156),(977,1157),(977,1158),(977,1157),(977,1157),(977,1158),(977,1158),(978,1159),(978,1160),(978,1161),(978,1162),(979,1163),(979,1163),(979,1163),(980,1068),(980,1068),(980,1068),(981,1164),(981,1164),(981,1165),(982,2),(982,2),(983,1166),(983,1167),(984,1168),(984,1168),(984,1168),(984,1168),(985,592),(985,592),(985,592),(985,592),(986,1169),(986,1169),(986,1169),(986,1170),(987,1171),(987,1171),(987,1171),(988,1172),(988,1172),(988,1172),(989,1173),(989,1173),(989,1173),(990,1174),(990,1174),(990,1174),(990,1174),(990,1174),(990,1174),(990,1174),(991,1175),(991,1175),(991,1175),(991,1175),(992,751),(992,751),(992,751),(992,751),(992,751),(992,751),(992,751),(992,751),(993,1176),(993,1176),(994,2),(994,1177),(994,1177),(994,1177),(995,1178),(995,1178),(995,1178),(995,1178),(995,1178),(995,1179),(996,1180),(996,1180),(996,1180),(996,664),(996,1180),(997,1180),(997,1180),(997,763),(997,1181),(997,1180),(997,1180),(998,1182),(998,1182),(998,863),(998,863),(999,1183),(999,1183),(999,1183),(999,1184),(999,1183),(999,1183),(1000,1082),(1000,1082),(1000,1082),(1001,1185),(1001,1185),(1001,1185),(1002,1186),(1002,1186),(1002,1187),(1003,1188),(1003,1188),(1003,1188),(1003,1189),(1004,1190),(1004,1117),(1005,1191),(1005,529),(1005,1192),(1005,1191),(1005,1191),(1005,1191),(1005,1193),(1005,1193),(1006,1194),(1006,1194),(1006,1194),(1006,1194),(1006,1194),(1007,1195),(1007,1195),(1007,1195),(1008,1196),(1008,1196),(1008,1197),(1008,1196),(1008,1196),(1008,1196),(1008,1196),(1008,1196),(1008,1196),(1008,1196),(1009,1198),(1009,1199),(1009,1198),(1009,903),(1009,1200),(1009,1201),(1009,1201),(1009,1202),(1009,903),(1009,903),(1010,1203),(1010,1203),(1010,1203),(1011,1092),(1011,136),(1011,1092),(1011,1204),(1011,1205),(1012,2),(1012,2),(1012,2),(1012,2),(1012,2),(1012,2),(1013,2),(1013,2),(1013,2),(1013,2),(1014,1206),(1014,1206),(1014,1206),(1014,1206),(1014,1206),(1014,1207),(1015,1208),(1015,1209),(1015,1210),(1015,1211),(1016,1196),(1016,1196),(1016,1196),(1017,1212),(1017,1212),(1018,1213),(1018,1213),(1018,1214),(1019,1215),(1019,1215),(1019,1215),(1019,1215),(1020,1216),(1020,1217),(1020,1217),(1021,377),(1021,377),(1022,774),(1022,774),(1022,1218),(1023,394),(1023,1219),(1023,638),(1023,394),(1023,1193),(1023,1193),(1024,1220),(1024,1220),(1024,1220),(1024,1070),(1024,1220),(1025,1221),(1025,1221),(1025,1221),(1025,1222),(1026,65),(1026,65),(1027,1223),(1027,1223),(1027,1223),(1028,591),(1028,591),(1028,591),(1028,591),(1028,591),(1028,591),(1028,591),(1029,1224),(1029,1224),(1029,1224),(1029,1224),(1029,1225),(1029,1225),(1029,1225),(1029,1225),(1029,1225),(1030,1226),(1030,1226),(1031,1227),(1031,1228),(1031,1227),(1031,1228),(1032,1229),(1032,1229),(1032,1229),(1032,1229),(1032,1229),(1032,1229),(1033,1230),(1033,1230),(1033,1230),(1033,1230),(1034,1231),(1034,1231),(1035,494),(1035,494),(1035,494),(1036,1232),(1036,1233),(1036,1232),(1036,1233),(1036,1232),(1037,1234),(1037,1234),(1038,2),(1038,2),(1038,2),(1038,2),(1038,2),(1039,1235),(1039,1235),(1039,1235),(1039,1235),(1039,1235),(1039,176),(1040,834),(1040,834),(1040,834),(1040,2),(1040,2),(1040,834),(1041,301),(1041,503),(1041,302),(1041,1236),(1042,1237),(1042,1238),(1043,1239),(1043,1240),(1044,1241),(1044,1241),(1044,1241),(1044,1241),(1045,1242),(1045,1242),(1045,1242),(1045,1243),(1045,1242),(1046,1244),(1046,1244),(1046,1082),(1046,1244),(1047,1245),(1047,266),(1047,266),(1047,560),(1047,266),(1047,561),(1048,1246),(1048,1246),(1049,397),(1049,397),(1049,397),(1050,1247),(1050,1247),(1051,1248),(1051,1248),(1051,1092),(1051,1248),(1051,1248),(1051,1248),(1052,1249),(1052,1249),(1052,1249),(1052,1249),(1052,1250),(1052,1250),(1053,419),(1053,1251),(1053,419),(1053,419),(1054,251),(1054,251),(1054,251),(1054,251),(1054,615),(1054,251),(1055,1252),(1055,1252),(1055,1184),(1055,1252),(1055,1252),(1056,1253),(1057,1254),(1057,1255),(1057,1256),(1057,1257),(1057,1258),(1058,1200),(1058,1259),(1058,1088),(1058,1260),(1058,1200),(1059,1103),(1059,136),(1059,1103),(1059,1103),(1059,1103),(1059,1261),(1060,1262),(1060,1262),(1060,1262),(1061,1263),(1062,392),(1062,278),(1062,392),(1062,392),(1063,46),(1063,46),(1063,46),(1063,46),(1063,46),(1063,46),(1064,1264),(1064,1264),(1065,1265),(1065,1266),(1065,1266),(1066,1267),(1066,1268),(1066,1268),(1066,1268),(1066,1268),(1066,1267),(1067,1269),(1067,1269),(1067,1269),(1068,2),(1068,1270),(1068,1270),(1068,1270),(1068,1270),(1068,1270),(1069,1271),(1070,1272),(1070,1078),(1070,1078),(1070,1080),(1070,1273),(1070,1273),(1071,1274),(1071,1274),(1071,1274),(1072,1275),(1072,1275),(1072,1275),(1072,1275),(1073,1276),(1073,1276),(1074,1277),(1074,1277),(1074,1277),(1074,1277),(1074,1277),(1074,1277),(1075,1278),(1076,1279),(1076,1279),(1076,1279),(1076,1280),(1076,1279),(1077,1281),(1078,570),(1078,2),(1078,2),(1079,494),(1079,494),(1079,494),(1080,1282),(1080,1282),(1081,1283),(1081,1283),(1081,1283),(1082,75),(1082,75),(1082,75),(1082,201),(1083,196),(1083,196),(1083,196),(1083,196),(1083,1284),(1083,1284),(1084,1169),(1084,1169),(1084,1285),(1085,1286),(1085,1287),(1085,1288),(1085,1286),(1085,1289),(1086,1290),(1086,1290),(1086,1290),(1086,1291),(1086,1290),(1087,1292),(1087,1293),(1087,1292),(1088,1294),(1088,1294),(1088,1294),(1088,1294),(1088,1294),(1089,303),(1089,303),(1089,1295),(1089,303),(1090,1248),(1090,1248),(1090,136),(1090,1296),(1090,1296),(1090,1248),(1091,227),(1091,1297),(1091,227),(1091,227),(1091,227),(1091,227),(1092,1298),(1092,1298),(1092,1298),(1093,1299),(1093,1299),(1093,1299),(1094,21),(1094,21),(1094,1300),(1095,2),(1095,941),(1095,941),(1095,941),(1096,1301),(1096,1301),(1096,1302),(1096,1303),(1097,1304),(1097,1304),(1097,1305),(1098,1306),(1098,1306),(1099,1307),(1099,1307),(1100,1308),(1100,1308),(1100,1308),(1100,1309),(1100,1310),(1100,1310),(1101,1311),(1101,1312),(1101,1313),(1101,1312),(1102,1314),(1102,1314),(1102,1314),(1102,1314),(1102,1315),(1102,1314),(1102,1314),(1103,1316),(1103,1316),(1103,1316),(1103,1316),(1104,1114),(1104,1114),(1105,1317),(1105,1317),(1105,1317),(1106,1318),(1106,1318),(1106,1319),(1107,136),(1107,136),(1107,34),(1107,1205),(1108,1320),(1108,1320),(1108,1320),(1109,1321),(1109,1321),(1109,1321),(1110,1322),(1110,1323),(1110,1322),(1111,474),(1111,390),(1111,474),(1111,474),(1111,2),(1112,2),(1112,2),(1112,2),(1112,2),(1113,1324),(1113,1324),(1114,196),(1114,1072),(1114,227),(1114,1072),(1114,1072),(1115,1325),(1115,1325),(1115,1325),(1115,1325),(1116,1326),(1116,1326),(1117,1327),(1117,1327),(1117,1328),(1117,2),(1117,1327),(1118,328),(1118,328),(1118,1072),(1118,1072),(1118,80),(1119,1257),(1119,1329),(1119,1257),(1119,1257),(1120,1330),(1120,1330),(1120,1330),(1120,1330),(1121,1331),(1121,1332),(1121,1331),(1121,1331),(1121,1332),(1122,1333),(1122,1334),(1122,1333),(1122,1333),(1122,1334),(1122,1333),(1122,1333),(1123,1335),(1123,1336),(1123,1336),(1123,1336),(1123,1337),(1123,1335),(1123,1338),(1123,1339),(1124,1340),(1124,1340),(1124,1340),(1125,1341),(1125,1341),(1125,1341),(1126,1135),(1126,1135),(1126,1135),(1126,1342),(1126,1343),(1126,1344),(1127,1345),(1127,1345),(1128,941),(1128,941),(1128,941),(1128,941),(1129,1346),(1129,1346),(1129,1347),(1129,1348),(1130,560),(1130,560),(1130,560),(1130,397),(1131,1349),(1131,1350),(1131,1305),(1132,593),(1132,593),(1132,593),(1133,830),(1133,150),(1133,830),(1133,830),(1133,830),(1134,1351),(1134,1352),(1134,1351),(1134,1352),(1134,1351),(1134,1351),(1134,1351),(1134,1351),(1134,1351),(1135,136),(1135,136),(1135,1070),(1135,34),(1135,136),(1135,1070),(1136,1157),(1136,1157),(1137,1353),(1137,1354),(1137,1354),(1138,1355),(1138,1355),(1138,1355),(1139,1356),(1139,1356),(1139,1356),(1139,1356),(1140,1357),(1140,1358),(1140,1357),(1140,1358),(1140,1357),(1141,1359),(1141,1359),(1141,1360),(1141,1359),(1141,1359),(1142,1361),(1142,1361),(1143,1362),(1143,1362),(1143,1362),(1143,1362),(1144,1363),(1144,1243),(1144,1243),(1144,1363),(1144,1364),(1144,1363),(1144,1363),(1144,1363),(1144,1363),(1144,1363),(1145,2),(1145,317),(1145,146),(1145,2),(1145,146),(1145,317),(1146,1365),(1146,1365),(1146,1365),(1146,1365),(1146,1365),(1147,426),(1147,1366),(1147,426),(1148,2),(1148,2),(1148,2),(1148,2),(1149,1367),(1149,285),(1149,1368),(1149,285),(1149,1368),(1149,1367),(1149,1368),(1149,1368),(1149,1368),(1149,1368),(1149,1368),(1150,1369),(1150,1369),(1151,1370),(1152,1371),(1152,1305),(1152,1371),(1152,1371),(1153,1372),(1153,1372),(1153,1372),(1154,394),(1154,1373),(1154,638),(1154,394),(1154,1374),(1154,1374),(1155,278),(1155,278),(1155,278),(1155,392),(1155,392),(1156,1375),(1156,1375),(1157,1376),(1157,1377),(1157,1378),(1157,1379),(1158,1380),(1158,1381),(1158,1380),(1159,1240),(1159,1240),(1159,1240),(1159,1240),(1159,1382),(1160,160),(1160,160),(1160,160),(1160,160),(1161,1383),(1161,1010),(1161,1384),(1162,1385),(1163,1386),(1163,1386),(1163,1387),(1163,1388),(1163,1386),(1164,1282),(1164,1282),(1164,1282),(1164,1389),(1165,264),(1165,264),(1165,264),(1166,1390),(1166,1391),(1166,1391),(1166,1390),(1167,1392),(1167,1242),(1168,1393),(1168,1394),(1168,1395),(1168,1330),(1169,1396),(1169,1396),(1169,1396),(1170,1397),(1170,1397),(1170,1397),(1170,1397),(1170,1397),(1171,1398),(1171,1398),(1172,1245),(1172,637),(1172,561),(1172,561),(1172,561),(1173,1190),(1173,1190),(1173,1117),(1174,1115),(1174,1115),(1175,731),(1175,731),(1175,731),(1175,731),(1175,731),(1176,1399),(1176,1399),(1176,1399),(1176,1399),(1177,2),(1177,2),(1177,2),(1178,1400),(1178,1400),(1179,1166),(1179,1401),(1180,1402),(1180,1105),(1180,1402),(1180,1402),(1181,1403),(1181,1403),(1181,1403),(1182,1404),(1182,1404),(1182,1404),(1182,1404),(1183,1405),(1183,1406),(1183,1406),(1184,1407),(1185,21),(1185,1408),(1185,21),(1185,21),(1185,21),(1185,1409),(1186,764),(1186,764),(1187,1410),(1187,298),(1187,1410),(1187,1410),(1187,1410),(1187,1411),(1188,1408),(1188,1408),(1188,1408),(1189,1412),(1189,1412),(1189,1412),(1189,1412),(1190,1413),(1190,1414),(1190,1413),(1191,1415),(1191,1415),(1191,1415),(1191,1416),(1191,1416),(1191,1416),(1192,2),(1192,2),(1193,717),(1193,717),(1193,1417),(1193,717),(1194,1418),(1194,1419),(1194,1419),(1195,1420),(1195,1421),(1195,1421),(1196,81),(1197,1422),(1197,1423),(1197,1423),(1197,1422),(1198,1424),(1198,1425),(1198,1424),(1199,299),(1200,1426),(1201,299),(1202,351),(1203,1427),(1203,1428),(1204,1429),(1205,1430),(1206,1105),(1207,1070),(1208,1103),(1208,1103),(1209,1431),(1209,1431),(1209,1432),(1210,1427),(1210,1433),(1211,1114),(1211,1137),(1211,1137),(1211,1137),(1212,1434),(1212,1435),(1212,1436),(1212,1437),(1213,1438),(1213,1438),(1213,1438),(1214,1109),(1214,1439),(1214,1109),(1214,1109),(1215,1440),(1215,1440),(1215,1440),(1216,1441),(1216,1441),(1216,1441),(1216,1442),(1217,1443),(1217,218),(1217,1444),(1217,1444),(1217,1444),(1218,1445),(1218,1445),(1218,136),(1218,136),(1218,1446),(1218,1446),(1218,1445),(1219,320),(1219,1447),(1219,320),(1220,1448),(1220,1449),(1220,1448),(1220,1448),(1220,1450),(1221,1451),(1221,1451),(1222,1452),(1222,1452),(1222,1452),(1223,1453),(1223,1129),(1223,1453),(1223,1453),(1223,1129),(1224,1453),(1224,1454),(1224,1454),(1224,1455),(1224,1456),(1224,1453),(1224,1453),(1225,1457),(1225,1321),(1226,1458),(1226,1459),(1226,1459),(1226,1459),(1227,1434),(1227,1436),(1227,1460),(1228,1461),(1228,1462),(1228,1462),(1228,1463),(1229,1097),(1229,1160),(1229,1096),(1229,1464),(1229,1095),(1229,1160),(1229,1097),(1230,1465),(1230,1465),(1231,62),(1231,62),(1231,1466),(1231,62),(1232,280),(1232,280),(1232,280),(1232,1467),(1232,280),(1232,1467),(1233,1468),(1233,1468),(1233,1468),(1233,1468),(1233,1468),(1234,1213),(1234,1213),(1234,1214),(1234,1213),(1235,1469),(1235,1469),(1235,1469),(1235,1469),(1235,1469),(1235,1469),(1236,1470),(1236,1471),(1236,1470),(1236,1470),(1237,1472),(1237,39),(1237,1473),(1238,1474),(1238,1474),(1239,271),(1239,136),(1239,271),(1239,1475),(1240,1476),(1240,1476),(1241,1477),(1241,268),(1241,1477),(1242,1478),(1242,1478),(1242,1478),(1242,1479),(1243,1480),(1243,1480),(1243,1480),(1243,1480),(1244,1481),(1244,1481),(1244,1482),(1244,1483),(1245,1484),(1245,1484),(1245,1485),(1246,1486),(1246,1486),(1246,1459),(1246,1486),(1247,1487),(1247,1487),(1247,1487),(1247,1487),(1248,1488),(1248,1489),(1248,1490),(1249,1491),(1249,1491),(1250,1492),(1250,1492),(1250,1492),(1251,1493),(1252,1494),(1252,1494),(1253,1495),(1253,1496),(1253,1496),(1253,1496),(1254,1205),(1254,1205),(1254,1205),(1255,1497),(1255,1498),(1255,1498),(1255,1499),(1256,1500),(1256,1500),(1256,1500),(1256,1501),(1256,1500),(1256,1500),(1256,1500),(1257,1282),(1257,1282),(1258,1229),(1258,1229),(1258,1229),(1258,1229),(1259,1330),(1260,1082),(1260,1082),(1260,1082),(1260,1082),(1260,1082),(1261,1502),(1261,1502),(1261,1277),(1261,1277),(1262,1503),(1262,1503),(1263,1504),(1263,1504),(1263,1504),(1263,1505),(1263,1506),(1264,1507),(1264,1508),(1264,1507),(1265,1509),(1265,1509),(1265,1509),(1265,1509),(1266,1440),(1266,1440),(1266,1440),(1267,1510),(1267,1510),(1267,1510),(1267,1510),(1268,1511),(1268,1511),(1269,1512),(1269,1512),(1269,1512),(1269,1513),(1270,1514),(1270,1514),(1271,1462),(1271,1330),(1271,1330),(1271,1462),(1271,1461),(1271,1463),(1272,1515),(1272,1515),(1272,1515),(1272,1515),(1272,1515),(1273,1243),(1273,1441),(1274,1439),(1274,1439),(1274,1516),(1274,1439),(1275,1103),(1275,1103),(1275,1103),(1275,1393),(1276,1517),(1276,1517),(1276,1518),(1276,1519),(1277,1520),(1277,1082),(1277,1520),(1277,1082),(1277,1520),(1278,1521),(1278,1521),(1278,1521),(1278,1521),(1279,1243),(1279,1243),(1279,1522),(1279,1243),(1279,1243),(1280,1523),(1280,1523),(1280,1523),(1281,1524),(1281,1524),(1281,1525),(1282,1526),(1283,1229),(1283,1527),(1283,1229),(1283,1229),(1283,1229),(1283,1229),(1284,1528),(1284,1529),(1284,1529),(1284,1529),(1284,1528),(1285,1468),(1285,1530),(1285,1468),(1286,1393),(1286,1103),(1286,1103),(1286,1393),(1286,1103),(1286,1393),(1287,1531),(1287,1531),(1287,1531),(1288,1532),(1288,1532),(1288,1532),(1288,1532),(1289,1533),(1289,227),(1289,227),(1289,1534),(1289,1533),(1290,1535),(1290,1535),(1290,1535),(1290,1535),(1290,1535),(1291,1536),(1291,1536),(1291,1536),(1292,1537),(1292,1537),(1293,1538),(1293,1538),(1294,1539),(1294,1539),(1294,1540),(1294,1539),(1294,1539),(1295,1541),(1295,1541),(1295,1541),(1295,1541),(1295,1541),(1295,1541),(1295,1541),(1295,1541),(1296,1542),(1296,1542),(1296,1542),(1296,1542),(1297,1543),(1297,1544),(1297,1545);
/*!40000 ALTER TABLE `article_to_affiliation` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article_to_author`
--

DROP TABLE IF EXISTS `article_to_author`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `article_to_author` (
  `doc_id` int(11) NOT NULL,
  `author_id` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article_to_author`
--

LOCK TABLES `article_to_author` WRITE;
/*!40000 ALTER TABLE `article_to_author` DISABLE KEYS */;
INSERT INTO `article_to_author` VALUES (1,1),(1,2),(1,3),(1,4),(2,5),(2,6),(3,7),(3,8),(3,9),(3,10),(3,11),(3,12),(4,13),(4,14),(4,15),(5,16),(5,17),(5,18),(5,19),(5,20),(5,21),(6,22),(6,23),(6,24),(7,25),(7,26),(8,27),(8,28),(8,29),(9,30),(9,31),(9,32),(9,33),(9,34),(10,35),(10,36),(10,37),(10,38),(10,39),(10,40),(11,41),(11,42),(12,43),(12,44),(12,45),(12,46),(13,47),(13,48),(13,49),(13,50),(13,51),(13,52),(14,53),(14,54),(14,55),(14,56),(14,57),(14,58),(14,59),(14,60),(15,61),(15,62),(15,63),(16,64),(16,65),(16,66),(16,67),(16,68),(16,69),(17,70),(17,71),(17,72),(17,73),(18,74),(18,75),(18,76),(18,77),(18,78),(18,79),(18,80),(19,81),(19,82),(19,83),(19,84),(19,85),(20,86),(20,87),(20,88),(20,89),(20,90),(21,91),(21,92),(21,93),(21,94),(22,95),(22,96),(23,97),(23,98),(23,99),(23,100),(24,101),(24,102),(24,103),(24,104),(24,105),(24,106),(25,107),(25,108),(26,109),(26,110),(26,111),(27,112),(27,113),(27,114),(27,115),(27,116),(27,117),(27,118),(27,119),(28,120),(28,121),(28,122),(28,123),(28,124),(28,125),(29,126),(29,127),(29,128),(29,129),(30,130),(30,131),(30,132),(30,133),(30,134),(30,135),(31,136),(31,137),(31,138),(31,139),(31,140),(31,141),(32,142),(32,143),(33,144),(33,145),(33,146),(33,147),(34,148),(34,149),(34,150),(34,151),(34,152),(35,153),(35,154),(35,155),(35,156),(35,157),(35,158),(36,159),(36,160),(36,161),(36,162),(36,163),(36,164),(36,165),(36,166),(37,167),(37,168),(37,169),(38,170),(38,171),(38,172),(39,173),(39,174),(39,175),(39,176),(39,177),(40,178),(40,179),(40,180),(40,181),(40,182),(40,183),(41,184),(41,185),(41,186),(41,187),(42,188),(42,189),(42,190),(43,191),(43,192),(43,193),(43,194),(43,195),(44,196),(44,197),(45,198),(45,199),(45,200),(46,201),(46,202),(46,203),(46,204),(46,205),(47,206),(47,207),(47,208),(47,209),(47,210),(47,211),(47,212),(48,213),(48,214),(48,215),(48,216),(48,217),(48,79),(48,218),(49,219),(49,220),(49,221),(49,222),(49,223),(49,224),(50,225),(50,226),(50,227),(51,228),(51,229),(51,230),(51,231),(51,232),(51,233),(52,234),(52,235),(53,236),(53,237),(53,238),(54,239),(54,240),(54,241),(54,242),(54,243),(55,244),(55,245),(55,246),(55,247),(55,248),(55,249),(55,250),(56,251),(56,252),(56,253),(56,254),(57,255),(57,256),(57,257),(57,258),(57,259),(57,260),(58,261),(58,262),(58,263),(59,264),(59,265),(60,266),(60,267),(60,268),(61,269),(61,270),(61,271),(61,272),(62,273),(62,274),(63,275),(63,276),(63,277),(64,278),(64,279),(64,280),(64,281),(64,282),(65,283),(65,284),(65,285),(65,286),(65,287),(65,288),(66,289),(66,290),(66,291),(66,292),(67,293),(67,294),(67,295),(67,296),(68,297),(68,298),(68,299),(68,300),(68,301),(68,302),(68,303),(69,304),(69,305),(69,306),(69,307),(69,308),(69,309),(69,310),(70,311),(70,312),(70,313),(70,314),(70,315),(71,316),(71,317),(71,318),(71,319),(72,320),(72,321),(72,322),(72,323),(72,324),(73,325),(73,326),(73,327),(74,328),(74,329),(74,299),(74,302),(74,330),(74,331),(75,332),(75,333),(75,334),(75,335),(75,336),(75,337),(75,338),(75,339),(76,340),(76,341),(76,342),(77,343),(77,344),(77,345),(77,253),(78,346),(78,347),(78,348),(79,349),(79,350),(80,351),(80,352),(80,353),(81,354),(81,355),(81,356),(82,357),(82,358),(82,359),(82,360),(83,361),(83,362),(83,363),(83,364),(83,365),(84,366),(84,367),(84,368),(84,369),(84,370),(85,371),(85,372),(85,373),(86,374),(86,375),(86,376),(86,377),(86,378),(86,379),(86,380),(86,381),(87,382),(87,383),(87,384),(87,385),(87,386),(87,387),(87,388),(87,389),(87,390),(88,391),(88,392),(88,393),(88,394),(89,395),(89,396),(89,29),(90,397),(90,398),(90,399),(90,400),(90,401),(90,402),(90,403),(90,404),(91,405),(91,406),(91,407),(91,408),(92,409),(92,410),(92,411),(93,412),(93,413),(93,414),(93,32),(93,415),(93,416),(94,417),(94,418),(94,419),(94,420),(94,421),(94,422),(94,423),(94,424),(95,425),(95,426),(96,427),(96,428),(96,429),(96,430),(97,431),(97,432),(97,433),(97,434),(97,435),(98,436),(98,437),(98,262),(98,438),(98,439),(98,440),(98,441),(99,442),(99,443),(100,444),(100,445),(100,446),(100,447),(101,448),(101,449),(101,450),(102,451),(102,452),(102,453),(102,454),(103,455),(103,456),(103,457),(103,63),(104,458),(104,459),(104,460),(104,461),(105,462),(105,463),(105,464),(105,465),(106,466),(106,467),(106,468),(106,469),(106,470),(106,471),(107,472),(107,473),(107,474),(107,475),(107,476),(108,477),(108,478),(109,479),(109,480),(109,481),(109,482),(109,483),(110,484),(110,485),(110,486),(110,487),(110,488),(111,489),(111,490),(111,491),(111,492),(111,493),(111,254),(112,470),(112,494),(112,469),(112,495),(112,467),(113,496),(113,497),(113,498),(113,499),(113,500),(113,501),(114,502),(114,503),(114,504),(115,505),(115,506),(115,507),(115,508),(116,509),(116,510),(116,511),(116,512),(117,513),(117,514),(117,515),(117,516),(118,517),(118,518),(118,519),(119,520),(119,521),(120,522),(120,523),(120,524),(120,525),(120,169),(121,526),(121,527),(121,528),(121,529),(121,530),(122,531),(122,532),(123,533),(123,534),(123,535),(123,536),(123,537),(123,538),(124,539),(124,540),(125,541),(125,542),(126,543),(126,544),(126,545),(126,546),(126,547),(127,104),(127,548),(127,549),(127,550),(127,551),(127,552),(127,553),(128,554),(128,555),(128,556),(128,557),(128,558),(128,559),(129,560),(129,561),(129,562),(129,563),(129,564),(130,565),(130,566),(130,567),(130,568),(130,569),(131,570),(131,571),(132,572),(132,573),(132,574),(132,575),(132,576),(133,577),(133,578),(133,579),(133,580),(134,581),(134,252),(134,253),(134,582),(135,583),(135,584),(135,585),(135,586),(135,587),(136,588),(136,589),(136,590),(136,591),(137,592),(137,593),(137,594),(137,595),(137,596),(137,597),(138,598),(138,599),(138,600),(139,601),(139,602),(139,24),(140,603),(140,604),(140,84),(140,582),(140,605),(141,606),(141,607),(141,608),(141,609),(141,610),(141,335),(141,611),(142,612),(142,613),(142,614),(142,615),(142,616),(143,617),(143,75),(143,618),(143,79),(144,619),(144,620),(144,621),(144,622),(144,623),(144,624),(144,625),(144,626),(144,627),(145,628),(145,629),(145,630),(145,631),(146,513),(146,632),(146,633),(146,634),(147,635),(147,636),(148,637),(148,638),(148,639),(148,640),(148,641),(149,642),(149,257),(149,643),(149,644),(150,645),(150,646),(150,647),(150,648),(150,649),(151,650),(151,651),(151,652),(151,653),(152,654),(152,655),(152,656),(152,657),(153,658),(153,659),(153,660),(154,661),(154,662),(154,663),(154,664),(154,665),(154,666),(154,667),(155,668),(155,462),(155,669),(155,465),(156,670),(156,671),(156,672),(157,673),(157,674),(158,675),(158,676),(158,677),(159,678),(159,679),(159,680),(159,681),(159,682),(159,683),(159,684),(160,685),(160,686),(160,687),(160,242),(160,688),(160,689),(161,690),(161,691),(162,692),(162,693),(162,694),(163,695),(163,696),(163,697),(164,698),(164,699),(164,700),(164,701),(164,702),(165,703),(165,704),(165,705),(165,706),(165,707),(165,708),(165,709),(165,710),(165,711),(165,641),(166,712),(166,713),(166,714),(166,715),(166,716),(166,717),(166,718),(167,719),(167,720),(167,721),(168,722),(168,723),(168,724),(168,725),(169,726),(169,727),(169,728),(170,729),(170,730),(170,731),(171,732),(171,733),(172,734),(172,735),(172,736),(173,737),(173,738),(173,739),(174,740),(174,741),(174,742),(174,743),(175,744),(175,745),(175,746),(175,747),(176,748),(176,749),(176,750),(176,751),(176,752),(176,753),(176,754),(176,755),(177,756),(177,757),(177,758),(177,759),(178,760),(178,761),(178,762),(178,763),(178,764),(178,765),(179,766),(179,767),(179,768),(179,769),(180,770),(180,771),(180,772),(180,773),(181,774),(181,775),(182,776),(182,777),(183,778),(183,779),(184,780),(184,781),(184,782),(185,783),(185,784),(185,785),(185,786),(186,787),(186,788),(186,789),(186,790),(186,791),(186,792),(187,793),(187,794),(187,795),(187,796),(187,797),(187,798),(187,799),(188,800),(188,801),(188,802),(189,803),(189,804),(189,805),(189,806),(189,807),(190,808),(190,809),(191,810),(191,811),(191,812),(191,813),(192,814),(192,815),(193,816),(193,817),(193,818),(194,819),(194,820),(194,821),(195,822),(195,823),(196,824),(196,825),(196,826),(196,827),(197,828),(198,829),(198,830),(198,831),(199,832),(200,833),(200,834),(200,835),(200,836),(201,837),(202,838),(202,839),(203,840),(204,841),(204,842),(204,843),(205,844),(205,845),(205,846),(205,847),(205,848),(205,849),(206,850),(206,851),(206,852),(206,853),(207,854),(208,855),(209,856),(209,857),(209,858),(209,859),(210,860),(211,861),(212,862),(212,863),(212,864),(213,865),(213,866),(213,867),(214,868),(215,869),(216,870),(216,871),(216,872),(216,873),(217,874),(217,875),(218,876),(219,877),(220,878),(221,879),(221,880),(221,881),(221,882),(221,883),(222,884),(222,885),(222,886),(222,887),(223,888),(224,476),(224,889),(224,890),(225,891),(226,892),(226,893),(226,894),(226,895),(226,896),(227,897),(227,898),(227,899),(228,900),(228,901),(228,902),(228,903),(228,904),(229,905),(230,906),(231,907),(232,908),(232,909),(232,910),(232,911),(232,912),(232,913),(233,914),(233,873),(233,915),(234,916),(234,917),(234,918),(234,919),(235,920),(235,921),(235,922),(235,923),(236,924),(237,925),(237,926),(237,927),(238,928),(238,63),(239,929),(239,930),(239,931),(239,932),(240,933),(241,934),(241,935),(241,936),(242,937),(242,938),(242,939),(243,940),(243,941),(243,942),(244,943),(244,944),(244,945),(244,946),(244,947),(245,948),(245,949),(245,863),(246,950),(247,951),(247,952),(248,953),(248,954),(249,955),(249,956),(249,957),(249,958),(250,959),(250,960),(250,961),(250,962),(250,963),(251,964),(251,965),(251,966),(251,967),(251,968),(252,969),(252,970),(252,971),(252,972),(253,973),(253,974),(253,975),(253,976),(254,977),(254,812),(254,813),(255,978),(255,979),(256,980),(256,981),(256,982),(256,983),(257,984),(257,985),(257,986),(257,987),(258,988),(258,989),(258,990),(259,991),(259,992),(259,993),(260,994),(260,995),(261,996),(261,997),(261,998),(261,999),(262,1000),(263,1001),(263,1002),(264,1003),(264,1004),(264,1005),(265,1006),(265,1007),(265,1008),(266,1009),(267,1010),(268,1011),(268,1012),(268,1013),(269,1014),(269,1015),(269,1016),(270,1017),(271,1018),(271,1019),(271,1020),(272,1021),(273,1022),(273,1023),(273,1024),(274,550),(275,1025),(276,1026),(277,1027),(278,1028),(278,1029),(278,781),(279,1030),(280,1031),(281,1032),(282,1033),(283,328),(284,1034),(285,1035),(285,1036),(285,1037),(285,1038),(285,1039),(286,1040),(286,1041),(286,1042),(286,1043),(287,1044),(287,1045),(287,998),(288,1046),(289,1047),(290,693),(290,1048),(290,1049),(290,1050),(291,1051),(291,1052),(291,1053),(292,1054),(293,1055),(293,1056),(293,1057),(294,450),(294,1058),(294,1059),(294,1060),(294,1061),(295,1062),(295,1063),(296,1064),(297,1065),(298,1066),(298,1067),(298,1068),(299,1069),(299,935),(299,1070),(299,1071),(299,1072),(299,1073),(300,1074),(300,1075),(300,1076),(300,794),(301,783),(301,1077),(301,1078),(301,1079),(302,1080),(302,1081),(302,1082),(302,1083),(302,1084),(302,1085),(302,1086),(303,1087),(303,1088),(303,1089),(304,1090),(305,1091),(305,1092),(305,1093),(306,1094),(306,813),(306,812),(307,1095),(307,1096),(307,1097),(308,1098),(308,1099),(308,1100),(309,1101),(310,1102),(310,1103),(310,1104),(310,1105),(311,1106),(311,1107),(311,1108),(311,1109),(312,1110),(312,1111),(312,1112),(312,40),(313,1113),(314,1114),(314,1115),(315,1116),(315,1117),(315,1118),(315,1119),(315,1120),(315,1121),(315,1122),(316,1123),(316,1124),(317,1125),(317,1126),(317,1127),(317,1128),(318,1129),(318,518),(318,1130),(318,1131),(318,1132),(318,1133),(319,1134),(319,1135),(319,1136),(320,1137),(320,1138),(320,1139),(320,1140),(320,1141),(321,1142),(321,1143),(321,1144),(322,1145),(322,1146),(322,1147),(322,1148),(323,1149),(323,779),(323,1150),(323,1151),(323,1152),(324,1153),(324,1154),(324,1155),(324,1156),(324,1157),(324,1158),(324,1159),(324,1160),(324,1161),(324,1162),(325,1163),(325,1164),(325,1165),(326,1166),(326,1167),(326,1168),(326,1169),(327,1170),(327,1171),(327,1172),(327,1173),(327,1174),(328,1175),(328,1176),(328,1177),(329,1178),(329,1179),(329,1180),(330,1181),(330,1182),(330,1183),(330,1184),(331,1185),(331,1186),(331,1187),(331,1188),(331,1189),(332,1190),(332,1191),(332,1192),(332,1193),(333,1194),(334,1195),(334,1196),(334,1197),(334,1198),(334,1199),(335,1200),(336,1201),(336,1202),(337,1203),(337,1204),(337,1205),(337,1206),(337,1207),(337,1208),(338,1209),(338,857),(338,1210),(338,1211),(338,1212),(339,1213),(339,1214),(339,1215),(339,1216),(340,1217),(340,976),(341,1218),(341,1219),(341,1220),(341,1221),(342,1222),(342,1223),(342,1224),(342,1172),(343,1225),(343,1226),(343,1227),(344,1228),(344,1229),(344,1169),(345,1230),(345,1231),(345,1232),(345,1233),(346,1234),(346,1235),(346,1236),(346,1237),(347,1238),(347,1130),(347,1132),(347,1131),(348,1239),(348,1240),(348,1241),(348,1242),(348,1243),(349,1244),(349,1245),(349,1246),(349,1247),(349,1248),(349,1249),(349,1250),(349,1251),(349,1252),(349,1253),(349,1254),(349,1255),(350,1256),(350,1257),(350,399),(350,1258),(351,1259),(351,1260),(351,1060),(351,1261),(351,775),(352,1262),(352,1263),(352,1264),(352,1265),(353,1266),(353,1267),(353,1268),(353,1269),(353,1270),(354,1271),(354,1272),(354,1273),(354,1274),(354,615),(354,1275),(354,1276),(354,1277),(355,236),(355,1272),(355,1278),(355,1279),(355,615),(356,1280),(356,1281),(357,1282),(357,1283),(357,1284),(357,1285),(357,1286),(358,1287),(358,1288),(358,1289),(359,1290),(359,1291),(359,1292),(359,1293),(360,1294),(360,1295),(360,1165),(361,1296),(361,1297),(361,1298),(361,1299),(361,1300),(361,1301),(362,1302),(362,862),(362,1303),(362,949),(362,1304),(362,863),(363,1305),(363,1306),(363,1307),(363,1308),(363,1309),(363,1310),(364,1311),(364,1312),(364,1313),(364,1314),(365,1315),(365,1316),(365,1317),(365,1318),(366,1319),(366,1320),(366,1321),(366,1322),(367,1323),(367,1324),(367,1325),(368,1170),(368,299),(368,302),(368,1326),(368,1173),(368,1174),(369,1327),(369,1328),(369,1329),(369,1330),(370,1331),(370,1332),(370,1333),(371,1334),(371,1335),(371,1336),(371,1337),(371,1338),(372,1339),(372,1340),(372,1341),(373,1342),(373,1343),(373,1344),(373,1345),(373,1013),(373,1346),(374,1347),(374,1348),(374,1349),(375,1350),(375,1351),(376,1352),(376,1353),(376,1354),(377,1355),(377,1356),(377,1357),(377,1358),(377,1359),(378,1360),(378,1361),(378,1362),(378,542),(378,1363),(379,1364),(379,1365),(379,1366),(379,1367),(380,1368),(380,1369),(380,1370),(381,1371),(381,1372),(382,1373),(382,1374),(382,1375),(382,274),(383,1376),(383,1377),(383,1378),(384,1379),(384,1380),(385,1381),(385,1382),(385,193),(385,1383),(385,1384),(386,1385),(386,900),(386,1386),(386,237),(386,1206),(386,1387),(387,1388),(387,1239),(388,1389),(388,1390),(388,1391),(388,1392),(388,1393),(389,1394),(389,1395),(389,1396),(389,1397),(390,1398),(390,1399),(390,1400),(391,900),(391,237),(391,1385),(391,1386),(391,1206),(392,1401),(392,1402),(392,1403),(392,1404),(392,1008),(393,1405),(393,1406),(393,1407),(393,1408),(393,1409),(393,1410),(393,1411),(394,1412),(394,1413),(394,1414),(395,1415),(395,1416),(395,1417),(395,1418),(395,1419),(396,1420),(396,1421),(396,1422),(396,1423),(396,1424),(396,1425),(397,1426),(397,1427),(397,1428),(397,1429),(398,1430),(398,1431),(398,1432),(398,1433),(398,1434),(398,1435),(398,1436),(399,855),(399,1437),(399,1438),(399,331),(400,1439),(400,1440),(400,1441),(401,142),(401,143),(402,1442),(402,1443),(402,1128),(403,1444),(403,1445),(403,1446),(403,392),(403,1447),(404,1448),(404,1449),(404,1450),(404,1451),(405,1452),(405,1453),(405,1454),(406,1455),(406,1456),(406,1457),(406,1458),(406,1459),(407,1460),(407,1461),(407,1462),(408,1463),(408,1172),(408,1464),(408,1465),(409,1466),(409,1467),(409,1468),(409,1173),(409,302),(409,667),(409,331),(410,1469),(410,1470),(410,1471),(410,1006),(410,1472),(410,1473),(410,1324),(411,1474),(411,1475),(411,1476),(411,1477),(412,1478),(413,966),(413,1479),(413,967),(413,1480),(414,1481),(414,1482),(414,1483),(414,1484),(415,1485),(415,1486),(415,1487),(416,1488),(416,1489),(416,1490),(417,1491),(417,1492),(417,1493),(417,1494),(417,1495),(417,1496),(417,1497),(418,1498),(418,1499),(418,1500),(418,1501),(419,1499),(420,1502),(421,1503),(421,1504),(421,392),(422,1505),(422,1506),(422,1507),(422,1508),(422,1509),(423,1510),(423,1511),(423,1206),(423,1512),(423,1513),(424,1514),(424,1515),(425,1516),(425,1517),(425,1518),(426,1519),(426,1520),(426,1521),(427,1522),(427,1523),(427,1524),(427,1525),(427,1526),(428,1527),(428,1468),(428,302),(428,1528),(428,1529),(429,1530),(429,1518),(430,1531),(430,1532),(430,1533),(431,1534),(431,1535),(431,1536),(432,1537),(432,1538),(432,1539),(433,1540),(433,1541),(433,1542),(433,1543),(433,1544),(434,1545),(434,1546),(434,1547),(434,1314),(435,1548),(435,867),(436,1549),(436,1550),(436,1551),(436,1552),(437,1553),(437,1554),(437,1555),(437,1556),(438,1557),(438,1558),(439,1559),(439,1560),(440,1561),(440,1562),(440,1563),(440,1564),(441,1565),(441,1566),(441,104),(441,553),(441,1277),(441,1567),(442,1568),(442,1569),(442,1570),(442,1571),(443,1572),(443,1573),(443,1574),(443,1575),(444,1576),(444,1577),(445,1578),(445,1579),(445,1580),(446,1581),(446,1582),(446,1583),(447,1584),(447,1585),(448,1586),(448,1587),(448,1588),(448,1589),(448,1590),(449,1591),(449,1592),(449,1593),(449,1594),(449,1595),(449,1596),(450,1597),(450,1598),(450,1599),(450,1600),(451,1601),(451,1602),(452,1603),(452,1604),(452,1605),(452,1606),(452,1607),(452,1608),(453,1609),(453,1610),(453,1611),(454,1612),(454,1613),(454,923),(455,1614),(455,1615),(455,1480),(456,1616),(456,857),(456,856),(456,1617),(456,1618),(457,1619),(457,1620),(457,1621),(457,1622),(457,1623),(458,1624),(459,1625),(459,1626),(459,1627),(460,1628),(460,1629),(460,1630),(460,1631),(461,1632),(461,1633),(461,1634),(461,1581),(462,1635),(462,1636),(462,1637),(462,1638),(463,1639),(463,1640),(463,1641),(463,1642),(464,1643),(464,1644),(465,1263),(465,1645),(465,1646),(465,1647),(465,1648),(466,1649),(466,935),(466,1650),(466,1072),(466,1651),(467,1652),(467,1653),(467,1654),(467,1655),(468,1656),(468,1657),(468,1658),(468,1659),(468,1660),(468,1661),(468,1662),(468,1663),(468,1664),(468,1665),(469,1666),(469,1667),(469,1668),(469,1669),(469,1670),(470,1671),(470,1672),(470,1673),(470,1674),(470,1675),(470,1676),(471,1677),(471,1678),(472,1679),(472,1680),(473,1681),(473,1682),(473,1683),(474,1684),(474,1685),(474,1686),(474,1687),(474,1688),(475,1689),(475,1690),(475,1691),(475,1692),(475,1693),(475,1694),(476,1695),(476,1451),(476,1696),(476,1697),(477,1698),(477,1699),(477,1700),(477,1701),(477,1702),(477,1703),(477,1704),(477,1705),(478,1706),(478,1707),(478,718),(479,1586),(479,1708),(480,1709),(480,1581),(480,1710),(480,1711),(480,1712),(480,1088),(480,1713),(481,1054),(481,1324),(482,1714),(482,1715),(482,1716),(482,1717),(483,1718),(483,1177),(483,1176),(484,1719),(484,1601),(484,1720),(484,1721),(484,1722),(485,1723),(485,1724),(485,1725),(485,1726),(485,1727),(485,1637),(486,1728),(486,1502),(486,1729),(487,1730),(487,1731),(487,1732),(487,1733),(487,1734),(488,1735),(488,350),(488,1736),(489,1737),(489,1738),(489,1739),(489,1740),(490,1741),(491,1742),(491,1743),(492,1744),(492,1515),(492,1745),(492,1746),(493,1747),(493,1748),(493,1749),(493,1750),(493,1751),(493,1752),(494,1753),(494,921),(495,1754),(495,518),(495,1130),(496,1755),(496,1756),(496,1757),(496,1758),(496,1396),(496,1759),(497,1760),(497,1761),(497,1762),(498,1763),(498,841),(498,1764),(499,1765),(499,1766),(499,1767),(500,1768),(500,1769),(500,1770),(500,1771),(500,1772),(500,1773),(500,1774),(500,1775),(501,1776),(501,1777),(501,1778),(501,1779),(501,1780),(501,1781),(501,1782),(501,1783),(501,1784),(502,1785),(503,1786),(503,1787),(504,1788),(504,1789),(504,1790),(504,1791),(504,1792),(504,1793),(504,1794),(504,1795),(504,1796),(504,1797),(505,1798),(505,1799),(505,1800),(506,1801),(506,104),(506,1802),(506,553),(506,1803),(506,1804),(506,106),(506,1567),(507,1805),(507,1806),(508,1807),(509,1808),(509,1809),(510,1810),(510,1811),(510,1812),(510,1813),(510,1814),(511,1815),(511,1816),(511,1817),(511,1818),(511,1819),(512,1820),(512,1821),(512,1822),(512,1823),(513,1601),(513,889),(513,476),(513,1721),(514,1824),(514,1825),(514,1826),(514,1827),(514,1828),(514,1829),(515,1830),(515,1831),(515,1832),(516,1833),(516,1834),(516,769),(516,1835),(517,442),(517,1836),(517,1837),(517,443),(518,1838),(518,1839),(518,1555),(519,1840),(519,1841),(519,1758),(519,1842),(519,1843),(519,1844),(520,1388),(520,18),(521,1845),(521,1846),(521,1847),(522,1848),(522,1849),(522,1850),(523,1851),(523,1852),(523,769),(523,1853),(524,1854),(524,518),(524,1855),(524,474),(525,1856),(526,1857),(526,1858),(526,392),(526,1504),(526,1859),(526,1860),(527,1861),(527,1862),(527,1863),(527,1864),(527,1865),(528,1866),(528,1867),(528,1868),(528,1629),(528,1869),(528,1193),(528,1870),(529,1871),(529,1872),(529,1873),(529,1874),(530,1875),(530,1876),(531,1877),(532,1878),(532,1879),(532,1880),(532,1881),(532,1882),(533,1883),(533,1884),(533,1885),(533,1886),(533,1887),(533,1888),(533,1889),(533,1890),(533,1891),(533,1892),(534,391),(534,1893),(534,392),(534,1503),(534,1894),(535,1895),(535,1896),(535,1897),(535,1898),(536,1899),(536,1900),(536,1901),(537,1902),(537,1903),(537,1904),(538,1905),(538,1906),(538,1907),(538,1908),(538,1909),(538,1910),(539,1911),(539,1912),(540,1500),(540,1913),(540,1498),(540,1501),(540,1499),(541,1914),(541,1915),(542,1916),(542,1917),(542,1918),(543,1919),(543,1920),(543,1921),(543,1922),(544,1923),(544,1924),(545,1925),(545,1926),(545,1927),(545,1928),(546,1929),(546,1930),(546,1532),(546,1931),(547,1932),(547,1933),(547,1934),(547,1638),(548,401),(548,1935),(548,1936),(549,1937),(549,1938),(549,1939),(549,1940),(549,1941),(549,1942),(550,1943),(550,1944),(550,1276),(550,1945),(550,1277),(551,1946),(552,1947),(552,1366),(552,1948),(553,1949),(553,1950),(553,1951),(554,1952),(554,1953),(554,1954),(554,1955),(555,1956),(555,1957),(555,1958),(555,1959),(556,1960),(557,1222),(557,1961),(557,1172),(558,1962),(558,1963),(558,1964),(558,1965),(558,1966),(558,1967),(558,1968),(559,1969),(559,1970),(560,1971),(560,1972),(560,1973),(560,1974),(560,1975),(560,1976),(561,1977),(561,1978),(562,1979),(562,1980),(562,1981),(562,63),(562,1982),(563,1983),(563,1984),(563,1277),(564,1985),(564,1986),(564,1987),(565,1988),(565,1989),(565,769),(566,1990),(566,1991),(566,1992),(566,1993),(566,1994),(567,1995),(567,1996),(567,1464),(567,1997),(567,1998),(568,1999),(568,2000),(568,1674),(568,2001),(569,2002),(569,2003),(569,2004),(569,276),(570,2005),(570,2006),(570,2007),(570,2008),(570,2009),(571,2010),(571,2011),(571,2012),(571,448),(571,450),(571,2013),(572,2014),(572,2015),(572,2016),(572,2017),(573,2018),(573,2019),(573,2020),(574,2021),(574,2022),(574,2023),(574,2024),(574,2025),(574,2026),(575,1516),(575,2027),(575,2028),(575,2029),(575,1518),(576,2030),(576,2031),(576,1823),(577,2032),(577,2033),(578,2034),(578,1192),(578,1545),(578,1314),(579,1621),(579,1622),(579,1623),(580,2035),(580,2036),(580,2037),(580,2038),(580,2039),(580,2040),(581,2041),(581,2042),(582,2043),(582,1330),(583,2044),(583,2045),(583,2046),(583,2047),(583,2048),(583,2049),(583,2050),(584,2051),(584,2052),(584,2053),(584,2054),(584,2055),(585,1654),(585,2056),(585,2057),(585,2058),(585,2059),(586,2060),(586,2061),(586,2062),(587,2063),(587,2000),(587,1674),(587,2064),(588,2065),(588,2066),(589,2067),(589,2068),(589,2069),(589,2070),(589,2071),(590,2072),(590,2073),(590,2074),(591,2075),(591,2076),(591,2077),(591,2078),(591,2079),(592,2080),(592,2081),(592,2082),(592,2083),(592,2084),(592,2085),(592,2086),(592,2087),(593,2088),(593,2089),(594,2090),(594,2091),(594,2092),(594,316),(595,2093),(595,2094),(595,2095),(595,2096),(596,2097),(596,2098),(596,1961),(597,104),(597,2099),(597,2100),(597,553),(597,552),(598,2101),(598,2102),(598,2103),(599,2104),(599,2105),(599,2106),(599,2104),(600,2107),(600,2108),(600,2109),(600,2110),(601,2111),(601,2112),(601,2113),(602,2114),(602,2115),(603,2116),(603,2117),(603,2118),(603,2119),(603,2120),(603,2121),(603,2122),(604,2123),(604,2124),(604,2125),(604,2126),(604,192),(604,615),(604,195),(605,2127),(605,2128),(605,2129),(605,2130),(605,2131),(606,2132),(606,2133),(607,2134),(607,1468),(607,2135),(607,1173),(607,302),(608,2136),(608,2137),(608,2138),(608,2139),(608,2140),(608,2141),(609,2142),(609,1305),(609,1310),(609,2143),(610,928),(610,63),(611,2144),(611,2145),(611,2146),(611,2147),(612,2148),(612,2149),(612,2150),(612,2151),(612,2152),(613,1632),(613,2153),(613,2154),(613,2155),(613,1581),(613,2156),(614,2157),(614,2158),(614,2159),(614,2160),(615,1366),(615,2161),(615,2162),(615,2163),(616,2164),(616,2165),(616,2166),(616,2167),(616,2168),(617,2169),(617,2170),(617,2171),(617,2172),(618,2173),(618,2174),(618,2175),(618,2176),(618,2177),(618,2178),(618,2179),(619,781),(619,2180),(619,2181),(620,2182),(620,2183),(620,2184),(620,2185),(621,2186),(621,2187),(621,2188),(621,2189),(621,2190),(622,2191),(622,2192),(622,2193),(622,2194),(622,1354),(623,2195),(623,2196),(623,2197),(623,2198),(623,2199),(624,2200),(624,2201),(624,2202),(624,1926),(624,103),(624,2203),(624,553),(625,2204),(625,2205),(625,2206),(625,2207),(625,2208),(625,2209),(625,2210),(625,2211),(626,1960),(626,1130),(626,518),(627,2212),(627,2213),(627,2214),(627,2215),(628,2216),(628,2217),(628,2218),(628,2219),(629,2220),(629,2221),(629,2222),(630,2223),(630,2224),(630,2225),(630,2226),(630,2227),(630,2228),(630,193),(631,2229),(631,2230),(631,2231),(631,2232),(631,2233),(631,2234),(632,2235),(632,2236),(632,2237),(632,2238),(632,2239),(633,2240),(633,2241),(633,2242),(634,2243),(634,2244),(635,2245),(635,2246),(635,2247),(635,1663),(636,2248),(636,2249),(637,2250),(637,2251),(637,2252),(637,2253),(637,2254),(638,2255),(638,2256),(638,2257),(639,2258),(639,2259),(639,2260),(639,2261),(639,2262),(640,2263),(640,1471),(640,2264),(641,2265),(641,2266),(641,2267),(641,2268),(641,2269),(642,2270),(642,2271),(642,2272),(643,2273),(643,2274),(643,2275),(643,2276),(643,2277),(643,2278),(644,2279),(644,2280),(644,2281),(644,2282),(645,2283),(645,2284),(646,1991),(646,1992),(646,2285),(646,1990),(646,1994),(647,2286),(647,2287),(647,2288),(648,2289),(648,2290),(648,2291),(648,1685),(649,2292),(649,2293),(649,2294),(649,2295),(650,1102),(650,1103),(650,2296),(650,2297),(650,1104),(650,1105),(651,2298),(651,2299),(651,2300),(652,1917),(652,2301),(652,2302),(652,1146),(652,2303),(652,2304),(652,2305),(652,2306),(652,2307),(652,2308),(653,2309),(653,1841),(653,1758),(653,1759),(654,1121),(654,1118),(654,1117),(654,2310),(654,2311),(654,1120),(654,1122),(655,1353),(655,1352),(655,1354),(656,2312),(656,2313),(656,2314),(657,2315),(657,2316),(657,2317),(657,2318),(658,2319),(659,2320),(659,518),(659,2321),(659,1006),(659,2322),(659,2323),(659,1008),(659,2324),(660,1463),(660,1464),(660,2325),(661,2326),(661,2327),(661,2328),(662,2329),(662,2330),(662,2331),(662,2332),(663,2333),(663,2334),(664,1947),(664,1366),(665,297),(665,1468),(665,300),(665,302),(665,1173),(665,2335),(665,2135),(665,970),(665,303),(666,2336),(666,2337),(666,2338),(666,1206),(667,2339),(667,2340),(667,2341),(667,2342),(668,2343),(668,2344),(668,2345),(668,2346),(668,2347),(668,2348),(669,2349),(669,2350),(669,2351),(669,2352),(670,2224),(670,2353),(670,2354),(670,2225),(670,2223),(670,2032),(671,2355),(671,2356),(671,2357),(671,2358),(671,1085),(672,2359),(672,2360),(672,1176),(673,2361),(673,2362),(673,2363),(673,2364),(673,2365),(674,2366),(674,2367),(674,1412),(675,2368),(675,1176),(675,1177),(676,2369),(676,2370),(676,2371),(677,2372),(677,2373),(677,2374),(677,2375),(677,2376),(678,2377),(678,2378),(678,2379),(679,2380),(679,2381),(679,2382),(679,1518),(680,2383),(680,2384),(680,2385),(680,2349),(680,2350),(680,2386),(681,2387),(681,2388),(681,2389),(681,2390),(681,2391),(681,2392),(681,443),(682,2393),(682,2394),(682,967),(683,2395),(683,1765),(683,2396),(683,2397),(683,2398),(683,2399),(683,2400),(684,2215),(684,2401),(684,2402),(684,2403),(684,2404),(684,2405),(685,2406),(685,2077),(685,2407),(685,2408),(685,2078),(686,2409),(686,2099),(686,2410),(686,1880),(686,2411),(686,103),(686,552),(686,2412),(687,2413),(687,2102),(687,2103),(688,1267),(688,2414),(688,2415),(688,2416),(688,2417),(688,2418),(688,2419),(689,2420),(689,575),(689,2421),(690,2415),(690,2417),(690,2422),(690,2419),(691,2423),(691,2424),(691,2425),(691,2426),(691,2427),(691,2428),(692,2429),(692,2430),(692,2431),(692,2432),(692,2433),(693,1054),(693,1324),(694,2232),(694,2229),(694,2434),(694,2435),(694,2436),(694,2437),(694,2233),(694,2234),(695,1133),(695,2438),(695,2439),(695,2440),(695,2441),(695,2442),(696,2443),(696,2444),(696,2445),(697,2446),(697,330),(697,302),(697,2447),(697,329),(697,2448),(698,2449),(698,26),(699,2450),(699,2451),(699,2452),(699,2453),(699,2454),(700,2455),(700,935),(700,936),(700,1277),(700,1072),(701,2089),(701,69),(702,2456),(702,2457),(702,769),(702,1851),(702,2458),(703,2459),(703,2460),(703,2461),(704,1238),(704,1130),(704,1132),(704,1131),(705,2462),(705,1996),(705,29),(705,1998),(706,2133),(706,2175),(706,2426),(706,2463),(706,2464),(706,2465),(707,2466),(707,2467),(707,2468),(707,2469),(708,2470),(708,2471),(708,2472),(708,40),(708,36),(709,2473),(709,2474),(710,1365),(710,101),(710,1364),(710,103),(710,1366),(711,1700),(711,1699),(711,2475),(711,1702),(711,1701),(712,664),(712,1171),(712,1222),(712,1172),(712,2476),(713,2477),(713,1785),(713,2478),(714,2319),(715,17),(715,2479),(715,2480),(715,2481),(715,18),(716,2482),(716,2483),(716,2484),(716,1823),(717,2485),(717,2486),(717,2487),(717,2488),(718,2489),(718,2490),(718,2491),(718,2492),(718,2493),(719,2494),(719,2495),(719,2496),(719,2497),(720,2498),(720,2499),(720,2500),(721,2501),(721,2502),(722,2503),(722,2504),(722,2505),(722,2506),(722,578),(722,2507),(723,2508),(723,2509),(724,2510),(724,2511),(724,2512),(725,2513),(725,2514),(725,2515),(725,2516),(725,2517),(725,2518),(725,2519),(726,2520),(726,2521),(726,782),(726,1308),(726,1758),(726,2522),(726,2523),(727,2524),(727,2525),(727,2526),(727,2527),(727,2426),(727,2528),(727,2529),(728,2530),(728,2531),(728,2532),(729,2533),(729,2534),(729,2535),(729,2536),(730,2537),(730,2538),(730,2539),(730,15),(730,2540),(731,2541),(731,2542),(731,2543),(731,2544),(732,2545),(732,2546),(732,861),(733,2547),(734,2548),(735,2549),(735,2550),(735,2551),(735,2552),(735,2553),(736,2554),(737,2555),(737,2556),(737,2557),(737,2558),(738,2559),(739,2560),(739,2561),(739,2562),(739,2563),(739,2564),(740,2565),(740,2566),(741,581),(742,2567),(742,2568),(742,2569),(743,2570),(744,2571),(744,2551),(744,2572),(744,2552),(744,2573),(745,2574),(746,2575),(747,2576),(747,2577),(747,2578),(747,2579),(747,2580),(748,2581),(749,2582),(749,2583),(749,2584),(749,2585),(749,2586),(750,2587),(750,2588),(750,2589),(751,2581),(751,2590),(751,2591),(751,2592),(751,2593),(752,2594),(753,2595),(753,2596),(753,2597),(753,2596),(753,2598),(754,2599),(754,2588),(754,2600),(754,2589),(755,2601),(755,2602),(756,2603),(757,2604),(757,2605),(757,2606),(758,2607),(758,2608),(758,2609),(759,2610),(759,2611),(759,2612),(759,2613),(759,2614),(759,2615),(759,2616),(759,2617),(760,2618),(760,2619),(760,2620),(760,2621),(761,2622),(761,2623),(761,2624),(761,2625),(761,2626),(761,2627),(761,2628),(762,2629),(762,2630),(762,2631),(762,2632),(762,2633),(762,347),(762,2634),(762,2635),(763,2636),(763,2637),(763,2638),(763,2639),(763,2640),(763,2641),(763,2642),(764,2643),(765,2644),(765,2645),(765,2646),(765,2647),(765,79),(765,2648),(766,2649),(766,2650),(766,2591),(766,2651),(766,2652),(766,2593),(767,2653),(768,2654),(769,2655),(770,2656),(771,2657),(772,2658),(773,2659),(773,2660),(773,2620),(773,2621),(774,2661),(774,2662),(774,2663),(775,2664),(775,2665),(775,2666),(775,2667),(776,2668),(776,2669),(776,2670),(777,2671),(778,2672),(778,2673),(778,2674),(778,2675),(778,2676),(778,2677),(778,2678),(779,173),(780,2679),(780,2680),(780,2681),(780,2682),(780,2683),(780,2684),(781,2685),(782,2686),(782,2687),(782,2688),(783,2689),(784,2690),(785,2691),(785,2692),(785,2693),(785,2694),(785,2695),(785,2696),(785,2697),(785,2698),(786,2699),(786,2700),(786,2701),(787,2702),(787,2703),(787,2704),(788,2705),(788,2706),(788,2707),(789,2708),(789,2709),(789,2710),(789,2711),(789,2700),(789,261),(790,2712),(790,2713),(790,2714),(790,2715),(790,2716),(790,2593),(791,2717),(791,2718),(791,2719),(791,2720),(792,2721),(793,2722),(793,2723),(793,2724),(793,2724),(794,2725),(795,2726),(795,1177),(795,1176),(796,2727),(796,2728),(796,2729),(797,2730),(798,2731),(799,2732),(800,2733),(801,2734),(802,2735),(802,2736),(802,2737),(803,2738),(804,2739),(805,2740),(806,2741),(807,2742),(807,2743),(807,2744),(808,2745),(809,2746),(809,2747),(809,2748),(810,2749),(811,2750),(811,2751),(811,2752),(812,2753),(813,2754),(813,2755),(813,2756),(813,2757),(813,2758),(813,2759),(813,2760),(813,2761),(814,2762),(814,2763),(814,2764),(815,2765),(815,2766),(815,2767),(816,2768),(816,2769),(816,2770),(817,2771),(817,2772),(818,2773),(818,2774),(818,2775),(818,2776),(819,2777),(819,2778),(819,173),(819,2779),(819,2557),(820,2780),(820,2781),(820,437),(821,2782),(821,240),(821,242),(821,243),(821,2783),(822,2784),(822,2785),(822,2786),(822,2608),(822,2787),(822,2788),(823,2789),(823,2790),(824,2791),(824,2792),(824,2793),(824,2794),(824,310),(825,2795),(825,242),(825,2796),(825,687),(825,688),(826,2797),(826,2798),(826,2799),(826,2800),(826,2801),(826,2802),(826,438),(826,2803),(826,2804),(827,2805),(827,2806),(827,2807),(827,2808),(827,2809),(827,2810),(827,2811),(827,2812),(828,2813),(828,2814),(828,2815),(828,2816),(828,2817),(828,2818),(829,2819),(829,2820),(829,687),(830,2821),(830,2822),(830,2823),(830,2824),(830,2825),(830,2826),(831,2827),(831,2828),(831,2829),(832,2830),(832,2831),(832,2832),(832,2833),(833,2834),(833,2835),(834,2836),(834,2777),(834,2837),(834,2838),(834,2557),(834,2839),(835,2840),(835,2841),(835,2842),(835,2843),(835,2844),(836,2845),(837,2846),(837,2847),(837,2848),(838,2849),(838,2850),(838,2851),(838,2769),(839,2852),(839,2853),(839,2854),(840,2855),(840,2856),(840,2857),(840,2828),(840,2858),(840,2859),(840,2860),(840,2861),(840,2862),(841,23),(841,22),(841,24),(842,2863),(842,2864),(842,173),(842,2764),(842,2579),(843,2865),(843,2866),(843,2867),(843,2084),(844,2868),(844,2850),(844,2849),(844,2869),(845,2870),(845,2871),(845,437),(845,2872),(845,2873),(845,2874),(845,2875),(846,2876),(846,2877),(846,2878),(846,2879),(847,2880),(847,2881),(847,2882),(847,2883),(847,2884),(847,2885),(847,2886),(847,2887),(847,2888),(847,2889),(847,2890),(847,2891),(847,2892),(848,2893),(848,2894),(848,2895),(848,2896),(849,2897),(849,2898),(849,2899),(849,2900),(849,2901),(850,2902),(850,2903),(850,2904),(850,2905),(850,2906),(850,2907),(851,2908),(851,2909),(851,2910),(851,2911),(851,2912),(852,2913),(852,2914),(852,2915),(852,2916),(852,2917),(852,2918),(852,2919),(852,2920),(852,2921),(853,2922),(853,2923),(853,2924),(853,2925),(853,2926),(854,2927),(854,2928),(854,2929),(854,2930),(854,512),(855,2931),(855,2932),(855,2933),(855,2934),(856,2935),(856,2936),(856,2937),(856,726),(857,2938),(857,2939),(857,2940),(858,2941),(858,2942),(858,2943),(858,2944),(858,2945),(859,2946),(859,2947),(859,2948),(859,2949),(859,2950),(859,2951),(860,2952),(860,2953),(861,2954),(861,123),(862,2799),(862,2955),(862,2956),(862,2800),(862,438),(862,2803),(863,2957),(863,2958),(864,2959),(864,2716),(864,2960),(864,378),(864,2961),(865,2855),(865,2962),(865,2858),(865,2899),(865,2828),(865,2901),(866,2963),(866,2964),(866,2965),(866,2966),(867,2967),(867,2968),(867,2969),(868,2970),(868,2971),(868,2972),(868,2973),(869,2974),(869,2975),(869,2976),(869,2977),(869,2978),(870,2979),(870,2980),(870,2981),(871,2982),(871,2983),(871,2984),(871,2985),(872,2986),(872,2987),(872,2755),(872,2988),(873,2989),(873,2990),(874,2991),(874,2799),(874,262),(874,2800),(874,2992),(874,2993),(874,438),(874,2994),(874,2995),(874,2996),(875,2997),(875,2998),(875,2999),(875,3000),(875,3001),(876,3002),(876,3003),(876,310),(876,3004),(877,3005),(877,3006),(877,3007),(877,3008),(877,3009),(878,3010),(879,732),(879,733),(880,3011),(880,3012),(881,3013),(881,3014),(881,3015),(881,3016),(881,3017),(881,3018),(882,3019),(882,3020),(882,242),(882,687),(882,3021),(882,3022),(883,3023),(883,3024),(883,3025),(883,3026),(883,3027),(883,3028),(883,59),(884,3029),(884,3030),(884,3031),(884,2767),(884,3032),(885,3033),(885,3034),(885,2824),(885,3035),(885,3036),(886,3037),(886,734),(886,3038),(886,3039),(887,2976),(887,3040),(887,3041),(887,3042),(888,2936),(888,726),(888,3043),(889,3044),(889,3045),(889,3046),(889,3047),(889,3048),(889,3021),(890,3049),(890,3050),(890,3051),(890,3052),(890,3053),(891,3054),(891,3055),(891,3056),(892,3057),(892,3058),(892,3059),(892,3060),(892,3061),(892,3062),(892,3063),(893,3064),(893,3065),(893,3066),(893,3067),(893,3068),(893,3069),(894,3070),(894,2969),(895,3071),(895,3072),(895,3073),(896,3074),(896,3075),(896,3076),(896,3077),(897,3078),(897,3079),(897,3080),(897,3081),(897,3082),(898,2548),(898,2716),(899,3083),(899,3084),(899,3085),(899,3086),(900,3087),(900,3088),(900,3089),(900,3090),(900,3091),(900,3092),(901,3093),(901,3094),(901,3095),(901,3096),(901,3097),(902,2660),(902,2659),(902,3098),(902,2620),(903,3099),(904,2690),(904,3100),(904,3101),(904,3102),(904,59),(905,3103),(905,3104),(905,3105),(905,3106),(905,3107),(906,3108),(906,2799),(906,2956),(906,2800),(906,438),(906,2803),(907,3109),(907,3110),(908,2897),(908,3111),(908,2899),(908,2716),(909,3112),(909,3113),(909,3114),(910,3115),(910,3116),(910,3117),(910,3118),(910,3119),(910,3120),(910,508),(911,3121),(911,26),(912,3122),(912,3123),(912,3124),(912,3125),(912,3126),(912,3127),(912,79),(912,3128),(912,3129),(913,3130),(913,3131),(913,3132),(913,3133),(914,3134),(914,3135),(914,3136),(914,3137),(915,3138),(915,3139),(915,3140),(915,3141),(915,3142),(915,3143),(915,1654),(916,3144),(917,3145),(918,3146),(918,3147),(918,3148),(918,3149),(919,3150),(919,3151),(920,3152),(920,3153),(920,3154),(920,3155),(920,3156),(921,3157),(921,3158),(921,3159),(922,3160),(922,3161),(922,3162),(923,3163),(923,3164),(923,3165),(923,3166),(923,3167),(924,3168),(925,3169),(925,3170),(926,3171),(926,1679),(927,1344),(927,3172),(927,1342),(928,3173),(928,3174),(928,3175),(928,681),(928,3176),(928,3177),(929,3178),(929,3179),(929,3180),(930,3181),(930,2248),(930,947),(931,3182),(931,3183),(931,3184),(931,3185),(932,466),(932,3186),(932,3187),(932,3188),(932,3189),(933,3190),(933,3191),(934,3192),(934,3126),(934,3193),(934,3194),(934,3195),(935,3196),(935,3197),(935,3198),(936,3199),(936,3200),(936,3201),(937,3202),(938,3203),(938,3204),(939,3205),(939,3206),(939,3207),(939,3208),(940,3209),(940,3210),(940,1504),(940,392),(940,3211),(941,3212),(941,3213),(941,3214),(941,3215),(941,3216),(942,3217),(942,3218),(942,3219),(943,3220),(943,3221),(943,3222),(944,3223),(944,3224),(944,3225),(944,3226),(944,3227),(945,1899),(945,3228),(945,1920),(946,3229),(946,3230),(946,3231),(946,3232),(947,3233),(947,3234),(947,3235),(947,3236),(948,3237),(948,3238),(948,3239),(949,3240),(949,3241),(949,3242),(949,3243),(949,587),(950,3244),(950,3245),(950,3246),(950,3247),(951,3248),(951,3210),(951,3249),(951,3211),(952,3250),(952,3251),(952,3252),(952,3253),(953,3254),(953,3255),(953,3256),(954,3257),(954,3258),(954,3259),(954,3260),(954,3261),(955,3262),(955,3263),(955,3264),(956,3265),(956,3266),(957,3267),(957,3268),(957,3269),(957,3270),(957,3271),(957,3272),(958,3273),(958,3274),(958,3275),(958,3276),(958,3277),(959,3278),(959,3279),(959,3201),(960,3280),(960,3281),(960,3282),(960,3283),(961,3284),(961,3285),(961,3286),(961,3287),(962,3288),(962,3289),(962,1128),(963,3290),(963,3291),(963,3292),(963,3293),(963,3294),(964,3295),(964,3296),(964,3297),(965,3298),(965,3299),(966,3182),(966,3183),(966,3300),(966,3301),(967,3302),(967,3303),(967,3304),(967,3305),(967,3306),(968,3307),(968,3308),(968,2937),(968,3309),(969,3310),(969,3311),(970,3312),(970,3313),(970,3314),(970,3315),(970,3316),(971,3317),(971,3318),(971,3319),(971,3320),(972,3321),(972,3322),(972,3322),(972,3323),(973,3324),(973,3325),(973,3326),(973,3327),(974,3328),(974,3266),(975,3329),(975,3330),(975,3331),(976,3332),(976,3333),(976,3334),(977,3335),(977,3336),(977,3337),(977,3338),(977,3339),(977,3340),(978,3341),(978,3342),(978,3343),(978,3344),(979,3345),(979,3346),(979,3347),(980,3112),(980,3113),(980,3114),(981,3348),(981,3349),(981,3350),(982,3351),(982,3352),(983,3353),(983,3354),(984,3355),(984,3356),(984,3357),(984,3358),(985,3359),(985,1514),(985,2504),(985,1515),(986,3360),(986,3361),(986,3362),(986,3363),(987,3364),(987,3365),(987,3366),(988,3367),(988,3368),(988,3369),(989,3370),(989,3371),(989,3372),(990,3373),(990,3374),(990,3375),(990,3376),(990,3377),(990,3378),(990,3379),(991,3380),(991,3381),(991,3382),(991,3383),(992,3384),(992,3385),(992,3386),(992,3387),(992,3388),(992,3389),(992,3390),(992,3391),(993,3392),(993,3393),(994,3394),(994,3395),(994,3396),(994,3397),(995,3398),(995,3399),(995,3400),(995,3401),(995,3402),(995,3403),(996,3404),(996,3405),(996,3406),(996,3407),(996,3408),(997,3409),(997,3410),(997,3411),(997,3412),(997,3413),(997,3408),(998,3414),(998,3415),(998,3416),(998,3417),(999,3418),(999,3419),(999,3420),(999,3421),(999,3422),(999,3423),(1000,3424),(1000,3425),(1000,3426),(1001,3427),(1001,3428),(1001,3429),(1002,3430),(1002,3431),(1002,3432),(1003,3433),(1003,3434),(1003,3435),(1003,3436),(1004,3437),(1004,3438),(1005,3439),(1005,3440),(1005,3441),(1005,3442),(1005,3443),(1005,3444),(1005,3445),(1005,3446),(1006,3447),(1006,3448),(1006,3449),(1006,3450),(1006,3451),(1007,3452),(1007,3453),(1007,3454),(1008,3455),(1008,3456),(1008,3457),(1008,3458),(1008,3459),(1008,3460),(1008,3461),(1008,3462),(1008,3463),(1008,3464),(1009,3465),(1009,3466),(1009,3467),(1009,3468),(1009,3469),(1009,3470),(1009,3471),(1009,3472),(1009,3473),(1009,2788),(1010,3474),(1010,3475),(1010,3476),(1011,3477),(1011,3126),(1011,3478),(1011,3479),(1011,3480),(1012,3481),(1012,3482),(1012,3483),(1012,3484),(1012,3485),(1012,3486),(1013,3487),(1013,3488),(1013,3489),(1013,3490),(1014,3491),(1014,3492),(1014,3493),(1014,3494),(1014,3495),(1014,3496),(1015,3497),(1015,3498),(1015,3499),(1015,3500),(1016,3456),(1016,3463),(1016,3501),(1017,3502),(1017,3503),(1018,3504),(1018,3505),(1018,3506),(1019,3507),(1019,3508),(1019,3509),(1019,3510),(1020,3511),(1020,3512),(1020,3513),(1021,854),(1021,3514),(1022,3515),(1022,3516),(1022,3517),(1023,3518),(1023,3519),(1023,3520),(1023,3521),(1023,3522),(1023,3445),(1024,3523),(1024,3524),(1024,3525),(1024,3526),(1024,3527),(1025,3528),(1025,3529),(1025,3530),(1025,3531),(1026,142),(1026,143),(1027,3532),(1027,3533),(1027,3534),(1028,3535),(1028,3536),(1028,3537),(1028,3538),(1028,3539),(1028,3540),(1028,3541),(1029,3542),(1029,3543),(1029,3544),(1029,3545),(1029,3546),(1029,3547),(1029,3548),(1029,3549),(1029,3550),(1030,3551),(1030,3552),(1031,3553),(1031,3554),(1031,3555),(1031,3556),(1032,3557),(1032,3558),(1032,3559),(1032,3560),(1032,3561),(1032,3562),(1033,3563),(1033,3564),(1033,3565),(1033,3566),(1034,3567),(1034,3568),(1035,3569),(1035,1176),(1035,3570),(1036,3571),(1036,3572),(1036,3573),(1036,3574),(1036,3575),(1037,3576),(1037,3577),(1038,3578),(1038,2175),(1038,3579),(1038,2176),(1038,2179),(1039,3580),(1039,3581),(1039,3582),(1039,3583),(1039,3584),(1039,3235),(1040,3585),(1040,3586),(1040,3587),(1040,3588),(1040,3589),(1040,2314),(1041,635),(1041,3590),(1041,636),(1041,3591),(1042,3592),(1042,3593),(1043,3594),(1043,3595),(1044,3596),(1044,3597),(1044,3598),(1044,3599),(1045,3600),(1045,3601),(1045,3602),(1045,3603),(1045,3604),(1046,3605),(1046,3606),(1046,3607),(1046,3608),(1047,3609),(1047,1758),(1047,1841),(1047,3610),(1047,1759),(1047,3611),(1048,3612),(1048,3613),(1049,3614),(1049,3615),(1049,3616),(1050,3617),(1050,3618),(1051,3619),(1051,3620),(1051,3621),(1051,3622),(1051,3623),(1051,3624),(1052,3625),(1052,3626),(1052,3627),(1052,3628),(1052,3629),(1052,3630),(1053,3631),(1053,3632),(1053,1497),(1053,3633),(1054,3634),(1054,520),(1054,3635),(1054,3636),(1054,3637),(1054,521),(1055,3638),(1055,3639),(1055,3421),(1055,3640),(1055,3641),(1056,3642),(1057,3643),(1057,3644),(1057,3645),(1057,3646),(1057,3647),(1058,3648),(1058,3649),(1058,3650),(1058,3651),(1058,3652),(1059,3195),(1059,3126),(1059,3653),(1059,3654),(1059,3655),(1059,3656),(1060,3657),(1060,3658),(1060,3659),(1061,3660),(1062,900),(1062,902),(1062,903),(1062,904),(1063,1801),(1063,3661),(1063,548),(1063,104),(1063,553),(1063,1567),(1064,3662),(1064,3663),(1065,3664),(1065,3665),(1065,3666),(1066,3667),(1066,3668),(1066,3669),(1066,3670),(1066,3671),(1066,3672),(1067,3673),(1067,3674),(1067,3675),(1068,3676),(1068,3677),(1068,3678),(1068,3679),(1068,3680),(1068,3681),(1069,3682),(1070,3683),(1070,3684),(1070,3685),(1070,3148),(1070,3686),(1070,3687),(1071,3688),(1071,3689),(1071,3690),(1072,3691),(1072,3692),(1072,3693),(1072,3694),(1073,3695),(1073,3696),(1074,3697),(1074,3698),(1074,3699),(1074,3700),(1074,3701),(1074,3702),(1075,3703),(1076,3704),(1076,3705),(1076,3706),(1076,3707),(1076,3708),(1077,3709),(1078,3710),(1078,3711),(1078,3712),(1079,2726),(1079,1177),(1079,1176),(1080,3713),(1080,3714),(1081,3715),(1081,3716),(1081,3717),(1082,3718),(1082,3719),(1082,3720),(1082,3721),(1083,3722),(1083,1504),(1083,392),(1083,3723),(1083,3724),(1083,3725),(1084,3726),(1084,3362),(1084,3727),(1085,3728),(1085,3729),(1085,3730),(1085,3731),(1085,3732),(1086,3733),(1086,3734),(1086,3735),(1086,3736),(1086,3737),(1087,3738),(1087,3739),(1087,3740),(1088,3741),(1088,3742),(1088,3743),(1088,3744),(1088,3745),(1089,3746),(1089,3747),(1089,3748),(1089,3749),(1090,3750),(1090,3620),(1090,3126),(1090,3751),(1090,3752),(1090,3624),(1091,3753),(1091,3754),(1091,3755),(1091,3756),(1091,3757),(1091,3758),(1092,3759),(1092,3760),(1092,3761),(1093,3762),(1093,3763),(1093,3764),(1094,3765),(1094,3766),(1094,3767),(1095,2106),(1095,2724),(1095,2723),(1095,2724),(1096,3768),(1096,3769),(1096,3770),(1096,3771),(1097,3772),(1097,3773),(1097,3774),(1098,3775),(1098,3776),(1099,3777),(1099,3778),(1100,3779),(1100,3780),(1100,3781),(1100,3782),(1100,3783),(1100,3784),(1101,3785),(1101,3786),(1101,3787),(1101,3788),(1102,3789),(1102,3790),(1102,3791),(1102,3792),(1102,3793),(1102,3794),(1102,3795),(1103,3796),(1103,3797),(1103,3798),(1103,3799),(1104,3800),(1104,3227),(1105,3801),(1105,3802),(1105,3803),(1106,3804),(1106,3805),(1106,3806),(1107,3807),(1107,3126),(1107,79),(1107,3808),(1108,3809),(1108,3810),(1108,3811),(1109,3812),(1109,3813),(1109,3814),(1110,3815),(1110,3816),(1110,3817),(1111,3818),(1111,3819),(1111,1117),(1111,1120),(1111,3820),(1112,3821),(1112,3822),(1112,2284),(1112,3823),(1113,3824),(1113,3825),(1114,3826),(1114,3131),(1114,3756),(1114,3827),(1114,3828),(1115,3829),(1115,3830),(1115,3831),(1115,3832),(1116,3833),(1116,3834),(1117,3835),(1117,3836),(1117,3837),(1117,3838),(1117,3839),(1118,3840),(1118,3841),(1118,3131),(1118,3842),(1118,169),(1119,3843),(1119,3844),(1119,3646),(1119,3845),(1120,3846),(1120,3847),(1120,3848),(1120,3849),(1121,3850),(1121,3851),(1121,3852),(1121,3853),(1121,3854),(1122,3855),(1122,3856),(1122,3857),(1122,3858),(1122,3859),(1122,3860),(1122,3861),(1123,3862),(1123,3863),(1123,3864),(1123,3865),(1123,3866),(1123,3867),(1123,3868),(1123,3869),(1124,3870),(1124,3871),(1124,3872),(1125,3873),(1125,3874),(1125,3875),(1126,3876),(1126,3877),(1126,3272),(1126,3878),(1126,3879),(1126,3880),(1127,3881),(1127,3882),(1128,2724),(1128,2723),(1128,2722),(1128,2724),(1129,3883),(1129,3884),(1129,3885),(1129,3886),(1130,3887),(1130,3888),(1130,1386),(1130,3616),(1131,3889),(1131,3890),(1131,3774),(1132,1519),(1132,3891),(1132,1521),(1133,3892),(1133,3893),(1133,3894),(1133,3895),(1133,3896),(1134,3897),(1134,3898),(1134,3899),(1134,3900),(1134,3901),(1134,3902),(1134,3903),(1134,3904),(1134,3905),(1135,3906),(1135,3126),(1135,3907),(1135,79),(1135,3908),(1135,3909),(1136,3910),(1136,3337),(1137,3911),(1137,3912),(1137,3913),(1138,3914),(1138,3915),(1138,3916),(1139,3917),(1139,3918),(1139,3919),(1139,3920),(1140,3921),(1140,3922),(1140,3923),(1140,3924),(1140,3925),(1141,3926),(1141,3927),(1141,3928),(1141,3929),(1141,3930),(1142,3931),(1142,3932),(1143,3933),(1143,3934),(1143,3935),(1143,3936),(1144,3937),(1144,3603),(1144,3938),(1144,3939),(1144,3940),(1144,3941),(1144,3942),(1144,3943),(1144,3944),(1144,3945),(1145,3946),(1145,664),(1145,3947),(1145,3948),(1145,3949),(1145,2476),(1146,3950),(1146,3951),(1146,3952),(1146,3953),(1146,3954),(1147,3955),(1147,3956),(1147,2324),(1148,3957),(1148,3958),(1148,3959),(1148,3490),(1149,3960),(1149,3961),(1149,3962),(1149,3963),(1149,3964),(1149,3965),(1149,3966),(1149,3967),(1149,3968),(1149,3969),(1149,3970),(1150,3971),(1150,3972),(1151,3973),(1152,3974),(1152,3975),(1152,3976),(1152,3977),(1153,3978),(1153,3979),(1153,3980),(1154,3518),(1154,3981),(1154,3520),(1154,3521),(1154,3982),(1154,3983),(1155,3984),(1155,3985),(1155,902),(1155,3986),(1155,903),(1156,3987),(1156,3988),(1157,3989),(1157,3990),(1157,3991),(1157,3992),(1158,3993),(1158,3994),(1158,3995),(1159,3996),(1159,3997),(1159,3998),(1159,3595),(1159,3999),(1160,855),(1160,4000),(1160,328),(1160,331),(1161,4001),(1161,2937),(1161,4002),(1162,4003),(1163,4004),(1163,4005),(1163,4006),(1163,4007),(1163,4008),(1164,4009),(1164,3714),(1164,4010),(1164,4011),(1165,4012),(1165,4013),(1165,545),(1166,4014),(1166,4015),(1166,4016),(1166,4017),(1167,4018),(1167,4019),(1168,4020),(1168,4021),(1168,4022),(1168,3849),(1169,4023),(1169,4024),(1169,4025),(1170,4026),(1170,4027),(1170,4028),(1170,4029),(1170,4030),(1171,4031),(1171,4032),(1172,4033),(1172,1626),(1172,1388),(1172,4034),(1172,3611),(1173,3437),(1173,4035),(1173,3438),(1174,4036),(1174,3226),(1175,4037),(1175,4038),(1175,4039),(1175,4040),(1175,4041),(1176,4042),(1176,4043),(1176,4044),(1176,4045),(1177,578),(1177,2104),(1177,580),(1178,4046),(1178,4047),(1179,3353),(1179,4048),(1180,4049),(1180,4050),(1180,4051),(1180,4052),(1181,4053),(1181,4054),(1181,4055),(1182,4056),(1182,4057),(1182,4058),(1182,4059),(1183,4060),(1183,4061),(1183,4062),(1184,4063),(1185,4064),(1185,4065),(1185,43),(1185,46),(1185,3766),(1185,4066),(1186,4067),(1186,2040),(1187,4068),(1187,4069),(1187,4070),(1187,4071),(1187,4072),(1187,4073),(1188,4074),(1188,4075),(1188,4076),(1189,4077),(1189,4078),(1189,4079),(1189,4080),(1190,4081),(1190,4082),(1190,4083),(1191,4084),(1191,4085),(1191,4086),(1191,4087),(1191,4088),(1191,4089),(1192,4090),(1192,4091),(1193,2248),(1193,4092),(1193,4093),(1193,2249),(1194,4094),(1194,4095),(1194,4096),(1195,4097),(1195,4098),(1195,4099),(1196,4100),(1197,4101),(1197,4102),(1197,4103),(1197,4104),(1198,4105),(1198,4106),(1198,4107),(1199,4108),(1200,4109),(1201,4110),(1202,4111),(1203,4112),(1203,4113),(1204,4114),(1205,4115),(1206,4116),(1207,4117),(1208,4118),(1208,4119),(1209,4120),(1209,4121),(1209,4122),(1210,4112),(1210,4123),(1211,4124),(1211,4125),(1211,4126),(1211,3275),(1212,4127),(1212,4128),(1212,4129),(1212,4130),(1213,4131),(1213,4132),(1213,4133),(1214,4134),(1214,4135),(1214,4136),(1214,3214),(1215,4137),(1215,4138),(1215,4139),(1216,4140),(1216,4141),(1216,4142),(1216,4143),(1217,4144),(1217,4145),(1217,4146),(1217,4147),(1217,4148),(1218,4149),(1218,4150),(1218,4151),(1218,3126),(1218,4152),(1218,4153),(1218,4154),(1219,676),(1219,4155),(1219,677),(1220,4156),(1220,4157),(1220,4158),(1220,4159),(1220,4160),(1221,4161),(1221,4162),(1222,4163),(1222,4164),(1222,4165),(1223,4166),(1223,4167),(1223,4168),(1223,4169),(1223,4170),(1224,4171),(1224,4172),(1224,4173),(1224,4174),(1224,4175),(1224,4176),(1224,4177),(1225,4178),(1225,4179),(1226,4180),(1226,4181),(1226,4182),(1226,4183),(1227,4127),(1227,4129),(1227,4184),(1228,4185),(1228,4186),(1228,4187),(1228,4188),(1229,4189),(1229,4190),(1229,3174),(1229,4191),(1229,3177),(1229,4192),(1229,3176),(1230,4193),(1230,4194),(1231,4195),(1231,4196),(1231,4197),(1231,4198),(1232,4199),(1232,4200),(1232,4201),(1232,4202),(1232,4203),(1232,4204),(1233,4205),(1233,4206),(1233,4207),(1233,4208),(1233,4209),(1234,3505),(1234,4210),(1234,3506),(1234,3504),(1235,4211),(1235,4212),(1235,4213),(1235,4214),(1235,4215),(1235,4216),(1236,4217),(1236,4218),(1236,4219),(1236,4220),(1237,4221),(1237,4222),(1237,4223),(1238,4224),(1238,4225),(1239,4226),(1239,4227),(1239,4228),(1239,4229),(1240,4230),(1240,4231),(1241,4232),(1241,4233),(1241,4234),(1242,4235),(1242,4236),(1242,4237),(1242,4238),(1243,4239),(1243,4240),(1243,4241),(1243,4242),(1244,4243),(1244,4244),(1244,4245),(1244,4246),(1245,4247),(1245,4248),(1245,4249),(1246,4250),(1246,4251),(1246,4181),(1246,4252),(1247,4253),(1247,4254),(1247,4255),(1247,4256),(1248,4257),(1248,4258),(1248,4259),(1249,4260),(1249,4261),(1250,4262),(1250,4263),(1250,4264),(1251,4265),(1252,4266),(1252,4267),(1253,4268),(1253,4269),(1253,4270),(1253,4271),(1254,4272),(1254,4273),(1254,4274),(1255,4275),(1255,4276),(1255,4277),(1255,4278),(1256,4279),(1256,4280),(1256,4281),(1256,4282),(1256,4283),(1256,4284),(1256,4285),(1257,3713),(1257,3714),(1258,3557),(1258,3558),(1258,3559),(1258,3560),(1259,4286),(1260,3424),(1260,4287),(1260,4288),(1260,4289),(1260,3426),(1261,4290),(1261,4291),(1261,4292),(1261,4293),(1262,4294),(1262,4295),(1263,4296),(1263,4297),(1263,4298),(1263,4299),(1263,4300),(1264,4301),(1264,4302),(1264,4303),(1265,4304),(1265,4305),(1265,4306),(1265,4307),(1266,4308),(1266,4309),(1266,4139),(1267,4310),(1267,4311),(1267,4312),(1267,4313),(1268,4314),(1268,4315),(1269,4316),(1269,4317),(1269,4318),(1269,4319),(1270,4320),(1270,4321),(1271,4322),(1271,4323),(1271,4324),(1271,4186),(1271,4325),(1271,4188),(1272,4326),(1272,4327),(1272,4328),(1272,4329),(1272,4330),(1273,4331),(1273,4142),(1274,4135),(1274,4332),(1274,4333),(1274,4334),(1275,4335),(1275,4118),(1275,4119),(1275,4020),(1276,4336),(1276,4337),(1276,4338),(1276,4339),(1277,4340),(1277,3425),(1277,4341),(1277,3426),(1277,4342),(1278,4343),(1278,4344),(1278,4345),(1278,4345),(1279,4346),(1279,4347),(1279,4348),(1279,4349),(1279,4350),(1280,4351),(1280,4352),(1280,4353),(1281,4354),(1281,4355),(1281,4356),(1282,4357),(1283,4358),(1283,4359),(1283,3562),(1283,4358),(1283,3559),(1283,3560),(1284,4360),(1284,4361),(1284,4362),(1284,4363),(1284,4364),(1285,4365),(1285,4366),(1285,4209),(1286,4020),(1286,4367),(1286,4119),(1286,4368),(1286,4335),(1286,4369),(1287,4370),(1287,4371),(1287,4372),(1288,4373),(1288,4374),(1288,4375),(1288,4376),(1289,4377),(1289,4378),(1289,3756),(1289,4379),(1289,4380),(1290,4381),(1290,4382),(1290,4383),(1290,4384),(1290,4385),(1291,4386),(1291,4387),(1291,4388),(1292,4389),(1292,4390),(1293,4391),(1293,4392),(1294,4393),(1294,4394),(1294,4395),(1294,4396),(1294,4397),(1295,4398),(1295,4399),(1295,4400),(1295,4401),(1295,4402),(1295,4403),(1295,4404),(1295,4398),(1296,4405),(1296,4406),(1296,4407),(1296,4408),(1297,4409),(1297,4410),(1297,4411);
/*!40000 ALTER TABLE `article_to_author` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article_to_keyword`
--

DROP TABLE IF EXISTS `article_to_keyword`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `article_to_keyword` (
  `doc_id` int(11) NOT NULL,
  `keyword_id` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article_to_keyword`
--

LOCK TABLES `article_to_keyword` WRITE;
/*!40000 ALTER TABLE `article_to_keyword` DISABLE KEYS */;
INSERT INTO `article_to_keyword` VALUES (1,1),(1,2),(1,3),(1,4),(2,5),(2,6),(3,7),(4,8),(4,9),(4,10),(5,11),(5,12),(5,13),(6,14),(6,15),(6,16),(8,9),(8,17),(8,18),(9,19),(9,20),(9,21),(10,20),(10,22),(10,23),(11,24),(11,25),(11,26),(11,27),(12,28),(12,29),(12,16),(12,30),(13,31),(14,32),(14,33),(14,16),(14,34),(14,35),(15,26),(15,17),(15,36),(16,15),(16,37),(16,38),(17,39),(17,40),(17,41),(17,42),(18,43),(19,44),(19,45),(20,46),(20,47),(20,48),(21,49),(21,50),(21,51),(21,19),(21,45),(22,52),(22,53),(22,2),(22,54),(23,55),(23,56),(23,57),(23,58),(23,59),(23,60),(25,6),(25,61),(25,62),(25,63),(26,19),(26,64),(26,65),(27,15),(27,66),(27,67),(28,68),(28,69),(28,70),(29,71),(29,45),(30,72),(30,6),(31,73),(31,48),(31,74),(32,75),(32,76),(32,77),(33,78),(33,79),(33,80),(33,81),(33,82),(33,83),(33,84),(33,85),(34,86),(34,87),(35,88),(36,89),(36,90),(36,91),(36,92),(37,93),(38,94),(39,95),(39,34),(39,96),(39,97),(40,98),(40,99),(40,100),(40,101),(41,102),(42,103),(42,104),(42,105),(42,106),(42,107),(42,108),(42,109),(42,110),(42,111),(43,112),(43,113),(43,114),(43,115),(44,116),(45,117),(45,68),(45,118),(45,119),(46,120),(46,121),(46,122),(46,45),(47,123),(47,86),(47,124),(47,125),(48,126),(48,127),(48,128),(48,129),(49,130),(49,131),(50,132),(50,133),(50,134),(50,135),(51,24),(51,136),(51,137),(51,9),(52,138),(52,139),(52,140),(53,141),(53,142),(53,143),(53,144),(53,145),(54,146),(54,147),(54,133),(55,148),(55,149),(55,150),(55,151),(56,152),(56,153),(56,154),(57,155),(57,19),(57,156),(58,157),(58,158),(58,159),(59,160),(59,161),(59,162),(59,163),(59,62),(60,164),(60,165),(60,166),(60,167),(60,9),(60,74),(61,168),(61,156),(61,169),(61,170),(61,171),(61,172),(63,19),(63,48),(63,173),(64,174),(64,175),(64,176),(64,30),(64,177),(65,178),(65,179),(65,180),(65,181),(66,182),(66,183),(66,184),(66,185),(67,186),(67,187),(67,6),(67,188),(67,189),(68,190),(68,191),(69,192),(69,193),(69,194),(70,195),(70,196),(70,197),(71,9),(71,198),(71,199),(71,200),(71,201),(71,202),(72,203),(72,204),(72,205),(72,206),(73,207),(73,208),(73,86),(73,165),(74,209),(74,163),(74,210),(75,211),(75,62),(75,41),(77,212),(78,213),(78,120),(78,214),(79,215),(79,216),(79,217),(79,218),(79,219),(79,220),(79,221),(79,222),(80,52),(80,54),(80,223),(80,224),(80,225),(80,2),(80,226),(81,227),(81,228),(83,229),(83,230),(83,231),(83,232),(83,233),(84,92),(84,234),(84,235),(85,236),(86,26),(86,237),(86,238),(87,239),(87,240),(87,241),(88,242),(88,243),(88,244),(88,39),(89,245),(89,246),(89,247),(91,248),(91,249),(91,250),(92,251),(92,252),(92,154),(92,253),(92,254),(94,255),(96,256),(97,257),(97,258),(97,259),(98,260),(98,15),(98,156),(99,261),(99,262),(99,149),(99,263),(100,264),(100,265),(100,266),(100,267),(101,268),(101,269),(101,270),(101,271),(101,45),(101,272),(101,273),(102,230),(102,274),(102,275),(102,276),(102,277),(104,278),(104,279),(104,280),(104,34),(104,37),(105,281),(105,282),(106,283),(107,284),(107,285),(107,286),(108,287),(108,288),(108,20),(108,289),(108,290),(109,15),(109,34),(109,291),(110,292),(110,293),(110,294),(110,295),(111,296),(111,297),(111,298),(111,16),(112,299),(113,165),(113,300),(114,301),(114,302),(114,303),(115,16),(115,304),(115,165),(116,284),(116,305),(116,306),(116,307),(117,16),(117,308),(117,309),(117,310),(118,20),(118,311),(118,312),(118,313),(118,39),(120,314),(120,315),(120,316),(120,317),(120,318),(120,319),(122,34),(122,313),(122,320),(123,321),(124,322),(124,323),(124,324),(124,325),(124,326),(124,327),(125,328),(125,329),(125,330),(126,331),(126,332),(126,333),(128,334),(128,335),(128,336),(128,337),(129,338),(130,339),(130,340),(130,341),(130,342),(131,9),(131,343),(131,344),(131,345),(132,329),(132,346),(132,272),(132,347),(132,348),(133,349),(133,350),(133,351),(133,352),(134,353),(135,354),(135,184),(135,53),(136,355),(136,356),(136,357),(137,358),(138,92),(138,359),(138,360),(139,361),(139,362),(139,363),(139,364),(139,365),(139,175),(139,366),(139,37),(139,367),(139,368),(139,369),(139,370),(140,371),(140,145),(140,372),(140,373),(141,374),(141,375),(141,376),(141,377),(143,378),(144,6),(144,379),(145,380),(145,381),(146,382),(146,383),(146,384),(146,385),(147,92),(147,370),(147,386),(147,387),(148,388),(149,389),(149,390),(149,391),(149,392),(150,393),(150,394),(150,395),(150,396),(151,92),(151,19),(151,397),(151,398),(151,399),(151,400),(152,401),(152,402),(152,403),(152,16),(152,404),(153,20),(153,133),(153,405),(153,406),(153,407),(154,292),(154,408),(154,156),(154,409),(155,410),(156,370),(156,411),(156,19),(156,412),(156,45),(157,413),(157,414),(157,364),(157,415),(157,416),(157,417),(157,418),(157,419),(158,420),(159,421),(160,422),(160,45),(160,423),(161,195),(161,424),(161,163),(161,19),(162,425),(162,426),(162,427),(163,192),(163,428),(163,429),(164,430),(164,431),(164,432),(164,433),(165,434),(165,435),(165,89),(166,436),(166,121),(166,437),(166,438),(166,439),(166,440),(167,441),(167,442),(167,443),(167,444),(168,445),(168,446),(168,447),(169,448),(169,366),(169,449),(170,6),(170,39),(170,450),(170,451),(170,452),(171,453),(171,454),(171,455),(171,456),(171,457),(172,458),(173,459),(173,460),(173,461),(173,462),(173,463),(173,464),(174,6),(174,465),(174,466),(174,467),(174,468),(174,469),(174,2),(174,470),(174,471),(174,472),(174,473),(174,184),(174,474),(174,452),(174,406),(174,475),(174,476),(174,477),(174,478),(174,479),(174,480),(174,481),(174,482),(174,483),(174,218),(174,484),(174,485),(174,486),(175,207),(175,487),(175,418),(176,488),(177,489),(177,490),(177,491),(177,16),(178,492),(178,493),(178,90),(178,290),(179,30),(179,494),(179,148),(179,495),(179,301),(182,496),(182,497),(182,498),(182,499),(182,500),(183,501),(183,414),(183,364),(183,502),(184,503),(184,16),(184,504),(184,25),(185,505),(185,6),(187,506),(187,6),(187,507),(189,45),(189,508),(189,509),(189,510),(189,511),(190,512),(190,178),(190,62),(191,19),(191,513),(191,36),(191,514),(192,515),(192,516),(192,517),(195,518),(195,363),(195,89),(195,519),(197,520),(197,521),(197,48),(197,522),(199,523),(199,16),(199,391),(199,524),(202,525),(202,15),(202,526),(202,527),(203,528),(203,152),(203,529),(203,530),(205,219),(205,391),(205,531),(206,532),(206,533),(206,534),(206,535),(210,536),(210,537),(210,538),(210,539),(212,540),(212,541),(212,542),(212,543),(213,544),(213,437),(213,62),(213,504),(214,545),(214,546),(214,547),(214,548),(216,549),(216,550),(216,504),(218,551),(218,306),(218,552),(219,553),(219,554),(219,163),(221,555),(221,556),(221,557),(221,558),(221,559),(221,560),(221,561),(221,562),(221,563),(221,564),(221,565),(221,566),(224,567),(224,568),(224,569),(226,570),(226,571),(226,572),(227,573),(227,574),(227,575),(228,576),(228,577),(230,578),(230,579),(230,580),(230,39),(232,414),(232,9),(232,581),(234,582),(234,583),(234,584),(234,585),(234,586),(240,6),(240,587),(240,588),(241,589),(241,590),(241,591),(241,592),(242,593),(242,594),(243,28),(243,595),(243,577),(243,596),(243,597),(247,6),(247,598),(247,599),(247,600),(247,601),(247,602),(248,603),(248,156),(248,604),(248,605),(248,606),(248,607),(248,608),(251,562),(251,6),(251,609),(252,610),(252,156),(255,611),(255,612),(255,613),(255,614),(255,615),(255,616),(256,617),(256,41),(257,618),(257,37),(257,140),(259,619),(259,620),(259,621),(260,622),(260,623),(260,624),(262,625),(262,626),(262,627),(262,628),(263,629),(263,6),(264,163),(264,630),(265,631),(265,632),(265,633),(265,634),(267,635),(267,9),(267,329),(268,636),(268,637),(268,638),(268,639),(272,640),(272,641),(272,642),(272,643),(273,644),(273,645),(273,646),(273,329),(275,647),(275,648),(275,295),(275,649),(275,650),(275,651),(276,652),(276,653),(276,654),(276,655),(279,191),(279,656),(279,657),(280,658),(280,659),(280,660),(280,661),(280,662),(280,663),(281,364),(281,664),(281,665),(282,6),(282,666),(282,667),(283,209),(283,39),(283,163),(284,668),(284,124),(284,401),(284,669),(284,670),(285,6),(285,671),(285,672),(285,535),(285,166),(285,673),(285,674),(285,675),(290,676),(290,677),(290,678),(290,634),(290,679),(291,680),(293,681),(293,682),(293,683),(293,684),(293,685),(293,686),(293,687),(294,688),(294,689),(294,286),(294,690),(294,691),(294,692),(294,693),(296,584),(296,352),(296,694),(296,314),(296,418),(297,695),(297,696),(298,697),(298,577),(298,698),(298,699),(298,700),(299,701),(299,68),(299,702),(299,703),(299,704),(300,364),(300,705),(300,706),(300,707),(300,41),(300,708),(300,40),(300,709),(301,710),(301,711),(301,712),(301,380),(301,484),(301,713),(304,39),(304,391),(304,714),(304,715),(305,716),(305,717),(305,718),(306,86),(306,20),(306,719),(306,720),(306,721),(307,6),(307,722),(307,723),(307,724),(308,725),(308,726),(308,77),(309,727),(309,414),(309,728),(309,729),(309,730),(309,45),(309,1),(309,2),(310,731),(310,732),(310,733),(311,529),(311,734),(311,735),(311,736),(311,737),(313,37),(313,550),(313,738),(313,739),(315,740),(315,472),(315,741),(315,742),(315,254),(315,743),(316,40),(316,744),(316,745),(317,329),(317,746),(317,86),(318,747),(318,6),(318,748),(318,45),(318,749),(318,750),(318,751),(319,752),(319,753),(319,754),(319,705),(320,55),(320,755),(320,756),(320,757),(320,758),(321,759),(321,760),(321,761),(321,762),(321,122),(322,15),(322,763),(322,764),(323,765),(323,766),(323,767),(323,768),(324,184),(324,769),(324,53),(325,770),(325,541),(325,771),(326,772),(326,773),(326,774),(326,775),(326,776),(327,777),(327,45),(327,39),(328,122),(328,778),(328,779),(329,780),(329,153),(329,781),(329,782),(330,783),(330,784),(330,45),(331,785),(331,786),(331,787),(331,788),(332,34),(332,789),(332,790),(332,791),(333,345),(333,792),(333,632),(333,793),(333,794),(334,705),(334,37),(335,795),(335,541),(335,86),(335,45),(336,796),(336,797),(336,54),(336,798),(336,799),(337,800),(337,801),(337,802),(337,803),(338,414),(338,804),(338,306),(338,222),(339,805),(339,806),(339,807),(339,545),(339,248),(339,808),(339,809),(340,810),(340,811),(340,39),(341,812),(341,813),(341,814),(341,815),(342,329),(342,9),(342,816),(342,817),(342,818),(343,819),(343,412),(343,820),(343,821),(344,822),(344,823),(344,824),(345,329),(345,290),(345,90),(345,825),(345,826),(346,827),(346,75),(346,9),(346,34),(346,828),(346,829),(347,830),(347,80),(348,831),(348,832),(348,833),(348,834),(348,835),(348,836),(348,837),(348,838),(348,254),(348,839),(349,840),(349,222),(349,841),(349,842),(350,422),(350,843),(351,92),(351,160),(351,292),(351,844),(352,845),(352,531),(352,846),(352,530),(352,847),(353,848),(353,849),(353,850),(353,851),(354,45),(354,852),(354,9),(354,19),(355,853),(355,854),(355,133),(356,855),(356,856),(356,857),(356,858),(356,45),(357,92),(357,859),(357,860),(358,861),(358,862),(358,629),(358,863),(359,372),(359,864),(359,145),(359,144),(359,865),(360,866),(360,541),(360,867),(361,868),(361,869),(361,870),(361,871),(361,872),(361,873),(361,460),(361,709),(361,874),(361,875),(362,16),(362,876),(362,148),(363,877),(363,472),(363,878),(363,879),(363,880),(363,881),(364,882),(364,23),(364,883),(365,884),(365,885),(365,886),(365,653),(366,887),(366,888),(366,889),(366,54),(366,890),(366,891),(366,892),(366,893),(367,894),(367,895),(368,777),(368,163),(368,39),(369,422),(369,90),(369,68),(369,896),(370,15),(370,19),(370,897),(370,95),(371,898),(371,899),(371,900),(371,866),(372,901),(372,902),(372,903),(373,904),(373,905),(373,906),(373,907),(374,122),(374,908),(374,909),(375,910),(375,911),(375,912),(375,401),(375,913),(376,496),(376,48),(376,914),(376,915),(376,411),(376,374),(377,916),(377,917),(377,45),(377,918),(377,122),(377,919),(377,920),(378,921),(378,922),(378,923),(378,924),(379,925),(379,926),(379,927),(379,928),(380,929),(380,930),(380,931),(381,932),(381,584),(381,933),(381,934),(381,700),(381,935),(381,936),(381,937),(382,8),(382,938),(382,939),(382,940),(383,941),(383,942),(383,572),(383,943),(384,707),(384,41),(384,62),(384,944),(384,945),(384,946),(384,947),(384,634),(385,329),(385,948),(385,457),(386,122),(386,679),(386,949),(387,950),(387,45),(387,290),(388,148),(388,290),(388,30),(389,951),(389,952),(389,953),(390,954),(390,955),(390,956),(390,957),(390,958),(390,90),(390,959),(391,960),(391,961),(391,962),(392,963),(392,964),(393,965),(393,966),(393,967),(393,226),(393,968),(393,969),(393,970),(394,971),(394,972),(394,86),(394,20),(394,34),(395,973),(395,974),(395,975),(395,976),(396,977),(396,978),(396,979),(396,980),(396,552),(396,981),(398,982),(398,983),(399,984),(399,332),(399,985),(400,986),(400,987),(400,461),(401,988),(401,989),(401,990),(402,991),(402,992),(404,37),(404,6),(404,993),(404,994),(405,40),(405,16),(405,995),(406,15),(406,897),(406,34),(406,95),(407,563),(407,996),(407,997),(407,998),(408,999),(408,1000),(408,1001),(408,472),(409,1002),(409,39),(409,45),(410,62),(410,1003),(410,1004),(410,679),(411,872),(411,1005),(411,1006),(411,1007),(411,663),(412,1008),(412,1009),(412,1010),(412,601),(412,1011),(413,609),(413,1012),(413,1013),(413,1014),(414,1015),(414,6),(414,16),(415,811),(415,1016),(416,1017),(416,1018),(416,264),(416,1019),(416,1020),(418,1021),(418,1022),(419,62),(419,6),(419,1023),(420,323),(420,5),(420,1024),(420,1025),(420,1026),(422,16),(422,1027),(422,1028),(422,1029),(423,1030),(423,55),(423,1031),(423,1032),(424,1033),(424,1034),(424,1035),(425,23),(425,1036),(425,90),(426,1037),(426,1038),(427,1039),(427,1040),(427,1041),(427,15),(427,1042),(427,1043),(428,1044),(428,163),(428,1045),(428,1046),(429,23),(429,1047),(429,1048),(430,1049),(430,1050),(430,1051),(431,1052),(431,1053),(431,1054),(434,1055),(434,1056),(436,1057),(436,1058),(436,1059),(436,19),(436,1060),(438,663),(438,1061),(438,1062),(439,6),(439,1063),(439,1064),(439,1065),(439,1066),(439,1067),(439,1068),(440,1045),(440,1069),(440,1070),(440,1071),(440,156),(442,803),(442,92),(442,1072),(442,647),(442,541),(442,866),(442,798),(445,1073),(445,746),(445,1074),(445,329),(446,1075),(446,1076),(446,1077),(446,1078),(447,695),(447,1079),(447,599),(448,29),(448,841),(448,1080),(448,1081),(449,854),(449,1082),(449,1083),(449,19),(449,1084),(450,1085),(450,1086),(450,1087),(450,1088),(453,1089),(453,1090),(453,1091),(456,472),(456,54),(456,484),(456,1092),(456,1093),(456,482),(456,1094),(456,1095),(457,156),(457,68),(457,16),(458,1096),(458,1097),(458,364),(458,1098),(461,1099),(461,1100),(461,1101),(461,1102),(462,663),(462,1103),(462,1104),(463,1105),(463,1106),(463,65),(463,1107),(464,90),(464,290),(464,156),(464,152),(465,34),(465,19),(466,572),(466,1108),(466,1109),(466,19),(466,86),(467,803),(467,92),(467,594),(467,979),(467,1110),(467,1111),(469,45),(469,1112),(469,1113),(469,1114),(469,1115),(469,1116),(469,1117),(470,523),(470,1118),(470,975),(470,1119),(470,1120),(471,1121),(471,1091),(471,1122),(471,1123),(471,966),(471,1124),(471,1125),(471,1126),(472,364),(472,660),(472,1127),(473,1027),(473,45),(473,682),(473,1128),(474,746),(474,1129),(474,541),(474,1130),(474,1131),(474,1132),(475,95),(475,1133),(475,34),(476,1134),(476,1135),(476,1136),(476,231),(476,1137),(478,1138),(478,6),(478,1139),(478,297),(479,29),(479,553),(479,1140),(480,563),(480,1141),(480,1142),(480,6),(480,1143),(480,1144),(480,1091),(480,1145),(480,1146),(480,1147),(480,1099),(482,231),(482,1148),(482,1149),(484,1150),(484,37),(484,1151),(484,1152),(484,9),(484,198),(484,1153),(486,5),(486,1024),(486,1025),(486,1026),(487,1154),(487,472),(487,1155),(490,1156),(490,1157),(490,550),(490,145),(490,1158),(490,1159),(490,705),(490,1160),(491,663),(491,841),(491,1161),(491,411),(491,1162),(493,364),(493,1163),(493,614),(493,1164),(495,1165),(498,1166),(498,780),(501,105),(501,1167),(501,1168),(501,1169),(501,1170),(502,676),(502,677),(502,678),(502,634),(502,679),(503,1171),(503,1172),(503,1173),(504,36),(504,1174),(504,1175),(507,1176),(507,1062),(507,6),(507,1177),(507,1178),(509,1179),(509,1180),(509,1181),(509,803),(510,1182),(510,1183),(510,1184),(510,1185),(512,1083),(512,26),(512,68),(518,1186),(518,1187),(518,1188),(521,1189),(521,1190),(521,871),(521,168),(522,881),(522,1191),(522,1192),(522,1193),(523,1194),(523,1195),(523,1196),(525,120),(525,1197),(525,6),(530,1198),(530,1199),(530,563),(531,1200),(531,1201),(531,1202),(531,1203),(531,1204),(531,1205),(532,1206),(532,1207),(532,68),(532,1208),(533,535),(533,1209),(533,198),(533,1210),(533,1211),(533,1212),(533,1213),(533,1214),(533,1215),(535,1216),(535,1164),(535,514),(537,1217),(537,1218),(537,541),(537,634),(538,6),(538,782),(538,1219),(538,811),(538,1220),(539,673),(539,1221),(541,663),(541,1222),(541,1223),(541,1224),(541,1225),(544,1226),(544,1227),(545,541),(545,46),(545,879),(546,617),(546,62),(547,6),(547,1228),(547,1091),(549,663),(549,1229),(550,68),(550,231),(550,1230),(550,1231),(550,302),(555,1232),(555,1233),(555,1234),(555,1235),(555,1236),(556,1237),(556,1238),(556,6),(556,1239),(558,1240),(558,663),(558,1241),(559,1242),(559,41),(559,1243),(560,1244),(560,1245),(560,1246),(560,75),(561,1247),(561,1248),(561,1249),(561,1250),(561,1251),(563,1252),(563,1253),(563,149),(564,1254),(564,1255),(564,1256),(564,517),(565,1257),(565,1258),(565,1259),(565,1260),(566,571),(566,314),(566,230),(566,1261),(566,647),(566,1262),(567,16),(567,1263),(567,297),(567,1264),(568,1265),(568,987),(568,41),(569,16),(569,304),(569,1266),(570,29),(570,828),(570,1267),(570,1268),(571,1269),(571,1270),(571,656),(571,370),(572,224),(572,1271),(572,1272),(572,1273),(572,184),(572,1274),(572,1275),(572,1276),(572,1277),(573,90),(573,1278),(573,193),(574,372),(574,6),(574,1238),(575,329),(575,290),(575,140),(576,422),(576,1279),(577,704),(577,1280),(577,1281),(577,1282),(578,1283),(578,292),(578,1284),(579,811),(579,1285),(579,133),(580,136),(580,1286),(580,149),(580,1287),(581,418),(581,275),(581,1288),(581,1164),(581,1289),(582,422),(582,1290),(583,1291),(583,1292),(583,1293),(583,1294),(584,1295),(587,55),(587,1296),(587,1016),(587,1297),(588,1298),(588,811),(588,244),(588,1299),(588,1300),(588,1301),(588,1302),(589,92),(589,1303),(589,1304),(589,1181),(589,24),(589,1305),(590,1306),(590,1307),(590,1235),(590,1308),(590,1309),(590,1310),(591,1311),(591,1312),(591,1313),(591,263),(591,1314),(591,1315),(591,524),(591,598),(591,1316),(592,90),(592,1317),(592,1318),(592,492),(592,1319),(593,155),(593,145),(593,1320),(594,1321),(594,1322),(594,524),(594,1323),(594,16),(594,1324),(595,1306),(595,1325),(595,1326),(595,1327),(595,92),(596,1328),(596,329),(596,1329),(596,122),(597,1330),(597,1331),(597,1332),(597,26),(598,1333),(598,1334),(598,529),(598,1335),(599,1336),(599,1337),(599,292),(600,39),(600,803),(600,92),(601,1338),(601,1339),(601,26),(601,34),(601,86),(601,15),(601,37),(601,1340),(602,1341),(602,329),(603,1342),(603,1343),(603,1344),(603,1345),(603,1346),(603,1347),(604,391),(604,705),(604,1348),(605,1349),(605,1350),(605,1351),(606,1352),(606,1353),(606,1354),(608,1355),(608,1356),(608,1357),(609,1358),(609,1359),(609,1360),(609,39),(609,1361),(610,20),(610,45),(610,1362),(610,1363),(611,30),(611,495),(611,1364),(612,1365),(612,1366),(612,1367),(613,786),(613,1368),(613,222),(614,149),(614,835),(614,834),(614,572),(614,1369),(615,1370),(615,1371),(615,1372),(615,274),(615,492),(616,16),(616,1373),(616,1374),(616,130),(617,36),(617,19),(617,1375),(617,231),(617,1376),(618,1377),(618,1378),(618,1379),(619,239),(619,1380),(619,1381),(619,1382),(620,1383),(620,34),(620,1058),(621,1384),(621,1385),(621,235),(622,15),(622,1386),(622,1024),(625,1387),(625,73),(625,15),(625,1224),(626,1388),(626,1389),(626,1390),(627,133),(627,9),(627,1391),(627,1392),(627,1393),(627,1394),(628,68),(628,19),(628,1395),(629,86),(629,41),(629,9),(629,329),(629,1396),(629,1397),(629,1398),(630,15),(630,1399),(630,1400),(631,1401),(631,1402),(631,1403),(632,15),(632,16),(632,1404),(633,1405),(633,1406),(633,782),(634,1232),(634,401),(634,1407),(635,839),(635,1408),(635,40),(636,45),(636,1409),(636,713),(637,1410),(637,1411),(637,1412),(637,1413),(638,86),(638,20),(638,9),(639,1414),(639,180),(639,1415),(640,9),(640,1416),(640,1417),(640,1418),(641,1419),(641,1420),(641,1421),(641,1422),(642,15),(642,1423),(642,1424),(643,1425),(643,196),(643,195),(643,1426),(643,1427),(643,197),(644,1428),(644,39),(644,1429),(644,1430),(644,1431),(644,1432),(645,1433),(645,1434),(645,1435),(645,1436),(646,314),(646,10),(646,1437),(647,740),(647,133),(647,1438),(648,1439),(648,1440),(648,62),(649,1257),(649,1441),(649,1442),(649,1443),(649,1444),(650,130),(650,552),(650,732),(651,297),(651,1445),(651,2),(651,1446),(652,1447),(652,1448),(652,434),(653,953),(653,1449),(653,1450),(653,1451),(653,1452),(654,740),(654,1453),(654,1454),(655,15),(655,45),(655,37),(655,1455),(655,1456),(656,552),(656,1457),(656,74),(657,1458),(657,1459),(657,619),(657,1315),(659,555),(659,45),(659,2),(660,1000),(660,1460),(660,1001),(660,1461),(660,472),(661,1462),(661,26),(661,1463),(661,1464),(661,1465),(662,418),(662,1466),(662,16),(662,1467),(663,290),(663,1352),(663,1468),(664,1469),(664,1470),(666,811),(666,1471),(666,1472),(666,1473),(666,1474),(666,1475),(667,1476),(667,1477),(668,302),(668,1478),(668,1479),(670,1058),(670,1480),(670,1395),(671,763),(671,979),(671,292),(671,15),(671,96),(672,1481),(672,1482),(672,1483),(672,1484),(673,360),(673,531),(673,1485),(674,1486),(674,9),(675,122),(675,1487),(675,1488),(676,1489),(676,740),(676,1490),(676,1491),(677,1492),(677,1493),(677,928),(677,1494),(677,1495),(678,734),(678,803),(678,821),(679,23),(679,1496),(679,1497),(679,1196),(680,284),(680,1498),(680,1499),(681,329),(681,1500),(681,1501),(681,1502),(681,1503),(682,1504),(682,244),(682,1505),(682,163),(683,1506),(683,1507),(683,156),(683,1508),(685,1311),(685,1509),(685,980),(686,292),(686,1510),(686,1511),(686,1512),(687,90),(687,737),(688,1513),(688,1514),(688,447),(688,1515),(689,975),(689,68),(690,1516),(690,1517),(690,224),(690,184),(691,1518),(691,1519),(691,1520),(691,1521),(691,1522),(691,1523),(694,1524),(694,1525),(694,1526),(695,1527),(695,960),(695,568),(695,184),(695,1528),(695,881),(696,1529),(696,1530),(696,392),(696,198),(696,1531),(697,209),(697,163),(697,1532),(698,1533),(698,1338),(698,1534),(699,132),(699,1535),(699,48),(699,54),(700,1108),(700,140),(700,572),(700,272),(700,1536),(701,1537),(701,1538),(702,541),(702,1539),(702,1540),(703,1541),(703,1338),(703,1542),(703,34),(704,80),(704,706),(704,1543),(705,656),(705,1544),(705,370),(706,304),(706,1545),(706,1546),(707,629),(707,90),(708,329),(708,86),(708,20),(708,29),(708,720),(709,1547),(709,1548),(709,74),(710,1549),(710,422),(710,1550),(711,364),(711,41),(711,617),(712,16),(712,1551),(712,45),(713,222),(713,6),(713,1552),(713,1553),(714,1554),(714,36),(714,1555),(714,1556),(715,1557),(715,1130),(715,329),(717,1558),(717,1559),(717,391),(717,6),(717,634),(718,90),(718,1560),(718,68),(718,1561),(720,19),(720,1294),(720,9),(720,1562),(720,572),(721,288),(721,1563),(721,1564),(721,1565),(721,70),(722,1566),(722,405),(722,1567),(722,1568),(722,1569),(722,1570),(722,1239),(723,19),(723,1571),(723,1572),(723,1560),(723,1573),(724,34),(724,95),(725,467),(725,472),(725,188),(727,496),(727,854),(727,1574),(727,45),(728,1575),(728,1576),(728,1577),(729,1578),(729,16),(729,1579),(729,245),(729,1580),(729,1581),(729,1582),(729,1583),(730,205),(730,1584),(730,1585),(731,1586),(731,92),(731,1587),(732,600),(732,1030),(732,981),(732,1588),(732,9),(734,290),(734,1589),(734,30),(735,1423),(735,1590),(735,177),(735,1591),(736,1592),(736,122),(736,133),(737,16),(737,1593),(737,1594),(737,133),(737,1595),(737,15),(738,133),(738,1596),(738,1597),(738,1151),(739,1598),(740,16),(740,1599),(740,30),(741,1600),(742,1601),(742,1602),(742,1603),(742,1604),(743,1605),(743,1606),(743,1607),(743,1608),(743,1609),(744,1610),(744,1611),(744,19),(745,1612),(746,1613),(747,1614),(747,9),(747,401),(748,331),(748,240),(748,1615),(749,1616),(750,1617),(751,1618),(751,1619),(751,1620),(752,1621),(752,1622),(752,1623),(752,1624),(752,763),(752,1625),(752,1626),(752,1627),(752,1628),(752,1629),(752,1630),(752,1631),(752,1632),(753,1633),(753,1634),(753,1635),(754,1636),(754,1637),(754,1638),(754,329),(754,1639),(754,1640),(755,1641),(756,1642),(757,800),(757,1643),(757,1644),(758,1645),(759,828),(759,1646),(759,1647),(759,1648),(759,1649),(759,1025),(759,1650),(759,1651),(759,1652),(760,1653),(761,1654),(762,5),(762,1655),(762,1255),(762,1656),(763,15),(763,1657),(763,45),(764,86),(764,19),(764,457),(764,405),(764,26),(765,133),(765,30),(766,1329),(766,1658),(766,122),(767,1659),(768,1660),(769,1661),(770,1662),(771,1663),(771,1664),(771,133),(772,1665),(772,1666),(772,1667),(772,1668),(773,1669),(774,1519),(774,1670),(774,1671),(775,34),(775,37),(775,1672),(776,1673),(776,1674),(776,1675),(776,1676),(776,1677),(776,1678),(777,1679),(778,1680),(778,1093),(778,1681),(778,1682),(778,1683),(779,1684),(779,133),(779,1685),(780,36),(780,1555),(781,422),(781,68),(781,1083),(781,1686),(782,1687),(782,1688),(783,1689),(784,1690),(784,1691),(784,1692),(785,1693),(785,1694),(785,68),(785,278),(785,1695),(786,1004),(786,1696),(786,1697),(787,1698),(788,1699),(788,1700),(788,1701),(789,1702),(789,1703),(789,1704),(790,279),(790,1705),(790,1706),(790,1707),(791,1708),(791,1709),(791,16),(791,1710),(793,129),(793,371),(793,1711),(795,90),(795,737),(795,1712),(795,1713),(795,77),(798,1714),(798,1715),(798,1716),(798,1717),(799,20),(799,98),(799,1718),(799,45),(799,1620),(799,1058),(801,549),(801,647),(801,1719),(802,1720),(802,156),(802,1721),(802,1722),(802,1723),(804,1724),(804,1725),(804,629),(804,1726),(805,92),(805,818),(805,1727),(805,1728),(805,306),(805,1729),(809,1730),(809,1116),(809,1731),(809,1732),(810,954),(810,1733),(810,1338),(812,1734),(812,1735),(812,1736),(813,1737),(814,1004),(814,48),(815,1738),(816,803),(816,1739),(816,1740),(817,241),(817,1741),(817,467),(818,1742),(819,1743),(819,1151),(819,1574),(819,1744),(820,1745),(821,1746),(822,1747),(823,791),(823,1263),(823,1748),(824,1749),(824,1750),(824,1751),(825,1001),(825,1752),(825,1753),(826,1754),(826,1755),(826,1756),(826,45),(827,1757),(828,1758),(828,1759),(828,1469),(828,1760),(829,1761),(829,1762),(829,1239),(830,1763),(830,302),(830,1764),(830,1765),(831,1766),(832,1767),(832,55),(832,1768),(832,48),(833,9),(833,19),(833,1769),(833,1770),(833,1771),(833,1772),(834,1773),(834,86),(834,1774),(834,15),(834,1574),(835,1775),(836,68),(836,1776),(837,929),(837,40),(837,432),(837,1777),(838,1778),(839,1779),(839,1130),(839,1395),(839,1780),(839,1253),(840,1781),(840,1782),(840,133),(841,1783),(842,1784),(842,1440),(842,1785),(843,1786),(843,662),(843,1787),(843,1788),(843,1789),(844,1790),(845,1610),(845,1791),(845,1792),(846,297),(846,1793),(846,1794),(846,122),(847,1795),(848,1392),(848,1796),(848,1797),(848,1013),(849,1798),(850,1371),(850,1799),(851,1800),(851,1801),(851,15),(851,9),(851,433),(851,1802),(851,1803),(852,1804),(853,1805),(854,1806),(854,1807),(854,1808),(854,30),(855,1809),(855,1810),(855,1811),(856,1533),(856,1573),(857,34),(857,140),(857,36),(857,1812),(857,1813),(858,1814),(858,1815),(858,1816),(859,1650),(859,16),(859,1329),(860,1817),(860,1650),(861,1818),(862,1819),(862,1820),(862,176),(863,41),(863,16),(863,1821),(863,25),(864,1822),(864,290),(864,1823),(864,89),(865,1253),(865,10),(865,666),(865,859),(866,1824),(866,258),(866,1825),(866,92),(866,1826),(867,36),(867,289),(867,1827),(867,1828),(868,1829),(868,1830),(868,1724),(868,1831),(869,1832),(870,1833),(871,1834),(871,92),(871,41),(872,512),(872,1835),(872,45),(873,1836),(874,1837),(874,1838),(874,1839),(874,1840),(875,1294),(875,1841),(875,1842),(875,1843),(876,422),(876,1844),(876,1845),(877,1846),(877,828),(877,1847),(877,5),(878,1848),(878,1849),(878,1850),(878,1740),(878,1006),(878,1851),(879,454),(879,1852),(879,1853),(879,455),(879,456),(880,92),(880,1854),(880,1328),(880,370),(881,803),(881,1855),(882,951),(882,1856),(882,1857),(883,280),(883,133),(884,1858),(884,155),(884,1859),(884,1860),(885,1861),(885,165),(885,9),(885,1862),(885,48),(885,1863),(886,1864),(887,1865),(887,40),(887,1866),(887,1867),(888,1533),(888,1573),(889,343),(889,1868),(889,1869),(889,1870),(889,1871),(890,1872),(891,36),(891,1873),(891,1874),(891,193),(892,1875),(892,1876),(892,1877),(892,133),(893,1878),(894,1392),(894,1363),(894,1879),(894,329),(894,1880),(894,1881),(895,1882),(896,1883),(896,1884),(897,290),(897,1614),(897,1885),(898,290),(898,1589),(898,30),(899,152),(899,1886),(899,1887),(899,34),(900,1888),(901,1889),(902,1890),(903,1891),(904,1690),(904,1691),(904,1692),(905,1892),(905,1893),(905,1894),(905,275),(906,1895),(906,1896),(906,1897),(906,1898),(906,302),(907,1899),(907,1900),(907,1901),(908,1902),(909,1903),(909,815),(909,845),(909,1803),(909,1904),(911,1338),(915,15),(915,19),(915,1905),(915,1906),(916,1011),(916,1907),(916,811),(917,1908),(917,1909),(917,48),(918,1910),(918,854),(918,231),(918,1911),(922,15),(922,1263),(922,1912),(922,1913),(923,1914),(923,70),(923,1915),(923,1916),(923,1917),(924,1918),(924,1919),(924,599),(925,1920),(925,1921),(925,1922),(926,1923),(926,1924),(927,1530),(927,1291),(927,246),(927,418),(927,1881),(928,617),(928,1925),(928,45),(928,1926),(929,1927),(929,1928),(929,1929),(929,1930),(929,1931),(929,1932),(929,1933),(929,1934),(930,1935),(930,1936),(930,1937),(931,1938),(931,1939),(931,1940),(931,1941),(932,1942),(932,803),(934,1943),(934,1294),(934,244),(934,1224),(934,1944),(935,1945),(935,1946),(935,1938),(937,1947),(937,1948),(937,90),(937,1949),(937,1950),(937,1951),(939,23),(939,1952),(939,1953),(939,1954),(939,329),(939,746),(940,1955),(940,8),(940,205),(942,1956),(942,1957),(942,1958),(942,1959),(946,231),(946,140),(946,238),(946,1382),(946,1960),(946,1961),(952,1962),(952,1963),(952,1964),(952,1965),(952,1720),(952,1966),(954,1967),(954,1968),(956,1969),(956,1970),(956,372),(956,1013),(957,777),(957,1971),(958,1972),(958,1973),(960,1974),(960,1975),(960,1976),(960,1977),(961,1978),(961,34),(961,918),(961,10),(962,1979),(962,1263),(962,1496),(963,1939),(963,1329),(963,1938),(965,1980),(965,746),(965,1981),(966,1982),(966,542),(966,1983),(967,1984),(967,932),(967,1941),(975,1338),(975,1985),(975,1986),(976,1987),(976,1883),(976,297),(976,1988),(976,1989),(976,524),(976,16),(978,45),(978,1990),(978,1991),(979,1561),(979,1992),(979,1993),(979,1994),(979,1995),(979,1996),(980,1903),(980,815),(980,845),(980,1803),(980,1904),(981,422),(981,30),(981,1997),(981,418),(982,1998),(982,1999),(982,2000),(982,2001),(983,371),(983,2002),(983,2003),(983,2004),(983,2005),(985,176),(985,133),(985,928),(985,879),(985,1494),(989,572),(989,2006),(989,513),(989,2007),(989,26),(991,414),(991,605),(991,156),(991,2008),(992,2009),(992,2010),(992,2011),(995,2012),(995,2013),(995,2014),(995,2015),(995,828),(996,610),(996,2016),(996,2017),(996,2018),(998,2019),(998,704),(998,231),(998,2020),(998,2021),(998,2022),(999,2023),(999,2024),(999,2025),(1001,1729),(1001,322),(1001,2026),(1001,1921),(1004,92),(1004,15),(1004,703),(1005,1116),(1005,2027),(1005,2028),(1005,2029),(1005,2030),(1005,2031),(1006,2032),(1006,2033),(1007,2034),(1007,2035),(1007,2036),(1010,740),(1010,2037),(1010,1133),(1010,1623),(1010,2038),(1012,2039),(1012,2040),(1012,19),(1012,2041),(1014,2012),(1014,2013),(1014,2014),(1014,2015),(1014,828),(1017,422),(1017,740),(1017,2042),(1018,2043),(1018,2044),(1018,2045),(1018,2046),(1021,2047),(1021,1338),(1021,2048),(1021,122),(1023,2049),(1023,2050),(1023,19),(1023,86),(1025,2051),(1025,1130),(1025,2052),(1025,15),(1026,988),(1026,140),(1026,2053),(1026,2054),(1027,314),(1027,1261),(1027,2055),(1027,432),(1028,2056),(1028,2057),(1028,2058),(1029,2059),(1029,2060),(1029,2061),(1030,540),(1030,1914),(1030,2062),(1032,152),(1032,1697),(1032,2063),(1033,29),(1033,191),(1033,960),(1033,2064),(1035,2065),(1035,26),(1035,572),(1035,2066),(1035,2067),(1035,20),(1035,77),(1036,15),(1036,2068),(1036,1574),(1036,41),(1037,2069),(1037,2070),(1037,854),(1037,2071),(1038,231),(1038,2072),(1038,2073),(1038,2074),(1039,2075),(1039,2076),(1039,2077),(1040,1826),(1040,1187),(1040,89),(1040,68),(1041,2078),(1041,803),(1042,92),(1042,370),(1042,386),(1042,387),(1042,2079),(1042,818),(1044,1183),(1044,2080),(1044,2081),(1044,800),(1044,1210),(1044,2082),(1047,740),(1047,2083),(1047,2084),(1047,2085),(1049,1338),(1049,2048),(1049,86),(1050,122),(1050,86),(1050,2086),(1050,2087),(1050,2088),(1053,19),(1053,2089),(1053,2090),(1054,15),(1054,763),(1054,19),(1054,2091),(1054,9),(1055,2092),(1055,405),(1055,2093),(1056,1935),(1056,2094),(1056,34),(1056,2085),(1057,19),(1057,1216),(1057,2095),(1057,1604),(1058,140),(1058,36),(1058,1812),(1058,1813),(1060,2096),(1060,240),(1060,26),(1065,2097),(1065,2098),(1065,2099),(1067,2100),(1067,845),(1067,122),(1067,2101),(1070,2102),(1070,2103),(1070,828),(1070,1541),(1070,2104),(1070,2105),(1073,2106),(1073,2107),(1073,90),(1073,2108),(1075,2109),(1075,2110),(1075,2111),(1077,1348),(1077,132),(1077,767),(1077,2112),(1077,48),(1079,90),(1079,737),(1079,1712),(1079,1713),(1079,77),(1080,2037),(1080,2113),(1080,2114),(1080,2115),(1080,2088),(1080,2116),(1082,2117),(1082,2118),(1082,2119),(1082,2120),(1082,2121),(1087,165),(1087,133),(1087,2122),(1087,2123),(1088,364),(1088,568),(1089,2124),(1089,706),(1089,2125),(1089,48),(1091,975),(1091,2126),(1092,2127),(1092,2128),(1092,2129),(1092,2130),(1092,48),(1092,2131),(1093,26),(1093,1382),(1093,20),(1093,2067),(1094,16),(1094,2132),(1094,163),(1095,371),(1095,2133),(1095,1711),(1096,746),(1096,1546),(1098,803),(1098,92),(1098,2134),(1098,2135),(1098,2136),(1099,1861),(1099,2137),(1099,692),(1099,2138),(1099,2139),(1099,2140),(1100,1116),(1100,2141),(1101,2142),(1101,2143),(1101,1085),(1101,1908),(1102,20),(1102,98),(1102,2144),(1102,2145),(1102,45),(1104,2146),(1104,2147),(1104,2148),(1105,1970),(1105,803),(1105,951),(1105,2149),(1106,2150),(1106,48),(1106,2151),(1106,592),(1108,2152),(1108,2153),(1108,932),(1108,323),(1108,2154),(1111,275),(1111,545),(1111,854),(1111,2155),(1112,292),(1112,2156),(1112,2157),(1113,2158),(1113,437),(1113,329),(1113,1139),(1116,1676),(1116,65),(1116,2159),(1116,2160),(1117,2161),(1117,36),(1117,2162),(1117,2163),(1117,2164),(1117,2165),(1119,928),(1119,879),(1119,859),(1120,155),(1120,1703),(1120,2166),(1121,17),(1121,2167),(1121,75),(1121,2168),(1121,2169),(1122,2170),(1122,329),(1122,746),(1122,130),(1122,2171),(1124,20),(1124,2172),(1124,2173),(1126,1337),(1126,1329),(1126,2174),(1126,740),(1127,2175),(1127,2176),(1127,2177),(1128,2178),(1128,1337),(1130,1338),(1130,2179),(1130,2180),(1130,2181),(1133,36),(1133,2182),(1133,86),(1134,2183),(1134,2184),(1134,2185),(1134,2186),(1134,140),(1139,932),(1139,92),(1139,2139),(1140,828),(1140,2187),(1140,701),(1140,2188),(1140,2189),(1140,68),(1140,231),(1141,1496),(1141,2190),(1141,19),(1144,1634),(1144,2191),(1144,2192),(1145,2193),(1145,156),(1145,45),(1146,2194),(1146,2195),(1146,2196),(1146,2197),(1149,839),(1149,574),(1149,230),(1149,1179),(1150,2198),(1150,1029),(1150,2199),(1154,2049),(1154,2050),(1154,1058),(1154,19),(1154,86),(1157,36),(1157,2200),(1157,86),(1162,19),(1162,2201),(1162,2202),(1162,273),(1163,2203),(1163,2204),(1163,2205),(1163,2206),(1164,656),(1164,1676),(1164,584),(1164,2207),(1164,2208),(1164,1568),(1164,1475),(1165,34),(1165,86),(1165,2209),(1165,2210),(1165,332),(1167,2211),(1167,34),(1167,2212),(1168,2213),(1168,2214),(1170,2215),(1170,1505),(1170,2216),(1170,2217),(1171,2218),(1171,2219),(1171,2220),(1171,854),(1172,2221),(1172,2222),(1172,2223),(1172,2224),(1172,2225),(1173,92),(1173,15),(1173,703),(1175,34),(1175,2226),(1175,2227),(1175,529),(1175,513),(1176,2228),(1176,2229),(1176,2230),(1176,1466),(1176,118),(1177,2231),(1177,1569),(1177,2232),(1178,92),(1178,2233),(1178,6),(1178,19),(1178,803),(1179,371),(1179,2002),(1179,2003),(1179,2004),(1179,2005),(1182,2234),(1182,2235),(1182,2236),(1182,156),(1185,1469),(1185,494),(1185,2237),(1185,45),(1185,541),(1187,2238),(1187,854),(1187,2239),(1187,2240),(1187,2241),(1188,2242),(1188,26),(1188,2243),(1189,1182),(1189,1183),(1189,1418),(1189,2244),(1189,2081),(1192,1772),(1192,2245),(1192,2246),(1193,2247),(1193,791),(1193,15),(1193,2248),(1194,2249),(1194,2250),(1194,2251),(1196,2252),(1196,2253),(1196,41),(1196,1873),(1196,2254),(1197,2255),(1197,1979),(1197,2256),(1198,68),(1198,329),(1198,2257),(1198,140),(1198,2258),(1200,932),(1200,1220),(1200,2259),(1200,401),(1201,656),(1201,1572),(1201,2260),(1202,2261),(1202,2262),(1202,2263),(1202,2264),(1203,2265),(1203,1720),(1203,2266),(1203,2267),(1203,2268),(1203,2269),(1204,2270),(1204,2271),(1204,1180),(1204,1477),(1205,2272),(1205,706),(1205,2273),(1206,305),(1206,1278),(1206,2274),(1206,2275),(1206,2276),(1206,2277),(1206,2278),(1207,2279),(1207,6),(1207,2280),(1209,68),(1209,36),(1209,1020),(1209,1131),(1210,1720),(1210,2281),(1210,2266),(1210,2269),(1210,156),(1211,2282),(1211,2283),(1211,2284),(1212,2285),(1212,2028),(1212,2286),(1212,2287),(1213,2288),(1213,2289),(1213,932),(1214,331),(1214,2290),(1214,1224),(1215,1510),(1215,2291),(1216,68),(1216,26),(1216,239),(1216,1678),(1217,2147),(1217,1546),(1217,2292),(1218,2293),(1218,1378),(1218,198),(1219,15),(1219,2294),(1219,19),(1219,2295),(1219,2296),(1220,2297),(1220,2147),(1220,2298),(1220,2299),(1220,2152),(1221,2300),(1221,2301),(1221,2302),(1222,2303),(1222,866),(1222,2304),(1222,2305),(1223,2306),(1223,2307),(1223,512),(1224,2308),(1224,2309),(1224,1990),(1224,2310),(1225,409),(1225,1541),(1225,2311),(1226,562),(1226,2312),(1226,1055),(1226,34),(1227,19),(1227,2313),(1227,2028),(1227,2286),(1228,2314),(1228,2315),(1228,2316),(1229,2317),(1229,39),(1229,803),(1230,2318),(1230,2319),(1230,2320),(1230,165),(1231,15),(1231,19),(1231,411),(1231,2321),(1232,36),(1232,287),(1232,513),(1233,329),(1233,2322),(1233,2323),(1234,2044),(1234,2324),(1234,2325),(1234,2326),(1234,1978),(1235,1595),(1235,2327),(1235,2328),(1235,2156),(1236,2329),(1236,2330),(1236,2331),(1237,1294),(1237,1017),(1237,2332),(1237,2333),(1237,1239),(1238,2334),(1238,2335),(1239,68),(1239,2336),(1240,1318),(1240,932),(1240,2337),(1240,2338),(1241,2339),(1241,1338),(1241,2340),(1242,2341),(1242,2342),(1242,2343),(1242,2344),(1242,1789),(1243,45),(1243,2345),(1243,964),(1244,2346),(1244,2347),(1244,2348),(1244,472),(1244,1001),(1245,2349),(1245,1998),(1245,76),(1245,86),(1245,854),(1245,1338),(1246,2350),(1246,34),(1246,1845),(1246,2351),(1247,2352),(1247,48),(1247,133),(1247,1789),(1247,154),(1247,2353),(1248,2354),(1248,2355),(1248,2356),(1249,2357),(1249,2358),(1249,39),(1250,68),(1250,2359),(1250,850),(1251,1025),(1251,2360),(1251,1604),(1252,1548),(1252,989),(1252,77),(1253,932),(1253,2361),(1253,2362),(1253,2363),(1254,68),(1254,2364),(1255,2365),(1255,2366),(1255,2367),(1256,25),(1256,2368),(1256,19),(1257,2037),(1257,2369),(1257,2370),(1257,2371),(1257,2372),(1257,145),(1258,2373),(1258,2374),(1258,140),(1259,954),(1259,2375),(1259,1883),(1259,1047),(1260,540),(1260,2376),(1260,45),(1261,331),(1261,2377),(1261,2378),(1261,2379),(1262,239),(1262,640),(1262,2380),(1262,2381),(1262,2382),(1263,2383),(1263,2384),(1263,2385),(1263,2386),(1263,2387),(1263,2388),(1264,2237),(1264,2389),(1264,918),(1265,16),(1265,2390),(1265,2152),(1266,928),(1266,1935),(1266,879),(1266,706),(1267,2391),(1267,2019),(1267,1595),(1267,15),(1267,9),(1268,2392),(1268,92),(1268,2393),(1268,352),(1269,418),(1269,1494),(1269,2379),(1269,62),(1270,34),(1270,2394),(1271,2395),(1271,2396),(1271,2397),(1272,2071),(1272,2398),(1272,2399),(1272,2400),(1273,704),(1273,2050),(1273,2401),(1273,1281),(1274,1058),(1274,2402),(1274,2403),(1275,2404),(1275,1492),(1275,2405),(1275,2406),(1276,2407),(1276,19),(1276,513),(1277,1482),(1277,301),(1277,17),(1277,30),(1278,371),(1278,2133),(1278,2408),(1279,1496),(1279,2190),(1279,19),(1279,2409),(1280,140),(1280,2258),(1280,2410),(1281,2411),(1281,276),(1281,92),(1282,30),(1282,2412),(1283,573),(1283,2413),(1283,2414),(1284,866),(1284,39),(1285,2415),(1285,2416),(1285,2417),(1285,2418),(1285,19),(1285,405),(1286,2419),(1286,1977),(1286,310),(1286,133),(1286,39),(1287,2420),(1287,68),(1287,2421),(1287,2422),(1288,2423),(1288,2424),(1288,2425),(1288,2426),(1288,2427),(1289,1893),(1289,571),(1289,2428),(1290,2429),(1290,2430),(1290,2431),(1290,2432),(1291,811),(1291,1013),(1291,2126),(1292,947),(1292,975),(1292,2433),(1293,2434),(1293,2215),(1293,544),(1293,2435),(1294,1355),(1294,2436),(1294,2437),(1295,68),(1295,48),(1295,2438),(1295,1164),(1296,2346),(1296,568),(1296,2439),(1296,2440),(1296,54),(1296,451),(1296,2260),(1297,2147),(1297,276);
/*!40000 ALTER TABLE `article_to_keyword` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `author_info`
--

DROP TABLE IF EXISTS `author_info`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `author_info` (
  `author_id` int(11) NOT NULL AUTO_INCREMENT,
  `author_name` varchar(100) DEFAULT NULL,
  `affiliation_id` int(11) DEFAULT NULL,
  `author_search_count` int(11) DEFAULT '0',
  PRIMARY KEY (`author_id`)
) ENGINE=InnoDB AUTO_INCREMENT=4412 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `author_info`
--

LOCK TABLES `author_info` WRITE;
/*!40000 ALTER TABLE `author_info` DISABLE KEYS */;
INSERT INTO `author_info` VALUES (1,'R. P. Reyes Ch.',1,0),(2,'O. Dieste',1,0),(3,'E. R. Fonseca C.',2,0),(4,'N. Juristo',1,0),(5,'S. Gnesi',2,0),(6,'N. Plat',2,0),(7,'J. Zhang',3,0),(8,'X. Wang',4,0),(9,'H. Zhang',3,0),(10,'H. Sun',4,0),(11,'K. Wang',5,0),(12,'X. Liu',3,0),(13,'S. Souto',6,0),(14,'M. D\'Amorim',7,0),(15,'R. Gheyi',8,0),(16,'H. Liu',9,0),(17,'C. Sun',10,0),(18,'Z. Su',10,0),(19,'Y. Jiang',9,0),(20,'M. Gu',9,0),(21,'J. Sun',9,0),(22,'R. Jabbarvand',11,0),(23,'J. Lin',11,0),(24,'S. Malek',11,0),(25,'R. Tzoref-Brill',12,0),(26,'S. Maoz',12,0),(27,'A. Perez',13,0),(28,'R. Abreu',13,0),(29,'A. van Deursen',14,0),(30,'E. Wittern',15,0),(31,'A. T. T. Ying',15,0),(32,'Y. Zheng',15,0),(33,'J. Dolby',15,0),(34,'J. A. Laredo',15,0),(35,'C. Q. Adamsen',16,0),(36,'A. M酶ller',16,0),(37,'R. Karim',17,0),(38,'M. Sridharan',17,0),(39,'F. Tip',18,0),(40,'K. Sen',19,0),(41,'M. Motwani',20,0),(42,'Y. Brun',20,0),(43,'J. M. Rojas',21,0),(44,'T. D. White',21,0),(45,'B. S. Clegg',21,0),(46,'G. Fraser',21,0),(47,'A. Agrawal',22,0),(48,'S. Khoshmanesh',23,0),(49,'M. Vierhauser',22,0),(50,'M. Rahimi',24,0),(51,'J. Cleland-Huang',22,0),(52,'R. Lutz',23,0),(53,'D. A. Tomassi',25,0),(54,'N. Dmeiri',25,0),(55,'Y. Wang',25,0),(56,'A. Bhowmick',25,0),(57,'Y. Liu',25,0),(58,'P. T. Devanbu',25,0),(59,'B. Vasilescu',26,0),(60,'C. Rubio-Gonz谩lez',25,0),(61,'A. Choudhary',27,0),(62,'S. Lu',28,0),(63,'M. Pradel',27,0),(64,'Y. K. Lee',29,0),(65,'J. Y. Bang',30,0),(66,'G. Safi',29,0),(67,'A. Shahbazian',29,0),(68,'Y. Zhao',29,0),(69,'N. Medvidovic',29,0),(70,'S. Yatish',31,0),(71,'J. Jiarpakdee',32,0),(72,'P. Thongtanunam',33,0),(73,'C. Tantithamthavorn',32,0),(74,'X. Du',34,0),(75,'B. Chen',35,0),(76,'Y. Li',34,0),(77,'J. Guo',36,0),(78,'Y. Zhou',34,0),(79,'Y. Liu',34,0),(80,'Y. Jiang',36,0),(81,'M. Tufano',37,0),(82,'J. Pantiuchina',38,0),(83,'C. Watson',37,0),(84,'G. Bavota',38,0),(85,'D. Poshyvanyk',37,0),(86,'A. A. Philip',39,0),(87,'R. Bhagwan',39,0),(88,'R. Kumar',39,0),(89,'C. S. Maddila',39,0),(90,'N. Nagppan',40,0),(91,'Z. Li',41,0),(92,'T. Chen',41,0),(93,'J. Yang',41,0),(94,'W. Shang',41,0),(95,'A. Lee',42,0),(96,'J. C. Carver',42,0),(97,'G. G. Cabral',43,0),(98,'L. L. Minku',44,0),(99,'E. Shihab',45,0),(100,'S. Mujahid',45,0),(101,'J. Chen',46,0),(102,'Y. Bai',46,0),(103,'D. Hao',46,0),(104,'Y. Xiong',46,0),(105,'H. Zhang',47,0),(106,'B. Xie',46,0),(107,'F. Servant',2,0),(108,'J. A. Jones',48,0),(109,'K. Heo',49,0),(110,'H. Oh',50,0),(111,'H. Yang',51,0),(112,'M. Li',52,0),(113,'W. Wang',52,0),(114,'P. Wang',53,0),(115,'S. Wang',53,0),(116,'D. Wu',53,0),(117,'J. Liu',52,0),(118,'R. Xue',54,0),(119,'W. Huo',52,0),(120,'R. Rutledge',55,0),(121,'S. Park',55,0),(122,'H. Khan',55,0),(123,'A. Orso',55,0),(124,'M. Prvulovic',55,0),(125,'A. Zajic',55,0),(126,'D. Kavaler',56,0),(127,'A. Trockman',57,0),(128,'B. Vasilescu',58,0),(129,'V. Filkov',56,0),(130,'N. Imtiaz',59,0),(131,'J. Middleton',59,0),(132,'J. Chakraborty',59,0),(133,'N. Robson',59,0),(134,'G. Bai',59,0),(135,'E. Murphy-Hill',60,0),(136,'F. Molina',61,0),(137,'R. Degiovanni',62,0),(138,'P. Ponzio',61,0),(139,'G. Regis',63,0),(140,'N. Aguirre',61,0),(141,'M. Frias',64,0),(142,'I. Bocic',65,0),(143,'T. Bultan',65,0),(144,'A. Fabijan',66,0),(145,'P. Dmitriev',67,0),(146,'H. H. Olsson',66,0),(147,'J. Bosch',68,0),(148,'L. Xue',69,0),(149,'X. Luo',69,0),(150,'L. Yu',69,0),(151,'S. Wang',69,0),(152,'D. Wu',70,0),(153,'S. Chattopadhyay',71,0),(154,'N. Nelson',71,0),(155,'Y. Ramirez Gonzalez',71,0),(156,'A. Amelia Leon',71,0),(157,'R. Pandita',72,0),(158,'A. Sarma',71,0),(159,'R. Rolim',73,0),(160,'G. Soares',73,0),(161,'L. D\'Antoni',74,0),(162,'O. Polozov',75,0),(163,'S. Gulwani',76,0),(164,'R. Gheyi',73,0),(165,'R. Suzuki',77,0),(166,'B. Hartmann',78,0),(167,'A. Alami',79,0),(168,'M. Leavitt Cohn',80,0),(169,'A. W膮sowski',80,0),(170,'A. Rahman',81,0),(171,'C. Parnin',81,0),(172,'L. Williams',81,0),(173,'X. Xiao',82,0),(174,'X. Wang',83,0),(175,'Z. Cao',82,0),(176,'H. Wang',82,0),(177,'P. Gao',84,0),(178,'X. Chang',85,0),(179,'W. Dou',86,0),(180,'Y. Gao',86,0),(181,'J. Wang',86,0),(182,'J. Wei',86,0),(183,'T. Huang',86,0),(184,'T. Azim',87,0),(185,'A. Alavi',87,0),(186,'I. Neamtiu',88,0),(187,'R. Gupta',87,0),(188,'T. Sedano',89,0),(189,'P. Ralph',90,0),(190,'C. P茅raire',89,0),(191,'W. Ma',91,0),(192,'L. Chen',91,0),(193,'X. Zhang',92,0),(194,'Y. Zhou',91,0),(195,'B. Xu',91,0),(196,'H. Ha',5,0),(197,'H. Zhang',5,0),(198,'A. Aquino',93,0),(199,'G. Denaro',94,0),(200,'M. Pezz猫',93,0),(201,'N. J. Abid',95,0),(202,'B. Sharif',96,0),(203,'N. Dragan',97,0),(204,'H. Alrasheed',98,0),(205,'J. I. Maletic',97,0),(206,'S. Huang',99,0),(207,'J. Guo',100,0),(208,'S. Li',100,0),(209,'X. Li',101,0),(210,'Y. Qi',101,0),(211,'K. Chow',100,0),(212,'J. Huang',99,0),(213,'S. Chen',102,0),(214,'L. Fan',102,0),(215,'C. Chen',103,0),(216,'T. Su',34,0),(217,'W. Li',104,0),(218,'L. Xu',104,0),(219,'M. Wen',105,0),(220,'Y. Liu',106,0),(221,'R. Wu',105,0),(222,'X. Xie',107,0),(223,'S. Cheung',105,0),(224,'Z. Su',108,0),(225,'J. Guo',109,0),(226,'J. Cheng',109,0),(227,'J. Cleland-Huang',109,0),(228,'Z. He',110,0),(229,'Y. Chen',110,0),(230,'E. Huang',110,0),(231,'Q. Wang',110,0),(232,'Y. Pei',110,0),(233,'H. Yuan',111,0),(234,'N. Licker',112,0),(235,'A. Rice',112,0),(236,'C. Chen',113,0),(237,'Z. Xing',114,0),(238,'X. Wang',113,0),(239,'D. Zhao',115,0),(240,'Z. Xing',115,0),(241,'C. Chen',32,0),(242,'X. Xia',32,0),(243,'G. Li',116,0),(244,'Y. Yang',117,0),(245,'Y. Zhou',117,0),(246,'H. Sun',118,0),(247,'Z. Su',119,0),(248,'Z. Zuo',117,0),(249,'L. Xu',117,0),(250,'B. Xu',117,0),(251,'V. J. Hellendoorn',56,0),(252,'S. Proksch',120,0),(253,'H. C. Gall',120,0),(254,'A. Bacchelli',120,0),(255,'Y. Zhou',121,0),(256,'R. Gu',121,0),(257,'T. Chen',122,0),(258,'Z. Huang',121,0),(259,'S. Panichella',123,0),(260,'H. Gall',123,0),(261,'Y. Chen',116,0),(262,'T. Su',124,0),(263,'Z. Su',125,0),(264,'B. Chen',126,0),(265,'Z. M. Jiang',126,0),(266,'V. Atlidakis',127,0),(267,'P. Godefroid',128,0),(268,'M. Polishchuk',128,0),(269,'Z. Shakeri Hossein Abad',129,0),(270,'V. Gervasi',130,0),(271,'D. Zowghi',131,0),(272,'B. H. Far',129,0),(273,'R. Padhye',132,0),(274,'K. Sen',132,0),(275,'K. Heo',133,0),(276,'H. Oh',134,0),(277,'K. Yi',133,0),(278,'J. Wang',135,0),(279,'G. Dong',136,0),(280,'J. Sun',137,0),(281,'X. Wang',136,0),(282,'P. Zhang',137,0),(283,'P. T. Nguyen',138,0),(284,'J. Di Rocco',138,0),(285,'D. Di Ruscio',138,0),(286,'L. Ochoa',139,0),(287,'T. Degueule',139,0),(288,'M. Di Penta',140,0),(289,'A. Barcomb',141,0),(290,'K. Stol',142,0),(291,'D. Riehle',143,0),(292,'B. Fitzgerald',142,0),(293,'P. Rodeghero',144,0),(294,'S. Jiang',144,0),(295,'A. Armaly',144,0),(296,'C. McMillan',144,0),(297,'L. Ponzanelli',93,0),(298,'S. Scalabrino',145,0),(299,'G. Bavota',93,0),(300,'A. Mocci',93,0),(301,'R. Oliveto',145,0),(302,'M. Di Penta',146,0),(303,'M. Lanza',93,0),(304,'Y. Huang',147,0),(305,'X. Liu',147,0),(306,'R. Krueger',148,0),(307,'T. Santander',149,0),(308,'X. Hu',147,0),(309,'K. Leach',148,0),(310,'W. Weimer',148,0),(311,'M. Coblenz',150,0),(312,'W. Nelson',151,0),(313,'J. Aldrich',150,0),(314,'B. Myers',150,0),(315,'J. Sunshine',150,0),(316,'A. Bertolino',152,0),(317,'B. Miranda',152,0),(318,'R. Pietrantuono',153,0),(319,'S. Russo',153,0),(320,'C. Kaltenecker',154,0),(321,'A. Grebhahn',154,0),(322,'N. Siegmund',155,0),(323,'J. Guo',156,0),(324,'S. Apel',154,0),(325,'S. Nilizadeh',157,0),(326,'Y. Noller',158,0),(327,'C. S. Pasareanu',159,0),(328,'C. Vendome',160,0),(329,'M. Linares-V谩squez',161,0),(330,'D. German',162,0),(331,'D. Poshyvanyk',160,0),(332,'D. Cui',163,0),(333,'T. Liu',163,0),(334,'Y. Cai',164,0),(335,'Q. Zheng',165,0),(336,'Q. Feng',164,0),(337,'W. Jin',165,0),(338,'J. Guo',165,0),(339,'Y. Qu',165,0),(340,'B. Behringer',166,0),(341,'J. Palz',167,0),(342,'T. Berger',168,0),(343,'J. Cito',169,0),(344,'P. Leitner',170,0),(345,'M. Rinard',169,0),(346,'A. LeClair',22,0),(347,'S. Jiang',171,0),(348,'C. McMillan',22,0),(349,'R. Hoda',172,0),(350,'J. Noble',173,0),(351,'A. Lee',174,0),(352,'J. C. Carver',174,0),(353,'A. Bosu',175,0),(354,'K. Joshi',176,0),(355,'V. Fernando',176,0),(356,'S. Misailovic',176,0),(357,'M. Christakis',177,0),(358,'P. Emmisberger',178,0),(359,'P. Godefroid',177,0),(360,'P. M眉ller',178,0),(361,'S. Lazreg',179,0),(362,'M. Cordy',180,0),(363,'P. Collet',181,0),(364,'P. Heymans',182,0),(365,'S. Mosser',181,0),(366,'A. Ketkar',183,0),(367,'A. Mesbah',184,0),(368,'D. Mazinanian',184,0),(369,'D. Dig',183,0),(370,'E. Aftandilian',185,0),(371,'L. Wei',105,0),(372,'Y. Liu',186,0),(373,'S. Cheung',187,0),(374,'Y. Wang',188,0),(375,'M. Wen',189,0),(376,'R. Wu',189,0),(377,'Z. Liu',188,0),(378,'S. H. Tan',190,0),(379,'Z. Zhu',188,0),(380,'H. Yu',188,0),(381,'S. Cheung',189,0),(382,'T. Gu',191,0),(383,'C. Sun',191,0),(384,'X. Ma',192,0),(385,'C. Cao',192,0),(386,'C. Xu',192,0),(387,'Y. Yao',192,0),(388,'Q. Zhang',193,0),(389,'J. Lu',192,0),(390,'Z. Su',194,0),(391,'M. Joblin',195,0),(392,'S. Apel',196,0),(393,'C. Hunsen',196,0),(394,'W. Mauerer',197,0),(395,'M. Soltani',14,0),(396,'A. Panichella',198,0),(397,'S. Pearson',199,0),(398,'J. Campos',200,0),(399,'R. Just',201,0),(400,'G. Fraser',200,0),(401,'R. Abreu',202,0),(402,'M. D. Ernst',199,0),(403,'D. Pang',199,0),(404,'B. Keller',199,0),(405,'D. Arya',203,0),(406,'W. Wang',203,0),(407,'J. L. C. Guo',203,0),(408,'J. Cheng',204,0),(409,'M. Rahman',205,0),(410,'D. Palani',205,0),(411,'P. C. Rigby',205,0),(412,'P. Liu',15,0),(413,'X. Zhang',206,0),(414,'M. Pistoia',15,0),(415,'M. Marques',15,0),(416,'L. Zeng',206,0),(417,'K. Liu',207,0),(418,'D. Kim',207,0),(419,'T. F. Bissyand茅',207,0),(420,'T. Kim',208,0),(421,'K. Kim',207,0),(422,'A. Koyuncu',207,0),(423,'S. Kim',208,0),(424,'Y. Le Traon',207,0),(425,'B. Hawkins',48,0),(426,'B. Demsky',48,0),(427,'X. Xu',209,0),(428,'Y. Sui',131,0),(429,'H. Yan',209,0),(430,'J. Xue',209,0),(431,'J. Yang',210,0),(432,'C. Yan',211,0),(433,'C. Wan',210,0),(434,'S. Lu',210,0),(435,'A. Cheung',211,0),(436,'Y. Zhao',212,0),(437,'T. Yu',212,0),(438,'Y. Liu',124,0),(439,'W. Zheng',213,0),(440,'J. Zhang',213,0),(441,'W. G.J. Halfond',214,0),(442,'T. Zhang',215,0),(443,'M. Kim',215,0),(444,'L. Yin',216,0),(445,'W. Dong',216,0),(446,'W. Liu',216,0),(447,'J. Wang',216,0),(448,'M. Sayagh',2,0),(449,'N. Kerzazi',2,0),(450,'B. Adams',2,0),(451,'R. Heradio',217,0),(452,'D. Fernandez-Amoros',217,0),(453,'C. Mayr-Dorn',218,0),(454,'A. Egyed',218,0),(455,'S. Rasthofer',219,0),(456,'S. Arzt',219,0),(457,'S. Triller',220,0),(458,'N. Grech',221,0),(459,'L. Brent',222,0),(460,'B. Scholz',222,0),(461,'Y. Smaragdakis',223,0),(462,'T. Zhang',224,0),(463,'D. Yang',11,0),(464,'C. Lopes',11,0),(465,'M. Kim',224,0),(466,'H. A. Nguyen',225,0),(467,'T. N. Nguyen',226,0),(468,'D. Dig',71,0),(469,'S. Nguyen',226,0),(470,'H. Tran',226,0),(471,'M. Hilton',227,0),(472,'A. Shi',228,0),(473,'S. Thummalapenta',229,0),(474,'S. K. Lahiri',177,0),(475,'N. Bjorner',177,0),(476,'J. Czerwonka',229,0),(477,'L. Zhang',230,0),(478,'C. Wang',231,0),(479,'Y. Tsutano',232,0),(480,'S. Bachala',232,0),(481,'W. Srisa-An',232,0),(482,'G. Rothermel',232,0),(483,'J. Dinh',232,0),(484,'T. Ki',233,0),(485,'C. M. Park',233,0),(486,'K. Dantu',233,0),(487,'S. Y. Ko',233,0),(488,'L. Ziarek',233,0),(489,'D. Spadini',234,0),(490,'F. Palomba',120,0),(491,'T. Baum',235,0),(492,'S. Hanenberg',236,0),(493,'M. Bruntink',237,0),(494,'N. Tran',226,0),(495,'H. Nguyen',225,0),(496,'W. You',238,0),(497,'X. Liu',239,0),(498,'S. Ma',238,0),(499,'D. Perry',238,0),(500,'X. Zhang',238,0),(501,'B. Liang',240,0),(502,'J. Kim',241,0),(503,'R. Feldt',242,0),(504,'S. Yoo',241,0),(505,'J. Choi',241,0),(506,'J. Jang',243,0),(507,'C. Han',244,0),(508,'S. K. Cha',241,0),(509,'C. Zhu',245,0),(510,'O. Legunsen',246,0),(511,'A. Shi',246,0),(512,'M. Gligoric',245,0),(513,'H. Jiang',247,0),(514,'X. Li',247,0),(515,'Z. Yang',248,0),(516,'J. Xuan',249,0),(517,'Z. Gao',250,0),(518,'C. Bird',177,0),(519,'E. T. Barr',250,0),(520,'H. Zhang',251,0),(521,'A. Rountev',251,0),(522,'M. Lillack',252,0),(523,'S. Stanciulescu',253,0),(524,'W. Hedman',254,0),(525,'T. Berger',254,0),(526,'J. Delplanque',255,0),(527,'S. Ducasse',256,0),(528,'G. Polito',255,0),(529,'A. P. Black',257,0),(530,'A. Etien',255,0),(531,'E. K. Kristensen',258,0),(532,'A. M酶ller',258,0),(533,'G. Fan',259,0),(534,'R. Wu',259,0),(535,'Q. Shi',259,0),(536,'X. Xiao',260,0),(537,'J. Zhou',260,0),(538,'C. Zhang',259,0),(539,'D. Faitelson',261,0),(540,'S. Tyszberowicz',262,0),(541,'L. Song',2,0),(542,'S. Lu',2,0),(543,'R. Hao',263,0),(544,'Y. Feng',264,0),(545,'J. A. Jones',264,0),(546,'Y. Li',263,0),(547,'Z. Chen',263,0),(548,'J. Wang',46,0),(549,'R. Yan',265,0),(550,'J. Zhang',46,0),(551,'S. Han',266,0),(552,'G. Huang',46,0),(553,'L. Zhang',46,0),(554,'K. Miller',267,0),(555,'Y. Kwon',268,0),(556,'Y. Sun',267,0),(557,'Z. Zhang',267,0),(558,'X. Zhang',267,0),(559,'Z. Lin',269,0),(560,'M. Chen',270,0),(561,'F. Fischer',271,0),(562,'N. Meng',270,0),(563,'X. Wang',272,0),(564,'J. Grossklags',271,0),(565,'J. Wang',273,0),(566,'Y. Yang',274,0),(567,'R. Krishna',81,0),(568,'T. Menzies',81,0),(569,'Q. Wang',275,0),(570,'A. Amar',41,0),(571,'P. C. Rigby',41,0),(572,'Y. Lin',276,0),(573,'J. Sun',277,0),(574,'Y. Xue',278,0),(575,'Y. Liu',278,0),(576,'J. Dong',276,0),(577,'T. D. Nguyen',2,0),(578,'A. T. Nguyen',2,0),(579,'H. D. Phan',2,0),(580,'T. N. Nguyen',2,0),(581,'C. Vassallo',120,0),(582,'M. Di Penta',279,0),(583,'H. S. Qiu',227,0),(584,'A. Nolte',280,0),(585,'A. Brown',281,0),(586,'A. Serebrenik',282,0),(587,'B. Vasilescu',227,0),(588,'R. Gopalakrishnan',283,0),(589,'P. Sharma',283,0),(590,'M. Mirakhorli',283,0),(591,'M. Galster',284,0),(592,'S. A. Chowdhury',285,0),(593,'A. Hindle',285,0),(594,'R. Kazman',286,0),(595,'T. Shuto',287,0),(596,'K. Matsui',287,0),(597,'Y. Kamei',287,0),(598,'N. Tsantalis',288,0),(599,'D. Mazinanian',288,0),(600,'S. Rostami',288,0),(601,'N. Ghorbani',11,0),(602,'J. Garcia',11,0),(603,'B. Lin',38,0),(604,'F. Zampetti',279,0),(605,'M. Lanza',38,0),(606,'M. Fan',165,0),(607,'X. Luo',289,0),(608,'J. Liu',290,0),(609,'M. Wang',291,0),(610,'C. Nong',165,0),(611,'T. Liu',165,0),(612,'Z. Xu',113,0),(613,'B. Chen',113,0),(614,'M. Chandramohan',113,0),(615,'Y. Liu',113,0),(616,'F. Song',292,0),(617,'J. Wang',34,0),(618,'L. Wei',34,0),(619,'E. Murphy-Hill',293,0),(620,'E. K. Smith',294,0),(621,'C. Sadowski',293,0),(622,'C. Jaspan',293,0),(623,'C. Winter',295,0),(624,'M. Jorde',293,0),(625,'A. Knight',293,0),(626,'A. Trenk',293,0),(627,'S. Gross',293,0),(628,'X. Xia',296,0),(629,'Z. Wan',297,0),(630,'P. S. Kochhar',298,0),(631,'D. Lo',299,0),(632,'J. Zhang',247,0),(633,'Z. Ren',247,0),(634,'T. Zhang',300,0),(635,'R. Khatchadourian',301,0),(636,'H. Masuhara',302,0),(637,'M. Pan',192,0),(638,'S. Chen',192,0),(639,'Y. Pei',289,0),(640,'T. Zhang',192,0),(641,'X. Li',192,0),(642,'G. Su',303,0),(643,'Y. Feng',304,0),(644,'D. S. Rosenblum',276,0),(645,'脰. Kafali',305,0),(646,'J. Jones',306,0),(647,'M. Petruso',307,0),(648,'L. Williams',305,0),(649,'M. P. Singh',305,0),(650,'R. Khatchadourian',308,0),(651,'Y. Tang',309,0),(652,'M. Bagherzadeh',310,0),(653,'S. Ahmed',310,0),(654,'E. Cruciani',311,0),(655,'B. Miranda',312,0),(656,'R. Verdecchia',313,0),(657,'A. Bertolino',314,0),(658,'R. S. Malik',315,0),(659,'J. Patra',315,0),(660,'M. Pradel',315,0),(661,'F. Palomba',14,0),(662,'P. Salza',316,0),(663,'A. Ciurumelea',317,0),(664,'S. Panichella',317,0),(665,'H. Gall',317,0),(666,'F. Ferrucci',316,0),(667,'A. De Lucia',316,0),(668,'A. Sivaraman',224,0),(669,'G. Van den Broeck',224,0),(670,'D. Landman',318,0),(671,'A. Serebrenik',318,0),(672,'J. J. Vinju',318,0),(673,'S. A. Busari',319,0),(674,'E. Letier',319,0),(675,'S. Bae',51,0),(676,'S. Lee',320,0),(677,'S. Ryu',320,0),(678,'E. Aghajani',321,0),(679,'C. Nagy',321,0),(680,'O. L. Vega-M谩rquez',322,0),(681,'M. Linares-V谩squez',322,0),(682,'L. Moreno',323,0),(683,'G. Bavota',321,0),(684,'M. Lanza',321,0),(685,'X. D. Le',26,0),(686,'L. Bao',324,0),(687,'D. Lo',325,0),(688,'S. Li',239,0),(689,'C. Pasareanu',326,0),(690,'J. Eyolfson',327,0),(691,'P. Lam',328,0),(692,'T. Sedano',329,0),(693,'P. Ralph',330,0),(694,'C. P茅raire',331,0),(695,'B. Floyd',2,0),(696,'T. Santander',2,0),(697,'W. Weimer',2,0),(698,'P. Su',332,0),(699,'S. Wen',332,0),(700,'H. Yang',3,0),(701,'M. Chabbi',333,0),(702,'X. Liu',332,0),(703,'X. Wang',192,0),(704,'H. Wang',192,0),(705,'Z. Su',334,0),(706,'E. Tang',192,0),(707,'X. Chen',192,0),(708,'W. Shen',192,0),(709,'Z. Chen',192,0),(710,'L. Wang',192,0),(711,'X. Zhang',192,0),(712,'T. Barik',305,0),(713,'J. Smith',305,0),(714,'K. Lubick',305,0),(715,'E. Holmes',335,0),(716,'J. Feng',336,0),(717,'E. Murphy-Hill',305,0),(718,'C. Parnin',305,0),(719,'W. Wang',337,0),(720,'I. L. Kim',238,0),(721,'Y. Zheng',338,0),(722,'H. Hata',339,0),(723,'C. Treude',340,0),(724,'R. G. Kula',339,0),(725,'T. Ishio',339,0),(726,'S. Maoz',341,0),(727,'J. O. Ringert',342,0),(728,'R. Shalom',341,0),(729,'R. Ramsauer',343,0),(730,'D. Lohmann',344,0),(731,'W. Mauerer',343,0),(732,'E. Horton',59,0),(733,'C. Parnin',59,0),(734,'S. Saha',345,0),(735,'R. k. Saha',346,0),(736,'M. r. Prasad',346,0),(737,'A. Filippova',347,0),(738,'E. Trainer',347,0),(739,'J. D. Herbsleb',347,0),(740,'F. Sarker',191,0),(741,'B. Vasilescu',348,0),(742,'K. Blincoe',349,0),(743,'V. Filkov',191,0),(744,'J. Thom茅',198,0),(745,'L. K. Shar',198,0),(746,'D. Bianculli',198,0),(747,'L. Briand',198,0),(748,'V. Saini',350,0),(749,'F. Farmahinifarahani',350,0),(750,'Y. Lu',350,0),(751,'D. Yang',350,0),(752,'P. Martins',350,0),(753,'H. Sajnani',351,0),(754,'P. Baldi',350,0),(755,'C. V. Lopes',350,0),(756,'H. V. Pham',352,0),(757,'T. Lutellier',352,0),(758,'W. Qi',353,0),(759,'L. Tan',238,0),(760,'L. Zhang',354,0),(761,'W. He',354,0),(762,'J. Martinez',354,0),(763,'N. Brackenbury',354,0),(764,'S. Lu',354,0),(765,'B. Ur',354,0),(766,'T. T. Chekam',355,0),(767,'M. Papadakis',355,0),(768,'Y. Le Traon',355,0),(769,'M. Harman',250,0),(770,'M. Tichy',2,0),(771,'J. Bosch',2,0),(772,'M. Goedicke',2,0),(773,'B. Fitzgerald',2,0),(774,'G. Gay',2,0),(775,'G. Antoniol',2,0),(776,'P. Falcarin',2,0),(777,'B. Wyseur',2,0),(778,'M. Galster',2,0),(779,'M. Mirakhorli',2,0),(780,'R. Subramanyan',2,0),(781,'L. Mariani',2,0),(782,'D. Hao',2,0),(783,'J. Bishop',2,0),(784,'K. M. L. Cooper',2,0),(785,'W. Scacchi',2,0),(786,'J. Whitehead',2,0),(787,'B. Turhan',2,0),(788,'A. Bener',2,0),(789,'R. Harrison',2,0),(790,'A. Miransky',2,0),(791,'C. Mericli',2,0),(792,'L. Minku',2,0),(793,'F. Oquendo',2,0),(794,'P. Avgeriou',2,0),(795,'C. E. Cuesta',2,0),(796,'K. Drira',2,0),(797,'E. Y. Nakagawa',2,0),(798,'J. C. Maldonado',2,0),(799,'A. Zisman',2,0),(800,'I. Matteucci',2,0),(801,'P. Mori',2,0),(802,'M. Petrocchi',2,0),(803,'K. Labunets',14,0),(804,'F. Massacci',356,0),(805,'F. Paci',357,0),(806,'S. Marczak',358,0),(807,'F. M. de Oliveira',358,0),(808,'E. A. Barbosa',359,0),(809,'A. Garcia',360,0),(810,'Q. Stievenart',361,0),(811,'J. Nicolay',361,0),(812,'W. De Meuter',361,0),(813,'C. De Roover',361,0),(814,'L. Gherardi',362,0),(815,'N. Hochgeschwender',363,0),(816,'G. S. Walia',2,0),(817,'J. C. Caver',2,0),(818,'G. Bradshaw',2,0),(819,'A. Sadeghi',364,0),(820,'H. Bagheri',364,0),(821,'S. Malek',364,0),(822,'J. I. Maletic',365,0),(823,'M. L. Collard',366,0),(824,'T. Wang',132,0),(825,'K. Aadithya',132,0),(826,'B. Wu',132,0),(827,'J. Roychowdhury',132,0),(828,'H. R. Joseph',367,0),(829,'N. Diallo',368,0),(830,'W. Ghardallou',369,0),(831,'A. Mili',368,0),(832,'Z. M. J. Jiang',370,0),(833,'L. Baresi',2,0),(834,'T. Menzies',2,0),(835,'A. Metzger',2,0),(836,'T. Zimmermann',2,0),(837,'C. Silenzi',371,0),(838,'R. Raudj盲rv',372,0),(839,'A. R. Gregersen',372,0),(840,'P. Roos',373,0),(841,'T. Menzies',374,0),(842,'L. Minku',375,0),(843,'F. Peters',376,0),(844,'A. Begel',2,0),(845,'R. Prikladnicki',2,0),(846,'Y. Dittrich',2,0),(847,'C. R. B. d. Souza',2,0),(848,'A. Sarma',2,0),(849,'S. Athavale',2,0),(850,'R. Padhye',2,0),(851,'P. Dhoolia',2,0),(852,'S. Mani',2,0),(853,'V. S. Sinha',2,0),(854,'C. Lemieux',377,0),(855,'M. Linares-V谩squez',160,0),(856,'K. Blincoe',2,0),(857,'D. Damian',2,0),(858,'G. Valetto',2,0),(859,'J. D. Herbsleb',2,0),(860,'J. Sant',378,0),(861,'F. Zieris',379,0),(862,'O. Legunsen',228,0),(863,'D. Marinov',228,0),(864,'G. Rosu',228,0),(865,'T. Barik',380,0),(866,'K. Lubick',381,0),(867,'E. Murphy-Hill',381,0),(868,'J. El Hachem',382,0),(869,'F. Palomba',383,0),(870,'J. Gray',2,0),(871,'M. Chechik',2,0),(872,'V. Kulkarni',2,0),(873,'R. F. Paige',2,0),(874,'A. Noureddine',384,0),(875,'A. Rajan',384,0),(876,'N. Dintzner',385,0),(877,'P. Accioly',386,0),(878,'A. Bichhawat',387,0),(879,'M. Morisio',2,0),(880,'P. Lago',2,0),(881,'N. Meyer',2,0),(882,'H. A. M眉ller',2,0),(883,'G. Scanniello',2,0),(884,'J. Rubin',2,0),(885,'G. Botterweck',2,0),(886,'A. Pleuss',2,0),(887,'D. Weiss',2,0),(888,'A. v. d. Berghe',2,0),(889,'M. Greiler',229,0),(890,'J. Tilford',229,0),(891,'M. White',388,0),(892,'J. Al-Kofahi',389,0),(893,'L. Guo',390,0),(894,'H. V. Nguyen',389,0),(895,'H. A. Nguyen',389,0),(896,'T. N. Nguyen',389,0),(897,'S. Barnett',391,0),(898,'R. Vasa',391,0),(899,'J. Grundy',391,0),(900,'L. Bao',392,0),(901,'J. Li',278,0),(902,'Z. Xing',278,0),(903,'X. Wang',392,0),(904,'B. Zhou',392,0),(905,'V. Avdiienko',393,0),(906,'R. Stevens',361,0),(907,'R. Suzuki',394,0),(908,'E. Bjarnason',2,0),(909,'M. Morandini',2,0),(910,'M. Borg',2,0),(911,'M. Unterkalmsteiner',2,0),(912,'M. Felderer',2,0),(913,'M. Staats',2,0),(914,'F. Hermans',2,0),(915,'P. Sestoft',2,0),(916,'S. Fischer',395,0),(917,'L. Linsbauer',395,0),(918,'R. E. Lopez-Herrejon',395,0),(919,'A. Egyed',395,0),(920,'Y. Pei',396,0),(921,'C. A. Furia',396,0),(922,'M. Nordio',396,0),(923,'B. Meyer',396,0),(924,'C. A. Thompson',397,0),(925,'F. Arcelli Fontana',398,0),(926,'V. Ferme',399,0),(927,'M. Zanoni',398,0),(928,'M. Selakovic',27,0),(929,'T. Bures',2,0),(930,'D. Weyns',2,0),(931,'M. Klein',2,0),(932,'R. E. Haber',2,0),(933,'E. S. Mesh',400,0),(934,'J. Zhou',401,0),(935,'Z. Chen',402,0),(936,'J. Wang',402,0),(937,'A. Borg',403,0),(938,'C. Porter',403,0),(939,'M. Micallef',403,0),(940,'R. Minelli',404,0),(941,'A. Mocci',404,0),(942,'M. Lanza',404,0),(943,'M. Famelis',405,0),(944,'N. Ben-David',405,0),(945,'A. Di Sandro',405,0),(946,'R. Salay',405,0),(947,'M. Chechik',405,0),(948,'M. Gligoric',228,0),(949,'L. Eloussi',228,0),(950,'H. v. d. Merwe',2,0),(951,'T. Dyb氓',406,0),(952,'T. Dings酶yr',406,0),(953,'S. Weigelt',2,0),(954,'W. F. Tichy',2,0),(955,'C. Franks',407,0),(956,'Z. Tu',407,0),(957,'P. Devanbu',407,0),(958,'V. Hellendoorn',14,0),(959,'F. Chen',408,0),(960,'J. Grundy',408,0),(961,'J. Schneider',408,0),(962,'Y. Yang',408,0),(963,'Q. He',408,0),(964,'G. Procaccianti',409,0),(965,'P. Lago',409,0),(966,'A. Vetr貌',410,0),(967,'D. M. Fern谩ndez',410,0),(968,'R. Wieringa',411,0),(969,'V. Arnaoudova',412,0),(970,'S. Haiduc',413,0),(971,'A. Marcus',412,0),(972,'G. Antoniol',414,0),(973,'T. Fukamachi',415,0),(974,'N. Ubayashi',415,0),(975,'S. Hosoai',415,0),(976,'Y. Kamei',415,0),(977,'L. Philips',361,0),(978,'S. Huang',416,0),(979,'P. Miranda',416,0),(980,'S. Counsell',2,0),(981,'A. Visaggio',2,0),(982,'R. Tonelli',2,0),(983,'E. Tempero',2,0),(984,'C. Tsigkanos',417,0),(985,'L. Pasquale',418,0),(986,'C. Ghezzi',417,0),(987,'B. Nuseibeh',418,0),(988,'G. Salvaneschi',419,0),(989,'A. Margara',93,0),(990,'G. Tamburrelli',420,0),(991,'S. Bandyopadhyay',421,0),(992,'D. Sarkar',421,0),(993,'C. Mandal',421,0),(994,'S. Sartoli',422,0),(995,'A. S. Namin',422,0),(996,'D. Schwartz-Narbonne',2,0),(997,'C. Oh',2,0),(998,'M. Sch盲f',2,0),(999,'T. Wies',2,0),(1000,'R. Salgado',423,0),(1001,'M. Nagappan',424,0),(1002,'M. Mirakhorli',424,0),(1003,'X. Franch',2,0),(1004,'N. H. Madhavji',2,0),(1005,'C. H. C. Duarte',2,0),(1006,'D. Shepherd',380,0),(1007,'K. Damevski',425,0),(1008,'L. Pollock',426,0),(1009,'N. R. Mead',427,0),(1010,'L. Inozemtseva',428,0),(1011,'E. Denney',429,0),(1012,'G. Pai',429,0),(1013,'I. Habli',430,0),(1014,'O. Benomar',431,0),(1015,'H. Sahraoui',431,0),(1016,'P. Poulin',431,0),(1017,'S. Landau',432,0),(1018,'R. Dixit',433,0),(1019,'C. Lutteroth',433,0),(1020,'G. Weber',433,0),(1021,'G. Imparato',434,0),(1022,'M. Grechanik',2,0),(1023,'J. Alonso',2,0),(1024,'A. P. Nikora',2,0),(1025,'H. Rajan',435,0),(1026,'V. Honsel',436,0),(1027,'G. Hecht',437,0),(1028,'G. Fraser',2,0),(1029,'T. D. LaToza',2,0),(1030,'S. Beyer',438,0),(1031,'M. Jazayeri',439,0),(1032,'A. Caracciolo',440,0),(1033,'G. Booch',441,0),(1034,'J. Escobar-Avila',442,0),(1035,'M. A. Babar',2,0),(1036,'H. Paik',2,0),(1037,'M. Chetlur',2,0),(1038,'M. Bauer',2,0),(1039,'A. M. Sharifloo',2,0),(1040,'H. K. Dam',443,0),(1041,'B. T. R. Savarimuthu',444,0),(1042,'D. Avery',443,0),(1043,'A. Ghose',443,0),(1044,'T. McCarthy',2,0),(1045,'P. R眉mmer',2,0),(1046,'J. F. S. Ouriques',2,0),(1047,'B. Cornu',445,0),(1048,'G. Engels',446,0),(1049,'I. Jacobson',447,0),(1050,'M. Goedicke',448,0),(1051,'Y. Tymchuk',449,0),(1052,'A. Mocci',449,0),(1053,'M. Lanza',449,0),(1054,'S. C. M眉ller',123,0),(1055,'A. Gambi',450,0),(1056,'Z. Rostyslav',450,0),(1057,'S. Dustdar',450,0),(1058,'S. Bellomo',2,0),(1059,'C. Bird',2,0),(1060,'F. Khomh',2,0),(1061,'K. Moir',2,0),(1062,'H. Sanchez',451,0),(1063,'J. Whitehead',452,0),(1064,'W. K. G. Assun莽茫o',453,0),(1065,'D. d. M. Baia',2,0),(1066,'M. Konopka',454,0),(1067,'P. Navrat',454,0),(1068,'M. Bielikova',454,0),(1069,'X. Fu',455,0),(1070,'H. Yu',455,0),(1071,'C. Huang',402,0),(1072,'W. Dong',402,0),(1073,'J. Wang',455,0),(1074,'I. Ozkaya',2,0),(1075,'R. L. Nord',2,0),(1076,'H. Koziolek',2,0),(1077,'R. Shukla',2,0),(1078,'F. Shull',2,0),(1079,'S. Sen',2,0),(1080,'F. Palomba',456,0),(1081,'M. Tufano',388,0),(1082,'G. Bavota',457,0),(1083,'R. Oliveto',458,0),(1084,'A. Marcus',459,0),(1085,'D. Poshyvanyk',388,0),(1086,'A. De Lucia',456,0),(1087,'D. W眉est',123,0),(1088,'N. Seyff',123,0),(1089,'M. Glinz',123,0),(1090,'A. Rastogi',460,0),(1091,'H. Liu',461,0),(1092,'P. Poon',462,0),(1093,'T. Y. Chen',463,0),(1094,'L. Christophe',361,0),(1095,'J. C. Carver',2,0),(1096,'N. Chue Hong',2,0),(1097,'P. Ciancarini',2,0),(1098,'H. V. Nguyen',464,0),(1099,'C. K盲stner',150,0),(1100,'T. N. Nguyen',464,0),(1101,'X. Franch',465,0),(1102,'X. Devroey',466,0),(1103,'G. Perrouin',466,0),(1104,'P. Schobbens',466,0),(1105,'P. Heymans',466,0),(1106,'S. Gulwani',177,0),(1107,'M. Mayer',467,0),(1108,'F. Niksic',468,0),(1109,'R. Piskac',469,0),(1110,'H. Tanno',470,0),(1111,'X. Zhang',470,0),(1112,'T. Hoshino',470,0),(1113,'P. Morrison',305,0),(1114,'P. Anthonysamy',471,0),(1115,'A. Rashid',472,0),(1116,'R. Sirres',473,0),(1117,'T. F. Bissyand茅',474,0),(1118,'D. Kim',474,0),(1119,'D. Lo',475,0),(1120,'J. Klein',474,0),(1121,'K. Kim',474,0),(1122,'Y. Le Traon',474,0),(1123,'L. Madeyski',476,0),(1124,'B. Kitchenham',477,0),(1125,'X. Li',478,0),(1126,'S. Zhu',478,0),(1127,'M. d鈥橝morim',7,0),(1128,'A. Orso',478,0),(1129,'E. Kalliamvakou',162,0),(1130,'T. Zimmermann',177,0),(1131,'A. Begel',177,0),(1132,'R. DeLine',177,0),(1133,'D. M. German',162,0),(1134,'N. Ajienka',479,0),(1135,'A. Capiluppi',480,0),(1136,'S. Counsell',480,0),(1137,'K. E. Bennin',481,0),(1138,'J. Keung',481,0),(1139,'P. Phannachitta',482,0),(1140,'A. Monden',483,0),(1141,'S. Mensah',481,0),(1142,'C. Hannebauer',2,0),(1143,'M. Hesenius',484,0),(1144,'V. Gruhn',484,0),(1145,'W. Choi',485,0),(1146,'K. Sen',485,0),(1147,'G. Necul',485,0),(1148,'W. Wang',486,0),(1149,'I. Rehman',2,0),(1150,'M. Nagappan',2,0),(1151,'A. Aralbay Uulu',2,0),(1152,'M. Thornton',2,0),(1153,'C. Mendez',487,0),(1154,'H. S. Padala',487,0),(1155,'Z. Steine-Hanson',487,0),(1156,'C. Hildebrand',487,0),(1157,'A. Horvath',487,0),(1158,'C. Hill',487,0),(1159,'L. Simpson',487,0),(1160,'N. Patil',487,0),(1161,'A. Sarma',487,0),(1162,'M. Burnett',487,0),(1163,'J. Kwon',488,0),(1164,'I. Ko',488,0),(1165,'G. Rothermel',489,0),(1166,'S. Hassan',490,0),(1167,'C. Tantithamthavorn',491,0),(1168,'C. Bezemer',490,0),(1169,'A. E. Hassan',490,0),(1170,'F. Palomba',317,0),(1171,'A. Panichella',14,0),(1172,'A. Zaidman',14,0),(1173,'R. Oliveto',492,0),(1174,'A. De Lucia',493,0),(1175,'S. Alimadadi',18,0),(1176,'A. Mesbah',494,0),(1177,'K. Pattabiraman',494,0),(1178,'S. Herbold',495,0),(1179,'A. Trautsch',495,0),(1180,'J. Grabowski',495,0),(1181,'B. Danglot',496,0),(1182,'P. Preux',497,0),(1183,'B. Baudry',498,0),(1184,'M. Monperrus',499,0),(1185,'S. Frey',357,0),(1186,'A. Rashid',500,0),(1187,'P. Anthonysamy',501,0),(1188,'M. Pinto-Albuquerque',502,0),(1189,'S. A. Naqvi',503,0),(1190,'Y. Zhao',231,0),(1191,'M. Schmitt Laser',504,0),(1192,'Y. Lyu',231,0),(1193,'N. Medvidovic',231,0),(1194,'A. Arcuri',505,0),(1195,'P. Morrison',381,0),(1196,'R. Pandita',506,0),(1197,'X. Xiao',507,0),(1198,'R. Chillarege',508,0),(1199,'L. Williams',381,0),(1200,'L. Zhang',509,0),(1201,'J. Stevenson',510,0),(1202,'M. Wood',510,0),(1203,'M. Bagherzadeh',511,0),(1204,'N. Kahani',511,0),(1205,'C. Bezemer',511,0),(1206,'A. E. Hassan',511,0),(1207,'J. Dingel',511,0),(1208,'J. R. Cordy',511,0),(1209,'C. Gralha',2,0),(1210,'A. Wasserman',2,0),(1211,'M. Goul茫o',2,0),(1212,'J. Ara煤jo',2,0),(1213,'D. Di Ruscio',512,0),(1214,'M. Franzago',512,0),(1215,'I. Malavolta',512,0),(1216,'H. Muccini',513,0),(1217,'S. McIntosh',514,0),(1218,'S. Segura',515,0),(1219,'J. A. Parejo',515,0),(1220,'J. Troya',515,0),(1221,'A. Ruiz-Cort茅s',515,0),(1222,'M. Beller',14,0),(1223,'N. Spruit',14,0),(1224,'D. Spinellis',516,0),(1225,'T. Vieira Ribeiro',517,0),(1226,'J. Massollar',517,0),(1227,'G. Horta Travassos',517,0),(1228,'S. Wang',490,0),(1229,'T. Chen',518,0),(1230,'J. Hua',519,0),(1231,'M. Zhang',519,0),(1232,'K. Wang',519,0),(1233,'S. Khurshid',519,0),(1234,'D. Beyer',520,0),(1235,'M. Jakobs',520,0),(1236,'T. Lemberger',520,0),(1237,'H. Wehrheim',521,0),(1238,'M. Kim',522,0),(1239,'N. Meng',523,0),(1240,'S. Nagy',523,0),(1241,'D. Yao',523,0),(1242,'W. Zhuang',523,0),(1243,'G. Arango-Argoty',523,0),(1244,'L. Sousa',2,0),(1245,'A. Oliveira',2,0),(1246,'W. Oizumi',2,0),(1247,'S. Barbosa',2,0),(1248,'A. Garcia',2,0),(1249,'J. Lee',2,0),(1250,'M. Kalinowski',2,0),(1251,'R. de Mello',2,0),(1252,'B. Fonseca',2,0),(1253,'R. Oliveira',2,0),(1254,'C. Lucena',2,0),(1255,'R. Paes',2,0),(1256,'M. Motwani',201,0),(1257,'S. Sankaranarayanan',201,0),(1258,'Y. Brun',201,0),(1259,'R. Morales',2,0),(1260,'R. Saborido',2,0),(1261,'F. Chicano',2,0),(1262,'A. Head',2,0),(1263,'C. Sadowski',2,0),(1264,'E. Murphy-Hill',2,0),(1265,'A. Knight',2,0),(1266,'J. Castelein',2,0),(1267,'M. Aniche',2,0),(1268,'M. Soltani',2,0),(1269,'A. Panichella',2,0),(1270,'A. van Deursen',2,0),(1271,'L. Fan',524,0),(1272,'T. Su',113,0),(1273,'S. Chen',524,0),(1274,'G. Meng',525,0),(1275,'L. Xu',524,0),(1276,'G. Pu',526,0),(1277,'Z. Su',527,0),(1278,'G. Meng',113,0),(1279,'Z. Xing',528,0),(1280,'C. Mayr-Dorn',529,0),(1281,'A. Egyed',529,0),(1282,'H. Lu',530,0),(1283,'S. Wang',530,0),(1284,'T. Yue',530,0),(1285,'S. Ali',530,0),(1286,'J. Nygard',531,0),(1287,'M. Scavuzzo',532,0),(1288,'E. Di Nitto',532,0),(1289,'D. Ardagna',532,0),(1290,'F. Calefato',533,0),(1291,'F. Lanubile',533,0),(1292,'F. Maiorano',533,0),(1293,'N. Novielli',533,0),(1294,'J. Liang',489,0),(1295,'S. Elbaum',489,0),(1296,'W. Kopec',534,0),(1297,'B. Balcerzak',534,0),(1298,'R. Nielek',534,0),(1299,'G. Kowalik',534,0),(1300,'A. Wierzbicki',534,0),(1301,'F. Casati',535,0),(1302,'J. Bell',536,0),(1303,'M. Hilton',537,0),(1304,'T. Yung',228,0),(1305,'S. Zhou',2,0),(1306,'S. Stanciulescu',2,0),(1307,'O. Le脽enich',2,0),(1308,'Y. Xiong',2,0),(1309,'A. Wasowski',2,0),(1310,'C. K盲stner',2,0),(1311,'S. Mahajan',231,0),(1312,'N. Abolhassani',231,0),(1313,'P. McMinn',200,0),(1314,'W. G. J. Halfond',231,0),(1315,'M. Habayeb',538,0),(1316,'S. S. Murtaza',538,0),(1317,'A. Miranskyy',539,0),(1318,'A. B. Bener',538,0),(1319,'M. Claes',540,0),(1320,'M. V. M盲ntyl盲',540,0),(1321,'M. Kuutila',540,0),(1322,'B. Adams',541,0),(1323,'N. Bradley',397,0),(1324,'T. Fritz',123,0),(1325,'R. Holmes',397,0),(1326,'F. Fasano',492,0),(1327,'X. D. Le',2,0),(1328,'F. Thung',2,0),(1329,'D. Lo',2,0),(1330,'C. Le Goues',2,0),(1331,'Z. Shan',542,0),(1332,'I. Neamtiu',368,0),(1333,'R. Samuel',368,0),(1334,'N. Borle',543,0),(1335,'M. Feghhi',543,0),(1336,'E. Stroulia',543,0),(1337,'R. Grenier',543,0),(1338,'A. Hindle',543,0),(1339,'D. Lin',544,0),(1340,'C. Bezemer',544,0),(1341,'A. E. Hassan',544,0),(1342,'R. Calinescu',430,0),(1343,'D. Weyns',545,0),(1344,'S. Gerasimou',430,0),(1345,'M. U. Iftikhar',546,0),(1346,'T. Kelly',430,0),(1347,'A. Armaly',109,0),(1348,'P. Rodeghero',109,0),(1349,'C. McMillan',109,0),(1350,'R. Gao',547,0),(1351,'W. E. Wong',547,0),(1352,'J. Garcia',548,0),(1353,'M. Hammad',548,0),(1354,'S. Malek',548,0),(1355,'J. Kr眉ger',549,0),(1356,'J. Wiemann',550,0),(1357,'W. Fenske',550,0),(1358,'G. Saake',550,0),(1359,'T. Leich',551,0),(1360,'J. Yang',2,0),(1361,'C. Yan',2,0),(1362,'P. Subramaniam',2,0),(1363,'A. Cheung',2,0),(1364,'R. Wu',552,0),(1365,'M. Wen',552,0),(1366,'S. Cheung',552,0),(1367,'H. Zhang',553,0),(1368,'M. M. Arif',554,0),(1369,'W. Shang',554,0),(1370,'E. Shihab',554,0),(1371,'J. de Lara',555,0),(1372,'E. Guerra',555,0),(1373,'R. Dutra',132,0),(1374,'K. Laeufer',132,0),(1375,'J. Bachrach',132,0),(1376,'Y. Kim',488,0),(1377,'Y. Choi',556,0),(1378,'M. Kim',488,0),(1379,'N. Ramasubbu',557,0),(1380,'C. Kemerer',557,0),(1381,'Z. Xu',558,0),(1382,'S. Ma',92,0),(1383,'S. Zhu',558,0),(1384,'B. Xu',558,0),(1385,'X. Xia',559,0),(1386,'D. Lo',560,0),(1387,'S. Li',392,0),(1388,'H. Zhong',561,0),(1389,'J. Yi',2,0),(1390,'S. H. Tan',2,0),(1391,'S. Mechtaev',2,0),(1392,'M. B枚hme',2,0),(1393,'A. Roychoudhury',2,0),(1394,'C. Gao',562,0),(1395,'J. Zeng',562,0),(1396,'M. R. Lyu',562,0),(1397,'I. King',562,0),(1398,'L. Gazzola',563,0),(1399,'L. Mariani',563,0),(1400,'D. Micucci',563,0),(1401,'K. Damevski',564,0),(1402,'H. Chen',565,0),(1403,'D. C. Shepherd',380,0),(1404,'N. A. Kraft',380,0),(1405,'I. Hadar',566,0),(1406,'T. Hasson',566,0),(1407,'O. Ayalon',567,0),(1408,'E. Toch',567,0),(1409,'M. Birnhack',567,0),(1410,'S. Sherman',566,0),(1411,'A. Balissa',567,0),(1412,'M. Pradel',2,0),(1413,'P. Schuh',2,0),(1414,'K. Sen',2,0),(1415,'D. Maplesden',330,0),(1416,'K. v. Randow',2,0),(1417,'E. Tempero',330,0),(1418,'J. Hosking',330,0),(1419,'J. Grundy',463,0),(1420,'J. Schroeder',2,0),(1421,'D. Holzner',2,0),(1422,'C. Berger',2,0),(1423,'C. Hoel',2,0),(1424,'L. Laine',2,0),(1425,'A. Magnusson',2,0),(1426,'M. Gomez',568,0),(1427,'M. Martineza',568,0),(1428,'M. Monperrus',568,0),(1429,'R. Rouvoy',568,0),(1430,'H. Baraki',569,0),(1431,'K. Geihs',569,0),(1432,'C. Voigtmann',569,0),(1433,'A. Hoffmann',569,0),(1434,'R. Kniewel',569,0),(1435,'B. Macek',569,0),(1436,'J. Zirfas',569,0),(1437,'L. F. Cort茅s-Coy',570,0),(1438,'J. Aponte',570,0),(1439,'P. L. Li',2,0),(1440,'A. J. Ko',2,0),(1441,'J. Zhu',2,0),(1442,'M. Fazzini',478,0),(1443,'P. Saxena',571,0),(1444,'J. Liebig',196,0),(1445,'A. Janker',196,0),(1446,'F. Garbe',196,0),(1447,'C. Lengauer',196,0),(1448,'D. Doligez',572,0),(1449,'C. Faure',573,0),(1450,'T. Hardin',573,0),(1451,'M. Maarek',573,0),(1452,'F. G. d. Oliveira Neto',2,0),(1453,'R. Torkar',574,0),(1454,'P. D. L. Machado',575,0),(1455,'B. Holland',576,0),(1456,'T. Deering',576,0),(1457,'S. Kothari',576,0),(1458,'J. Mathews',2,0),(1459,'N. Ranade',2,0),(1460,'H. S. Zhu',577,0),(1461,'C. Lin',577,0),(1462,'Y. D. Liu',577,0),(1463,'G. Gousios',578,0),(1464,'M. Storey',162,0),(1465,'A. v. Deursen',14,0),(1466,'M. Tufano',160,0),(1467,'F. Palomba',316,0),(1468,'G. Bavota',579,0),(1469,'V. Augustine',380,0),(1470,'P. Francis',380,0),(1471,'X. Qu',380,0),(1472,'W. Snipes',380,0),(1473,'C. Braunlich',580,0),(1474,'F. Anvari',581,0),(1475,'D. Richards',581,0),(1476,'M. Hitchens',581,0),(1477,'M. A. Babar',582,0),(1478,'R. Gil',583,0),(1479,'S. Ognawala',410,0),(1480,'S. Wagner',584,0),(1481,'D. Clark',319,0),(1482,'R. Feldt',585,0),(1483,'S. Poulding',585,0),(1484,'S. Yoo',319,0),(1485,'B. Ghotra',586,0),(1486,'S. McIntosh',586,0),(1487,'A. E. Hassan',586,0),(1488,'M. Kusano',587,0),(1489,'A. Chattopadhyay',587,0),(1490,'C. Wang',587,0),(1491,'V. Avdiienko',387,0),(1492,'K. Kuznetsov',387,0),(1493,'A. Gorla',588,0),(1494,'A. Zeller',387,0),(1495,'S. Arzt',419,0),(1496,'S. Rasthofer',419,0),(1497,'E. Bodden',419,0),(1498,'K. Falkner',491,0),(1499,'C. Szabo',491,0),(1500,'R. Vivian',491,0),(1501,'N. Falkner',491,0),(1502,'M. M. Pourhashem Kallehbasti',589,0),(1503,'J. Siegmund',196,0),(1504,'N. Siegmund',196,0),(1505,'Z. Gao',590,0),(1506,'Y. Liang',232,0),(1507,'M. B. Cohen',232,0),(1508,'A. M. Memon',590,0),(1509,'Z. Wang',232,0),(1510,'C. Tantithamthavorn',591,0),(1511,'S. McIntosh',511,0),(1512,'A. Ihara',591,0),(1513,'K. Matsumoto',591,0),(1514,'A. T. Nguyen',592,0),(1515,'T. N. Nguyen',592,0),(1516,'S. Mechtaev',571,0),(1517,'J. Yi',571,0),(1518,'A. Roychoudhury',571,0),(1519,'K. Dewey',593,0),(1520,'L. Nichols',593,0),(1521,'B. Hardekopf',593,0),(1522,'D. Octeau',594,0),(1523,'D. Luchaup',594,0),(1524,'M. Dering',595,0),(1525,'S. Jha',594,0),(1526,'P. McDaniel',595,0),(1527,'L. Moreno',509,0),(1528,'R. Oliveto',596,0),(1529,'A. Marcus',509,0),(1530,'S. H. Tan',571,0),(1531,'C. K枚ppe',597,0),(1532,'M. v. Eekelen',2,0),(1533,'S. Hoppenbrouwers',597,0),(1534,'N. Soundarajan',598,0),(1535,'S. Joshi',598,0),(1536,'R. Ramnath',598,0),(1537,'L. Guerrouj',599,0),(1538,'D. Bourque',599,0),(1539,'P. C. Rigby',599,0),(1540,'M. W. Whalen',600,0),(1541,'S. Person',601,0),(1542,'N. Rungta',602,0),(1543,'M. Staats',603,0),(1544,'D. Grijincu',604,0),(1545,'J. Gui',231,0),(1546,'S. Mcilroy',605,0),(1547,'M. Nagappan',283,0),(1548,'F. Hermans',14,0),(1549,'A. Nistor',606,0),(1550,'P. Chang',607,0),(1551,'C. Radoi',486,0),(1552,'S. Lu',608,0),(1553,'G. Denaro',609,0),(1554,'A. Margara',610,0),(1555,'M. Pezz猫',610,0),(1556,'M. Vivanti',610,0),(1557,'J. G. Hall',611,0),(1558,'L. Rapanotti',611,0),(1559,'B. Boehm',612,0),(1560,'S. K. Mobasser',612,0),(1561,'C. Treude',613,0),(1562,'M. Sicard',614,0),(1563,'M. Klocke',614,0),(1564,'M. Robillard',614,0),(1565,'D. Zou',46,0),(1566,'R. Wang',46,0),(1567,'H. Mei',46,0),(1568,'M. Vakilian',615,0),(1569,'R. Sauciuc',615,0),(1570,'J. D. Morgenthaler',615,0),(1571,'V. Mirrokni',615,0),(1572,'Y. Pan',616,0),(1573,'J. White',616,0),(1574,'Y. Sun',617,0),(1575,'J. Gray',618,0),(1576,'M. Goldstein',619,0),(1577,'I. Segall',619,0),(1578,'Z. Yu',620,0),(1579,'C. Bai',620,0),(1580,'K. Cai',620,0),(1581,'R. Chitchyan',621,0),(1582,'W. Cazzola',622,0),(1583,'A. Rashid',623,0),(1584,'L. Peters',1,0),(1585,'A. M. Moreno',1,0),(1586,'T. D. LaToza',548,0),(1587,'M. Chen',624,0),(1588,'L. Jiang',624,0),(1589,'M. Zhao',548,0),(1590,'A. v. d. Hoek',548,0),(1591,'D. Gopan',625,0),(1592,'E. Driscoll',625,0),(1593,'D. Nguyen',626,0),(1594,'D. Naydich',626,0),(1595,'A. Loginov',626,0),(1596,'D. Melski',626,0),(1597,'S. Ben-David',627,0),(1598,'B. Sterin',628,0),(1599,'J. M. Atlee',627,0),(1600,'S. Beidu',627,0),(1601,'K. Herzig',629,0),(1602,'N. Nagappan',177,0),(1603,'L. Baresi',630,0),(1604,'L. Goix',631,0),(1605,'S. Guinea',630,0),(1606,'V. Panzica La Manna',632,0),(1607,'J. Aliprandi',630,0),(1608,'D. Archetti',630,0),(1609,'A. Pathak',633,0),(1610,'V. Issarny',633,0),(1611,'J. Holston',485,0),(1612,'J. Shin',396,0),(1613,'A. Rusakov',396,0),(1614,'E. Janke',634,0),(1615,'P. Brune',634,0),(1616,'E. Kalliamvakou',2,0),(1617,'L. Singer',2,0),(1618,'D. M. German',2,0),(1619,'E. Wong',635,0),(1620,'L. Zhang',635,0),(1621,'S. Wang',635,0),(1622,'T. Liu',635,0),(1623,'L. Tan',635,0),(1624,'E. Cavalcante',636,0),(1625,'Y. Y. Lee',637,0),(1626,'D. Marinov',637,0),(1627,'R. E. Johnson',637,0),(1628,'M. Tan',638,0),(1629,'L. Tan',638,0),(1630,'S. Dara',639,0),(1631,'C. Mayeux',639,0),(1632,'A. Rashid',640,0),(1633,'K. Moore',640,0),(1634,'C. May-Chahal',640,0),(1635,'J. Lee',623,0),(1636,'G. Kotonya',623,0),(1637,'J. Whittle',623,0),(1638,'C. Bull',623,0),(1639,'L. Haaranen',2,0),(1640,'P. Ihantola',2,0),(1641,'J. Sorva',2,0),(1642,'A. Vihavainen',2,0),(1643,'T. Gvero',641,0),(1644,'V. Kuncak',641,0),(1645,'J. v. Gogh',2,0),(1646,'C. Jaspan',2,0),(1647,'E. S枚derberg',2,0),(1648,'C. Winter',2,0),(1649,'Y. Zhang',642,0),(1650,'J. Wang',642,0),(1651,'Z. Liu',643,0),(1652,'M. Vakilian',228,0),(1653,'A. Phaosawasdi',228,0),(1654,'M. D. Ernst',75,0),(1655,'R. E. Johnson',228,0),(1656,'L. Li',2,0),(1657,'A. Bartel',2,0),(1658,'T. F. Bissyand茅',2,0),(1659,'J. Klein',2,0),(1660,'Y. Le Traon',2,0),(1661,'S. Arzt',2,0),(1662,'S. Rasthofer',2,0),(1663,'E. Bodden',2,0),(1664,'D. Octeau',2,0),(1665,'P. McDaniel',2,0),(1666,'M. Kl盲s',644,0),(1667,'T. Bauer',644,0),(1668,'A. Dereani',645,0),(1669,'T. S枚derqvist',646,0),(1670,'P. Helle',647,0),(1671,'K. C. Foo',648,0),(1672,'Z. M. Jiang',649,0),(1673,'B. Adams',414,0),(1674,'A. E. Hassan',605,0),(1675,'Y. Zou',605,0),(1676,'P. Flora',648,0),(1677,'M. J盲gemar',650,0),(1678,'G. Dodig-Crnkovic',651,0),(1679,'C. R. Rupakheti',652,0),(1680,'S. V. Chenoweth',652,0),(1681,'I. Salman',653,0),(1682,'A. T. Misirli',654,0),(1683,'N. Juristo',653,0),(1684,'Q. Yi',655,0),(1685,'Z. Yang',656,0),(1686,'J. Liu',655,0),(1687,'C. Zhao',655,0),(1688,'C. Wang',657,0),(1689,'W. Yang',637,0),(1690,'X. Xiao',658,0),(1691,'B. Andow',305,0),(1692,'S. Li',637,0),(1693,'T. Xie',637,0),(1694,'W. Enck',305,0),(1695,'J. Etienne',573,0),(1696,'F. Anseaume',573,0),(1697,'V. Delebarre',573,0),(1698,'R. Kazman',659,0),(1699,'Y. Cai',660,0),(1700,'R. Mo',660,0),(1701,'Q. Feng',660,0),(1702,'L. Xiao',660,0),(1703,'S. Haziyev',661,0),(1704,'V. Fedak',661,0),(1705,'A. Shapochka',661,0),(1706,'A. Elliott',305,0),(1707,'B. Peiris',2,0),(1708,'A. v. d. Hoek',2,0),(1709,'C. Becker',662,0),(1710,'L. Duboc',663,0),(1711,'S. Easterbrook',664,0),(1712,'B. Penzenstadler',665,0),(1713,'C. C. Venters',666,0),(1714,'G. Regis',667,0),(1715,'R. Degiovanni',667,0),(1716,'N. D\'Ippolito',668,0),(1717,'N. Aguirre',667,0),(1718,'F. S. Ocariza',494,0),(1719,'C. Theisen',669,0),(1720,'P. Morrison',669,0),(1721,'B. Murphy',629,0),(1722,'L. Williams',669,0),(1723,'P. Newman',623,0),(1724,'M. A. Ferrario',670,0),(1725,'W. Simm',623,0),(1726,'S. Forshaw',671,0),(1727,'A. Friday',623,0),(1728,'L. Baresi',589,0),(1729,'M. Rossi',589,0),(1730,'C. Casalnuovo',672,0),(1731,'P. Devanbu',672,0),(1732,'A. Oliveira',672,0),(1733,'V. Filkov',672,0),(1734,'B. Ray',672,0),(1735,'M. Waterman',673,0),(1736,'G. Allan',173,0),(1737,'Na Meng',519,0),(1738,'L. Hua',519,0),(1739,'Miryung Kim',215,0),(1740,'K. S. McKinley',177,0),(1741,'M. Squire',674,0),(1742,'T. V. Wilkins',675,0),(1743,'J. C. Georgas',675,0),(1744,'H. Rajan',592,0),(1745,'G. T. Leavens',676,0),(1746,'R. Dyer',677,0),(1747,'H. Song',678,0),(1748,'A. Elgammal',679,0),(1749,'V. Nallur',679,0),(1750,'F. Chauvel',678,0),(1751,'F. Fleurey',678,0),(1752,'S. Clarke',679,0),(1753,'S. Nanz',396,0),(1754,'E. K. Smith',680,0),(1755,'J. Zhu',562,0),(1756,'P. He',562,0),(1757,'Q. Fu',681,0),(1758,'H. Zhang',266,0),(1759,'D. Zhang',266,0),(1760,'R. Yandrapally',682,0),(1761,'G. Sridhara',682,0),(1762,'S. Sinha',682,0),(1763,'F. Peters',683,0),(1764,'L. Layman',684,0),(1765,'J. Huang',2,0),(1766,'Q. Luo',2,0),(1767,'G. Rosu',2,0),(1768,'P. Avgustinov',685,0),(1769,'A. I. Baars',685,0),(1770,'A. S. Henriksen',685,0),(1771,'G. Lavender',685,0),(1772,'G. Menzel',685,0),(1773,'O. d. Moor',2,0),(1774,'M. Sch盲fer',685,0),(1775,'J. Tibble',685,0),(1776,'M. Paasivaara',686,0),(1777,'K. Blincoe',687,0),(1778,'C. Lassenius',686,0),(1779,'D. Damian',687,0),(1780,'J. Sheoran',687,0),(1781,'F. Harrison',687,0),(1782,'P. Chhabra',687,0),(1783,'A. Yussuf',687,0),(1784,'V. Isotalo',686,0),(1785,'P. Ralph',433,0),(1786,'F. Pastore',688,0),(1787,'L. Mariani',689,0),(1788,'X. Yuan',690,0),(1789,'C. Wu',690,0),(1790,'Z. Wang',690,0),(1791,'J. Li',690,0),(1792,'P. Yew',691,0),(1793,'J. Huang',692,0),(1794,'X. Feng',690,0),(1795,'Y. Lan',693,0),(1796,'Y. Chen',690,0),(1797,'Y. Guan',694,0),(1798,'G. Petrosyan',614,0),(1799,'M. P. Robillard',614,0),(1800,'R. De Mori',614,0),(1801,'Q. Gao',46,0),(1802,'Y. Mi',46,0),(1803,'W. Yang',46,0),(1804,'Z. Zhou',46,0),(1805,'K. Marasovic',695,0),(1806,'M. Lutz',424,0),(1807,'K. R. Jayaram',696,0),(1808,'C. V. Alexandru',123,0),(1809,'H. C. Gall',123,0),(1810,'S. Winter',697,0),(1811,'O. Schwahn',697,0),(1812,'R. Natella',698,0),(1813,'N. Suri',697,0),(1814,'D. Cotroneo',698,0),(1815,'S. Yang',2,0),(1816,'D. Yan',2,0),(1817,'H. Wu',2,0),(1818,'Y. Wang',2,0),(1819,'A. Rountev',2,0),(1820,'V. Pham',276,0),(1821,'W. B. Ng',276,0),(1822,'K. Rubinov',276,0),(1823,'A. Roychoudhury',276,0),(1824,'M. Wermelinger',699,0),(1825,'J. G. Hall',699,0),(1826,'L. Rapanotti',699,0),(1827,'L. Barroca',699,0),(1828,'M. Ramage',699,0),(1829,'A. Bandara',699,0),(1830,'L. Camilloni',2,0),(1831,'D. Vallespir',2,0),(1832,'M. Ardis',2,0),(1833,'C. Henard',700,0),(1834,'M. Papadakis',700,0),(1835,'Y. Le Traon',700,0),(1836,'M. Song',519,0),(1837,'J. Pinedo',519,0),(1838,'A. Carzaniga',610,0),(1839,'A. Mattavelli',610,0),(1840,'H. Zhou',266,0),(1841,'J. Lou',266,0),(1842,'H. Lin',701,0),(1843,'H. Lin',266,0),(1844,'T. Qin',266,0),(1845,'B. Barn',702,0),(1846,'R. Barn',703,0),(1847,'F. Raimondi',702,0),(1848,'E. S. Monsalve',704,0),(1849,'J. C. S. d. P. Leite',2,0),(1850,'V. M. B. Werneck',705,0),(1851,'Y. Jia',250,0),(1852,'M. B. Cohen',489,0),(1853,'J. Petke',250,0),(1854,'M. Barnett',177,0),(1855,'J. Brunet',8,0),(1856,'P. W. McBurney',144,0),(1857,'A. v. Rhein',2,0),(1858,'A. Grebhahn',196,0),(1859,'D. Beyer',196,0),(1860,'T. Berger',638,0),(1861,'Y. Park',706,0),(1862,'S. Hong',706,0),(1863,'M. Kim',706,0),(1864,'D. Lee',707,0),(1865,'J. Cho',707,0),(1866,'T. Lutellier',638,0),(1867,'D. Chollak',638,0),(1868,'J. Garcia',536,0),(1869,'D. Rayside',638,0),(1870,'R. Kroeger',708,0),(1871,'M. Papadakis',709,0),(1872,'Y. Jia',710,0),(1873,'M. Harman',710,0),(1874,'Y. Le Traon',709,0),(1875,'J. L. C谩novas Izquierdo',2,0),(1876,'J. Cabot',2,0),(1877,'N. Hanakawa',711,0),(1878,'J. Bishop',177,0),(1879,'R. N. Horspool',162,0),(1880,'T. Xie',228,0),(1881,'N. Tillmann',712,0),(1882,'J. d. Halleux',2,0),(1883,'I. I. Yusuf',713,0),(1884,'I. E. Thomas',461,0),(1885,'M. Spichkova',461,0),(1886,'S. Androulakis',714,0),(1887,'G. R. Meyer',714,0),(1888,'D. W. Drumm',461,0),(1889,'G. Opletal',461,0),(1890,'S. P. Russo',461,0),(1891,'A. M. Buckle',714,0),(1892,'H. W. Schmidt',461,0),(1893,'W. Mauerer',715,0),(1894,'D. Riehle',716,0),(1895,'A. Milicevic',717,0),(1896,'J. P. Near',717,0),(1897,'E. Kang',717,0),(1898,'D. Jackson',717,0),(1899,'A. Filieri',584,0),(1900,'L. Grunske',584,0),(1901,'A. Leva',417,0),(1902,'J. Anderson',2,0),(1903,'S. Salem',2,0),(1904,'H. Do',2,0),(1905,'B. Caglayan',718,0),(1906,'B. Turhan',653,0),(1907,'A. Bener',719,0),(1908,'M. Habayeb',719,0),(1909,'A. Miransky',539,0),(1910,'E. Cialini',720,0),(1911,'K. Lyons',662,0),(1912,'C. Oh',662,0),(1913,'H. Tarmazdi',491,0),(1914,'Y. Sedelmaier',721,0),(1915,'D. Landes',721,0),(1916,'C. Weiss',2,0),(1917,'C. Rubio-Gonz谩lez',10,0),(1918,'B. Liblit',74,0),(1919,'R. Qiu',722,0),(1920,'G. Yang',723,0),(1921,'C. S. Pasareanu',724,0),(1922,'S. Khurshid',722,0),(1923,'Y. Yoon',347,0),(1924,'B. A. Myers',725,0),(1925,'R. K. Saha',726,0),(1926,'L. Zhang',727,0),(1927,'S. Khurshid',726,0),(1928,'D. E. Perry',726,0),(1929,'J. Cox',728,0),(1930,'E. Bouwers',729,0),(1931,'J. Visser',728,0),(1932,'P. Sawyer',623,0),(1933,'A. Sutcliffe',623,0),(1934,'P. Rayson',623,0),(1935,'H. Erdogmus',730,0),(1936,'A. Perez',202,0),(1937,'A. Simpson',731,0),(1938,'A. Martin',731,0),(1939,'C. Cremers',731,0),(1940,'I. Flechais',731,0),(1941,'I. Martinovic',731,0),(1942,'K. Rasmussen',731,0),(1943,'T. Su',526,0),(1944,'Z. Fu',527,0),(1945,'J. He',526,0),(1946,'A. Shahzada',589,0),(1947,'V. Terragni',552,0),(1948,'C. Zhang',552,0),(1949,'K. Yskout',732,0),(1950,'R. Scandariato',732,0),(1951,'W. Joosen',732,0),(1952,'M. Lindvall',733,0),(1953,'D. Ganesan',733,0),(1954,'R. 脕rdal',733,0),(1955,'R. E. Wiegand',734,0),(1956,'A. Pecchia',735,0),(1957,'M. Cinque',735,0),(1958,'G. Carrozza',736,0),(1959,'D. Cotroneo',735,0),(1960,'P. Devanbu',737,0),(1961,'G. Gousios',14,0),(1962,'P. V. Anderson',738,0),(1963,'S. Heckman',381,0),(1964,'M. Vouk',381,0),(1965,'D. Wright',381,0),(1966,'M. Carter',381,0),(1967,'J. E. Burge',739,0),(1968,'G. C. Gannod',740,0),(1969,'M. Lavall茅e',741,0),(1970,'P. N. Robillard',741,0),(1971,'D. Matichuk',742,0),(1972,'T. Murray',742,0),(1973,'J. Andronick',742,0),(1974,'R. Jeffery',742,0),(1975,'G. Klein',742,0),(1976,'M. Staples',742,0),(1977,'Y. Xue',743,0),(1978,'Y. Li',744,0),(1979,'H. Liu',745,0),(1980,'Q. Liu',745,0),(1981,'C. Staicu',27,0),(1982,'Y. Luo',745,0),(1983,'C. Sun',527,0),(1984,'V. Le',527,0),(1985,'K. Madala',746,0),(1986,'H. Do',746,0),(1987,'D. Aceituna',2,0),(1988,'F. Sarro',250,0),(1989,'A. Petrozziello',747,0),(1990,'R. Schr枚ter',748,0),(1991,'S. Krieter',748,0),(1992,'T. Th眉m',749,0),(1993,'F. Benduhn',748,0),(1994,'G. Saake',748,0),(1995,'D. Spadini',750,0),(1996,'M. Aniche',14,0),(1997,'M. Bruntink',729,0),(1998,'A. Bacchelli',317,0),(1999,'P. Thongtanunam',751,0),(2000,'S. McIntosh',752,0),(2001,'H. Iida',751,0),(2002,'S. Cha',134,0),(2003,'S. Hong',134,0),(2004,'J. Lee',134,0),(2005,'D. Fava',753,0),(2006,'D. Shapiro',753,0),(2007,'J. Osborn',753,0),(2008,'M. Schaef',754,0),(2009,'E. J. Whitehead',753,0),(2010,'S. Hasan',2,0),(2011,'Z. King',2,0),(2012,'M. Hafiz',2,0),(2013,'A. Hindle',2,0),(2014,'I. Steinmacher',755,0),(2015,'T. U. Conte',756,0),(2016,'C. Treude',757,0),(2017,'M. A. Gerosa',757,0),(2018,'C. Loncaric',758,0),(2019,'M. D. Ernst',758,0),(2020,'E. Torlak',758,0),(2021,'B. Lin',759,0),(2022,'F. Zampetti',760,0),(2023,'G. Bavota',759,0),(2024,'M. Di Penta',760,0),(2025,'M. Lanza',759,0),(2026,'R. Oliveto',761,0),(2027,'M. Nguyen',571,0),(2028,'Y. Noller',762,0),(2029,'L. Grunske',762,0),(2030,'S. Mechtaev',276,0),(2031,'J. Yi',276,0),(2032,'Y. Cai',763,0),(2033,'L. Cao',763,0),(2034,'D. Li',231,0),(2035,'S. A. Chowdhury',764,0),(2036,'S. Mohian',764,0),(2037,'S. Mehra',764,0),(2038,'S. Gawsane',764,0),(2039,'T. T. Johnson',765,0),(2040,'C. Csallner',764,0),(2041,'J. Guo',766,0),(2042,'K. Shi',767,0),(2043,'R. van Tonder',2,0),(2044,'Y. Chen',2,0),(2045,'C. Hsieh',768,0),(2046,'O. Leng谩l',2,0),(2047,'T. Lii',768,0),(2048,'M. Tsai',2,0),(2049,'B. Wang',2,0),(2050,'F. Wang',768,0),(2051,'L. Lambers',769,0),(2052,'D. Str眉ber',770,0),(2053,'G. Taentzer',771,0),(2054,'K. Born',771,0),(2055,'J. Huebert',771,0),(2056,'A. Lovato',772,0),(2057,'D. Macedonio',773,0),(2058,'F. Spoto',772,0),(2059,'J. Thaine',75,0),(2060,'H. Palikareva',774,0),(2061,'T. Kuchta',774,0),(2062,'C. Cadar',774,0),(2063,'C. Tantithamthavorn',751,0),(2064,'K. Matsumoto',751,0),(2065,'A. Agrawal',305,0),(2066,'T. Menzies',305,0),(2067,'N. Tsantalis',775,0),(2068,'M. Mansouri',775,0),(2069,'L. Eshkevari',775,0),(2070,'D. Mazinanian',775,0),(2071,'D. Dig',487,0),(2072,'D. Spinellis',776,0),(2073,'P. Louridas',776,0),(2074,'M. Kechagia',776,0),(2075,'H. Sajnani',777,0),(2076,'V. Saini',777,0),(2077,'J. Svajlenko',778,0),(2078,'C. K. Roy',778,0),(2079,'C. V. Lopes',777,0),(2080,'A. Desai',779,0),(2081,'S. Gulwani',780,0),(2082,'V. Hingorani',779,0),(2083,'N. Jain',779,0),(2084,'A. Karkare',779,0),(2085,'M. Marron',780,0),(2086,'S. R.',779,0),(2087,'S. Roy',779,0),(2088,'C. Treude',491,0),(2089,'M. P. Robillard',781,0),(2090,'B. Miranda',7,0),(2091,'E. Cruciani',782,0),(2092,'R. Verdecchia',782,0),(2093,'N. Sultana',783,0),(2094,'J. Middleton',783,0),(2095,'J. Overbey',783,0),(2096,'M. Hafiz',783,0),(2097,'H. Banken',14,0),(2098,'E. Meijer',14,0),(2099,'X. Liu',46,0),(2100,'M. Zeng',46,0),(2101,'A. Omari',2,0),(2102,'S. Shoham',2,0),(2103,'E. Yahav',2,0),(2104,'T. T. Nguyen',2,0),(2105,'H. V. Pham',2,0),(2106,'P. M. Vu',2,0),(2107,'A. Hora',784,0),(2108,'D. Silva',785,0),(2109,'M. T. Valente',785,0),(2110,'R. Robbes',786,0),(2111,'K. Jamrozik',787,0),(2112,'P. von Styp-Rekowsky',787,0),(2113,'A. Zeller',787,0),(2114,'G. Salvaneschi',788,0),(2115,'M. Mezini',788,0),(2116,'P. R. Anish',789,0),(2117,'B. Balasubramaniam',789,0),(2118,'A. Sainani',789,0),(2119,'J. Cleland-Huang',790,0),(2120,'M. Daneva',411,0),(2121,'R. J. Wieringa',411,0),(2122,'S. Ghaisas',789,0),(2123,'Z. Chen',91,0),(2124,'B. Chen',791,0),(2125,'L. Xiao',792,0),(2126,'X. Wang',792,0),(2127,'W. Oizumi',793,0),(2128,'A. Garcia',793,0),(2129,'L. d. S. Sousa',2,0),(2130,'B. Cafeo',793,0),(2131,'Y. Zhao',794,0),(2132,'F. Hassan',2,0),(2133,'X. Wang',2,0),(2134,'L. Villarroel',579,0),(2135,'B. Russo',579,0),(2136,'R. Degiovanni',795,0),(2137,'P. Castro',795,0),(2138,'M. Arroyo',795,0),(2139,'M. Ruiz',795,0),(2140,'N. Aguirre',795,0),(2141,'M. Frias',795,0),(2142,'A. Trockman',2,0),(2143,'B. Vasilescu',2,0),(2144,'M. Papadakis',2,0),(2145,'D. Shin',2,0),(2146,'S. Yoo',2,0),(2147,'D. Bae',2,0),(2148,'W. Cui',2,0),(2149,'M. Peinado',2,0),(2150,'S. K. Cha',2,0),(2151,'Y. Fratantonio',2,0),(2152,'V. P. Kemerlis',2,0),(2153,'S. A. A. Naqvi',640,0),(2154,'R. Ramdhany',640,0),(2155,'M. Edwards',640,0),(2156,'M. A. Babar',491,0),(2157,'C. Chen',796,0),(2158,'C. Tian',796,0),(2159,'Z. Duan',796,0),(2160,'L. Zhao',796,0),(2161,'W. Chen',552,0),(2162,'Y. Liu',552,0),(2163,'C. Xu',797,0),(2164,'R. Gopinath',2,0),(2165,'M. A. Alipour',2,0),(2166,'I. Ahmed',2,0),(2167,'C. Jensen',2,0),(2168,'A. Groce',2,0),(2169,'J. Lange',2,0),(2170,'N. Ng',2,0),(2171,'B. Toninho',2,0),(2172,'N. Yoshida',2,0),(2173,'T. H. Tan',2,0),(2174,'M. Chen',2,0),(2175,'J. Sun',2,0),(2176,'Y. Liu',2,0),(2177,'脡. Andr茅',2,0),(2178,'Y. Xue',2,0),(2179,'J. S. Dong',2,0),(2180,'M. Pezz猫',2,0),(2181,'D. Zuddas',2,0),(2182,'H. Yan',798,0),(2183,'Y. Sui',799,0),(2184,'S. Chen',800,0),(2185,'J. Xue',798,0),(2186,'M. M. Bersani',801,0),(2187,'D. Bianculli',802,0),(2188,'C. Ghezzi',801,0),(2189,'S. Krstic',801,0),(2190,'P. San Pietro',801,0),(2191,'A. Sadeghi',548,0),(2192,'R. Jabbarvand',548,0),(2193,'N. Ghorbani',548,0),(2194,'H. Bagheri',803,0),(2195,'L. Xiao',804,0),(2196,'Y. Cai',804,0),(2197,'R. Kazman',805,0),(2198,'R. Mo',804,0),(2199,'Q. Feng',805,0),(2200,'Y. Lu',727,0),(2201,'Y. Lou',46,0),(2202,'S. Cheng',727,0),(2203,'Y. Zhou',806,0),(2204,'A. Radhakrishna',2,0),(2205,'N. V. Lewchenko',2,0),(2206,'S. Meier',2,0),(2207,'S. Mover',2,0),(2208,'K. C. Sripada',2,0),(2209,'D. Zufferey',2,0),(2210,'B. E. Chang',2,0),(2211,'P. Cern媒',2,0),(2212,'Y. Tian',2,0),(2213,'K. Pei',2,0),(2214,'S. Jana',2,0),(2215,'B. Ray',2,0),(2216,'D. Trabish',807,0),(2217,'A. Mattavelli',808,0),(2218,'N. Rinetzky',807,0),(2219,'C. Cadar',808,0),(2220,'T. Liu',809,0),(2221,'C. Curtsinger',810,0),(2222,'E. D. Berger',811,0),(2223,'W. You',812,0),(2224,'B. Liang',812,0),(2225,'W. Shi',812,0),(2226,'S. Zhu',812,0),(2227,'P. Wang',812,0),(2228,'S. Xie',812,0),(2229,'X. Wang',813,0),(2230,'X. Qin',813,0),(2231,'M. Bokaei Hosseini',813,0),(2232,'R. Slavin',813,0),(2233,'T. D. Breaux',537,0),(2234,'J. Niu',813,0),(2235,'N. Mirzaei',2,0),(2236,'J. Garcia',2,0),(2237,'H. Bagheri',2,0),(2238,'A. Sadeghi',2,0),(2239,'S. Malek',2,0),(2240,'E. F. Rizzi',814,0),(2241,'S. Elbaum',815,0),(2242,'M. B. Dwyer',815,0),(2243,'G. Upadhyaya',816,0),(2244,'H. Rajan',816,0),(2245,'S. Nadi',2,0),(2246,'S. Kr眉ger',2,0),(2247,'M. Mezini',2,0),(2248,'J. Rubin',717,0),(2249,'M. Rinard',717,0),(2250,'X. Huang',558,0),(2251,'H. Zhang',558,0),(2252,'X. Zhou',558,0),(2253,'M. Ali Babar',491,0),(2254,'S. Yang',558,0),(2255,'M. Dhok',2,0),(2256,'M. K. Ramanathan',2,0),(2257,'N. Sinha',682,0),(2258,'T. Zhang',2,0),(2259,'G. Upadhyaya',2,0),(2260,'A. Reinhardt',2,0),(2261,'H. Rajan',2,0),(2262,'M. Kim',2,0),(2263,'T. Yu',817,0),(2264,'M. B. Cohen',818,0),(2265,'S. Wang',819,0),(2266,'S. Ali',819,0),(2267,'T. Yue',819,0),(2268,'Y. Li',820,0),(2269,'M. Liaaen',821,0),(2270,'Y. Zhang',822,0),(2271,'Y. Sui',823,0),(2272,'J. Xue',822,0),(2273,'M. Coblenz',537,0),(2274,'J. Sunshine',537,0),(2275,'J. Aldrich',537,0),(2276,'B. Myers',537,0),(2277,'S. Weber',824,0),(2278,'F. Shull',824,0),(2279,'P. C. Rigby',554,0),(2280,'Y. C. Zhu',554,0),(2281,'S. M. Donadelli',554,0),(2282,'A. Mockus',825,0),(2283,'D. Menendez',2,0),(2284,'S. Nagarakatte',2,0),(2285,'S. Schulze',748,0),(2286,'X. Gu',826,0),(2287,'H. Zhang',827,0),(2288,'S. Kim',826,0),(2289,'Z. Ren',828,0),(2290,'H. Jiang',828,0),(2291,'J. Xuan',829,0),(2292,'X. Jing',249,0),(2293,'F. Qi',249,0),(2294,'F. Wu',249,0),(2295,'B. Xu',830,0),(2296,'M. Papadakis',474,0),(2297,'A. Legay',633,0),(2298,'O. Kononenko',428,0),(2299,'O. Baysal',831,0),(2300,'M. W. Godfrey',428,0),(2301,'C. Nguyen',485,0),(2302,'B. Mehne',485,0),(2303,'J. Demmel',485,0),(2304,'W. Kahan',485,0),(2305,'C. Iancu',832,0),(2306,'W. Lavrijsen',832,0),(2307,'D. H. Bailey',832,0),(2308,'D. Hough',833,0),(2309,'Q. Lin',266,0),(2310,'E. Choi',751,0),(2311,'L. Li',559,0),(2312,'J. Melo',834,0),(2313,'C. Brabrand',834,0),(2314,'A. Wasowski',834,0),(2315,'H. Sun',91,0),(2316,'X. Zhang',830,0),(2317,'Y. Zheng',92,0),(2318,'Q. Zeng',835,0),(2319,'J. Huang',836,0),(2320,'I. Manotas',426,0),(2321,'R. Zhang',837,0),(2322,'C. Jaspan',838,0),(2323,'C. Sadowski',838,0),(2324,'J. Clause',426,0),(2325,'A. Bacchelli',14,0),(2326,'O. Semer谩th',839,0),(2327,'A. S. Nagy',839,0),(2328,'D. Varr贸',752,0),(2329,'R. Ben Abdessalem',198,0),(2330,'S. Nejati',198,0),(2331,'L. C. Briand',198,0),(2332,'T. Stifter',840,0),(2333,'F. Long',841,0),(2334,'M. Rinard',841,0),(2335,'M. Hasan',413,0),(2336,'F. Zhang',511,0),(2337,'Q. Zheng',511,0),(2338,'Y. Zou',842,0),(2339,'J. Lin',48,0),(2340,'R. Jabbarvand',48,0),(2341,'J. Garcia',48,0),(2342,'S. Malek',48,0),(2343,'M. Marcozzi',774,0),(2344,'S. Bardin',843,0),(2345,'N. Kosmatov',843,0),(2346,'M. Papadakis',844,0),(2347,'V. Prevosto',843,0),(2348,'L. Correnson',843,0),(2349,'J. Kim',2,0),(2350,'D. Batory',2,0),(2351,'D. Dig',2,0),(2352,'M. Azanza',2,0),(2353,'P. Bian',812,0),(2354,'Y. Zhang',812,0),(2355,'K. Moran',388,0),(2356,'B. Li',388,0),(2357,'C. Bernal-C谩rdenas',388,0),(2358,'D. Jelf',388,0),(2359,'A. Vahabzadeh',494,0),(2360,'A. Stocco',494,0),(2361,'P. M. Uesbeck',845,0),(2362,'A. Stefik',845,0),(2363,'S. Hanenberg',846,0),(2364,'J. Pedersen',845,0),(2365,'P. Daleiden',845,0),(2366,'J. Patra',2,0),(2367,'P. N. Dixit',2,0),(2368,'S. Alimadadi',494,0),(2369,'M. Raghothaman',847,0),(2370,'Y. Wei',629,0),(2371,'Y. Hamadi',848,0),(2372,'X. Ye',849,0),(2373,'H. Shen',849,0),(2374,'X. Ma',849,0),(2375,'R. Bunescu',849,0),(2376,'C. Liu',849,0),(2377,'J. Kubelka',2,0),(2378,'R. Robbes',2,0),(2379,'A. Bergel',2,0),(2380,'S. H. Tan',850,0),(2381,'Z. Dong',571,0),(2382,'X. Gao',571,0),(2383,'K. Wang',2,0),(2384,'C. Zhu',2,0),(2385,'A. Celik',2,0),(2386,'M. Gligoric',2,0),(2387,'M. A. Gulzar',215,0),(2388,'M. Interlandi',215,0),(2389,'S. Yoo',215,0),(2390,'S. D. Tetali',215,0),(2391,'T. Condie',215,0),(2392,'T. Millstein',215,0),(2393,'J. Eckhardt',410,0),(2394,'A. Vogelsang',410,0),(2395,'J. Zhai',2,0),(2396,'S. Ma',2,0),(2397,'X. Zhang',2,0),(2398,'L. Tan',2,0),(2399,'J. Zhao',2,0),(2400,'F. Qin',2,0),(2401,'V. Hellendoorn',2,0),(2402,'S. Godhane',2,0),(2403,'Z. Tu',2,0),(2404,'A. Bacchelli',2,0),(2405,'P. Devanbu',2,0),(2406,'P. Wang',851,0),(2407,'Y. Wu',851,0),(2408,'Y. Xu',851,0),(2409,'X. Lu',46,0),(2410,'H. Li',46,0),(2411,'Q. Mei',852,0),(2412,'F. Feng',853,0),(2413,'H. Peleg',2,0),(2414,'C. Treude',2,0),(2415,'I. Steinmacher',2,0),(2416,'I. Wiese',2,0),(2417,'G. Pinto',2,0),(2418,'M. Storey',2,0),(2419,'M. A. Gerosa',2,0),(2420,'B. Chen',278,0),(2421,'W. Le',854,0),(2422,'I. S. Wiese',2,0),(2423,'X. Xie',2,0),(2424,'Z. Liu',2,0),(2425,'S. Song',2,0),(2426,'Z. Chen',2,0),(2427,'J. Xuan',2,0),(2428,'B. Xu',2,0),(2429,'D. Alrajeh',774,0),(2430,'A. van Lamsweerde',855,0),(2431,'J. Kramer',774,0),(2432,'A. Russo',774,0),(2433,'S. Uchitel',774,0),(2434,'M. B. Hosseini',813,0),(2435,'J. Hester',509,0),(2436,'R. Krishnan',813,0),(2437,'J. Bhatia',537,0),(2438,'G. Robles',856,0),(2439,'G. Poo-Caama帽o',162,0),(2440,'X. Yang',857,0),(2441,'H. Iida',858,0),(2442,'K. Inoue',857,0),(2443,'G. Su',571,0),(2444,'D. S. Rosenblum',571,0),(2445,'G. Tamburrelli',2,0),(2446,'C. Vendome',859,0),(2447,'G. Bavota',610,0),(2448,'D. Poshyvanyk',859,0),(2449,'N. Busany',12,0),(2450,'M. Rath',860,0),(2451,'J. Rendall',861,0),(2452,'J. L. C. Guo',752,0),(2453,'J. Cleland-Huang',861,0),(2454,'P. M盲der',860,0),(2455,'H. Yu',402,0),(2456,'C. Henard',166,0),(2457,'M. Papadakis',166,0),(2458,'Y. Le Traon',166,0),(2459,'S. Grant',494,0),(2460,'H. Cech',862,0),(2461,'I. Beschastnikh',494,0),(2462,'A. A. Sawant',14,0),(2463,'P. Zhang',2,0),(2464,'J. Wang',2,0),(2465,'Y. Lin',2,0),(2466,'Y. Lu',863,0),(2467,'S. Chaudhuri',863,0),(2468,'C. Jermaine',863,0),(2469,'D. Melski',814,0),(2470,'M. Madsen',638,0),(2471,'F. Tip',17,0),(2472,'E. Andreasen',16,0),(2473,'J. P. Near',2,0),(2474,'D. Jackson',2,0),(2475,'R. Kazman',864,0),(2476,'H. C. Gall',317,0),(2477,'K. Stol',865,0),(2478,'B. Fitzgerald',865,0),(2479,'Y. Li',10,0),(2480,'Q. Zhang',10,0),(2481,'T. Gu',10,0),(2482,'K. Rubinov',866,0),(2483,'L. Rosculete',867,0),(2484,'T. Mitra',276,0),(2485,'R. E. S. Santos',868,0),(2486,'F. Q. B. da Silva',868,0),(2487,'C. V. C. de Magalh茫es',868,0),(2488,'C. V. F. Monteiro',869,0),(2489,'J. Jeon',870,0),(2490,'X. Qiu',717,0),(2491,'J. Fetter-Degges',870,0),(2492,'J. S. Foster',870,0),(2493,'A. Solar-Lezama',717,0),(2494,'Z. Qin',388,0),(2495,'Y. Tang',388,0),(2496,'E. Novak',388,0),(2497,'Q. Li',388,0),(2498,'M. Christakis',396,0),(2499,'P. M眉ller',396,0),(2500,'V. W眉stholz',396,0),(2501,'X. Yu',305,0),(2502,'G. Jin',305,0),(2503,'H. Phan',592,0),(2504,'H. A. Nguyen',592,0),(2505,'N. M. Tran',509,0),(2506,'L. H. Truong',509,0),(2507,'T. N. Nguyen',509,0),(2508,'S. Arzt',871,0),(2509,'E. Bodden',871,0),(2510,'W. Yang',2,0),(2511,'M. Prasad',872,0),(2512,'T. Xie',2,0),(2513,'B. Vasilescu',873,0),(2514,'K. Blincoe',874,0),(2515,'Q. Xuan',875,0),(2516,'C. Casalnuovo',873,0),(2517,'D. Damian',876,0),(2518,'P. Devanbu',873,0),(2519,'V. Filkov',873,0),(2520,'J. Chen',2,0),(2521,'W. Hu',2,0),(2522,'L. Zhang',2,0),(2523,'B. Xie',2,0),(2524,'P. Wang',2,0),(2525,'Q. Bao',2,0),(2526,'L. Wang',2,0),(2527,'S. Wang',2,0),(2528,'T. Wei',2,0),(2529,'D. Wu',2,0),(2530,'S. Bhatia',877,0),(2531,'P. Kohli',878,0),(2532,'R. Singh',177,0),(2533,'R. Matinnejad',802,0),(2534,'S. Nejati',802,0),(2535,'L. C. Briand',802,0),(2536,'T. Bruckmann',879,0),(2537,'F. Medeiros',8,0),(2538,'C. K盲stner',880,0),(2539,'M. Ribeiro',881,0),(2540,'S. Apel',882,0),(2541,'B. Hempel',2,0),(2542,'J. Lubin',2,0),(2543,'G. Lu',2,0),(2544,'R. Chugh',2,0),(2545,'L. Prechelt',379,0),(2546,'H. Schmeisky',379,0),(2547,'J. Penix',883,0),(2548,'A. Ghanbari',884,0),(2549,'Y. Wang',885,0),(2550,'G. Chen',885,0),(2551,'M. Zhou',885,0),(2552,'M. Gu',885,0),(2553,'J. Sun',885,0),(2554,'B. Wei',886,0),(2555,'Y. Li',886,0),(2556,'Z. Yang',886,0),(2557,'Y. Guo',886,0),(2558,'X. Chen',886,0),(2559,'K. Zhang',887,0),(2560,'A. Sung',888,0),(2561,'S. Kim',888,0),(2562,'Y. Kim',888,0),(2563,'Y. Jang',888,0),(2564,'J. Kim',888,0),(2565,'S. Tokumoto',889,0),(2566,'K. Takayama',889,0),(2567,'Z. Wu',890,0),(2568,'J. Liu',890,0),(2569,'X. Chen',891,0),(2570,'K. M. Kattiyan Ramamoorthy',892,0),(2571,'C. Li',885,0),(2572,'Z. Gu',885,0),(2573,'H. Zhang',885,0),(2574,'L. Yu',893,0),(2575,'R. Mudduluru',894,0),(2576,'J. Osei-Owusu',246,0),(2577,'A. Astorga',246,0),(2578,'L. Butler',246,0),(2579,'T. Xie',886,0),(2580,'G. Challen',895,0),(2581,'S. Yu',893,0),(2582,'Y. Tao',896,0),(2583,'S. Tang',896,0),(2584,'Y. Liu',190,0),(2585,'Z. Xu',896,0),(2586,'S. Qin',897,0),(2587,'R. Ahmadi',898,0),(2588,'K. Jahed',898,0),(2589,'J. Dingel',898,0),(2590,'C. Fang',893,0),(2591,'Y. Feng',893,0),(2592,'W. Zhao',893,0),(2593,'Z. Chen',893,0),(2594,'K. Kolthoff',899,0),(2595,'X. Ma',900,0),(2596,'J. Yan',900,0),(2597,'Y. Li',900,0),(2598,'J. Zhang',900,0),(2599,'M. Bagherzadeh',898,0),(2600,'N. Kahani',898,0),(2601,'D. Beyer',901,0),(2602,'T. Lemberger',901,0),(2603,'M. Soto',26,0),(2604,'Y. Wen',902,0),(2605,'J. Cao',902,0),(2606,'S. Cheng',902,0),(2607,'N. D. Q. Bui',325,0),(2608,'Y. Yu',903,0),(2609,'L. Jiang',325,0),(2610,'M. Afzal',904,0),(2611,'A. Asia',904,0),(2612,'A. Chauhan',904,0),(2613,'B. Chimdyalwar',904,0),(2614,'P. Darke',904,0),(2615,'A. Datar',904,0),(2616,'S. Kumar',904,0),(2617,'R. Venkatesh',904,0),(2618,'K. Singi',905,0),(2619,'J. C. B. R P',905,0),(2620,'S. Podder',905,0),(2621,'A. P. Burden',906,0),(2622,'P. K. Chittimalli',907,0),(2623,'K. Anand',908,0),(2624,'S. Pradhan',907,0),(2625,'S. Mitra',907,0),(2626,'C. Prakash',907,0),(2627,'R. Shere',907,0),(2628,'R. Naik',907,0),(2629,'Y. Huang',890,0),(2630,'J. Feng',890,0),(2631,'H. Zheng',890,0),(2632,'J. Zhu',890,0),(2633,'S. Wang',890,0),(2634,'W. Miao',890,0),(2635,'G. Pu',909,0),(2636,'Y. Tang',910,0),(2637,'X. Zhan',910,0),(2638,'H. Zhou',910,0),(2639,'X. Luo',910,0),(2640,'Z. Xu',911,0),(2641,'Y. Zhou',239,0),(2642,'Q. Yan',912,0),(2643,'S. Lukasczyk',154,0),(2644,'Q. Hu',287,0),(2645,'L. Ma',287,0),(2646,'X. Xie',34,0),(2647,'B. Yu',287,0),(2648,'J. Zhao',287,0),(2649,'X. Zhang',893,0),(2650,'Z. Yin',893,0),(2651,'Q. Shi',893,0),(2652,'J. Liu',893,0),(2653,'S. Zhou',26,0),(2654,'K. Neupane',913,0),(2655,'M. Reich',914,0),(2656,'M. Kellogg',915,0),(2657,'S. Jiang',35,0),(2658,'I. Laguna',916,0),(2659,'V. S. Sharma',905,0),(2660,'R. Mehra',905,0),(2661,'B. Castro',917,0),(2662,'A. Perez',918,0),(2663,'R. Abreu',919,0),(2664,'G. Piskachev',920,0),(2665,'L. Nguyen Quang Do',921,0),(2666,'O. Johnson',920,0),(2667,'E. Bodden',922,0),(2668,'V. Tankov',923,0),(2669,'Y. Golubev',924,0),(2670,'T. Bryksin',924,0),(2671,'G. Balasubramaniam',925,0),(2672,'X. Liu',926,0),(2673,'L. Fan',927,0),(2674,'J. Xu',927,0),(2675,'X. Li',927,0),(2676,'L. Gong',927,0),(2677,'J. Grundy',32,0),(2678,'Y. Yang',928,0),(2679,'R. Meng',929,0),(2680,'B. Zhu',930,0),(2681,'H. Yun',929,0),(2682,'H. Li',930,0),(2683,'Y. Cai',929,0),(2684,'Z. Yang',930,0),(2685,'V. Sharma',931,0),(2686,'C. Artho',932,0),(2687,'M. Pande',932,0),(2688,'Q. Tang',933,0),(2689,'F. Hassan',934,0),(2690,'D. Nam',26,0),(2691,'M. Mossberg',935,0),(2692,'F. Manzano',935,0),(2693,'E. Hennenfent',935,0),(2694,'A. Groce',935,0),(2695,'G. Grieco',935,0),(2696,'J. Feist',935,0),(2697,'T. Brunson',935,0),(2698,'A. Dinaburg',935,0),(2699,'S. Zhou',116,0),(2700,'B. Shen',116,0),(2701,'H. Zhong',116,0),(2702,'C. Escobar-Vel谩squez',936,0),(2703,'M. Osorio-Ria帽o',936,0),(2704,'M. Linares-V谩squez',936,0),(2705,'S. Amreen',937,0),(2706,'A. Karnauch',937,0),(2707,'A. Mockus',937,0),(2708,'T. Du',116,0),(2709,'J. Cao',116,0),(2710,'Q. Wu',116,0),(2711,'W. Li',116,0),(2712,'Z. Li',893,0),(2713,'H. Wu',893,0),(2714,'J. Xu',893,0),(2715,'X. Wang',893,0),(2716,'L. Zhang',884,0),(2717,'D. Reuling',938,0),(2718,'U. Kelter',938,0),(2719,'S. Ruland',939,0),(2720,'M. Lochau',939,0),(2721,'S. A. Busari',940,0),(2722,'P. M. Vu',941,0),(2723,'H. V. Pham',941,0),(2724,'T. T. Nguyen',941,0),(2725,'J. Frank',942,0),(2726,'K. Bajaj',494,0),(2727,'S. Falke',943,0),(2728,'F. Merz',943,0),(2729,'C. Sinz',943,0),(2730,'G. Holzmann',944,0),(2731,'J. Braeuer',945,0),(2732,'J. Wang',946,0),(2733,'A. van Deursen',947,0),(2734,'A. ?ut卯i',948,0),(2735,'K. J. Letsholo',949,0),(2736,'L. Zhao',949,0),(2737,'E. Chioasca',949,0),(2738,'S. Okur',228,0),(2739,'M. Guerriero',950,0),(2740,'K. Narasimhan',2,0),(2741,'J. M. Hellerstein',951,0),(2742,'I. Avazpour',952,0),(2743,'J. Grundy',952,0),(2744,'L. Grunske',953,0),(2745,'J. Han',954,0),(2746,'C. Schaefer',955,0),(2747,'Hyunsook Do',955,0),(2748,'B. M. Slator',955,0),(2749,'S. Nielebock',956,0),(2750,'R. Calinescu',957,0),(2751,'K. Johnson',957,0),(2752,'Y. Rafiq',957,0),(2753,'G. J. Greene',958,0),(2754,'Y. Yang',893,0),(2755,'Y. Jiang',893,0),(2756,'Z. Zuo',893,0),(2757,'Y. Wang',893,0),(2758,'H. Sun',893,0),(2759,'H. Lu',893,0),(2760,'Y. Zhou',893,0),(2761,'B. Xu',893,0),(2762,'L. Jiang',959,0),(2763,'H. Liu',959,0),(2764,'H. Jiang',960,0),(2765,'C. M. K. Saifullah',961,0),(2766,'M. Asaduzzaman',898,0),(2767,'C. K. Roy',961,0),(2768,'S. M眉hlbauer',962,0),(2769,'S. Apel',963,0),(2770,'N. Siegmund',962,0),(2771,'D. Kim',964,0),(2772,'Y. Choi',964,0),(2773,'J. Palmerino',965,0),(2774,'Q. Yu',965,0),(2775,'T. Desell',965,0),(2776,'D. Krutz',965,0),(2777,'H. Wang',966,0),(2778,'H. Liu',886,0),(2779,'G. Meng',967,0),(2780,'T. S. Zaman',212,0),(2781,'X. Han',212,0),(2782,'X. Ren',968,0),(2783,'J. Sun',239,0),(2784,'P. H. Maia',969,0),(2785,'L. Vieira',969,0),(2786,'M. Chagas',969,0),(2787,'A. Zisman',903,0),(2788,'B. Nuseibeh',903,0),(2789,'D. Lai',970,0),(2790,'J. Rubin',970,0),(2791,'M. Endres',148,0),(2792,'G. Sakkas',971,0),(2793,'B. Cosman',971,0),(2794,'R. Jhala',971,0),(2795,'Z. Liu',239,0),(2796,'C. Treude',972,0),(2797,'Q. Guo',973,0),(2798,'S. Chen',124,0),(2799,'X. Xie',124,0),(2800,'L. Ma',974,0),(2801,'Q. Hu',974,0),(2802,'H. Liu',973,0),(2803,'J. Zhao',974,0),(2804,'X. Li',973,0),(2805,'D. Mu',893,0),(2806,'W. Guo',975,0),(2807,'A. Cuevas',975,0),(2808,'Y. Chen',975,0),(2809,'J. Gai',975,0),(2810,'X. Xing',975,0),(2811,'B. Mao',893,0),(2812,'C. Song',976,0),(2813,'C. Gladisch',977,0),(2814,'T. Heinz',977,0),(2815,'C. Heinzemann',977,0),(2816,'J. Oehlerking',977,0),(2817,'A. von Vietinghoff',977,0),(2818,'T. Pfitzer',978,0),(2819,'H. J. Kang',325,0),(2820,'T. F. Bissyand茅',979,0),(2821,'Z. Wang',973,0),(2822,'Y. Zhao',973,0),(2823,'S. Liu',973,0),(2824,'J. Sun',325,0),(2825,'X. Chen',980,0),(2826,'H. Lin',973,0),(2827,'X. Gu',189,0),(2828,'H. Zhang',981,0),(2829,'S. Kim',189,0),(2830,'L. Gong',982,0),(2831,'S. Jiang',982,0),(2832,'R. Wang',982,0),(2833,'L. Jiang',982,0),(2834,'D. Sondhi',983,0),(2835,'R. Purandare',983,0),(2836,'T. Liu',966,0),(2837,'L. Li',32,0),(2838,'G. Bai',984,0),(2839,'G. Xu',966,0),(2840,'A. Godio',985,0),(2841,'V. Bengolea',986,0),(2842,'P. Ponzio',986,0),(2843,'N. Aguirre',986,0),(2844,'M. F. Frias',985,0),(2845,'M. Nowack',933,0),(2846,'D. G. Reichelt',987,0),(2847,'S. K眉hne',987,0),(2848,'W. Hasselbring',988,0),(2849,'G. Cavalcanti',989,0),(2850,'P. Borba',989,0),(2851,'G. Seibt',154,0),(2852,'D. Stepanov',990,0),(2853,'M. Akhin',990,0),(2854,'M. Belyaev',990,0),(2855,'J. Chen',973,0),(2856,'X. He',128,0),(2857,'Q. Lin',128,0),(2858,'D. Hao',886,0),(2859,'F. Gao',991,0),(2860,'Z. Xu',991,0),(2861,'Y. Dang',991,0),(2862,'D. Zhang',128,0),(2863,'Z. Ren',960,0),(2864,'C. Liu',82,0),(2865,'U. Z. Ahmed',779,0),(2866,'R. Sindhgatta',992,0),(2867,'N. Srivastava',779,0),(2868,'A. Trindade Tavares',989,0),(2869,'S. Soares',989,0),(2870,'Z. Jia',993,0),(2871,'S. Li',993,0),(2872,'X. Liao',993,0),(2873,'J. Wang',993,0),(2874,'X. Liu',993,0),(2875,'Y. Liu',886,0),(2876,'M. Wang',886,0),(2877,'Z. Lin',128,0),(2878,'Y. Zou',886,0),(2879,'B. Xie',886,0),(2880,'Z. Yuan',994,0),(2881,'M. Feng',994,0),(2882,'F. Li',994,0),(2883,'G. Ban',994,0),(2884,'Y. Xiao',994,0),(2885,'S. Wang',994,0),(2886,'Q. Tang',994,0),(2887,'H. Su',994,0),(2888,'C. Yu',994,0),(2889,'J. Xu',994,0),(2890,'A. Piao',994,0),(2891,'J. Xuey',995,0),(2892,'W. Huo',994,0),(2893,'D. Gopinath',26,0),(2894,'H. Converse',245,0),(2895,'C. Pasareanu',996,0),(2896,'A. Taly',997,0),(2897,'J. Jiang',886,0),(2898,'R. Wang',886,0),(2899,'Y. Xiong',886,0),(2900,'X. Chen',107,0),(2901,'L. Zhang',886,0),(2902,'D. Li',893,0),(2903,'H. Wang',893,0),(2904,'C. Xu',893,0),(2905,'R. Zhang',998,0),(2906,'S. Cheung',999,0),(2907,'X. Ma',893,0),(2908,'O. Sahin',1000,0),(2909,'A. Aliyeva',1000,0),(2910,'H. Mathavan',1000,0),(2911,'A. Coskun',1000,0),(2912,'M. Egele',1000,0),(2913,'D. He',1001,0),(2914,'H. Li',1002,0),(2915,'L. Wang',930,0),(2916,'H. Meng',1002,0),(2917,'H. Zheng',930,0),(2918,'J. Liu',1002,0),(2919,'S. Hu',930,0),(2920,'L. Li',1002,0),(2921,'J. Xue',930,0),(2922,'B. Verhaeghe',1003,0),(2923,'C. Fuhrman',1004,0),(2924,'L. Guerrouj',1004,0),(2925,'N. Anquetil',1005,0),(2926,'S. Ducasse',1006,0),(2927,'A. Celik',245,0),(2928,'K. Palmskog',245,0),(2929,'M. Parovic',245,0),(2930,'E. Jes煤s Gallego Arias',1007,0),(2931,'L. Bao',1008,0),(2932,'X. Liu',25,0),(2933,'F. Wang',1008,0),(2934,'B. Fang',1008,0),(2935,'L. Bao',1009,0),(2936,'N. Busany',341,0),(2937,'D. Lo',1010,0),(2938,'B. Fischer',1011,0),(2939,'S. La Torre',1012,0),(2940,'G. Parlato',1013,0),(2941,'I. Gerostathopoulos',1014,0),(2942,'S. Kugele',1014,0),(2943,'C. Segler',1015,0),(2944,'T. Bures',1016,0),(2945,'A. Knoll',1014,0),(2946,'C. Zhou',885,0),(2947,'M. Wang',885,0),(2948,'J. Liang',885,0),(2949,'Z. Liu',1017,0),(2950,'C. Sun',1018,0),(2951,'Y. Jiang',885,0),(2952,'N. Havrikov',1019,0),(2953,'A. Zeller',1019,0),(2954,'F. Behrang',55,0),(2955,'H. Chen',124,0),(2956,'Y. Li',124,0),(2957,'M. Nejadgholi',205,0),(2958,'J. Yang',205,0),(2959,'M. Wu',190,0),(2960,'C. Liu',884,0),(2961,'Y. Zhang',190,0),(2962,'G. Wang',886,0),(2963,'B. Chen',1020,0),(2964,'Z. M. Jiang',1020,0),(2965,'P. Matos',1021,0),(2966,'M. Lacaria',1021,0),(2967,'E. Pobee',1022,0),(2968,'X. Mei',1022,0),(2969,'W. K. Chan',1022,0),(2970,'B. Paulsen',214,0),(2971,'C. Sung',214,0),(2972,'P. A.H. Peterson',1023,0),(2973,'C. Wang',214,0),(2974,'L. G. Michael',1024,0),(2975,'J. Donohue',1025,0),(2976,'J. C. Davis',1024,0),(2977,'D. Lee',1026,0),(2978,'F. Servant',1024,0),(2979,'L. Luo',921,0),(2980,'E. Bodden',1027,0),(2981,'J. Sp盲th',920,0),(2982,'V. Alizadeh',1028,0),(2983,'M. A. Ouali',148,0),(2984,'M. Kessentini',148,0),(2985,'M. Chater',148,0),(2986,'H. Chen',1029,0),(2987,'W. Dou',994,0),(2988,'F. Qin',1029,0),(2989,'E. Sherman',1030,0),(2990,'A. Harris',1030,0),(2991,'Y. Zheng',973,0),(2992,'J. Hao',973,0),(2993,'Z. Meng',973,0),(2994,'R. Shen',1031,0),(2995,'Y. Chen',1032,0),(2996,'C. Fan',1033,0),(2997,'J. Liu',896,0),(2998,'X. Shi',896,0),(2999,'M. Tsai',1034,0),(3000,'B. Wang',1034,0),(3001,'B. Yang',1034,0),(3002,'P. Cashin',1035,0),(3003,'C. Martinez',1036,0),(3004,'S. Forrest',1035,0),(3005,'F. Recoules',1037,0),(3006,'S. Bardin',1037,0),(3007,'R. Bonichon',1037,0),(3008,'L. Mounier',1038,0),(3009,'M. Potet',1038,0),(3010,'Y. Wang',913,0),(3011,'M. K枚hler',1039,0),(3012,'G. Salvaneschi',1039,0),(3013,'Q. Feng',1040,0),(3014,'Y. Cai',1040,0),(3015,'R. Kazman',1041,0),(3016,'D. Cui',290,0),(3017,'T. Liu',290,0),(3018,'H. Fang',1040,0),(3019,'C. Gao',1042,0),(3020,'J. Zeng',1042,0),(3021,'M. R. Lyu',1042,0),(3022,'I. King',1042,0),(3023,'J. Lacomis',26,0),(3024,'P. Yin',26,0),(3025,'E. Schwartz',1043,0),(3026,'M. Allamanis',128,0),(3027,'C. Le Goues',26,0),(3028,'G. Neubig',26,0),(3029,'K. W. Nafi',961,0),(3030,'T. S. Kar',961,0),(3031,'B. Roy',961,0),(3032,'K. A. Schneider',961,0),(3033,'Y. Chen',1044,0),(3034,'C. M. Poskitt',1044,0),(3035,'S. Adepu',1044,0),(3036,'F. Zhang',1045,0),(3037,'W. Eiers',345,0),(3038,'T. Brennan',345,0),(3039,'T. Bultan',345,0),(3040,'D. Moyer',1024,0),(3041,'A. M. Kazerouni',1024,0),(3042,'D. Lee',1046,0),(3043,'Y. Yulazari',341,0),(3044,'J. Liu',1047,0),(3045,'J. Zhu',1048,0),(3046,'S. He',1042,0),(3047,'P. He',1049,0),(3048,'Z. Zheng',107,0),(3049,'J. Chen',205,0),(3050,'W. Shang',205,0),(3051,'A. E. Hassan',898,0),(3052,'Y. Wang',156,0),(3053,'J. Lin',156,0),(3054,'J. Zhang',1050,0),(3055,'Q. Yi',1050,0),(3056,'D. Dechev',1051,0),(3057,'Y. Wan',239,0),(3058,'J. Shu',239,0),(3059,'Y. Sui',1052,0),(3060,'G. Xu',1052,0),(3061,'Z. Zhao',239,0),(3062,'J. Wu',239,0),(3063,'P. Yu',1053,0),(3064,'W. Zheng',1054,0),(3065,'H. Lu',1055,0),(3066,'Y. Zhou',1055,0),(3067,'J. Liang',1054,0),(3068,'H. Zheng',1054,0),(3069,'Y. Deng',1054,0),(3070,'H. Zhang',1022,0),(3071,'T. A. Rahat',1056,0),(3072,'Y. Feng',1057,0),(3073,'Y. Tian',1056,0),(3074,'X. Liu',1058,0),(3075,'L. Huang',1058,0),(3076,'J. Ge',893,0),(3077,'V. Ng',884,0),(3078,'Y. Hu',245,0),(3079,'U. Z. Ahmed',1059,0),(3080,'S. Mechtaev',1060,0),(3081,'B. Leong',1059,0),(3082,'A. Roychoudhury',1059,0),(3083,'S. Nguyen',1061,0),(3084,'T. Nguyen',1061,0),(3085,'Y. Li',88,0),(3086,'S. Wang',88,0),(3087,'Y. Wu',1062,0),(3088,'X. Li',884,0),(3089,'D. Zou',1062,0),(3090,'W. Yang',884,0),(3091,'X. Zhang',1062,0),(3092,'H. Jin',1062,0),(3093,'A. Sadiq',103,0),(3094,'L. Li',103,0),(3095,'Y. Li',103,0),(3096,'I. Ahmed',1063,0),(3097,'S. Ling',103,0),(3098,'V. Kaulgud',905,0),(3099,'A. Boronat',342,0),(3100,'A. Horvath',26,0),(3101,'A. Macvean',1064,0),(3102,'B. Myers',26,0),(3103,'S. Nguyen',1065,0),(3104,'H. Nguyen',1066,0),(3105,'N. Tran',1061,0),(3106,'H. Tran',1065,0),(3107,'T. Nguyen',1065,0),(3108,'X. Du',124,0),(3109,'J. Vedurada',1067,0),(3110,'V. K. Nandivada',1067,0),(3111,'L. Ren',886,0),(3112,'S. M. Sohan',1068,0),(3113,'C. Anslow',1068,0),(3114,'F. Maurer',1068,0),(3115,'S. Kim',241,0),(3116,'M. Faerevaag',241,0),(3117,'M. Jung',241,0),(3118,'S. Jung',241,0),(3119,'D. Oh',241,0),(3120,'J. Lee',1069,0),(3121,'H. Cohen',12,0),(3122,'Y. Lin',1070,0),(3123,'G. Meng',34,0),(3124,'Y. Xue',34,0),(3125,'Z. Xing',1071,0),(3126,'J. Sun',136,0),(3127,'X. Peng',35,0),(3128,'W. Zhao',35,0),(3129,'J. Dong',1070,0),(3130,'A. Simb眉rger',1072,0),(3131,'S. Apel',1072,0),(3132,'A. Gr枚脽linger',1072,0),(3133,'C. Lengauer',1072,0),(3134,'D. Dhungana',1073,0),(3135,'C. H. Tang',1074,0),(3136,'C. Weidenbach',1074,0),(3137,'P. Wischnewski',1075,0),(3138,'P. Barros',7,0),(3139,'R. Just',75,0),(3140,'S. Millstein',75,0),(3141,'P. Vines',75,0),(3142,'W. Dietl',638,0),(3143,'M. dAmorim',2,0),(3144,'R. Krishna',1076,0),(3145,'C. Mills',1077,0),(3146,'Y. Maezawa',1078,0),(3147,'H. Washizaki',1079,0),(3148,'Y. Tanabe',1080,0),(3149,'S. Honiden',1081,0),(3150,'N. Chen',1082,0),(3151,'R. E. Johnson',1082,0),(3152,'G. Pinto',1083,0),(3153,'A. Canino',1084,0),(3154,'F. Castor',1085,0),(3155,'G. Xu',1086,0),(3156,'Y. D. Liu',1084,0),(3157,'T. Nguyen',1087,0),(3158,'M. B. Dwyer',1087,0),(3159,'W. Visser',1088,0),(3160,'W. Song',1089,0),(3161,'X. Qian',1089,0),(3162,'J. Huang',1090,0),(3163,'N. Arora',1091,0),(3164,'Hui Zhang',1091,0),(3165,'Junghwan Rhee',1091,0),(3166,'K. Yoshihira',1091,0),(3167,'Guofei Jiang',1091,0),(3168,'J. Lin',1092,0),(3169,'E. S. Wang',1093,0),(3170,'Z. Dang',1093,0),(3171,'K. Zimmerman',652,0),(3172,'G. Tamburrelli',1094,0),(3173,'S. Scalabrino',1095,0),(3174,'G. Bavota',1096,0),(3175,'C. Vendome',1097,0),(3176,'D. Poshyvanyk',1097,0),(3177,'R. Oliveto',1095,0),(3178,'S. Ghaisas',1098,0),(3179,'M. Motwani',1098,0),(3180,'P. R. Anish',1098,0),(3181,'Y. Li',405,0),(3182,'M. Vierhauser',1099,0),(3183,'R. Rabiser',1099,0),(3184,'P. Gr眉nbacher',1100,0),(3185,'A. Egyed',1100,0),(3186,'A. T. Nguyen',225,0),(3187,'T. T. Nguyen',225,0),(3188,'T. N. Nguyen',225,0),(3189,'H. Rajan',225,0),(3190,'S. Zhang',1101,0),(3191,'Y. Sun',1101,0),(3192,'J. Li',136,0),(3193,'L. Li',136,0),(3194,'Q. L. Le',1102,0),(3195,'S. Lin',1103,0),(3196,'T. Krismayer',1104,0),(3197,'R. Rabiser',1104,0),(3198,'P. GrUnbacher',1104,0),(3199,'L. D. Toffola',1105,0),(3200,'C. Staicu',1106,0),(3201,'M. Pradel',1106,0),(3202,'R. Demasi',1107,0),(3203,'S. Mirhosseini',1108,0),(3204,'C. Parnin',1108,0),(3205,'Y. Ke',2,0),(3206,'K. T. Stolee',2,0),(3207,'C. L. Goues',2,0),(3208,'Y. Brun',2,0),(3209,'A. Sarkar',638,0),(3210,'J. Guo',638,0),(3211,'K. Czarnecki',638,0),(3212,'L. Shi',1109,0),(3213,'C. Chen',1110,0),(3214,'Q. Wang',1109,0),(3215,'S. Li',1109,0),(3216,'B. Boehm',1110,0),(3217,'E. Incerto',1111,0),(3218,'M. Tribastone',1112,0),(3219,'C. Trubiani',1111,0),(3220,'N. Sannier',1113,0),(3221,'M. Acher',1113,0),(3222,'B. Baudry',1113,0),(3223,'F. M. Kifetew',1114,0),(3224,'W. Jin',1115,0),(3225,'R. Tiella',1114,0),(3226,'A. Orso',1115,0),(3227,'P. Tonella',1114,0),(3228,'C. S. Pasareanu',1116,0),(3229,'A. Groce',1117,0),(3230,'I. Ahmed',1117,0),(3231,'C. Jensen',1117,0),(3232,'P. E. McKenney',2,0),(3233,'X. Xiao',1118,0),(3234,'S. Li',176,0),(3235,'T. Xie',176,0),(3236,'N. Tillmann',1119,0),(3237,'J. Candido',1120,0),(3238,'L. Melo',1120,0),(3239,'M. d\'Amorim',1120,0),(3240,'Y. Zhao',192,0),(3241,'A. Serebrenik',1121,0),(3242,'Y. Zhou',1122,0),(3243,'V. Filkov',1123,0),(3244,'T. Ahmed',1124,0),(3245,'A. Bosu',1125,0),(3246,'A. Iqbal',1124,0),(3247,'S. Rahimi',1125,0),(3248,'Y. Zhang',638,0),(3249,'E. Blais',638,0),(3250,'G. Daniel',1126,0),(3251,'F. Jouault',1127,0),(3252,'G. Suny茅',1126,0),(3253,'J. Cabot',1128,0),(3254,'A. Di Franco',1129,0),(3255,'H. Guo',1129,0),(3256,'C. Rubio-Gonz谩lez',1129,0),(3257,'C. Xu',1130,0),(3258,'Wenhua Yang',1130,0),(3259,'X. Ma',1130,0),(3260,'C. Cao',1130,0),(3261,'J. L眉',1130,0),(3262,'N. Kukreja',1131,0),(3263,'W. G. J. Halfond',1131,0),(3264,'M. Tambe',1131,0),(3265,'X. Gu',552,0),(3266,'S. Kim',552,0),(3267,'F. Palomba',1132,0),(3268,'G. Bavota',1133,0),(3269,'M. Di Penta',1133,0),(3270,'R. Oliveto',1134,0),(3271,'A. De Lucia',1132,0),(3272,'D. Poshyvanyk',1135,0),(3273,'M. Chandramohan',1136,0),(3274,'H. B. K. Tan',1137,0),(3275,'L. C. Briand',1137,0),(3276,'L. K. Shar',1136,0),(3277,'B. M. Padmanabhuni',1136,0),(3278,'S. Herfert',1106,0),(3279,'J. Patra',1106,0),(3280,'Z. Lin',1138,0),(3281,'Y. Zou',1138,0),(3282,'J. Zhao',1138,0),(3283,'B. Xie',1138,0),(3284,'F. Angerer',1099,0),(3285,'A. Grimmer',1099,0),(3286,'H. Pr盲hofer',1139,0),(3287,'P. Gr眉nbacher',1139,0),(3288,'S. R. Choudhary',478,0),(3289,'A. Gorla',1140,0),(3290,'L. M. Kritzinger',1141,0),(3291,'T. Krismayer',1141,0),(3292,'M. Vierhauser',1142,0),(3293,'R. Rabiser',1141,0),(3294,'P. Gr眉nbacher',1141,0),(3295,'Y. Higo',1143,0),(3296,'A. Ohtani',1143,0),(3297,'S. Kusumoto',1143,0),(3298,'H. A. de Souza',1144,0),(3299,'M. L. Chaim',1145,0),(3300,'P. Gr眉nbacher',1099,0),(3301,'J. Thanhofer-Pilisch',1099,0),(3302,'D. Bozhinoski',782,0),(3303,'D. D. Ruscio',2,0),(3304,'I. Malavolta',782,0),(3305,'P. Pelliccione',1146,0),(3306,'M. Tivoli',1146,0),(3307,'F. Thung',1010,0),(3308,'S. Wang',1010,0),(3309,'J. Lawall',1147,0),(3310,'R. Vanciu',1148,0),(3311,'M. Abi-Antoun',1148,0),(3312,'Y. K. Lee',1149,0),(3313,'P. Yoodee',1149,0),(3314,'A. Shahbazian',1149,0),(3315,'D. Nam',1149,0),(3316,'N. Medvidovic',1149,0),(3317,'Y. Sun',1150,0),(3318,'C. Chen',1151,0),(3319,'Q. Wang',1150,0),(3320,'B. Boehm',1151,0),(3321,'C. Tian',1152,0),(3322,'Z. Duan',1152,0),(3323,'C. -. L. Ong',1153,0),(3324,'M. Kowal',749,0),(3325,'M. Tschaikowski',1154,0),(3326,'M. Tribastone',1154,0),(3327,'I. Schaefer',749,0),(3328,'J. Nam',552,0),(3329,'L. Schmidt',1155,0),(3330,'A. Narayan',1155,0),(3331,'S. Fischmeister',1155,0),(3332,'M. Menarini',1156,0),(3333,'Y. Yan',1156,0),(3334,'W. G. Griswold',1156,0),(3335,'D. Liew',1157,0),(3336,'D. Schemmel',1158,0),(3337,'C. Cadar',1157,0),(3338,'A. F. Donaldson',1157,0),(3339,'R. Zahl',1158,0),(3340,'K. Wehrle',1158,0),(3341,'G. Scanniello',1159,0),(3342,'C. Gravino',1160,0),(3343,'A. Marcus',1161,0),(3344,'T. Menzies',1162,0),(3345,'D. W眉est',1163,0),(3346,'N. Seyff',1163,0),(3347,'M. Glinz',1163,0),(3348,'W. Weimer',1164,0),(3349,'Z. P. Fry',1164,0),(3350,'S. Forrest',1165,0),(3351,'A. Alshanqiti',2,0),(3352,'R. Heckel',2,0),(3353,'G. Uddin',1166,0),(3354,'F. Khomh',1167,0),(3355,'R. Casta帽o',1168,0),(3356,'V. Braberman',1168,0),(3357,'D. Garbervetsky',1168,0),(3358,'S. Uchitel',1168,0),(3359,'A. N. Lam',592,0),(3360,'C. Pietsch',1169,0),(3361,'M. Ohrndorf',1169,0),(3362,'U. Kelter',1169,0),(3363,'T. Kehrer',1170,0),(3364,'Lu Zhang',1171,0),(3365,'A. Chattopadhyay',1171,0),(3366,'C. Wang',1171,0),(3367,'K. F. T贸masd贸ttir',1172,0),(3368,'M. Aniche',1172,0),(3369,'A. van Deursen',1172,0),(3370,'E. Alatawi',1173,0),(3371,'H. S鈯榥dergaard',1173,0),(3372,'T. Miller',1173,0),(3373,'S. Holavanalli',1174,0),(3374,'D. Manuel',1174,0),(3375,'V. Nanjundaswamy',1174,0),(3376,'B. Rosenberg',1174,0),(3377,'F. Shen',1174,0),(3378,'S. Y. Ko',1174,0),(3379,'L. Ziarek',1174,0),(3380,'K. M. Annervaz',1175,0),(3381,'V. Kaulgud',1175,0),(3382,'S. Sengupta',1175,0),(3383,'M. Savagaonkar',1175,0),(3384,'H. Fudaba',751,0),(3385,'Y. Oda',751,0),(3386,'K. Akabe',751,0),(3387,'G. Neubig',751,0),(3388,'H. Hata',751,0),(3389,'S. Sakti',751,0),(3390,'T. Toda',751,0),(3391,'S. Nakamura',751,0),(3392,'P. Ohmann',1176,0),(3393,'B. Liblit',1176,0),(3394,'D. D. Nardo',2,0),(3395,'F. Pastore',1177,0),(3396,'A. Arcuri',1177,0),(3397,'L. Briand',1177,0),(3398,'F. Corradini',1178,0),(3399,'F. Fornari',1178,0),(3400,'A. Polini',1178,0),(3401,'B. Re',1178,0),(3402,'F. Tiezzi',1178,0),(3403,'A. Vandin',1179,0),(3404,'Y. Zou',1180,0),(3405,'T. Ye',1180,0),(3406,'Y. Lu',1180,0),(3407,'J. Mylopoulos',664,0),(3408,'L. Zhang',1180,0),(3409,'J. Lin',1180,0),(3410,'C. Luo',1180,0),(3411,'S. Cai',763,0),(3412,'K. Su',1181,0),(3413,'D. Hao',1180,0),(3414,'E. G. Mercer',1182,0),(3415,'P. Anderson',1182,0),(3416,'N. Vrvilo',863,0),(3417,'V. Sarkar',863,0),(3418,'Y. Wang',1183,0),(3419,'M. Zhou',1183,0),(3420,'Y. Jiang',1183,0),(3421,'X. Song',1184,0),(3422,'M. Gu',1183,0),(3423,'J. Sun',1183,0),(3424,'O. Legunsen',1082,0),(3425,'A. Shi',1082,0),(3426,'D. Marinov',1082,0),(3427,'Y. Huang',1185,0),(3428,'E. Mercer',1185,0),(3429,'J. McCarthy',1185,0),(3430,'L. Chen',1186,0),(3431,'Y. Pei',1186,0),(3432,'C. A. Furia',1187,0),(3433,'H. Saada',1188,0),(3434,'M. Huchard',1188,0),(3435,'C. Nebut',1188,0),(3436,'H. Sahraoui',1189,0),(3437,'Y. Lin',1190,0),(3438,'D. Dig',1117,0),(3439,'C. Artho',1191,0),(3440,'M. Seidl',529,0),(3441,'Q. Gros',1192,0),(3442,'E. Choi',1191,0),(3443,'T. Kitamura',1191,0),(3444,'A. Mori',1191,0),(3445,'R. Ramler',1193,0),(3446,'Y. Yamagata',1193,0),(3447,'H. V. Nguyen',1194,0),(3448,'H. A. Nguyen',1194,0),(3449,'T. T. Nguyen',1194,0),(3450,'A. T. Nguyen',1194,0),(3451,'T. N. Nguyen',1194,0),(3452,'M. Waterloo',1195,0),(3453,'S. Person',1195,0),(3454,'S. Elbaum',1195,0),(3455,'W. Wang',1196,0),(3456,'Y. Kwon',1196,0),(3457,'Y. Zheng',1197,0),(3458,'Y. Aafer',1196,0),(3459,'I. Kim',1196,0),(3460,'W. Lee',1196,0),(3461,'Y. Liu',1196,0),(3462,'W. Meng',1196,0),(3463,'X. Zhang',1196,0),(3464,'P. Eugster',1196,0),(3465,'Y. Rafiq',1198,0),(3466,'L. Dickens',1199,0),(3467,'A. Russo',1198,0),(3468,'A. K. Bandara',903,0),(3469,'M. Yang',1200,0),(3470,'A. Stuart',1201,0),(3471,'M. Levine',1201,0),(3472,'G. Calikli',1202,0),(3473,'B. A. Price',903,0),(3474,'L. Martie',1203,0),(3475,'T. D. LaToza',1203,0),(3476,'A. v. d. Hoek',1203,0),(3477,'H. Xiao',1092,0),(3478,'Y. Liu',1092,0),(3479,'S. Lin',1204,0),(3480,'C. Sun',1205,0),(3481,'A. Tzannes',2,0),(3482,'S. T. Heumann',2,0),(3483,'L. Eloussi',2,0),(3484,'M. Vakilian',2,0),(3485,'V. S. Adve',2,0),(3486,'M. Han',2,0),(3487,'C. Park',2,0),(3488,'S. Won',2,0),(3489,'J. Jin',2,0),(3490,'S. Ryu',2,0),(3491,'F. Corradini',1206,0),(3492,'F. Fornari',1206,0),(3493,'A. Polini',1206,0),(3494,'B. Re',1206,0),(3495,'F. Tiezzi',1206,0),(3496,'A. Vandin',1207,0),(3497,'L. Meftah',1208,0),(3498,'M. Gomez',1209,0),(3499,'R. Rouvoy',1210,0),(3500,'I. Chrisment',1211,0),(3501,'D. Xu',1196,0),(3502,'Q. Xin',1212,0),(3503,'S. P. Reiss',1212,0),(3504,'T. Rolfsnes',1213,0),(3505,'L. Moonen',1213,0),(3506,'D. Binkley',1214,0),(3507,'M. Baruwal Chhetri',1215,0),(3508,'S. Chichin',1215,0),(3509,'Q. Bao Vo',1215,0),(3510,'R. Kowalczyk',1215,0),(3511,'A. Gambi',1216,0),(3512,'W. Hummer',1217,0),(3513,'S. Dustdar',1217,0),(3514,'I. Beschastnikh',377,0),(3515,'P. Deligiannis',774,0),(3516,'A. F. Donaldson',774,0),(3517,'Z. Rakamaric',1218,0),(3518,'L. Ma',394,0),(3519,'C. Artho',1219,0),(3520,'C. Zhang',638,0),(3521,'H. Sato',394,0),(3522,'J. Gmeiner',1193,0),(3523,'B. Mathis',1220,0),(3524,'V. Avdiienko',1220,0),(3525,'E. O. Soremekun',1220,0),(3526,'M. B枚hme',1070,0),(3527,'A. Zeller',1220,0),(3528,'B. Jiang',1221,0),(3529,'Y. Wu',1221,0),(3530,'T. Li',1221,0),(3531,'W. K. Chan',1222,0),(3532,'R. Pohl',1223,0),(3533,'V. Stricker',1223,0),(3534,'K. Pohl',1223,0),(3535,'Y. Oda',591,0),(3536,'H. Fudaba',591,0),(3537,'G. Neubig',591,0),(3538,'H. Hata',591,0),(3539,'S. Sakti',591,0),(3540,'T. Toda',591,0),(3541,'S. Nakamura',591,0),(3542,'J. Lin',1224,0),(3543,'Y. Liu',1224,0),(3544,'J. Guo',1224,0),(3545,'J. Cleland-Huang',1224,0),(3546,'W. Goss',1225,0),(3547,'W. Liu',1225,0),(3548,'S. Lohar',1225,0),(3549,'N. Monaikul',1225,0),(3550,'A. Rasin',1225,0),(3551,'P. Meredith',1226,0),(3552,'G. Ro艧u',1226,0),(3553,'Z. Xu',1227,0),(3554,'M. Hirzel',1228,0),(3555,'G. Rothermel',1227,0),(3556,'K. Wu',1228,0),(3557,'Y. Yang',1229,0),(3558,'Y. Jiang',1229,0),(3559,'M. Gu',1229,0),(3560,'J. Sun',1229,0),(3561,'J. Gao',1229,0),(3562,'H. Liu',1229,0),(3563,'Z. Wang',1230,0),(3564,'H. Sun',1230,0),(3565,'Y. Fu',1230,0),(3566,'L. Ye',1230,0),(3567,'M. Kusano',1231,0),(3568,'Chao Wang',1231,0),(3569,'A. M. Fard',494,0),(3570,'E. Wohlstadter',494,0),(3571,'G. Hecht',1232,0),(3572,'O. Benomar',1233,0),(3573,'R. Rouvoy',1232,0),(3574,'N. Moha',1233,0),(3575,'L. Duchien',1232,0),(3576,'S. Wang',1234,0),(3577,'D. Wu',1234,0),(3578,'S. Lin',2,0),(3579,'T. K. Nguyen',2,0),(3580,'J. Lou',1235,0),(3581,'Q. Lin',1235,0),(3582,'R. Ding',1235,0),(3583,'Q. Fu',1235,0),(3584,'D. Zhang',1235,0),(3585,'A. F. Iosif-Lazar',834,0),(3586,'A. S. Al-Sibahi',834,0),(3587,'A. S. Dimovski',834,0),(3588,'J. E. Savolainen',2,0),(3589,'K. Sierszecki',2,0),(3590,'A. Rashid',503,0),(3591,'T. Watanabe',1236,0),(3592,'R. Khatchadourian',1237,0),(3593,'H. Masuhara',1238,0),(3594,'W. N. Sumner',1239,0),(3595,'X. Zhang',1240,0),(3596,'D. Cotroneo',1241,0),(3597,'D. Di Leo',1241,0),(3598,'F. Fucci',1241,0),(3599,'R. Natella',1241,0),(3600,'J. Zhou',1242,0),(3601,'S. Silvestro',1242,0),(3602,'H. Liu',1242,0),(3603,'Y. Cai',1243,0),(3604,'T. Liu',1242,0),(3605,'N. Tillmann',1244,0),(3606,'J. de Halleux',1244,0),(3607,'T. Xie',1082,0),(3608,'J. Bishop',1244,0),(3609,'F. Lv',1245,0),(3610,'S. Wang',560,0),(3611,'J. Zhao',561,0),(3612,'U. Karg茅n',1246,0),(3613,'N. Shahmehri',1246,0),(3614,'C. Lemieux',397,0),(3615,'D. Park',397,0),(3616,'I. Beschastnikh',397,0),(3617,'M. Sul铆r',1247,0),(3618,'J. Porub盲n',1247,0),(3619,'G. Zhang',1248,0),(3620,'X. Peng',1248,0),(3621,'Z. Xing',1092,0),(3622,'Shihai Jiang',1248,0),(3623,'Hai Wang',1248,0),(3624,'W. Zhao',1248,0),(3625,'D. Di Nardo',1249,0),(3626,'N. Alshahwan',1249,0),(3627,'L. C. Briand',1249,0),(3628,'E. Fourneret',1249,0),(3629,'T. Naki膰-Alfirevi膰',1250,0),(3630,'V. Masquelier',1250,0),(3631,'J. Lerch',419,0),(3632,'J. Sp盲th',1251,0),(3633,'M. Mezini',419,0),(3634,'S. Yang',251,0),(3635,'H. Wu',251,0),(3636,'Y. Wang',251,0),(3637,'D. Yan',615,0),(3638,'X. Cheng',1252,0),(3639,'M. Zhou',1252,0),(3640,'M. Gu',1252,0),(3641,'J. Sun',1252,0),(3642,'Y. Li',1253,0),(3643,'N. Rosner',1254,0),(3644,'J. H. Siddiqui',1255,0),(3645,'N. Aguirre',1256,0),(3646,'S. Khurshid',1257,0),(3647,'M. F. Frias',1258,0),(3648,'T. L. Nguyen',1200,0),(3649,'P. Schrammel',1259,0),(3650,'B. Fischer',1088,0),(3651,'S. L. Torre',1260,0),(3652,'G. Parlato',1200,0),(3653,'H. Xiao',1103,0),(3654,'Y. Liu',1103,0),(3655,'D. San谩n',1103,0),(3656,'H. Hansen',1261,0),(3657,'K. Mao',1262,0),(3658,'M. Harman',1262,0),(3659,'Y. Jia',1262,0),(3660,'F. Servant',1263,0),(3661,'H. Zhang',46,0),(3662,'M. J. Gerrard',1264,0),(3663,'M. B. Dwyer',1264,0),(3664,'C. Chapman',1265,0),(3665,'P. Wang',1266,0),(3666,'K. T. Stolee',1266,0),(3667,'Y. Kim',1267,0),(3668,'Y. Kim',1268,0),(3669,'Taeksu Kim',1268,0),(3670,'Gunwoo Lee',1268,0),(3671,'Y. Jang',1268,0),(3672,'M. Kim',1267,0),(3673,'E. Wong',1269,0),(3674,'Jinqiu Yang',1269,0),(3675,'Lin Tan',1269,0),(3676,'J. D. Vecchio',2,0),(3677,'F. Shen',1270,0),(3678,'K. M. Yee',1270,0),(3679,'B. Wang',1270,0),(3680,'S. Y. Ko',1270,0),(3681,'L. Ziarek',1270,0),(3682,'K. Z. Sultana',1271,0),(3683,'C. Artho',1272,0),(3684,'M. Hagiya',1078,0),(3685,'R. Potter',1078,0),(3686,'F. Weitl',1273,0),(3687,'M. Yamamoto',1273,0),(3688,'J. M. Barnes',1274,0),(3689,'A. Pandey',1274,0),(3690,'D. Garlan',1274,0),(3691,'P. Metzler',1275,0),(3692,'H. Saissi',1275,0),(3693,'P. Bokor',1275,0),(3694,'N. Suri',1275,0),(3695,'A. Leung',1276,0),(3696,'S. Lerner',1276,0),(3697,'C. Zhang',1277,0),(3698,'H. Cheng',1277,0),(3699,'E. Tang',1277,0),(3700,'X. Chen',1277,0),(3701,'L. Bu',1277,0),(3702,'X. Li',1277,0),(3703,'F. Hendijani Fard',1278,0),(3704,'D. Kavaler',1279,0),(3705,'S. Sirovica',1279,0),(3706,'V. Hellendoorn',1279,0),(3707,'R. Aranovich',1280,0),(3708,'V. Filkov',1279,0),(3709,'M. Mirakhorli',1281,0),(3710,'S. Vargas-Baldrich',570,0),(3711,'M. Linares-V谩squez',2,0),(3712,'D. Poshyvanyk',2,0),(3713,'M. M. Rahman',1282,0),(3714,'C. K. Roy',1282,0),(3715,'J. Garc铆a-Gal谩n',1283,0),(3716,'P. Trinidad',1283,0),(3717,'A. Ruiz-Cort茅s',1283,0),(3718,'K. Muslu',75,0),(3719,'L. Swart',75,0),(3720,'Y. Brun',75,0),(3721,'M. D. Ernst',201,0),(3722,'A. W枚lfl',196,0),(3723,'H. Kosch',196,0),(3724,'J. Krautlager',1284,0),(3725,'G. Weber-Urbina',1284,0),(3726,'T. Kehrer',1169,0),(3727,'G. Taentzer',1285,0),(3728,'K. Li',1286,0),(3729,'C. Reichenbach',1287,0),(3730,'Y. Smaragdakis',1288,0),(3731,'Y. Diao',1286,0),(3732,'C. Csallner',1289,0),(3733,'S. Zamanirad',1290,0),(3734,'B. Benatallah',1290,0),(3735,'M. C. Barukh',1290,0),(3736,'F. Casati',1291,0),(3737,'C. Rodriguez',1290,0),(3738,'P. Godefroid',1292,0),(3739,'H. Peleg',1293,0),(3740,'R. Singh',1292,0),(3741,'M. Paixao',1294,0),(3742,'J. Krinke',1294,0),(3743,'D. Han',1294,0),(3744,'C. Ragkhitwetsagul',1294,0),(3745,'M. Harman',1294,0),(3746,'M. Choetkiertikul',303,0),(3747,'H. K. Dam',303,0),(3748,'T. Tran',1295,0),(3749,'A. Ghose',303,0),(3750,'W. Qian',1248,0),(3751,'Y. Yu',1296,0),(3752,'B. Nuseibeh',1296,0),(3753,'P. Jamshidi',227,0),(3754,'N. Siegmund',1297,0),(3755,'M. Velez',227,0),(3756,'C. K盲stner',227,0),(3757,'A. Patel',227,0),(3758,'Y. Agarwal',227,0),(3759,'T. Dietrich',1298,0),(3760,'J. Cleland-Huang',1298,0),(3761,'Y. Shin',1298,0),(3762,'S. Mirshokraie',1299,0),(3763,'A. Mesbah',1299,0),(3764,'K. Pattabiraman',1299,0),(3765,'T. A. Walsh',21,0),(3766,'P. McMinn',21,0),(3767,'G. M. Kapfhammer',1300,0),(3768,'J. Campos',1301,0),(3769,'R. Abreu',1301,0),(3770,'G. Fraser',1302,0),(3771,'M. d\'Amorim',1303,0),(3772,'L. Cheng',1304,0),(3773,'Z. Yang',1304,0),(3774,'C. Wang',1305,0),(3775,'I. K. Ratol',1306,0),(3776,'M. P. Robillard',1306,0),(3777,'U. Pohlmann',1307,0),(3778,'M. H眉we',1307,0),(3779,'D. You',1308,0),(3780,'S. Rayadurgam',1308,0),(3781,'M. P. E. Heimdahl',1308,0),(3782,'J. Komp',1309,0),(3783,'B. Kim',1310,0),(3784,'O. Sokolsky',1310,0),(3785,'M. Rahimi',1311,0),(3786,'W. Xiong',1312,0),(3787,'J. Cleland-Huang',1313,0),(3788,'R. Lutz',1312,0),(3789,'J. Wang',1314,0),(3790,'W. Dou',1314,0),(3791,'Y. Gao',1314,0),(3792,'C. Gao',1314,0),(3793,'F. Qin',1315,0),(3794,'K. Yin',1314,0),(3795,'J. Wei',1314,0),(3796,'E. Holder',1316,0),(3797,'E. Shah',1316,0),(3798,'M. Davoodi',1316,0),(3799,'E. Tilevich',1316,0),(3800,'Cu Duy Nguyen',1114,0),(3801,'E. Guzman',1317,0),(3802,'M. El-Haliby',1317,0),(3803,'B. Bruegge',1317,0),(3804,'T. Jiang',1318,0),(3805,'L. Tan',1318,0),(3806,'S. Kim',1319,0),(3807,'Y. Wu',136,0),(3808,'J. S. Dong',1205,0),(3809,'G. Soltana',1320,0),(3810,'M. Sabetzadeh',1320,0),(3811,'L. C. Briand',1320,0),(3812,'S. Jiang',1321,0),(3813,'A. Armaly',1321,0),(3814,'C. McMillan',1321,0),(3815,'A. Celik',1322,0),(3816,'K. Palmskog',1323,0),(3817,'M. Gligoric',1322,0),(3818,'J. Martinez',474,0),(3819,'T. Ziadi',390,0),(3820,'Y. l. Traon',2,0),(3821,'N. Boushehrinejadmoradi',2,0),(3822,'V. Ganapathy',2,0),(3823,'L. Iftode',2,0),(3824,'S. P. Reiss',1324,0),(3825,'Q. Xin',1324,0),(3826,'O. Le脽enich',196,0),(3827,'G. Seibt',1072,0),(3828,'J. Siegmund',1072,0),(3829,'P. Sagdeo',1325,0),(3830,'N. Ewalt',1325,0),(3831,'D. Pal',1325,0),(3832,'S. Vasudevan',1325,0),(3833,'N. Flores',1326,0),(3834,'A. Aguiar',1326,0),(3835,'O. Inverso',1327,0),(3836,'T. L. Nguyen',1327,0),(3837,'B. Fischer',1328,0),(3838,'S. L. Torre',2,0),(3839,'G. Parlato',1327,0),(3840,'J. Guo',328,0),(3841,'K. Czarnecki',328,0),(3842,'N. Siegmund',1072,0),(3843,'R. K. Saha',1257,0),(3844,'M. Lease',1329,0),(3845,'D. E. Perry',1257,0),(3846,'Y. Tian',1330,0),(3847,'F. Thung',1330,0),(3848,'A. Sharma',1330,0),(3849,'D. Lo',1330,0),(3850,'E. Ghassabani',1331,0),(3851,'A. Gacek',1332,0),(3852,'M. W. Whalen',1331,0),(3853,'M. P. E. Heimdahl',1331,0),(3854,'L. Wagner',1332,0),(3855,'S. Hong',1333,0),(3856,'B. Lee',1334,0),(3857,'T. Kwak',1333,0),(3858,'Y. Jeon',1333,0),(3859,'B. Ko',1334,0),(3860,'Y. Kim',1333,0),(3861,'M. Kim',1333,0),(3862,'F. Erata',1335,0),(3863,'C. Gardent',1336,0),(3864,'B. Gyawali',1336,0),(3865,'A. Shimorina',1336,0),(3866,'Y. Lussaud',1337,0),(3867,'B. Tekinerdogan',1335,0),(3868,'G. Kardas',1338,0),(3869,'A. Monceaux',1339,0),(3870,'F. S. Ocariza',1340,0),(3871,'K. Pattabiraman',1340,0),(3872,'A. Mesbah',1340,0),(3873,'E. Coppa',1341,0),(3874,'D. C. D\'Elia',1341,0),(3875,'C. Demetrescu',1341,0),(3876,'E. Moritz',1135,0),(3877,'M. Linares-V谩squez',1135,0),(3878,'M. Grechanik',1342,0),(3879,'C. McMillan',1343,0),(3880,'M. Gethers',1344,0),(3881,'V. Veerappa',1345,0),(3882,'R. Harrison',1345,0),(3883,'B. Ray',1346,0),(3884,'M. Kim',1346,0),(3885,'S. Person',1347,0),(3886,'N. Rungta',1348,0),(3887,'T. B. Le',560,0),(3888,'X. D. Le',560,0),(3889,'C. Sung',1349,0),(3890,'M. Kusano',1350,0),(3891,'J. Roesch',593,0),(3892,'Y. Jiang',830,0),(3893,'D. Li',150,0),(3894,'C. Xu',830,0),(3895,'X. Ma',830,0),(3896,'J. Lu',830,0),(3897,'A. Abate',1351,0),(3898,'I. Bessa',1352,0),(3899,'D. Cattaruzza',1351,0),(3900,'L. Chaves',1352,0),(3901,'L. Cordeiro',1351,0),(3902,'C. David',1351,0),(3903,'P. Kesseli',1351,0),(3904,'D. Kroening',1351,0),(3905,'E. Polgreen',1351,0),(3906,'S. J. Zhang',136,0),(3907,'C. Sun',1070,0),(3908,'J. Ma',136,0),(3909,'J. S. Dong',1070,0),(3910,'T. Kapus',1157,0),(3911,'A. Weiss',1353,0),(3912,'A. Guha',1354,0),(3913,'Y. Brun',1354,0),(3914,'G. Reger',1355,0),(3915,'H. Barringer',1355,0),(3916,'D. Rydeheard',1355,0),(3917,'J. von Pilgrim',1356,0),(3918,'B. Ulke',1356,0),(3919,'A. Thies',1356,0),(3920,'F. Steimann',1356,0),(3921,'M. Zheng',1357,0),(3922,'M. S. Rogers',1358,0),(3923,'Z. Luo',1357,0),(3924,'M. B. Dwyer',1358,0),(3925,'S. F. Siegel',1357,0),(3926,'C. Guo',1359,0),(3927,'J. Zhang',1359,0),(3928,'J. Yan',1360,0),(3929,'Z. Zhang',1359,0),(3930,'Y. Zhang',1359,0),(3931,'S. Carino',1361,0),(3932,'J. H. Andrews',1361,0),(3933,'J. Chen',1362,0),(3934,'O. Olivo',1362,0),(3935,'I. Dillig',1362,0),(3936,'C. Lin',1362,0),(3937,'L. He',1363,0),(3938,'H. Hu',1243,0),(3939,'P. Su',1363,0),(3940,'Z. Liang',1364,0),(3941,'Y. Yang',1363,0),(3942,'H. Huang',1363,0),(3943,'J. Yan',1363,0),(3944,'X. Jia',1363,0),(3945,'D. Feng',1363,0),(3946,'A. D. Sorbo',2,0),(3947,'C. A. Visaggio',146,0),(3948,'M. D. Penta',2,0),(3949,'G. Canfora',146,0),(3950,'B. Izs贸',1365,0),(3951,'Z. Szatm谩ri',1365,0),(3952,'G. Bergmann',1365,0),(3953,'脕. Horv谩th',1365,0),(3954,'I. R谩th',1365,0),(3955,'B. Zhang',426,0),(3956,'E. Hill',1366,0),(3957,'Y. Ko',2,0),(3958,'H. Lee',2,0),(3959,'J. Dolby',2,0),(3960,'S. Kr眉ger',1367,0),(3961,'S. Nadi',285,0),(3962,'M. Reif',1368,0),(3963,'K. Ali',285,0),(3964,'M. Mezini',1368,0),(3965,'E. Bodden',1367,0),(3966,'F. G枚pfert',1368,0),(3967,'F. G眉nther',1368,0),(3968,'C. Weinert',1368,0),(3969,'D. Demmler',1368,0),(3970,'R. Kamath',1368,0),(3971,'J. A. Saddler',1369,0),(3972,'M. B. Cohen',1369,0),(3973,'M. K. Ganai',1370,0),(3974,'R. K. Saha',1371,0),(3975,'Y. Lyu',1305,0),(3976,'H. Yoshida',1371,0),(3977,'M. R. Prasad',1371,0),(3978,'N. Macedo',1372,0),(3979,'T. Guimar茫es',1372,0),(3980,'A. Cunha',1372,0),(3981,'C. Artho',1373,0),(3982,'J. Gmeiner',1374,0),(3983,'R. Ramler',1374,0),(3984,'L. Bao',278,0),(3985,'D. Ye',278,0),(3986,'X. Xia',392,0),(3987,'E. 脰sterlund',1375,0),(3988,'W. L枚we',1375,0),(3989,'J. R. Wilcox',1376,0),(3990,'P. Finch',1377,0),(3991,'C. Flanagan',1378,0),(3992,'S. N. Freund',1379,0),(3993,'S. Lee',1380,0),(3994,'S. Hwang',1381,0),(3995,'S. Ryu',1380,0),(3996,'J. Huang',1240,0),(3997,'Y. Aafer',1240,0),(3998,'D. Perry',1240,0),(3999,'C. Tian',1382,0),(4000,'B. Li',160,0),(4001,'D. Fahland',1383,0),(4002,'S. Maoz',1384,0),(4003,'M. Hills',1385,0),(4004,'F. Kjolstad',1386,0),(4005,'S. Chou',1386,0),(4006,'D. Lugato',1387,0),(4007,'S. Kamil',1388,0),(4008,'S. Amarasinghe',1386,0),(4009,'M. Asaduzzaman',1282,0),(4010,'K. A. Schneider',1282,0),(4011,'D. Hou',1389,0),(4012,'V. K. Palepu',264,0),(4013,'G. Xu',264,0),(4014,'L. Zhang',1390,0),(4015,'M. Gligoric',1391,0),(4016,'D. Marinov',1391,0),(4017,'S. Khurshid',1390,0),(4018,'H. Zhong',1392,0),(4019,'X. Wang',1242,0),(4020,'B. Xu',1393,0),(4021,'Z. Xing',1394,0),(4022,'X. Xia',1395,0),(4023,'A. Cimatti',1396,0),(4024,'M. Dorigatti',1396,0),(4025,'S. Tonetta',1396,0),(4026,'C. Pietsch',1397,0),(4027,'T. Kehrer',1397,0),(4028,'U. Kelter',1397,0),(4029,'D. Reuling',1397,0),(4030,'M. Ohrndorf',1397,0),(4031,'I. C. Morgado',1398,0),(4032,'A. C. R. Paiva',1398,0),(4033,'Z. Lin',1245,0),(4034,'Y. Chen',561,0),(4035,'S. Okur',1190,0),(4036,'M. Fazzini',1115,0),(4037,'H. Chen',731,0),(4038,'C. David',731,0),(4039,'D. Kroening',731,0),(4040,'P. Schrammel',731,0),(4041,'B. Wachter',731,0),(4042,'A. S. Sayyad',1399,0),(4043,'J. Ingram',1399,0),(4044,'T. Menzies',1399,0),(4045,'H. Ammar',1399,0),(4046,'K. Narasimhan',1400,0),(4047,'C. Reichenbach',1400,0),(4048,'F. Khomh',1401,0),(4049,'S. Tasharofi',1402,0),(4050,'M. Pradel',1105,0),(4051,'Y. Lin',1402,0),(4052,'R. Johnson',1402,0),(4053,'M. Gasparic',1403,0),(4054,'T. Gurbanov',1403,0),(4055,'F. Ricci',1403,0),(4056,'S. P茅rez-Soler',1404,0),(4057,'E. Guerra',1404,0),(4058,'J. de Lara',1404,0),(4059,'F. Jurado',1404,0),(4060,'B. Fischer',1405,0),(4061,'O. Inverso',1406,0),(4062,'G. Parlato',1406,0),(4063,'M. Salama',1407,0),(4064,'S. Shamshiri',21,0),(4065,'R. Just',1408,0),(4066,'A. Arcuri',1409,0),(4067,'T. A. Nguyen',764,0),(4068,'T. Rupprecht',1410,0),(4069,'X. Chen',298,0),(4070,'D. H. White',1410,0),(4071,'J. H. Boockmann',1410,0),(4072,'G. L眉ttgen',1410,0),(4073,'H. Bos',1411,0),(4074,'J. Toman',1408,0),(4075,'S. Pernsteiner',1408,0),(4076,'E. Torlak',1408,0),(4077,'N. Coppik',1412,0),(4078,'O. Schwahn',1412,0),(4079,'S. Winter',1412,0),(4080,'N. Suri',1412,0),(4081,'J. Garcia',1413,0),(4082,'I. Ivkovic',1414,0),(4083,'N. Medvidovic',1413,0),(4084,'S. Nejati',1415,0),(4085,'M. Adedjouma',1415,0),(4086,'L. C. Briand',1415,0),(4087,'J. Hellebaut',1416,0),(4088,'J. Begey',1416,0),(4089,'Y. Clement',1416,0),(4090,'E. Sherman',2,0),(4091,'M. B. Dwyer',2,0),(4092,'M. I. Gordon',717,0),(4093,'N. Nguyen',1417,0),(4094,'J. Grigera',1418,0),(4095,'A. Garrido',1419,0),(4096,'G. Rossi',1419,0),(4097,'C. Y. Cho',1420,0),(4098,'V. D\'Silva',1421,0),(4099,'D. Song',1421,0),(4100,'M. Abdelrasoul',81,0),(4101,'L. L. Zhang',1422,0),(4102,'C. M. Liang',1423,0),(4103,'Y. Liu',1423,0),(4104,'E. Chen',1422,0),(4105,'M. Hentschel',1424,0),(4106,'R. H盲hnle',1425,0),(4107,'R. Bubel',1424,0),(4108,'J. C. J. Keng',299,0),(4109,'脰. Babur',1426,0),(4110,'F. Thung',299,0),(4111,'W. Schulte',351,0),(4112,'J. S. Thakur',1427,0),(4113,'A. Gupta',1428,0),(4114,'D. Mougouei',1429,0),(4115,'J. Cito',1430,0),(4116,'M. P眉schel',1105,0),(4117,'D. S. Rosenblum',1070,0),(4118,'C. Chen',1103,0),(4119,'Z. Xing',1103,0),(4120,'S. Guo',1431,0),(4121,'M. Kusano',1431,0),(4122,'C. Wang',1432,0),(4123,'A. Gupta',1433,0),(4124,'M. Ceccato',1114,0),(4125,'C. D. Nguyen',1137,0),(4126,'D. Appelt',1137,0),(4127,'T. Szab贸',1434,0),(4128,'S. Alperovich',1435,0),(4129,'S. Erdweg',1436,0),(4130,'M. Voelter',1437,0),(4131,'A. Demuth',1438,0),(4132,'M. Riedl-Ehrenleitner',1438,0),(4133,'A. Egyed',1438,0),(4134,'J. Wang',1109,0),(4135,'S. Wang',1439,0),(4136,'Q. Cui',1109,0),(4137,'L. Wei',1440,0),(4138,'Y. Liu',1440,0),(4139,'S. Cheung',1440,0),(4140,'L. Cheng',1441,0),(4141,'J. Chang',1441,0),(4142,'Z. Yang',1441,0),(4143,'C. Wang',1442,0),(4144,'A. Yamada',1443,0),(4145,'A. Biere',218,0),(4146,'C. Artho',1444,0),(4147,'T. Kitamura',1444,0),(4148,'E. Choi',1444,0),(4149,'X. Peng',1445,0),(4150,'J. Gu',1445,0),(4151,'T. H. Tan',136,0),(4152,'Y. Yu',1446,0),(4153,'B. Nuseibeh',1446,0),(4154,'W. Zhao',1445,0),(4155,'J. Dolby',1447,0),(4156,'N. Li',1448,0),(4157,'Y. Lei',1449,0),(4158,'H. R. Khan',1448,0),(4159,'J. Liu',1448,0),(4160,'Y. Guo',1450,0),(4161,'G. Dotzler',1451,0),(4162,'M. Philippsen',1451,0),(4163,'G. Laghari',1452,0),(4164,'A. Murgia',1452,0),(4165,'S. Demeyer',1452,0),(4166,'T. Gu',1453,0),(4167,'C. Sun',1129,0),(4168,'X. Ma',1453,0),(4169,'J. L眉',1453,0),(4170,'Z. Su',1129,0),(4171,'Y. Yang',1453,0),(4172,'M. Harman',1454,0),(4173,'J. Krinke',1454,0),(4174,'S. Islam',1455,0),(4175,'D. Binkley',1456,0),(4176,'Y. Zhou',1453,0),(4177,'B. Xu',1453,0),(4178,'H. Cai',1457,0),(4179,'D. Thain',1321,0),(4180,'J. Cito',1458,0),(4181,'J. Rubin',1459,0),(4182,'P. Stanley-Marbell',1459,0),(4183,'M. Rinard',1459,0),(4184,'M. Voelter',1460,0),(4185,'Z. Lin',1461,0),(4186,'H. Zhong',1462,0),(4187,'Y. Chen',1462,0),(4188,'J. Zhao',1463,0),(4189,'M. Tufano',1097,0),(4190,'F. Palomba',1160,0),(4191,'M. Di Penta',1464,0),(4192,'A. De Lucia',1160,0),(4193,'M. H枚schele',1465,0),(4194,'A. Zeller',1465,0),(4195,'L. Li',62,0),(4196,'T. F. Bissyand茅',62,0),(4197,'D. Octeau',1466,0),(4198,'J. Klein',62,0),(4199,'V. Vojdani',280,0),(4200,'K. Apinis',280,0),(4201,'V. R玫tov',280,0),(4202,'H. Seidl',1467,0),(4203,'V. Vene',280,0),(4204,'R. Vogler',1467,0),(4205,'P. Ohmann',1468,0),(4206,'D. B. Brown',1468,0),(4207,'N. Neelakandan',1468,0),(4208,'J. Linderoth',1468,0),(4209,'B. Liblit',1468,0),(4210,'S. Di Alesio',1213,0),(4211,'Z. Zhai',1469,0),(4212,'B. Cheng',1469,0),(4213,'M. Niu',1469,0),(4214,'Z. Wang',1469,0),(4215,'Y. Feng',1469,0),(4216,'J. Chen',1469,0),(4217,'S. Maro',1470,0),(4218,'A. Anjorin',1471,0),(4219,'R. Wohlrab',1470,0),(4220,'J. Stegh枚fer',1470,0),(4221,'Z. Pavlinovic',1472,0),(4222,'A. Lal',39,0),(4223,'R. Sharma',1473,0),(4224,'P. Stratis',1474,0),(4225,'A. Rajan',1474,0),(4226,'S. Ognawala',271,0),(4227,'M. Ochoa',136,0),(4228,'A. Pretschner',271,0),(4229,'T. Limmer',1475,0),(4230,'A. Pescador',1476,0),(4231,'J. de Lara',1476,0),(4232,'Y. Kang',1477,0),(4233,'B. Ray',268,0),(4234,'S. Jana',1477,0),(4235,'R. Ben Abdessalem',1478,0),(4236,'S. Nejati',1478,0),(4237,'L. C. Briand',1478,0),(4238,'T. Stifter',1479,0),(4239,'S. Proksch',1480,0),(4240,'S. Amann',1480,0),(4241,'S. Nadi',1480,0),(4242,'M. Mezini',1480,0),(4243,'M. M. Rahman',1481,0),(4244,'C. K. Roy',1481,0),(4245,'J. Redl',1482,0),(4246,'J. A. Collins',1483,0),(4247,'A. Alshanqiti',1484,0),(4248,'R. Heckel',1484,0),(4249,'T. Kehrer',1485,0),(4250,'Y. Li',1486,0),(4251,'C. Zhu',1486,0),(4252,'M. Chechik',1486,0),(4253,'M. White',1487,0),(4254,'M. Tufano',1487,0),(4255,'C. Vendome',1487,0),(4256,'D. Poshyvanyk',1487,0),(4257,'M. Rodriguez-Cancio',1488,0),(4258,'B. Combemale',1489,0),(4259,'B. Baudry',1490,0),(4260,'G. J. Greene',1491,0),(4261,'B. Fischer',1491,0),(4262,'M. S. Mahmood',1492,0),(4263,'M. A. Ghafoor',1492,0),(4264,'J. H. Siddiqui',1492,0),(4265,'M. Nishi',1493,0),(4266,'I. Boci膰',1494,0),(4267,'T. Bultan',1494,0),(4268,'J. Liu',1495,0),(4269,'J. Grundy',1496,0),(4270,'I. Avazpour',1496,0),(4271,'M. Abdelrazek',1496,0),(4272,'V. Pham',1205,0),(4273,'M. B枚hme',1205,0),(4274,'A. Roychoudhury',1205,0),(4275,'S. Peldszus',1497,0),(4276,'G. Kulcs谩r',1498,0),(4277,'M. Lochau',1498,0),(4278,'S. Schulze',1499,0),(4279,'J. Chen',1500,0),(4280,'Y. Bai',1500,0),(4281,'D. Hao',1500,0),(4282,'L. Zhang',1501,0),(4283,'L. Zhang',1500,0),(4284,'B. Xie',1500,0),(4285,'H. Mei',1500,0),(4286,'X. D. Le',1330,0),(4287,'W. U. Hassan',1082,0),(4288,'X. Xu',1082,0),(4289,'G. Ro艧u',1082,0),(4290,'Y. Feng',1502,0),(4291,'J. A. Jones',1502,0),(4292,'Z. Chen',1277,0),(4293,'C. Fang',1277,0),(4294,'Y. Baek',1503,0),(4295,'D. Bae',1503,0),(4296,'N. A. Moketar',1504,0),(4297,'M. Kamalrudin',1504,0),(4298,'S. Sidek',1504,0),(4299,'M. Robinson',1505,0),(4300,'J. Grundy',1506,0),(4301,'B. Zhang',1507,0),(4302,'E. Hill',1508,0),(4303,'J. Clause',1507,0),(4304,'M. Patrick',1509,0),(4305,'M. D. Castle',1509,0),(4306,'R. O. J. H. Stutt',1509,0),(4307,'C. A. Gilligan',1509,0),(4308,'M. Wen',1440,0),(4309,'R. Wu',1440,0),(4310,'H. Tang',1510,0),(4311,'G. Wu',1510,0),(4312,'J. Wei',1510,0),(4313,'H. Zhong',1510,0),(4314,'D. Mazinanian',1511,0),(4315,'N. Tsantalis',1511,0),(4316,'R. Almhana',1512,0),(4317,'W. Mkaouer',1512,0),(4318,'M. Kessentini',1512,0),(4319,'A. Ouni',1513,0),(4320,'M. Christakis',1514,0),(4321,'C. Bird',1514,0),(4322,'X. Cheng',1462,0),(4323,'Z. Peng',1330,0),(4324,'L. Jiang',1330,0),(4325,'H. Yu',1461,0),(4326,'J. Ming',1515,0),(4327,'D. Wu',1515,0),(4328,'J. Wang',1515,0),(4329,'G. Xiao',1515,0),(4330,'P. Liu',1515,0),(4331,'Y. Cait',1243,0),(4332,'D. Chollak',1439,0),(4333,'D. Movshovitz-Attias',1516,0),(4334,'L. Tan',1439,0),(4335,'G. Chen',1103,0),(4336,'D. Kroening',1517,0),(4337,'D. Poetzl',1517,0),(4338,'P. Schrammel',1518,0),(4339,'B. Wachter',1519,0),(4340,'M. A. Alipour',1520,0),(4341,'R. Gopinath',1520,0),(4342,'A. Groce',1520,0),(4343,'P. M. Vu',1521,0),(4344,'H. V. Pham',1521,0),(4345,'T. T. Nguyen',1521,0),(4346,'T. Wu',1243,0),(4347,'J. Liu',1243,0),(4348,'X. Deng',1522,0),(4349,'J. Yan',1243,0),(4350,'J. Zhang',1243,0),(4351,'M. Hentschel',1523,0),(4352,'R. H盲hnle',1523,0),(4353,'R. Bubel',1523,0),(4354,'D. Asenov',1524,0),(4355,'P. M眉ller',1524,0),(4356,'L. Vogel',1525,0),(4357,'W. Visser',1526,0),(4358,'H. Zhang',1229,0),(4359,'Y. Jiang',1527,0),(4360,'M. Hilton',1528,0),(4361,'T. Tunnell',1529,0),(4362,'K. Huang',1529,0),(4363,'D. Marinov',1529,0),(4364,'D. Dig',1528,0),(4365,'A. J. Maas',1468,0),(4366,'H. Nazar茅',1530,0),(4367,'D. Ye',1103,0),(4368,'X. Xia',1393,0),(4369,'S. Li',1393,0),(4370,'F. Gao',1531,0),(4371,'L. Wang',1531,0),(4372,'X. Li',1531,0),(4373,'T. Kowark',1532,0),(4374,'C. Matthies',1532,0),(4375,'M. Uflacker',1532,0),(4376,'H. P. H. Plattner',1532,0),(4377,'J. Meinicke',1533,0),(4378,'C. Wong',227,0),(4379,'T. Th眉m',1534,0),(4380,'G. Saake',1533,0),(4381,'F. Qi',1535,0),(4382,'X. Jing',1535,0),(4383,'X. Zhu',1535,0),(4384,'F. Wu',1535,0),(4385,'L. Cheng',1535,0),(4386,'R. Krishna',1536,0),(4387,'T. Menzies',1536,0),(4388,'W. Fu',1536,0),(4389,'M. Raza',1537,0),(4390,'J. P. Faria',1537,0),(4391,'F. Schw盲ger',1538,0),(4392,'B. Westfechtel',1538,0),(4393,'R. Degiovanni',1539,0),(4394,'N. Ricci',1539,0),(4395,'D. Alrajeh',1540,0),(4396,'P. Castro',1539,0),(4397,'N. Aguirre',1539,0),(4398,'X. Li',1541,0),(4399,'Y. Liang',1541,0),(4400,'H. Qian',1541,0),(4401,'Y. Hu',1541,0),(4402,'L. Bu',1541,0),(4403,'Y. Yu',1541,0),(4404,'X. Chen',1541,0),(4405,'C. Hannebauer',1542,0),(4406,'M. Patalas',1542,0),(4407,'S. St眉nkelt',1542,0),(4408,'V. Gruhn',1542,0),(4409,'R. Tzoref-Brill',1543,0),(4410,'P. Wojciak',1544,0),(4411,'S. Maoz',1545,0);
/*!40000 ALTER TABLE `author_info` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `keyword_info`
--

DROP TABLE IF EXISTS `keyword_info`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `keyword_info` (
  `keyword_id` int(11) NOT NULL AUTO_INCREMENT,
  `keyword` varchar(200) DEFAULT NULL,
  `keyword_search_count` int(11) DEFAULT '0',
  PRIMARY KEY (`keyword_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2441 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `keyword_info`
--

LOCK TABLES `keyword_info` WRITE;
/*!40000 ALTER TABLE `keyword_info` DISABLE KEYS */;
INSERT INTO `keyword_info` VALUES (1,'Literature review',0),(2,'Survey',0),(3,'Prevalence',0),(4,'Statistical errors',0),(5,'Formal methods',0),(6,'Software engineering',0),(7,'Abstract Syntax Tree, source code representation, neural network, code classification, code clone detection',0),(8,'sampling',0),(9,'testing',0),(10,'configuration',0),(11,'program obfuscation',0),(12,'obscurity language model',0),(13,'markov chain monte carlo methods',0),(14,'Energy Testing',0),(15,'Android',0),(16,'Software Testing',0),(17,'Coverage',0),(18,'Diagnosability',0),(19,'Static analysis',0),(20,'JavaScript',0),(21,'Web APIs',0),(22,'event-driven programming',0),(23,'automated repair',0),(24,'oracle',0),(25,'test oracle',0),(26,'test generation',0),(27,'natural language specification',0),(28,'gamification',0),(29,'crowdsourcing',0),(30,'mutation testing',0),(31,'Change Impact, Safety Assurance Cases, Evolution, Traceability',0),(32,'Bug Database',0),(33,'Reproducibility',0),(34,'Program Analysis',0),(35,'Experiment Infrastructure',0),(36,'concurrency',0),(37,'Security',0),(38,'Inter-app vulnerability',0),(39,'Mining Software Repositories',0),(40,'Empirical Software Engineering',0),(41,'Software Quality',0),(42,'Defect Prediction Models',0),(43,'Program Metric, Vulnerability, Fuzzing',0),(44,'Neural-Machine Translation',0),(45,'Empirical Study',0),(46,'test prioritization',0),(47,'commit risk',0),(48,'machine learning',0),(49,'log',0),(50,'code smell',0),(51,'duplicate log',0),(52,'FLOSS',0),(53,'gender',0),(54,'Open Source',0),(55,'Software defect prediction',0),(56,'class imbalance',0),(57,'verification latency',0),(58,'online learning',0),(59,'concept drift',0),(60,'ensembles',0),(61,'computer aided software engineering',0),(62,'software maintenance',0),(63,'reasoning about programs',0),(64,'resource constraint',0),(65,'learning',0),(66,'third-party library',0),(67,'software mining',0),(68,'symbolic execution',0),(69,'path profiling',0),(70,'tracing',0),(71,'quality assurance tools',0),(72,'gender bias',0),(73,'Specification inference',0),(74,'Bug finding',0),(75,'Formal Verification',0),(76,'Model Extraction',0),(77,'Web Applications',0),(78,'A/B testing',0),(79,'continuous experimentation',0),(80,'data science',0),(81,'customer feedback',0),(82,'continuous product innovation',0),(83,'Experimentation Evolution Model',0),(84,'product value',0),(85,'Experiment Owner',0),(86,'Dynamic Analysis',0),(87,'App Unpacking',0),(88,'context, task decomposition, field study',0),(89,'Program transformation',0),(90,'program synthesis',0),(91,'tutoring systems',0),(92,'refactoring',0),(93,'Open Source, Code Review, Motivation',0),(94,'devops, devsecops, empirical study, infrastructure as code, puppet, security, smell, static analysis',0),(95,'Mobile Security',0),(96,'Computer Vision',0),(97,'Icon Recognition',0),(98,'Node.js',0),(99,'event-driven architecture',0),(100,'atomicity violation',0),(101,'happens-before',0),(102,'Mobile apps, Android, Dynamic analysis',0),(103,'Product-backlog',0),(104,'dual-track-agile',0),(105,'scrum',0),(106,'lean',0),(107,'extreme-programming',0),(108,'user-stories',0),(109,'design-thinking',0),(110,'user-centered-design',0),(111,'feature-engineering',0),(112,'GitHub ecosystems',0),(113,'cross-project correlated bugs',0),(114,'root causes tracking',0),(115,'coordinate',0),(116,'software performance prediction, deep sparse feedforward neural network, highly configurable systems, sparsity regularization',0),(117,'SMT-based program analysis',0),(118,'SMT solvers',0),(119,'solution reuse',0),(120,'source code summarization',0),(121,'eye tracking',0),(122,'program comprehension',0),(123,'Java Unsafe API',0),(124,'Bytecode',0),(125,'Memoey Safety',0),(126,'Android app',0),(127,'Storyboard',0),(128,'Competitive analysis',0),(129,'App review',0),(130,'Mutation Analysis',0),(131,'Library API Misuse',0),(132,'Traceability',0),(133,'Deep Learning',0),(134,'Recurrent Neural Network',0),(135,'Semantic Representation',0),(136,'Cyber-Physical System',0),(137,'Debug',0),(138,'build tools',0),(139,'exhaustive testing',0),(140,'verification',0),(141,'abbreviation',0),(142,'synonym',0),(143,'morphological form',0),(144,'word embedding',0),(145,'Stack Overflow',0),(146,'Programming Screencast',0),(147,'Action Recognition',0),(148,'Code Coverage',0),(149,'Differential Testing',0),(150,'Coverage Tools',0),(151,'Bug Detection.',0),(152,'Code completion',0),(153,'Benchmark',0),(154,'Language models',0),(155,'API documentation',0),(156,'natural language processing',0),(157,'Differential JVM testing',0),(158,'live bytecode mutation',0),(159,'semantically different mutants',0),(160,'anti-patterns',0),(161,'logging code',0),(162,'logging practices',0),(163,'empirical studies',0),(164,'REST API',0),(165,'Fuzzing',0),(166,'cloud services',0),(167,'fuzzer',0),(168,'Requirements elicitation',0),(169,'Requirements classification',0),(170,'Weighted Finite State Transducer',0),(171,'Dynamic language models',0),(172,'Information extraction',0),(173,'Bug-finding',0),(174,'adversarial sample',0),(175,'detection',0),(176,'deep neural network',0),(177,'sensitivity',0),(178,'recommender system',0),(179,'api mining',0),(180,'api usage pattern',0),(181,'api recommendation',0),(182,'community management',0),(183,'episodic volunteering',0),(184,'open source software',0),(185,'volunteer management',0),(186,'developer communication',0),(187,'user story generation',0),(188,'productivity',0),(189,'transcripts',0),(190,'Mining unstructured data',0),(191,'Recommender systems',0),(192,'medical imaging',0),(193,'data structures',0),(194,'spatial ability',0),(195,'immutability',0),(196,'programming language usability',0),(197,'empirical studies of programmers',0),(198,'Reliability',0),(199,'Operational profile',0),(200,'Program count spectrum',0),(201,'Operational coverage',0),(202,'Test case selection',0),(203,'Distance Based Sampling',0),(204,'Configuration Sampling',0),(205,'Configurable Systems',0),(206,'Performance Modeling',0),(207,'vulnerability detection',0),(208,'side-channel',0),(209,'Software Licenses',0),(210,'Classifiers',0),(211,'Software Structure',0),(212,'software performance engineering, IDE, user study',0),(213,'automatic documentation generation',0),(214,'code comment generation',0),(215,'agile software development',0),(216,'transition',0),(217,'selforganizing',0),(218,'teams',0),(219,'management',0),(220,'culture',0),(221,'theory',0),(222,'grounded theory',0),(223,'OSS',0),(224,'Newcomers',0),(225,'One Time Contributors',0),(226,'Qualitative Research',0),(227,'profiler',0),(228,'randomized algorithms',0),(229,'Embedded system design engineering',0),(230,'variability modeling',0),(231,'model checking',0),(232,'non functional property',0),(233,'multi objective optimization',0),(234,'Type Migration',0),(235,'MapReduce',0),(236,'Android fragmentation, compatibility, static analysis, learning',0),(237,'third party-library',0),(238,'mutation',0),(239,'GUI testing',0),(240,'mobile app testing',0),(241,'CEGAR',0),(242,'Developer roles',0),(243,'developer networks',0),(244,'classification',0),(245,'Search-Based Software Testing',0),(246,'Genetic Algorithms',0),(247,'Automated Crash Reproduction',0),(248,'collaborative software engineering',0),(249,'issue tracking system',0),(250,'issue discussion analysis',0),(251,'Basic Science',0),(252,'Entropy',0),(253,'Statistical Code Graphs',0),(254,'StackOverflow',0),(255,'Code refactoring, inconsistent method names, deep neural networks, code embedding',0),(256,'program repair, static analysis, null dereference',0),(257,'database backed web applications',0),(258,'ORM framework',0),(259,'view centric',0),(260,'Bug reproduction',0),(261,'Test Reuse',0),(262,'Code Transplantation',0),(263,'Code Clones',0),(264,'Concurrent Program',0),(265,'Abstraction Refinement',0),(266,'Scheduling Constraint',0),(267,'Parallel Verification',0),(268,'Software Configuration',0),(269,'Software Stack',0),(270,'Qualitative Study',0),(271,'Multi-layer Systems',0),(272,'Slicing',0),(273,'PHP',0),(274,'feature modeling',0),(275,'software product lines',0),(276,'software visualization',0),(277,'binary decision diagrams',0),(278,'Ethereum',0),(279,'Blockchain',0),(280,'Decompilation',0),(281,'online code examples',0),(282,'code adaptation',0),(283,'Semantic Change Pattern Mining, Graph Mining',0),(284,'regression test selection',0),(285,'module-level regression testing',0),(286,'build system',0),(287,'Race condition',0),(288,'web application',0),(289,'deterministic replay',0),(290,'program repair',0),(291,'inter-app communication',0),(292,'Mobile apps',0),(293,'UI compatibility testing',0),(294,'Parallel testing',0),(295,'Programming model',0),(296,'MSR',0),(297,'code review',0),(298,'TDR',0),(299,'Minified JS Code, Variable Name Recovery, Naturalness of Code, Usage Contexts.',0),(300,'seed inputs',0),(301,'Test Adequacy',0),(302,'Coverage Criteria',0),(303,'Deep Learning Systems',0),(304,'concolic testing',0),(305,'program generation',0),(306,'evolution',0),(307,'checking software tools',0),(308,'system and integration testing',0),(309,'test alarm analysis',0),(310,'multiclass classification',0),(311,'static type systems',0),(312,'Flow',0),(313,'TypeScript',0),(314,'software product line',0),(315,'variant integration',0),(316,'clone and own',0),(317,'re engineering variants',0),(318,'code merging',0),(319,'intention based integration',0),(320,'most general client',0),(321,'memory leak, static bug finding, use-flow graph, value-flow graph',0),(322,'Refinement',0),(323,'UML',0),(324,'Class diagram',0),(325,'Use case diagram',0),(326,'Graph homomorphism',0),(327,'Design patterns',0),(328,'performance diagnosis',0),(329,'debugging',0),(330,'loop inefficiency',0),(331,'crowdsourced testing',0),(332,'summarization',0),(333,'duplicate bug reports',0),(334,'binary',0),(335,'disassembly',0),(336,'binary rewrite',0),(337,'probabilistic disassembly',0),(338,'Stack Overflow, crowdsourced knowledge, social dynamics, security implementation',0),(339,'Crowdtesting',0),(340,'automated close prediction',0),(341,'test completion',0),(342,'crowdtesting management',0),(343,'Logs',0),(344,'Faults',0),(345,'Industry',0),(346,'feedback',0),(347,'path pattern',0),(348,'approximation',0),(349,'Word2Vec',0),(350,'API embedding',0),(351,'API usages',0),(352,'migration',0),(353,'Continuous Integration, Anti-Pattern, Detection, CI-Smell, CI-Decay',0),(354,'social capital',0),(355,'Architectural design and implementation',0),(356,'tactic recommender',0),(357,'emergent design',0),(358,'software energy consumption, MVP, MVC, software architecture',0),(359,'Code duplication',0),(360,'Lambda expressions',0),(361,'Java Platform Module System',0),(362,'Architectural Inconsistencies',0),(363,'Static Program Analysis',0),(364,'Software Architecture',0),(365,'Module',0),(366,'Repair',0),(367,'Maintainability',0),(368,'Encapsulation',0),(369,'Software Bloat',0),(370,'Java',0),(371,'opinion mining',0),(372,'sentiment analysis',0),(373,'aspect detection',0),(374,'Android malware',0),(375,'graph embedding',0),(376,'familial analysis',0),(377,'unsupervised learning',0),(378,'Greybox Fuzzing, Structured Inputs, ASTs',0),(379,'diffusion of innovations',0),(380,'practitioners',0),(381,'coding proficiency',0),(382,'Application Programming Interface',0),(383,'PageRank Algorithm',0),(384,'Topic Model',0),(385,'Unsupervised Approaches',0),(386,'interfaces',0),(387,'default methods',0),(388,'Interrupt-driven systems, Sequence diagrams, System modelling, Model checking',0),(389,'continuous-time Markov chain',0),(390,'imprecise parameters',0),(391,'performance',0),(392,'Quality-of-Service',0),(393,'Security and privacy breaches',0),(394,'social norms',0),(395,'breach ontology',0),(396,'semantic similarity',0),(397,'automatic parallelization',0),(398,'typestate analysis',0),(399,'Java 8',0),(400,'streams',0),(401,'Clustering',0),(402,'Random projection',0),(403,'Similarity-based testing',0),(404,'Test suite reduction',0),(405,'type inference',0),(406,'comments',0),(407,'identifiers',0),(408,'Mining User Reviews',0),(409,'Impact Analysis',0),(410,'Code Search, Active Learning, Inductive Logic Programming',0),(411,'Reflection',0),(412,'Systematic Literature Review',0),(413,'Decision Analysis',0),(414,'Requirements Engineering',0),(415,'Goal Modelling',0),(416,'Monte-Carlo Simulation',0),(417,'Multi-Objective Optimisation',0),(418,'Search-Based Software Engineering',0),(419,'Expected Value of Information',0),(420,'Android hybrid applications, interoperability, multi-language systems, operational semantics, type system',0),(421,'Documentation, Empirical Study',0),(422,'Automated program repair',0),(423,'test case generationn',0),(424,'language design',0),(425,'Software engineering waste',0),(426,'Extreme Programming',0),(427,'Lean Software Development',0),(428,'code comprehension',0),(429,'prose review',0),(430,'Whole-program profiling',0),(431,'Software optimization',0),(432,'Performance measurement',0),(433,'Tools',0),(434,'program optimization',0),(435,'numerical analysis',0),(436,'compiler errors',0),(437,'integrated development environments',0),(438,'programmer comprehension',0),(439,'reading',0),(440,'visual attention',0),(441,'online ads',0),(442,'defective ads',0),(443,'resource abusing',0),(444,'performance degradation',0),(445,'code comment',0),(446,'link decay',0),(447,'knowledge sharing',0),(448,'reactive synthesis',0),(449,'GR(1)',0),(450,'mailing lists',0),(451,'patches',0),(452,'commits',0),(453,'Docker',0),(454,'Configuration Management',0),(455,'Environment Inference',0),(456,'Dependencies',0),(457,'Python',0),(458,'automatic program repair, multi-hunk patches, code similarity',0),(459,'Diversity',0),(460,'hackathons',0),(461,'teamwork',0),(462,'brainstorming',0),(463,'satisfaction',0),(464,'software engineering management',0),(465,'work related stress',0),(466,'work patterns',0),(467,'multitasking',0),(468,'socio technical',0),(469,'work rate increase',0),(470,'empirical analysis',0),(471,'regression modeling',0),(472,'GitHub',0),(473,'software developers',0),(474,'online projects',0),(475,'sentiment',0),(476,'social activities',0),(477,'technical activities',0),(478,'focus switching',0),(479,'recommendations',0),(480,'repositories',0),(481,'issues',0),(482,'pull requests',0),(483,'discussions',0),(484,'collaboration',0),(485,'team members',0),(486,'social coding',0),(487,'string constraint solving',0),(488,'Precision Evaluation, Clone Detection, Machine learning, Open source labeled datasets',0),(489,'deep learning software testing',0),(490,'cross-implementation testing',0),(491,'bugs detection',0),(492,'End-user programming',0),(493,'Trigger-action programming',0),(494,'test effectiveness',0),(495,'real faults',0),(496,'Obfuscation',0),(497,'Virtualization',0),(498,'Information Hiding',0),(499,'security modelling',0),(500,'security metrics',0),(501,'twin peaks',0),(502,'agile',0),(503,'Automation of Software Test',0),(504,'Software Tools',0),(505,'Game engineering',0),(506,'System-of-Systems',0),(507,'Ultra-large Scale Systems',0),(508,'Security Risk Assessment',0),(509,'Risk Modeling',0),(510,'Comprehensibility',0),(511,'Cognitive Fit',0),(512,'Exception Handling',0),(513,'abstract interpretation',0),(514,'higher-order',0),(515,'Variability Resolution',0),(516,'Runtime Adaptation',0),(517,'Model-based Approach',0),(518,'srcML',0),(519,'XML',0),(520,'Software risk',0),(521,'software management',0),(522,'risk prompts',0),(523,'load testing',0),(524,'scalability',0),(525,'Class Reloading',0),(526,'Dynamic Software Updating',0),(527,'Resource Reloading',0),(528,'Statistical Language Models',0),(529,'Synthesis',0),(530,'APIs',0),(531,'Human Factors',0),(532,'playgrounds',0),(533,'code snippets',0),(534,'dependency injection',0),(535,'cloud computing',0),(536,'Assessment',0),(537,'Code Repurposing',0),(538,'Plagiarism Softwaredevelopment',0),(539,'Cloze Testing',0),(540,'Runtime Verification',0),(541,'Regression Testing',0),(542,'Runtime Monitoring',0),(543,'Monitoring-Oriented Programming',0),(544,'version control',0),(545,'Model Driven Engineering',0),(546,'Maritime Security',0),(547,'Architectural Alternatives',0),(548,'Simulation.',0),(549,'modeling',0),(550,'quality',0),(551,'Product line',0),(552,'variability',0),(553,'Collaborative Software Development',0),(554,'Conflicts',0),(555,'Green software engineering',0),(556,'green design',0),(557,'key green indicators (KGIs)',0),(558,'green monitoring',0),(559,'green adaptation',0),(560,'smart green sensors and actuators',0),(561,'self-greening',0),(562,'energy efficiency',0),(563,'sustainability',0),(564,'green scheduling',0),(565,'green computing',0),(566,'green IT',0),(567,'Software engineering workflow',0),(568,'code reviews',0),(569,'code integration',0),(570,'configuration-dependent bugs',0),(571,'configurable software',0),(572,'dynamic symbolic execution',0),(573,'Model Driven Development',0),(574,'Code Generation',0),(575,'Mobile App Prototyping',0),(576,'Video Scraping',0),(577,'Interaction Data',0),(578,'declarative programming',0),(579,'program querying',0),(580,'history querying',0),(581,'alignment',0),(582,'product variants',0),(583,'clone-and-own',0),(584,'reuse',0),(585,'features',0),(586,'feature interactions',0),(587,'process improvement',0),(588,'scientific software',0),(589,'performance problem diagnosis',0),(590,'principal component analysis',0),(591,'system trace',0),(592,'software reliability',0),(593,'Exploratory Testing Strategies',0),(594,'Human-Computer Interaction',0),(595,'ide',0),(596,'doctor',0),(597,'window plague',0),(598,'Large-Scale',0),(599,'Project Management',0),(600,'Agile Development',0),(601,'Self-Management',0),(602,'Portfolio Management',0),(603,'programming in natural language',0),(604,'end user programming',0),(605,'ontology',0),(606,'agent-based software design',0),(607,'natural lanuage understanding',0),(608,'robotics',0),(609,'Empirical Methods',0),(610,'Text retrieval',0),(611,'Brain computer interface (BCI)',0),(612,'human computer interface (HCI)',0),(613,'neural input',0),(614,'self-adaptive systems',0),(615,'overt and covert behavior',0),(616,'human in the loop',0),(617,'Software Metrics',0),(618,'Adaptive Systems',0),(619,'Equivalence checking',0),(620,'PRES+ model',0),(621,'FSMD model',0),(622,'Adaptive security',0),(623,'imperfect data',0),(624,'non-monotonic logic',0),(625,'gpgpu',0),(626,'opencl',0),(627,'memory profiling',0),(628,'profiling',0),(629,'Big Data',0),(630,'software industry',0),(631,'integrated development environment',0),(632,'technology transfer',0),(633,'plugins',0),(634,'case study',0),(635,'software faults',0),(636,'Dynamic safety case',0),(637,'Safety assurance',0),(638,'Lifecycle processes',0),(639,'Safety management',0),(640,'Android Application Testing',0),(641,'GUI Ripping',0),(642,'Testing Automation',0),(643,'Input Perturbation Testing',0),(644,'Workshop',0),(645,'Mandelbug',0),(646,'failure',0),(647,'Modularity',0),(648,'implicit concurrency',0),(649,'modular structure',0),(650,'concurrency abstraction',0),(651,'capsules',0),(652,'Software Process Simulation',0),(653,'Hidden Markov Model',0),(654,'Agent Based Modeling',0),(655,'Developer Behavior',0),(656,'api',0),(657,'mobile api developers',0),(658,'first programming course',0),(659,'mastery learning',0),(660,'project-based learning',0),(661,'CS1/CS2',0),(662,'introductory programming',0),(663,'software engineering education',0),(664,'conformance checking',0),(665,'architectural constraints',0),(666,'history',0),(667,'future',0),(668,'software categorization',0),(669,'dirichlet process',0),(670,'automatic labeling',0),(671,'software services',0),(672,'collaborative services',0),(673,'SOA',0),(674,'service-oriented architecture',0),(675,'service-oriented systems',0),(676,'Research methodology',0),(677,'process theory',0),(678,'questionnaire',0),(679,'field study',0),(680,'Lugano',0),(681,'integration test',0),(682,'test-driven development',0),(683,'snapshot',0),(684,'system tests',0),(685,'linear programming',0),(686,'cost flow',0),(687,'flow constraints',0),(688,'release engineering',0),(689,'integration',0),(690,'test execution',0),(691,'packaging',0),(692,'deployment',0),(693,'continuous delivery',0),(694,'Re-engineering',0),(695,'software project management',0),(696,'multi-agent-based simulation',0),(697,'Source code dependency',0),(698,'task context',0),(699,'implicit feedback',0),(700,'dynamic typing',0),(701,'MPI',0),(702,'Synchronous',0),(703,'Asynchronous',0),(704,'Deadlock',0),(705,'metrics',0),(706,'software analytics',0),(707,'technical debt',0),(708,'software maintenance and evolution',0),(709,'qualitative methods',0),(710,'Software engineering research',0),(711,'industrial practice',0),(712,'researchers',0),(713,'challenges',0),(714,'Participation Intentions',0),(715,'Software Projects',0),(716,'partition testing',0),(717,'choice relation framework',0),(718,'output scenario',0),(719,'Harmony Proxy',0),(720,'Instrumentation',0),(721,'ECMAScript6',0),(722,'Computational Science',0),(723,'Computational Engineering',0),(724,'High Performance Computing',0),(725,'IDE services',0),(726,'embedded code',0),(727,'Software Requirements Patterns',0),(728,'Patterns',0),(729,'Requirements Reuse',0),(730,'Knowledge Engineering',0),(731,'Model-Based Mutation Testing',0),(732,'Featured Transition Systems',0),(733,'VIBeS',0),(734,'Live Programming',0),(735,'Scripting',0),(736,'File Manipulation',0),(737,'Programming by Example',0),(738,'Measurement Frameworks',0),(739,'Software Development Lifecycle.',0),(740,'Code search',0),(741,'Free form search',0),(742,'Query augmentation',0),(743,'Vocabulary mismatch',0),(744,'Meta-analysis',0),(745,'Effect size',0),(746,'fault localization',0),(747,'Manager',0),(748,'Knowledge Work',0),(749,'Conceptual Framework',0),(750,'Manager Attributes',0),(751,'Technical Skills',0),(752,'Semantic coupling',0),(753,'co-change',0),(754,'Java software',0),(755,'Class imbalance learning',0),(756,'Synthetic sample generation',0),(757,'Data sampling methods',0),(758,'Classification problems',0),(759,'Syntax Highlighting',0),(760,'Source Code Typography',0),(761,'Code Colouring',0),(762,'IDE Interface',0),(763,'GUI',0),(764,'Test minimization',0),(765,'Architect',0),(766,'coding',0),(767,'tactics',0),(768,'architecture savvy',0),(769,'newcomer',0),(770,'Web application testing',0),(771,'Browser environments',0),(772,'Google Play Store',0),(773,'User-developer dialogue',0),(774,'Developer response',0),(775,'Mixed-effect model',0),(776,'Android mobile apps',0),(777,'code smells',0),(778,'behavioural model',0),(779,'hierarchical motifs',0),(780,'cross project defect prediction',0),(781,'comparison',0),(782,'replication',0),(783,'perturbation analysis',0),(784,'software correctness',0),(785,'security decisions',0),(786,'security requirements',0),(787,'game',0),(788,'decision patterns',0),(789,'prefetch',0),(790,'network latency',0),(791,'mobile applications',0),(792,'Practice',0),(793,'Impact',0),(794,'Applied Research',0),(795,'Test selection',0),(796,'Object-oriented',0),(797,'inheritance',0),(798,'empirical',0),(799,'design guidance',0),(800,'Linux kernel',0),(801,'System calls',0),(802,'API evolution',0),(803,'Software evolution',0),(804,'startups',0),(805,'Collaborative MDSE',0),(806,'CoMDSE',0),(807,'C MDSE',0),(808,'CoSE',0),(809,'systematic mapping study',0),(810,'Just In Time prediction',0),(811,'Defect prediction',0),(812,'Metamorphic testing',0),(813,'REST',0),(814,'RESTful Web services',0),(815,'Web API',0),(816,'WatchDog',0),(817,'IntelliJ',0),(818,'Eclipse',0),(819,'Novice researchers',0),(820,'Evidence based software engineering',0),(821,'Exploratory study',0),(822,'Q&A website',0),(823,'Factor importance analysis',0),(824,'Response time',0),(825,'lazy initialization',0),(826,'execution driven pruning',0),(827,'Conditional Model Checking',0),(828,'Software Verification',0),(829,'Sequential Combination',0),(830,'Software productivity',0),(831,'Secure coding',0),(832,'Spring security',0),(833,'CSRF',0),(834,'SSL/TLS',0),(835,'certificate validation',0),(836,'cryptographic hash functions',0),(837,'authentication',0),(838,'authorization',0),(839,'cryptography',0),(840,'design problem',0),(841,'software design',0),(842,'symptoms',0),(843,'Repairability',0),(844,'Energy consumption',0),(845,'documentation',0),(846,'developer workflow',0),(847,'usability',0),(848,'search based software engineering',0),(849,'automated test data generation',0),(850,'SQL',0),(851,'databases',0),(852,'mobile app bugs',0),(853,'User interface',0),(854,'reverse engineering',0),(855,'task links',0),(856,'change propagation',0),(857,'bugzilla',0),(858,'mylyn',0),(859,'Search',0),(860,'Object Constraint Language',0),(861,'Data intensive applications',0),(862,'Experiment driven action research',0),(863,'Data migration',0),(864,'Communication Channels',0),(865,'Social Software Engineering',0),(866,'continuous integration',0),(867,'large scale testing',0),(868,'older adults',0),(869,'elderly',0),(870,'participatory design',0),(871,'co-design',0),(872,'user-centered design',0),(873,'user experience',0),(874,'intergenerational interaction',0),(875,'intergenerational cooperation',0),(876,'flaky tests',0),(877,'Fork-based development',0),(878,'Community detection',0),(879,'Information retrieval',0),(880,'overview of forks',0),(881,'transparency',0),(882,'Mobile Friendly Problems',0),(883,'web apps',0),(884,'Bug repositories',0),(885,'Temporal activities',0),(886,'Time to fix a bug',0),(887,'software repository mining',0),(888,'overtime',0),(889,'overwork',0),(890,'apache',0),(891,'mozilla',0),(892,'weekend',0),(893,'night',0),(894,'Conversational Development Assistants',0),(895,'Natural User Interfaces',0),(896,'Patch Overfitting',0),(897,'malware',0),(898,'Test Driven Development',0),(899,'Human Factors in Software Development',0),(900,'GitHub Repositories',0),(901,'early access games',0),(902,'computer games',0),(903,'Steam',0),(904,'self adaptive software systems',0),(905,'software engineering methodology',0),(906,'assurance evidence',0),(907,'assurance cases',0),(908,'accessibility technology',0),(909,'blindness',0),(910,'Software fault localization',0),(911,'parallel debugging',0),(912,'multiple bugs',0),(913,'distance metrics',0),(914,'lightweight',0),(915,'native code',0),(916,'familiarity',0),(917,'forgetting',0),(918,'maintenance',0),(919,'expert identification',0),(920,'knowledge management',0),(921,'performance anti-patterns',0),(922,'Object-Relational Mapping frameworks',0),(923,'database-backed applications',0),(924,'bug study',0),(925,'crash-inducing change',0),(926,'software crash',0),(927,'crash stack',0),(928,'bug localization',0),(929,'Software performance engineering',0),(930,'Software performance analysis',0),(931,'Testing on virtual environments',0),(932,'Model-driven engineering',0),(933,'model typing',0),(934,'partial typing',0),(935,'model transformations',0),(936,'bidirectionality',0),(937,'MetaDepth',0),(938,'stimulus generation',0),(939,'constraint-based testing',0),(940,'constrained random verification',0),(941,'automated unit testing',0),(942,'unit test driver/stub generation',0),(943,'false alarm reduction',0),(944,'software engineering economics',0),(945,'cost of quality',0),(946,'software product development',0),(947,'software process',0),(948,'Probabilistic Inference',0),(949,'Inference Model',0),(950,'reusing past fix',0),(951,'app reviews',0),(952,'online analysis',0),(953,'emerging issues',0),(954,'Automatic Program Repair',0),(955,'Generate and Validate',0),(956,'Search Based',0),(957,'Semantics driven repair',0),(958,'Correct by Construction',0),(959,'Self Repairing',0),(960,'Software development',0),(961,'Developers\' interaction data',0),(962,'Condition Random Field',0),(963,'command recommendation systems',0),(964,'IDE interaction data',0),(965,'Data protection',0),(966,'Privacy',0),(967,'Privacy by design',0),(968,'Grounded analysis',0),(969,'Social cognitive theory',0),(970,'Organizational climate',0),(971,'Dynamic languages',0),(972,'types',0),(973,'Subsuming methods',0),(974,'Runtime bloat',0),(975,'Performance analysis',0),(976,'Object oriented software',0),(977,'self-driving vehicles',0),(978,'reference architecture',0),(979,'design',0),(980,'evaluation',0),(981,'industrial case study',0),(982,'Interdisciplinary Design Patterns',0),(983,'Socially Aware Computing',0),(984,'Commit message',0),(985,'code changes',0),(986,'Software engineers',0),(987,'expertise',0),(988,'Data Models',0),(989,'Logic-based Verification',0),(990,'Loop Analysis',0),(991,'Content security policy',0),(992,'cross-site scripting',0),(993,'Functional Programming',0),(994,'XML Security',0),(995,'Reproducibility in Software Engineering',0),(996,'programming models',0),(997,'energy management',0),(998,'thermal management',0),(999,'Distributed Software Development',0),(1000,'Pull-based Development',0),(1001,'Pull Request',0),(1002,'bad code smells',0),(1003,'Structural Navigation',0),(1004,'Code Recommendation',0),(1005,'persona',0),(1006,'personality',0),(1007,'conceptual design',0),(1008,'automated planning',0),(1009,'PDDL',0),(1010,'self-adaptive',0),(1011,'planning',0),(1012,'Research methods',0),(1013,'Data mining',0),(1014,'Knowledge transfer',0),(1015,'information theory',0),(1016,'Classification Techniques',0),(1017,'invariant generation',0),(1018,'likely invariant',0),(1019,'transition invariant',0),(1020,'partial order reduction',0),(1021,'software development strategies',0),(1022,'self regulated learning behavior',0),(1023,'cognitive models',0),(1024,'Temporal Logic',0),(1025,'Bounded Model Checking',0),(1026,'Bit-Vector Logic',0),(1027,'experimentation',0),(1028,'benchmarking',0),(1029,'graphical user interfaces',0),(1030,'Software Quality Assurance',0),(1031,'Data Quality',0),(1032,'Mislabelling',0),(1033,'Graph-based Language Model',0),(1034,'API Suggestion',0),(1035,'Syntactic Template Suggestion',0),(1036,'SMT solving',0),(1037,'Constraint Logic Programming',0),(1038,'Data Structure Generation',0),(1039,'inter-component communication',0),(1040,'composite constant',0),(1041,'constant propagation',0),(1042,'Android IPC',0),(1043,'Android ICC',0),(1044,'Code examples',0),(1045,'Software documentation',0),(1046,'Static software analysis',0),(1047,'Genetic Programming',0),(1048,'Real-life Software Regressions',0),(1049,'Group Work',0),(1050,'Student Projects',0),(1051,'Collaboration Patterns',0),(1052,'Collaborative Learning',0),(1053,'Cooperative Learning',0),(1054,'Use of technology in classroom',0),(1055,'Mobile advertisements',0),(1056,'mobile devices',0),(1057,'performance bugs',0),(1058,'bug detection',0),(1059,'automatic bug fixing',0),(1060,'real-world bugs',0),(1061,'Masters',0),(1062,'distance education',0),(1063,'Systems Engineering',0),(1064,'System Thinking',0),(1065,'T-shaped',0),(1066,'Curriculum',0),(1067,'Education and Training',0),(1068,'The Incremental Commitment Spiral Model',0),(1069,'Development Tasks',0),(1070,'Navigation',0),(1071,'Auto-Complete',0),(1072,'build',0),(1073,'distance calculation',0),(1074,'binary classification',0),(1075,'sustainabiity',0),(1076,'micro-languages',0),(1077,'adaptability',0),(1078,'change management',0),(1079,'Software Project Management Curriculum',0),(1080,'collective intelligence',0),(1081,'collaborative design',0),(1082,'data delineation',0),(1083,'binary analysis',0),(1084,'buffer overrun detection',0),(1085,'Product Lines',0),(1086,'Symbolic Model Checking',0),(1087,'IC3',0),(1088,'IMC',0),(1089,'service-oriented computing',0),(1090,'social activism',0),(1091,'social sustainability',0),(1092,'coordination',0),(1093,'workflow',0),(1094,'practices',0),(1095,'commercial projects',0),(1096,'systems-of-systems',0),(1097,'SoS',0),(1098,'architecture-driven engineering',0),(1099,'ethics',0),(1100,'software in society',0),(1101,'cyber crime',0),(1102,'citizen science',0),(1103,'software design studio',0),(1104,'reflective teaching approach.',0),(1105,'emotional design',0),(1106,'programming',0),(1107,'multimedia',0),(1108,'Regular Property',0),(1109,'Finite State Machine',0),(1110,'type system',0),(1111,'type qualifier inference',0),(1112,'embedded software quality assurance',0),(1113,'multiple case study',0),(1114,'GQM+Strategies',0),(1115,'quantitative technology evaluation',0),(1116,'model-based testing',0),(1117,'internal baselines',0),(1118,'performance testing',0),(1119,'performance regression testing',0),(1120,'performance regression',0),(1121,'Cognitive sustainability',0),(1122,'Sustainable ICT',0),(1123,'Cognitive revolution',0),(1124,'Shared attention',0),(1125,'Social cognition',0),(1126,'Software engineering for social good.',0),(1127,'Course Evolution',0),(1128,'code quality',0),(1129,'error diagnosis',0),(1130,'delta debugging',0),(1131,'weakest precondition',0),(1132,'SMT solver',0),(1133,'Context',0),(1134,'Verification and Validation',0),(1135,'Model-Based Design',0),(1136,'Functional Hazard Analysis (FHA)',0),(1137,'Matlab/Simulink',0),(1138,'virtual reality',0),(1139,'live coding',0),(1140,'open source software development',0),(1141,'sustainability design',0),(1142,'systems thinking',0),(1143,'long-term thinking',0),(1144,'environmental sustainability',0),(1145,'economic sustainability',0),(1146,'societal sustainability',0),(1147,'technical sustainability',0),(1148,'Linear Temporal Logics',0),(1149,'Event-Based System Analysis',0),(1150,'stack traces',0),(1151,'vulnerability',0),(1152,'models',0),(1153,'attack surface',0),(1154,'Assertions',0),(1155,'Defects',0),(1156,'developer support',0),(1157,'technical support',0),(1158,'mailing list',0),(1159,'forums',0),(1160,'social media',0),(1161,'design learning',0),(1162,'structured reflection',0),(1163,'software diversity',0),(1164,'constraint solving',0),(1165,'Homegrown Tools',0),(1166,'privacy-preserving data sharing',0),(1167,'global software engineering',0),(1168,'distributed scrum',0),(1169,'teaching',0),(1170,'project',0),(1171,'oracle problem',0),(1172,'oracle generation',0),(1173,'anomaly detection',0),(1174,'bug reproducing',0),(1175,'local clock',0),(1176,'remote collaboration',0),(1177,'information technology education',0),(1178,'team projects',0),(1179,'code analysis',0),(1180,'graph',0),(1181,'abstract syntax tree',0),(1182,'Software Fault Injection',0),(1183,'Robustness Testing',0),(1184,'Test Automation',0),(1185,'Test Parallelization',0),(1186,'Software redundancy',0),(1187,'functional equivalence',0),(1188,'execution diversity',0),(1189,'Value Sensitive Design',0),(1190,'Values',0),(1191,'Games-based Learning',0),(1192,'SimulES-W',0),(1193,'Pedagogy',0),(1194,'Hyperheuristic',0),(1195,'CIT',0),(1196,'SBSE',0),(1197,'automatic documentation',0),(1198,'governance',0),(1199,'open source systems',0),(1200,'Contest',0),(1201,'IT business plan',0),(1202,'blending education',0),(1203,'marketing',0),(1204,'accounting',0),(1205,'business management',0),(1206,'Programming contests',0),(1207,'unit tests',0),(1208,'Code Hunt game',0),(1209,'HPC',0),(1210,'fault tolerance',0),(1211,'data management',0),(1212,'data curation',0),(1213,'data publication',0),(1214,'data discovery',0),(1215,'visualisation',0),(1216,'alloy',0),(1217,'Test failure prediction',0),(1218,'data-mining software repositories',0),(1219,'organizational metrics',0),(1220,'model comparison',0),(1221,'Disaster Response',0),(1222,'didactical approach',0),(1223,'inductive learning',0),(1224,'active learning',0),(1225,'higher education',0),(1226,'selective undo',0),(1227,'backtracking',0),(1228,'Dementia',0),(1229,'security education',0),(1230,'data flow coverage',0),(1231,'data flow testing',0),(1232,'Source code analysis',0),(1233,'Event logging',0),(1234,'Development process',0),(1235,'Coding practices',0),(1236,'Industry domain',0),(1237,'language modeling',0),(1238,'NLP',0),(1239,'big code',0),(1240,'communication across the curriculum',0),(1241,'black box test plans',0),(1242,'Organizational factors',0),(1243,'observational case study',0),(1244,'seL4',0),(1245,'Isabelle',0),(1246,'proof engineering',0),(1247,'Optimal Feature Selection Problem',0),(1248,'Multi Objective Optimization(MOO)',0),(1249,'Multi Objective Integer Programming (MOIP)',0),(1250,'Indicator Based Evolutionary Algorithm (IBEA)',0),(1251,'IBED',0),(1252,'compiler warnings',0),(1253,'compiler testing',0),(1254,'Off-Nominal Behaviors',0),(1255,'Requirements Verification',0),(1256,'Combinatorial Approach',0),(1257,'Software effort estimation',0),(1258,'multi-objective evolutionary algorithm',0),(1259,'confidence interval',0),(1260,'estimates uncertainty',0),(1261,'Feature Model',0),(1262,'Compositionality',0),(1263,'automated testing',0),(1264,'Gerrit',0),(1265,'Ownership',0),(1266,'Search Heuristics',0),(1267,'invariant discovery',0),(1268,'game with a purpose',0),(1269,'Energy Profile',0),(1270,'Collections',0),(1271,'Newbies',0),(1272,'Novices',0),(1273,'Beginners',0),(1274,'Barriers',0),(1275,'Obstacles',0),(1276,'Onboarding',0),(1277,'Joining Process',0),(1278,'automatic programming',0),(1279,'Semantic analysis',0),(1280,'fixing',0),(1281,'multithreaded program',0),(1282,'lock order',0),(1283,'Energy optimization',0),(1284,'HTTP requests',0),(1285,'feature generation',0),(1286,'Simulink',0),(1287,'tool chain bug',0),(1288,'multi objective evolutionary algorithms',0),(1289,'validity',0),(1290,'Separation Logic',0),(1291,'model synthesis',0),(1292,'PAC learning',0),(1293,'finite automata',0),(1294,'program verification',0),(1295,'automated static analysis',0),(1296,'experimental design',0),(1297,'parameter optimization',0),(1298,'Search based SE',0),(1299,'data analytics for software engineering',0),(1300,'SMOTE',0),(1301,'imbalanced data',0),(1302,'preprocessing',0),(1303,'Commit',0),(1304,'Git',0),(1305,'Accuracy',0),(1306,'C',0),(1307,'coding style',0),(1308,'Unix',0),(1309,'BSD',0),(1310,'FreeBSD',0),(1311,'clone detection',0),(1312,'large software repositories',0),(1313,'software repositories',0),(1314,'recall',0),(1315,'precision',0),(1316,'big-code',0),(1317,'Natrual Language Programming',0),(1318,'Domain Specific Languages',0),(1319,'User Intent',0),(1320,'insight sentences',0),(1321,'locality sensitive hashing',0),(1322,'minhashing',0),(1323,'similarity',0),(1324,'test case prioritization',0),(1325,'Fortran',0),(1326,'language interoperability',0),(1327,'polyglot',0),(1328,'reactive programming',0),(1329,'visualization',0),(1330,'Test based program repair',0),(1331,'patch correctness',0),(1332,'patch classification',0),(1333,'Data extraction',0),(1334,'wrapper',0),(1335,'scarpper',0),(1336,'Statistical model',0),(1337,'API usage',0),(1338,'specification mining',0),(1339,'sandboxing',0),(1340,'policy enforcement',0),(1341,'Functional-reactive Programming',0),(1342,'Architecturally significant requirements',0),(1343,'automated requirement classification',0),(1344,'functional requirements',0),(1345,'requirements knowledge',0),(1346,'Probing Questions (PQs)',0),(1347,'PQ-flows',0),(1348,'Architecture',0),(1349,'agglomeration',0),(1350,'code anomaly',0),(1351,'desing problem',0),(1352,'Patch Generation',0),(1353,'Software Build Scripts',0),(1354,'Build Logs',0),(1355,'Goal Conflicts',0),(1356,'Risk Likelihood Assessment',0),(1357,'Model Counting',0),(1358,'repository badge',0),(1359,'signaling theory',0),(1360,'regression discontinuity design',0),(1361,'dependency manager',0),(1362,'Performance issue',0),(1363,'Optimization',0),(1364,'test suite effectiveness',0),(1365,'triaging',0),(1366,'backward taint analysis',0),(1367,'reverse execution',0),(1368,'incident analysis',0),(1369,'Request For Comments',0),(1370,'Spreadsheets',0),(1371,'cell clustering',0),(1372,'smell detection',0),(1373,'statistical analysis',0),(1374,'theoretical analysis',0),(1375,'behavioural types',0),(1376,'go programming language',0),(1377,'Service Selection',0),(1378,'Service Composition',0),(1379,'Mixed Integer Programming',0),(1380,'automatic test case generation',0),(1381,'semantics',0),(1382,'oracles',0),(1383,'use after free',0),(1384,'metric temporal logic',0),(1385,'trace checking',0),(1386,'Access Control (Permission)',0),(1387,'typestate',0),(1388,'Practitioner Belief',0),(1389,'Empirical Evidence',0),(1390,'Empirical Software Engineering.',0),(1391,'self-driving cars',0),(1392,'deep neural networks',0),(1393,'autonomous vehicle',0),(1394,'neuron coverage',0),(1395,'Program slicing',0),(1396,'Leak Detection',0),(1397,'Buffer Overflow Detection',0),(1398,'Use-After-Free Detection',0),(1399,'Security enhancement',0),(1400,'Practicability',0),(1401,'Mobile privacy policy',0),(1402,'Android application',0),(1403,'User input',0),(1404,'Input Generation',0),(1405,'Research incentives',0),(1406,'research tools and infrastructure',0),(1407,'Boa',0),(1408,'API misuse',0),(1409,'industrial software development',0),(1410,'research synthesis',0),(1411,'qualitative (synthesis) methods',0),(1412,'systematic (literature) review',0),(1413,'evidence-based software engineering',0),(1414,'online Q&A forums',0),(1415,'code example assessment',0),(1416,'Virtual Devices',0),(1417,'Device Drivers',0),(1418,'Test Oracles',0),(1419,'Quality Indicators',0),(1420,'Multi-objective Software Engineering Problems',0),(1421,'Pareto-based Search Algorithms',0),(1422,'Practical Guide',0),(1423,'Pointer Analysis',0),(1424,'Activity Transition Analysis',0),(1425,'Programming language design',0),(1426,'Mutability',0),(1427,'Programmer productivity',0),(1428,'Quantitative Risk Management',0),(1429,'Knowledge Distribution',0),(1430,'Truck Factor',0),(1431,'Successors',0),(1432,'Turnover',0),(1433,'Compiler Verification',0),(1434,'Peephole Optimization',0),(1435,'Alive',0),(1436,'Termination',0),(1437,'Decision Propagation',0),(1438,'joint embedding',0),(1439,'Unreproducible Build',0),(1440,'Localization',0),(1441,'Missing data problem',0),(1442,'Drive factor missing case',0),(1443,'Effort label missing case',0),(1444,'Low-rank recovery and semi-supervised regression imputation (LRSRI)',0),(1445,'review quality',0),(1446,'developer perception',0),(1447,'floating point',0),(1448,'mixed precision',0),(1449,'problem identification',0),(1450,'effective combination',0),(1451,'problem diagnostic',0),(1452,'issue reports',0),(1453,'semantic clones',0),(1454,'code to code search',0),(1455,'Code Obfuscation',0),(1456,'Anti malware products',0),(1457,'Preprocessors',0),(1458,'Integer Overflow',0),(1459,'benign',0),(1460,'open source contribution',0),(1461,'dis- tributed software development',0),(1462,'Graph generation',0),(1463,'Domain Specific Modeling Languages',0),(1464,'Logic Solver',0),(1465,'Graph Solver',0),(1466,'Evolutionary algorithms',0),(1467,'Automotive Software Systems',0),(1468,'Search space',0),(1469,'Automated test generation',0),(1470,'Interleaving coverage criteria',0),(1471,'heterogeneity',0),(1472,'cross-project',0),(1473,'unsupervised',0),(1474,'spectral clustering',0),(1475,'graph mining',0),(1476,'Test-suite minimization',0),(1477,'integer programming',0),(1478,'Infeasible Objectives',0),(1479,'Redundant Objectives',0),(1480,'Code mining',0),(1481,'test minization',0),(1482,'test reduction',0),(1483,'test redundancy',0),(1484,'test model',0),(1485,'C++11',0),(1486,'JavaScript libraries',0),(1487,'asynchronicity',0),(1488,'full-stack JavaScript',0),(1489,'Free form queries',0),(1490,'idiomatic snippet synthesis',0),(1491,'structured call sequences',0),(1492,'word embeddings',0),(1493,'skip-gram model',0),(1494,'bug reports',0),(1495,'API documents',0),(1496,'Android apps',0),(1497,'Crash',0),(1498,'Behavior-preserving changes',0),(1499,'Reks',0),(1500,'big data analytics',0),(1501,'interactive tools',0),(1502,'data-intensive scalable computing (DISC)',0),(1503,'fault localization and recovery',0),(1504,'Non-functional requirements',0),(1505,'model-based development',0),(1506,'documentation analysis',0),(1507,'environment modeling',0),(1508,'auto-testing',0),(1509,'Large-gap Clone',0),(1510,'Android fragmentation',0),(1511,'prioritization',0),(1512,'usage data',0),(1513,'News aggregators',0),(1514,'development communities',0),(1515,'social computing',0),(1516,'pull-requests',0),(1517,'quasi contributors',0),(1518,'Automated debugging',0),(1519,'spectrum-based fault localization',0),(1520,'user studies',0),(1521,'attention tracking',0),(1522,'navigation pattern',0),(1523,'fault comprehension',0),(1524,'Privacy Policies',0),(1525,'Android Applications',0),(1526,'Violation Detection',0),(1527,'Fairness',0),(1528,'human and social aspects',0),(1529,'Data distribution',0),(1530,'probabilistic model checking',0),(1531,'run-time evaluation',0),(1532,'Open Source Practices',0),(1533,'Log analysis',0),(1534,'statistical guarantees',0),(1535,'Link Recovery',0),(1536,'Guiding',0),(1537,'Architecture Description',0),(1538,'Open-Source Software',0),(1539,'White-box',0),(1540,'Black-box',0),(1541,'distributed systems',0),(1542,'runtime checking',0),(1543,'Data Scientist',0),(1544,'deprecation',0),(1545,'Markov Chain',0),(1546,'Test Case Generation',0),(1547,'web application security',0),(1548,'access control',0),(1549,'Context-Aware',0),(1550,'Patch Prioritization',0),(1551,'Test Case Summarization',0),(1552,'review',0),(1553,'guidelines',0),(1554,'UAF',0),(1555,'Vulnerabilities',0),(1556,'UFO',0),(1557,'program reduction',0),(1558,'job rotation',0),(1559,'software teams',0),(1560,'Framework Model',0),(1561,'Sketch',0),(1562,'partial verification',0),(1563,'request based applications',0),(1564,'web frameworks',0),(1565,'inter request analysis',0),(1566,'Type Resolution',0),(1567,'Type Annotations',0),(1568,'Partial Program Analysis',0),(1569,'Statistical Machine Translation',0),(1570,'Naturalness',0),(1571,'summary',0),(1572,'library',0),(1573,'model inference',0),(1574,'mobile app',0),(1575,'Neural Program Correction',0),(1576,'Automated Feedback Generation',0),(1577,'Neural guided search',0),(1578,'Simulink models',0),(1579,'Time-continuous behaviors',0),(1580,'Output diversity',0),(1581,'Signal features',0),(1582,'Structural coverage',0),(1583,'Simulink Design Verifier (SLDV)',0),(1584,'Sampling Algorithms',0),(1585,'Configuration-Related Faults',0),(1586,'Structured Editing',0),(1587,'Sketch-n-Sketch',0),(1588,'Grounded Theory Methodology',0),(1589,'JVM Bytecode',0),(1590,'uninitialized pointer',0),(1591,'multi-entry',0),(1592,'comment generation',0),(1593,'automated test input generation',0),(1594,'graphical user interface',0),(1595,'mobile application',0),(1596,'prediction model',0),(1597,'SQL injection',0),(1598,'embedded system, software layer, integration test, test automation',0),(1599,'Test Code',0),(1600,'Continuous Integration, Build Failures, Anti patterns, Best Practices',0),(1601,'SysML',0),(1602,'Formal Method',0),(1603,'Model-Driven',0),(1604,'SAT',0),(1605,'Network Economics',0),(1606,'Game Theory',0),(1607,'Prospect Theory',0),(1608,'Quality of Experience (QoE)',0),(1609,'Smart Multimedia Pricing',0),(1610,'Error Handling',0),(1611,'Error Specification',0),(1612,'Python, call graph, empirical study, quantitative, qualitative',0),(1613,'nondeterminism, type system, verification, specification',0),(1614,'programming education',0),(1615,'Bug Report Generation',0),(1616,'API selection, data analytics, performance optimization, Stack Overflow',0),(1617,'Concolic Testing, MDE, State machines, Unit Testing, UML',0),(1618,'Cross-Platform Testing',0),(1619,'Image Recognition',0),(1620,'Record and Replay',0),(1621,'Graphical',0),(1622,'User',0),(1623,'Interface',0),(1624,'Automatic',0),(1625,'Generation',0),(1626,'Processing',0),(1627,'Natural',0),(1628,'Language',0),(1629,'Requirements',0),(1630,'Intelligent',0),(1631,'Interaction',0),(1632,'Prototyping',0),(1633,'C++ Smart Pointer',0),(1634,'Memory Error',0),(1635,'Coding Styles',0),(1636,'MDD',0),(1637,'Partial Models',0),(1638,'Execution',0),(1639,'Model level debugging',0),(1640,'Model execution',0),(1641,'Test Execution, Coverage, Test-Suite Reduction',0),(1642,'Automatic Program Repair, Patch Quality',0),(1643,'patch identification',0),(1644,'trace bot',0),(1645,'attention mechanisms, neural networks, algorithm classification, interpretability, explainability, code perturbation, program comprehension',0),(1646,'Strategy Selection',0),(1647,'Portfolio Verifier',0),(1648,'Loop Abstraction',0),(1649,'Array Abstraction',0),(1650,'Fuzz Testing',0),(1651,'Loop Invariant Generation',0),(1652,'Value Analysis',0),(1653,'trust, supply chain, provenance, governance, compliance, integrity, smart advisors',0),(1654,'Business Rules Extraction, Rule Document, Rule Components, SBVR, Natural Language Processing, Text Mining, Graphs, Match and Gap, Search and Query, Source Code',0),(1655,'requirements modeling',0),(1656,'formal engineering methods',0),(1657,'Application Performance Management Library',0),(1658,'Neural Network Visualization',0),(1659,'Fork-based Development, Distributed Collaboration, Awareness of Collaboration, Open-Source Community',0),(1660,'Emotion dynamics, emotion awareness, emotion intensity, software development, time-series database',0),(1661,'embedded systems, formal verification, specification mining, formal properties, declarative requirement specification',0),(1662,'pluggable types, AMI sniping, AWS, EC2, Java, lightweight verification, DescribeImagesRequest',0),(1663,'Neural machine translation (NMT)',0),(1664,'Commit message generation',0),(1665,'Floating-point arithmetic',0),(1666,'exceptions',0),(1667,'GPU',0),(1668,'scientific computing',0),(1669,'Software Delivery, Software Analytics, Project Management, Actionable Insights',0),(1670,'Program Understanding',0),(1671,'Maintenance and Evolution',0),(1672,'Machine-Learning',0),(1673,'Kotlin',0),(1674,'Serverless',0),(1675,'Web',0),(1676,'Framework',0),(1677,'Kotless',0),(1678,'Cloud',0),(1679,'Cyber Physical Systems, Controller Synthesis, Model Checking, Machine Learning, Inductive Logic Programming, Domain Knowledge, Strategy Representation',0),(1680,'Fog Computing',0),(1681,'Performance Evaluation',0),(1682,'Task Scheduling',0),(1683,'Simulation Toolkit',0),(1684,'Android Malware Detection',0),(1685,'CNN',0),(1686,'adapter synthesis',0),(1687,'Execution trace visualization',0),(1688,'Visual analytics',0),(1689,'build failures, build repair, continuous integration',0),(1690,'Boilerplate Code',0),(1691,'API Usability',0),(1692,'Repository Mining',0),(1693,'manticore',0),(1694,'mcore',0),(1695,'smart contract',0),(1696,'Code reuse',0),(1697,'Language model',0),(1698,'Mutation Testing, Closed Source Apps, Android',0),(1699,'Developer Reputation',0),(1700,'Software Ecosystem',0),(1701,'Identity Disambiguation',0),(1702,'Coding convention',0),(1703,'question answering',0),(1704,'knowledge graph',0),(1705,'Ethereum-Smart-Contract',0),(1706,'Mutation-Test',0),(1707,'Mutation-Operator',0),(1708,'Program Merging',0),(1709,'Model Merging',0),(1710,'Family-Based Analyses',0),(1711,'Keyword',0),(1712,'Element locators',0),(1713,'CSS selectors',0),(1714,'design principles',0),(1715,'software-design quality',0),(1716,'softwaredesign assessment method',0),(1717,'design model',0),(1718,'non-deterministic bug',0),(1719,'DSLs',0),(1720,'Model transformation',0),(1721,'conceptual patterns',0),(1722,'semantic object models',0),(1723,'analysis models',0),(1724,'Data Privacy',0),(1725,'Data-Intensive Applications',0),(1726,'Dataflow computing',0),(1727,'CDT',0),(1728,'Clone',0),(1729,'Abstraction',0),(1730,'Crushinator',0),(1731,'exploratory testing',0),(1732,'event-driven applications',0),(1733,'API-specific Bugs',0),(1734,'formal concept analysis',0),(1735,'tag clouds',0),(1736,'browsing software repositories',0),(1737,'Code coverage, Metamorphic testing, Coverage profilers, Bug detection.',0),(1738,'API usages, Context sensitive technique, Recommendation system, Fully Qualified Name',0),(1739,'software performance',0),(1740,'time series analysis',0),(1741,'embedded OS',0),(1742,'Artificial Intelligence, Self-Adaptation, Machine Learning',0),(1743,'Signature',0),(1744,'Certificate',0),(1745,'Multi Process Applications, Concurrency Failures, Fault Localization',0),(1746,'Controversial discussion, Stack Overflow, Open information extraction, Sentence embedding',0),(1747,'Defiant Component, Adaptation, Scenarios, Aspects',0),(1748,'automated GUI exploration',0),(1749,'input repair',0),(1750,'novice programs',0),(1751,'human study',0),(1752,'Document Generation',0),(1753,'Sequence to Sequence Learning',0),(1754,'Deep learning frameworks',0),(1755,'Deep learning platforms',0),(1756,'Deep learning deployment',0),(1757,'Reverse Execution, Deep Learning, Memory Alias',0),(1758,'search-based testing',0),(1759,'automated driving',0),(1760,'experience paper',0),(1761,'Code Embeddings',0),(1762,'Distributed Representations',0),(1763,'Memory Access Pattern',0),(1764,'Thread Safe Classes',0),(1765,'Concurrency Bugs',0),(1766,'API usage example, graph kernel, code search, software reuse',0),(1767,'Class overlap',0),(1768,'K Means clustering',0),(1769,'string input generation',0),(1770,'regular expression',0),(1771,'automaton modeling',0),(1772,'data flow analysis',0),(1773,'Push notification',0),(1774,'advertisement',0),(1775,'Field-exhaustive testing, field-based testing, symbolic execution, transcoping',0),(1776,'memory representation',0),(1777,'performance benchmarking',0),(1778,'software merging, collaborative development, code integration, version control systems',0),(1779,'program fuzzing',0),(1780,'input reduction',0),(1781,'Incident Triage',0),(1782,'Online Service Systems',0),(1783,'Test transfer, test migration, GUI testing, natural language processing, semantic similarity',0),(1784,'unreproducible builds',0),(1785,'system call tracing',0),(1786,'Intelligent Tutoring Systems',0),(1787,'Compilation Error',0),(1788,'Example Generation',0),(1789,'Neural Networks',0),(1790,'Collaborative development, Software merging, Semistructured merge, Version control systems, JavaScript',0),(1791,'Library function',0),(1792,'Specification',0),(1793,'Code changes decomposition',0),(1794,'Code changes description',0),(1795,'COTS Software, OSS, Code Reuse, One Day Vulnerability, Code Feature, Binary-to Source Matching',0),(1796,'Explainability',0),(1797,'Property Inference',0),(1798,'Software engineering, Fault localization, Program debugging',0),(1799,'Defect detection',0),(1800,'Record',0),(1801,'Replay',0),(1802,'Mobile Systems',0),(1803,'Automation',0),(1804,'IFDS, data-flow analysis, taint analysis',0),(1805,'Java interfaces, coupling, empirical study, software repositories, cochange, GitHub',0),(1806,'mutation proving',0),(1807,'Coq',0),(1808,'prof assistants',0),(1809,'software system',0),(1810,'automatic configuration tuning',0),(1811,'generative adversarial networks',0),(1812,'sequentialization',0),(1813,'swarm verification',0),(1814,'trainability',0),(1815,'smart software functions',0),(1816,'continuous deployment',0),(1817,'grammar based',0),(1818,'Test migration, GUI testing, mobile apps',0),(1819,'Coverage guided testing',0),(1820,'deep learning testing',0),(1821,'Testing Deep Learning Libraries',0),(1822,'CUDA',0),(1823,'synchronization automation',0),(1824,'performance anti patterns',0),(1825,'database centric applications',0),(1826,'experience report',0),(1827,'Transactions',0),(1828,'Multi-threading',0),(1829,'Program Synthesis and Transformations',0),(1830,'Automated Defect Repair',0),(1831,'Side Channel',0),(1832,'regular expressions, developer process, qualitative research',0),(1833,'taint analysis, path conditions, Android',0),(1834,'Software bot',0),(1835,'cloud system',0),(1836,'probabilistic symbolic execution, string constraints, quantitative program analysis',0),(1837,'Game Testing',0),(1838,'Artificial Intelligence',0),(1839,'Deep Reinforcement Learning',0),(1840,'Evolutionary Multi-Objective Optimization',0),(1841,'cryptographic programs',0),(1842,'functional correctness',0),(1843,'OpenSSL',0),(1844,'Program Measurement',0),(1845,'Dynamic Invariants',0),(1846,'inline assembly',0),(1847,'lifting',0),(1848,'emotion recognition',0),(1849,'emotion dynamics',0),(1850,'text based NLP techniques',0),(1851,'organizational norms',0),(1852,'Configuration Repair',0),(1853,'Configuration Drift',0),(1854,'asynchronous programming',0),(1855,'architecture debt',0),(1856,'response generation',0),(1857,'neural machine translation',0),(1858,'Code Clone',0),(1859,'Word2Vector',0),(1860,'Source Code Syntax',0),(1861,'cyber-physical systems',0),(1862,'benchmark generation',0),(1863,'metaheuristic optimisation',0),(1864,'formula caching, model counting, quantitative program analysis',0),(1865,'Regular expressions',0),(1866,'Data driven design',0),(1867,'Methods',0),(1868,'structure extraction',0),(1869,'log compression',0),(1870,'log management',0),(1871,'iterative clustering',0),(1872,'Workload recovery, Load tests, Software log analysis, Software performance',0),(1873,'Parallel Programming',0),(1874,'Automation Compilers',0),(1875,'Code retrieval',0),(1876,'multi-modal network',0),(1877,'attention mechanism',0),(1878,'Bug and vulnerability detection',0),(1879,'Model Evolution',0),(1880,'Model Fixing',0),(1881,'Model Repair',0),(1882,'Security, OAuth, Android, Static Analysis, Bug Finding',0),(1883,'Mining Software Repository',0),(1884,'Software License Prediction',0),(1885,'Software Refactoring',0),(1886,'Statement Completion',0),(1887,'Statistical Language Model',0),(1888,'Lightweight feature, Android Malware, API Centrality, Market-wide',0),(1889,'access permissions, static analysis, concurrency, permission inference',0),(1890,'Augmented Reality, Immersive Experience, Software Visualization, Software Comprehension',0),(1891,'domain model, MDE, EMF, roundtrip synchronization, algebraic specification, performance analysis',0),(1892,'Configurable Code',0),(1893,'Feature Interaction',0),(1894,'Configuration Prioritization',0),(1895,'recurrent neural netwrod',0),(1896,'model abstraction',0),(1897,'quantitative analysis',0),(1898,'similarity metrics',0),(1899,'Batch analysis',0),(1900,'Alias analysis',0),(1901,'Points to Analysis',0),(1902,'Pattern generation, Program adaptation, Code abstraction',0),(1903,'RESTful API',0),(1904,'Example based documentation',0),(1905,'Implicit Control Flow',0),(1906,'Type systems',0),(1907,'bellwethers',0),(1908,'software traceability',0),(1909,'traceability link recovery',0),(1910,'Ajax',0),(1911,'Design Pattern',0),(1912,'event generation',0),(1913,'event handlers',0),(1914,'Monitoring',0),(1915,'Hotpatching',0),(1916,'Production Systems',0),(1917,'Low-Overhead',0),(1918,'distributed agile',0),(1919,'task allocation',0),(1920,'behavior composition',0),(1921,'message passing',0),(1922,'multi node',0),(1923,'Recommendation Framework',0),(1924,'pq-Gram Algorithm',0),(1925,'Code understandability',0),(1926,'Negative result',0),(1927,'Requirement documents',0),(1928,'System use cases',0),(1929,'validations',0),(1930,'NL analyses',0),(1931,'Rules',0),(1932,'Rule types',0),(1933,'Rule acts',0),(1934,'Rule intents',0),(1935,'Software changes',0),(1936,'version history',0),(1937,'dependency',0),(1938,'Systems of systems',0),(1939,'requirements monitoring',0),(1940,'constraint checking',0),(1941,'domain-specific languages',0),(1942,'Repetitive Code Changes',0),(1943,'Loop-invariant',0),(1944,'selective sampling',0),(1945,'Constraint mining',0),(1946,'event-based monitoring',0),(1947,'Formal specification',0),(1948,'Fault-tolerance',0),(1949,'Temporal Logics',0),(1950,'Deontic logics',0),(1951,'Correctness by construction',0),(1952,'SearchRepair',0),(1953,'semantic code search',0),(1954,'repair quality',0),(1955,'performance prediction',0),(1956,'Adaptive software',0),(1957,'Control-theory',0),(1958,'Model predictive control',0),(1959,'Performance requirements',0),(1960,'falsification',0),(1961,'test harnesses',0),(1962,'ATL',0),(1963,'Gremlin',0),(1964,'OCL Scalability',0),(1965,'Persistence Framework',0),(1966,'NoSQL',0),(1967,'Consistency failure',0),(1968,'environment rematching',0),(1969,'Review Summarization',0),(1970,'User Feedback',0),(1971,'Change History Information',0),(1972,'Malware detection',0),(1973,'Malware behavior modeling',0),(1974,'Software text retrieval',0),(1975,'conceptual knowledge',0),(1976,'API graph',0),(1977,'semantic relatedness',0),(1978,'change impact analysis',0),(1979,'Test input generation',0),(1980,'Coverage-based debugging',0),(1981,'Integration coverage',0),(1982,'System of systems',0),(1983,'tool support',0),(1984,'Multicopter',0),(1985,'Timed Regular Expressions',0),(1986,'Real-time systems',0),(1987,'Software behavior',0),(1988,'likely invariants',0),(1989,'dynamic impact analysis',0),(1990,'Fault Prediction',0),(1991,'Software Clustering',0),(1992,'model',0),(1993,'metamodel',0),(1994,'inference',0),(1995,'semiautomated',0),(1996,'end-user',0),(1997,'program equivalence',0),(1998,'graph transformation',0),(1999,'rule learning',0),(2000,'multi objects',0),(2001,'extraction of visual contracts',0),(2002,'API informal documentation',0),(2003,'opinion summaries',0),(2004,'study',0),(2005,'summary quality',0),(2006,'DSE',0),(2007,'path explosion',0),(2008,'Business Domain Modeling',0),(2009,'machine translation',0),(2010,'programming language',0),(2011,'natural language',0),(2012,'Business Processes',0),(2013,'BPMN',0),(2014,'Structural Operational Semantics',0),(2015,'MAUDE',0),(2016,'interrogative',0),(2017,'classifier',0),(2018,'rank',0),(2019,'Data race',0),(2020,'task parallel languages',0),(2021,'Habanero',0),(2022,'Java Pathfinder',0),(2023,'Reachability determination',0),(2024,'constraint pattern',0),(2025,'path constraint solving',0),(2026,'SMT',0),(2027,'software test tools',0),(2028,'domain-specific language',0),(2029,'extended finite-state machines',0),(2030,'component-based systems',0),(2031,'exception testing',0),(2032,'Dangling References',0),(2033,'Web Code Analysis',0),(2034,'coding patterns',0),(2035,'lightweight static analysis',0),(2036,'test faults',0),(2037,'query reformulation',0),(2038,'internet-scale',0),(2039,'Annotation Inference',0),(2040,'Safe Parallelism',0),(2041,'Checkable Proof',0),(2042,'code transfer',0),(2043,'recommendation confidence',0),(2044,'evolutionary coupling',0),(2045,'targeted association rule mining',0),(2046,'random forests',0),(2047,'texada',0),(2048,'linear temporal logic',0),(2049,'Automatic test generation',0),(2050,'random testing',0),(2051,'Test case reduction',0),(2052,'event sequence reduction',0),(2053,'Logic',0),(2054,'Many-Sorted Logic',0),(2055,'automated analysis',0),(2056,'Algorithms',0),(2057,'Education',0),(2058,'Statistical Approach',0),(2059,'Natural Language Interface',0),(2060,'Project Data',0),(2061,'Query',0),(2062,'String Rewriting',0),(2063,'IR',0),(2064,'Topcoder',0),(2065,'Test fixture',0),(2066,'concolic execution',0),(2067,'DOM',0),(2068,'antipattern',0),(2069,'In-memory fuzzing',0),(2070,'code similarity',0),(2071,'taint analysis',0),(2072,'automatic compositional verification',0),(2073,'satisfiability',0),(2074,'interpolation',0),(2075,'Online service',0),(2076,'service incident diagnosis',0),(2077,'incident management',0),(2078,'Aspect-Oriented programming',0),(2079,'type constraints',0),(2080,'Fault Injection',0),(2081,'Operating Systems',0),(2082,'Dependability Benchmarking',0),(2083,'API understanding',0),(2084,'Extended Boolean model',0),(2085,'software reuse',0),(2086,'debugger',0),(2087,'text search',0),(2088,'concept location',0),(2089,'access path',0),(2090,'field sensitive',0),(2091,'control-flow analysis',0),(2092,'integer error',0),(2093,'fix pattern',0),(2094,'version histories',0),(2095,'Parallel analysis',0),(2096,'Crowdsourced Software Engineering',0),(2097,'Regular expression comprehension',0),(2098,'equivalence class',0),(2099,'regex representations',0),(2100,'automated comment generation',0),(2101,'natural language processing for software engineering',0),(2102,'software model checking',0),(2103,'caching',0),(2104,'non-blocking input/output',0),(2105,'selector-based input/output',0),(2106,'Lexer',0),(2107,'parser',0),(2108,'programming-by-example',0),(2109,'Emergent behavior',0),(2110,'distributed software system',0),(2111,'multiagent system',0),(2112,'traceability patterns',0),(2113,'CodeRank',0),(2114,'term weighting',0),(2115,'query quality analysis',0),(2116,'data resampling',0),(2117,'automated version control',0),(2118,'fine-grained development history',0),(2119,'history rewriting',0),(2120,'history transformation',0),(2121,'Codebase Manipulation',0),(2122,'Grammar-based Fuzzing',0),(2123,'Grammar Learning',0),(2124,'Networked classification',0),(2125,'Risk management',0),(2126,'transfer learning',0),(2127,'requirements traceability',0),(2128,'query replacement',0),(2129,'contractual requirements',0),(2130,'text mining',0),(2131,'association rules',0),(2132,'responsive web',0),(2133,'Review Analysis',0),(2134,'source code comments',0),(2135,'inconsistent code',0),(2136,'fragile comments',0),(2137,'Allocation',0),(2138,'Automotive',0),(2139,'Constraints',0),(2140,'MechatronicUML',0),(2141,'platform-specific implementation',0),(2142,'Environmental assumptions',0),(2143,'Safety-critical systems',0),(2144,'event-driven',0),(2145,'concurrency bug',0),(2146,'Automated input classifications',0),(2147,'combinatorial testing',0),(2148,'invariant inference',0),(2149,'Text Classification',0),(2150,'Change classification',0),(2151,'personalized defect prediction',0),(2152,'Test Data Generation',0),(2153,'Usage-based Statistical Testing',0),(2154,'OCL',0),(2155,'model variants',0),(2156,'Cross-platform',0),(2157,'Porting',0),(2158,'Continuous execution',0),(2159,'tool',0),(2160,'collaborative',0),(2161,'C programs',0),(2162,'multi-thread',0),(2163,'multi-threaded',0),(2164,'bounded model-checking',0),(2165,'context-bounded',0),(2166,'Bot',0),(2167,'requirements completeness',0),(2168,'inductive proofs',0),(2169,'inductive validity cores',0),(2170,'Multilingual Programs',0),(2171,'Mutation Based Fault Localization',0),(2172,'fault detection',0),(2173,'cross-language interactions',0),(2174,'call graph',0),(2175,'Soundness of refinements',0),(2176,'Bayesian belief networks',0),(2177,'maturity of requirements',0),(2178,'Statistical code completion',0),(2179,'Synergizing Miners',0),(2180,'Model Fission',0),(2181,'Model Fusion',0),(2182,'shared memory dependence',0),(2183,'Formal Synthesis',0),(2184,'Digital Control Systems',0),(2185,'MATLAB Toolbox',0),(2186,'Finite-Word Length',0),(2187,'parallel programs',0),(2188,'OpenMP',0),(2189,'function equivalence',0),(2190,'resource leak',0),(2191,'Heap overflow',0),(2192,'Vulnerability assessment',0),(2193,'Unstructured Data Mining',0),(2194,'Performance benchmark',0),(2195,'Model queries',0),(2196,'Model metrics',0),(2197,'Query metrics',0),(2198,'Software test generation',0),(2199,'goal-based testing',0),(2200,'data race detection',0),(2201,'dynamic language features',0),(2202,'usage patterns',0),(2203,'Tensor algebra',0),(2204,'linear algebra',0),(2205,'sparse',0),(2206,'compiler',0),(2207,'extension point',0),(2208,'extension',0),(2209,'Dynamic Slicing',0),(2210,'Data-flow',0),(2211,'Partial program',0),(2212,'boosting complete-code tool',0),(2213,'Summary generation',0),(2214,'question retrieval',0),(2215,'software product line engineering',0),(2216,'delta modeling',0),(2217,'model differencing',0),(2218,'Mobile Testing',0),(2219,'UI Patterns',0),(2220,'Pattern-based testing',0),(2221,'Java concurrency bugs',0),(2222,'evaluations',0),(2223,'benchmark suite',0),(2224,'SIR',0),(2225,'JaConTeBe',0),(2226,'termination analysis',0),(2227,'interprocedural analysis',0),(2228,'Variability models',0),(2229,'automated configuration',0),(2230,'multiobjective optimization',0),(2231,'Language Migration',0),(2232,'Syntax-directed Translation',0),(2233,'Clone management',0),(2234,'Collaborative modelling',0),(2235,'meta-modelling',0),(2236,'social networks',0),(2237,'unit testing',0),(2238,'Data structure identification',0),(2239,'dynamic data structures',0),(2240,'pointer programs',0),(2241,'type recovery',0),(2242,'SMT-based verification',0),(2243,'memory safety',0),(2244,'Execution Tracing',0),(2245,'transfer function',0),(2246,'abstract domain',0),(2247,'communication',0),(2248,'application analysis',0),(2249,'Web Usability',0),(2250,'Software as a Service',0),(2251,'Usability Refactoring',0),(2252,'Multithreading',0),(2253,'software debugging',0),(2254,'scheduling algorithms',0),(2255,'App background services',0),(2256,'Android Intents',0),(2257,'Program Execution Visualization',0),(2258,'Proof Understanding',0),(2259,'vector space model',0),(2260,'Recommendation System',0),(2261,'Build-system',0),(2262,'build-language',0),(2263,'build-automation',0),(2264,'build-as-a-service',0),(2265,'Automated tool for analysis modeling',0),(2266,'Analysis class diagram',0),(2267,'Problem level sequence diagram',0),(2268,'Template code',0),(2269,'Automated approach',0),(2270,'Software Requirement Selection',0),(2271,'Software Requirement Dependencies',0),(2272,'Developer Targeted Analytics',0),(2273,'Performance Engineering',0),(2274,'parallelization',0),(2275,'vectorization',0),(2276,'rewriting systems',0),(2277,'Fourier transform',0),(2278,'matrix algebra',0),(2279,'Probabilistic reasoning',0),(2280,'stochastic behavior',0),(2281,'Analysis modeling',0),(2282,'Security testing',0),(2283,'Security oracle',0),(2284,'SQL-injection',0),(2285,'Data-flow Analysis',0),(2286,'Language Workbench',0),(2287,'Inter-procedural Analysis',0),(2288,'Incremental Consistency Checking',0),(2289,'Multi-Developer Engineering',0),(2290,'Test Report Classification',0),(2291,'compatibility issues',0),(2292,'SAT solving',0),(2293,'mobile crowdsourcing',0),(2294,'hybrid applications',0),(2295,'multi-language analysis',0),(2296,'analysis framework',0),(2297,'Big Data Testing',0),(2298,'Input Domain Model',0),(2299,'Adaptive Input Domain Model',0),(2300,'Tree Differencing',0),(2301,'Optimizations',0),(2302,'Source Code',0),(2303,'Automated developer tests',0),(2304,'Spectrum based fault localisation',0),(2305,'Statistical debugging',0),(2306,'automatic runtime recovery',0),(2307,'JVM',0),(2308,'Dependence clusters',0),(2309,'fault-proneness',0),(2310,'network analysis',0),(2311,'dynamic partial ordering',0),(2312,'battery lifetime',0),(2313,'Incremental Computation',0),(2314,'Latent lock',0),(2315,'deadlock detection',0),(2316,'API method',0),(2317,'Test Smells',0),(2318,'Input formats',0),(2319,'context-free grammars',0),(2320,'dynamic tainting',0),(2321,'DroidRA',0),(2322,'mixed integer linear optimization',0),(2323,'program coverage',0),(2324,'association rule mining',0),(2325,'parameter tuning',0),(2326,'change recommendations',0),(2327,'end-user development',0),(2328,'visual development environment',0),(2329,'traceability quality',0),(2330,'traceability maintenance',0),(2331,'consistency',0),(2332,'Learning invariants',0),(2333,'Verification history',0),(2334,'Cache misses',0),(2335,'Instruction locality',0),(2336,'Compositional analysis',0),(2337,'Domain Analysis',0),(2338,'Meta-Modelling Patterns',0),(2339,'error handling bugs',0),(2340,'API errors',0),(2341,'Advanced Driver Assistance Systems',0),(2342,'Multi-Objective Search Optimization',0),(2343,'Simulation',0),(2344,'Surrogate Modeling',0),(2345,'Artificial Evaluation',0),(2346,'Code reviewer recommendation',0),(2347,'cross-project experience',0),(2348,'specialized technology experience',0),(2349,'Visual contracts',0),(2350,'Semantic history slicing',0),(2351,'software configuration management',0),(2352,'code clone detection',0),(2353,'abstract syntax trees',0),(2354,'Performace evaluation',0),(2355,'microbencharking',0),(2356,'text tagging',0),(2357,'Identifying candidate developers',0),(2358,'Developer skills identification',0),(2359,'Stored Procedures',0),(2360,'Nonlinear Programming',0),(2361,'domain-specific visual modeling language',0),(2362,'software component interface description',0),(2363,'testing environment emulation',0),(2364,'Program Binaries',0),(2365,'design-flaw detection',0),(2366,'continuous software evolution',0),(2367,'object-oriented software architecture',0),(2368,'oracle data selection',0),(2369,'crowdsourced knowledge',0),(2370,'semantic relevance',0),(2371,'word co-occurrence',0),(2372,'adjacency list',0),(2373,'Simulink Stateflow',0),(2374,'Uppaal Timed Automaton',0),(2375,'Deductive Reasoning',0),(2376,'specification quality',0),(2377,'Test Report Prioritization',0),(2378,'Image Understanding',0),(2379,'Multi-Objective Optimization',0),(2380,'GUI model generation',0),(2381,'GUI comparison criteria',0),(2382,'Model-based test input generation',0),(2383,'Abstract test',0),(2384,'Essential Use Cases',0),(2385,'Essential User Interface',0),(2386,'requirement-based testing',0),(2387,'requirements validation',0),(2388,'communication and collaboration',0),(2389,'Descriptive names',0),(2390,'image processing',0),(2391,'record/replay',0),(2392,'Cascading style sheets',0),(2393,'duplication',0),(2394,'code defects',0),(2395,'cross-language clone',0),(2396,'diff',0),(2397,'revision history',0),(2398,'Decoupling',0),(2399,'Offline',0),(2400,'Symbolic taint analysis',0),(2401,'bug radius',0),(2402,'Static Code Analysis',0),(2403,'N-gram Language Model',0),(2404,'Cross-lingual question retrieval',0),(2405,'Convolutional Neural Network',0),(2406,'Dual-Language Vector Space',0),(2407,'deadlock analysis',0),(2408,'Phrase Extraction',0),(2409,'byte-code',0),(2410,'Empirical Evaluation',0),(2411,'code queries',0),(2412,'Probabilistic Symbolic Execution',0),(2413,'computation model',0),(2414,'hardwaresoftware co-design',0),(2415,'FFI',0),(2416,'foreign function interfaces',0),(2417,'bindings',0),(2418,'libraries',0),(2419,'Link prediction',0),(2420,'Buffer Overflow',0),(2421,'Validation',0),(2422,'Automatic Repair',0),(2423,'Data Collection',0),(2424,'Data Mapping Definition',0),(2425,'Link Discovery',0),(2426,'API monitoring',0),(2427,'Data Storage',0),(2428,'Variability-Aware Execution',0),(2429,'Effort estimation',0),(2430,'Privacy-preserving',0),(2431,'Locality preserving projection',0),(2432,'Subclass division',0),(2433,'improvement recommendation',0),(2434,'Model-driven software engineering',0),(2435,'filtered editing',0),(2436,'Satisfiability Checking',0),(2437,'Tableaux Method',0),(2438,'Complicated Path Condition',0),(2439,'expertise metrics',0),(2440,'issue tracker',0);
/*!40000 ALTER TABLE `keyword_info` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `publication_info`
--

DROP TABLE IF EXISTS `publication_info`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `publication_info` (
  `publication_id` int(11) NOT NULL AUTO_INCREMENT,
  `publication_title` varchar(500) DEFAULT NULL,
  `publication_year` varchar(5) DEFAULT NULL,
  `publication_type` varchar(10) DEFAULT NULL,
  PRIMARY KEY (`publication_id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `publication_info`
--

LOCK TABLES `publication_info` WRITE;
/*!40000 ALTER TABLE `publication_info` DISABLE KEYS */;
INSERT INTO `publication_info` VALUES (1,'2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE)','2018','icse'),(2,'2015 IEEE/ACM 37th IEEE International Conference on Software Engineering','2015','icse'),(3,'2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)','2019','icse'),(4,'2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)','2017','icse'),(5,'2016 IEEE/ACM 38th International Conference on Software Engineering (ICSE)','2016','icse'),(6,'2013 28th IEEE/ACM International Conference on Automated Software Engineering (ASE)','2013','ase'),(7,'2019 34th IEEE/ACM International Conference on Automated Software Engineering (ASE)','2019','ase'),(8,'2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)','2017','ase'),(9,'2015 30th IEEE/ACM International Conference on Automated Software Engineering (ASE)','2015','ase'),(10,'2016 31st IEEE/ACM International Conference on Automated Software Engineering (ASE)','2016','ase');
/*!40000 ALTER TABLE `publication_info` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2020-03-06 11:07:17
